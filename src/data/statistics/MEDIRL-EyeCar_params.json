{
    "driving/maskModel.py": {
        "tensorflow": {
            "stack_193": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[y1, x1, y2, x2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "apply_box_deltas_out",
                    "type": "str",
                    "possible_values": []
                }
            },
            "split_203": {
                "variable": {
                    "value": "(wy1, wx1, wy2, wx2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "window",
                    "type": "variable",
                    "possible_values": [
                        [
                            "meta[:, 4:8]",
                            "Subscript"
                        ],
                        [
                            "meta[:, 4:8]",
                            "Subscript"
                        ],
                        [
                            "np.array([0, 0, height, width]).astype(np.float32)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_204": {
                "variable": {
                    "value": "(y1, x1, y2, x2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "boxes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "positive_rois",
                            "variable"
                        ],
                        [
                            "tf.concat([y1, x1, y2, x2], 1)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(boxes, non_zeros, name=name)",
                            "Call"
                        ],
                        [
                            "utils.batch_slice([anchors, deltas], lambda x, y: apply_box_deltas_graph(x, y), self.config.IMAGES_PER_GPU, names=['refined_anchors'])",
                            "Call"
                        ],
                        [
                            "utils.batch_slice(boxes, lambda x: clip_boxes_graph(x, window), self.config.IMAGES_PER_GPU, names=['refined_anchors_clipped'])",
                            "Call"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "detections[:N, :4]",
                            "Subscript"
                        ],
                        [
                            "np.multiply(boxes - shifts, scales).astype(np.int32)",
                            "Call"
                        ],
                        [
                            "np.delete(boxes, exclude_ix, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "maximum_206": {
                "variable": {
                    "value": "y1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.minimum(y1, wy2)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "wy1",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "maximum_207": {
                "variable": {
                    "value": "x1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.minimum(x1, wx2)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "wx1",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "maximum_208": {
                "variable": {
                    "value": "y2",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.minimum(y2, wy2)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "wy1",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "maximum_209": {
                "variable": {
                    "value": "x2",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.minimum(x2, wx2)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "wx1",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "concat_210": {
                "variable": {
                    "value": "clipped",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[y1, x1, y2, x2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "clipped_boxes",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_418": {
                "variable": {
                    "value": "b1",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.tile(tf.expand_dims(boxes1, 1), [1, 1, tf.shape(boxes2)[0]])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_420": {
                "variable": {
                    "value": "b2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "boxes2",
                    "type": "variable",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[tf.shape(boxes1)[0], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "split_422": {
                "variable": {
                    "value": "(b1_y1, b1_x1, b1_y2, b1_x2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "b1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.tile(tf.expand_dims(boxes1, 1), [1, 1, tf.shape(boxes2)[0]]), [-1, 4])",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_423": {
                "variable": {
                    "value": "(b2_y1, b2_x1, b2_y2, b2_x2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "b2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(boxes2, [tf.shape(boxes1)[0], 1])",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "maximum_424": {
                "variable": {
                    "value": "y1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "b1_y1",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "b2_y1",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "maximum_425": {
                "variable": {
                    "value": "x1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "b1_x1",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "b2_x1",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "minimum_426": {
                "variable": {
                    "value": "y2",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "b1_y2",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "b2_y2",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "minimum_427": {
                "variable": {
                    "value": "x2",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "b1_x2",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "b2_x2",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reshape_435": {
                "variable": {
                    "value": "overlaps",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "iou",
                    "type": "variable",
                    "possible_values": [
                        [
                            "intersection / union",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[tf.shape(boxes1)[0], tf.shape(boxes2)[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "boolean_mask_472": {
                "variable": {
                    "value": "gt_class_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "gt_class_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(gt_class_ids, non_zeros, name='trim_gt_class_ids')",
                            "Call"
                        ],
                        [
                            "tf.gather(gt_class_ids, non_crowd_ix)",
                            "Call"
                        ],
                        [
                            "gt_class_ids[instance_ids]",
                            "Subscript"
                        ],
                        [
                            "gt_class_ids[non_crowd_ix]",
                            "Subscript"
                        ],
                        [
                            "gt_class_ids[ids]",
                            "Subscript"
                        ],
                        [
                            "inputs[1]",
                            "Subscript"
                        ]
                    ]
                },
                "mask": {
                    "value": "non_zeros",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.reduce_sum(tf.abs(boxes), axis=1), tf.bool)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "trim_gt_class_ids",
                    "type": "str",
                    "possible_values": []
                }
            },
            "gather_474": {
                "variable": {
                    "value": "gt_masks",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "gt_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(gt_masks, tf.where(non_zeros)[:, 0], axis=2, name='trim_gt_masks')",
                            "Call"
                        ],
                        [
                            "tf.gather(gt_masks, non_crowd_ix, axis=2)",
                            "Call"
                        ],
                        [
                            "gt_masks[:, :, instance_ids]",
                            "Subscript"
                        ],
                        [
                            "gt_masks[:, :, ids]",
                            "Subscript"
                        ],
                        [
                            "inputs[3]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.where(non_zeros)[:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "trim_gt_masks",
                    "type": "str",
                    "possible_values": []
                }
            },
            "gather_482": {
                "variable": {
                    "value": "crowd_boxes",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "gt_boxes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(gt_boxes, non_crowd_ix)",
                            "Call"
                        ],
                        [
                            "gt_boxes[instance_ids]",
                            "Subscript"
                        ],
                        [
                            "gt_boxes[non_crowd_ix]",
                            "Subscript"
                        ],
                        [
                            "gt_boxes[ids]",
                            "Subscript"
                        ],
                        [
                            "inputs[2]",
                            "Subscript"
                        ],
                        [
                            "KL.Lambda(lambda x: x / image_scale)(input_gt_boxes)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "crowd_ix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(gt_class_ids < 0)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "np.where(gt_class_ids < 0)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "gather_483": {
                "variable": {
                    "value": "crowd_masks",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "gt_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(gt_masks, tf.where(non_zeros)[:, 0], axis=2, name='trim_gt_masks')",
                            "Call"
                        ],
                        [
                            "tf.gather(gt_masks, non_crowd_ix, axis=2)",
                            "Call"
                        ],
                        [
                            "gt_masks[:, :, instance_ids]",
                            "Subscript"
                        ],
                        [
                            "gt_masks[:, :, ids]",
                            "Subscript"
                        ],
                        [
                            "inputs[3]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "crowd_ix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(gt_class_ids < 0)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "np.where(gt_class_ids < 0)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_484": {
                "variable": {
                    "value": "gt_class_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "gt_class_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(gt_class_ids, non_zeros, name='trim_gt_class_ids')",
                            "Call"
                        ],
                        [
                            "tf.gather(gt_class_ids, non_crowd_ix)",
                            "Call"
                        ],
                        [
                            "gt_class_ids[instance_ids]",
                            "Subscript"
                        ],
                        [
                            "gt_class_ids[non_crowd_ix]",
                            "Subscript"
                        ],
                        [
                            "gt_class_ids[ids]",
                            "Subscript"
                        ],
                        [
                            "inputs[1]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "non_crowd_ix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(gt_class_ids > 0)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "np.where(gt_class_ids > 0)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "gather_485": {
                "variable": {
                    "value": "gt_boxes",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "gt_boxes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(gt_boxes, non_crowd_ix)",
                            "Call"
                        ],
                        [
                            "gt_boxes[instance_ids]",
                            "Subscript"
                        ],
                        [
                            "gt_boxes[non_crowd_ix]",
                            "Subscript"
                        ],
                        [
                            "gt_boxes[ids]",
                            "Subscript"
                        ],
                        [
                            "inputs[2]",
                            "Subscript"
                        ],
                        [
                            "KL.Lambda(lambda x: x / image_scale)(input_gt_boxes)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "non_crowd_ix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(gt_class_ids > 0)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "np.where(gt_class_ids > 0)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "gather_486": {
                "variable": {
                    "value": "gt_masks",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "gt_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(gt_masks, tf.where(non_zeros)[:, 0], axis=2, name='trim_gt_masks')",
                            "Call"
                        ],
                        [
                            "tf.gather(gt_masks, non_crowd_ix, axis=2)",
                            "Call"
                        ],
                        [
                            "gt_masks[:, :, instance_ids]",
                            "Subscript"
                        ],
                        [
                            "gt_masks[:, :, ids]",
                            "Subscript"
                        ],
                        [
                            "inputs[3]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "non_crowd_ix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(gt_class_ids > 0)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "np.where(gt_class_ids > 0)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_493": {
                "variable": {
                    "value": "crowd_iou_max",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "crowd_overlaps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "overlaps_graph(proposals, crowd_boxes)",
                            "Call"
                        ],
                        [
                            "utils.compute_overlaps(anchors, crowd_boxes)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_497": {
                "variable": {
                    "value": "roi_iou_max",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "overlaps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(iou, [tf.shape(boxes1)[0], tf.shape(boxes2)[0]])",
                            "Call"
                        ],
                        [
                            "overlaps_graph(proposals, gt_boxes)",
                            "Call"
                        ],
                        [
                            "np.zeros((rpn_rois.shape[0], gt_boxes.shape[0]))",
                            "Call"
                        ],
                        [
                            "utils.compute_overlaps(anchors, gt_boxes)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_515": {
                "variable": {
                    "value": "positive_rois",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "proposals",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(proposals)",
                            "Call"
                        ],
                        [
                            "utils.batch_slice([normalized_boxes, scores], nms, self.config.IMAGES_PER_GPU)",
                            "Call"
                        ],
                        [
                            "tf.gather(normalized_boxes, indices)",
                            "Call"
                        ],
                        [
                            "tf.pad(proposals, [(0, padding), (0, 0)])",
                            "Call"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "positive_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(positive_roi_bool)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.random_shuffle(positive_indices)[:positive_count]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "gather_516": {
                "variable": {
                    "value": "negative_rois",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "proposals",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(proposals)",
                            "Call"
                        ],
                        [
                            "utils.batch_slice([normalized_boxes, scores], nms, self.config.IMAGES_PER_GPU)",
                            "Call"
                        ],
                        [
                            "tf.gather(normalized_boxes, indices)",
                            "Call"
                        ],
                        [
                            "tf.pad(proposals, [(0, padding), (0, 0)])",
                            "Call"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "negative_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.logical_and(roi_iou_max < 0.5, no_crowd_bool))[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.random_shuffle(negative_indices)[:negative_count]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "gather_519": {
                "variable": {
                    "value": "positive_overlaps",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "overlaps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(iou, [tf.shape(boxes1)[0], tf.shape(boxes2)[0]])",
                            "Call"
                        ],
                        [
                            "overlaps_graph(proposals, gt_boxes)",
                            "Call"
                        ],
                        [
                            "np.zeros((rpn_rois.shape[0], gt_boxes.shape[0]))",
                            "Call"
                        ],
                        [
                            "utils.compute_overlaps(anchors, gt_boxes)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "positive_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(positive_roi_bool)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.random_shuffle(positive_indices)[:positive_count]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "argmax_520": {
                "variable": {
                    "value": "roi_gt_box_assignment",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "positive_overlaps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(overlaps, positive_indices)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_521": {
                "variable": {
                    "value": "roi_gt_boxes",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "gt_boxes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(gt_boxes, non_crowd_ix)",
                            "Call"
                        ],
                        [
                            "gt_boxes[instance_ids]",
                            "Subscript"
                        ],
                        [
                            "gt_boxes[non_crowd_ix]",
                            "Subscript"
                        ],
                        [
                            "gt_boxes[ids]",
                            "Subscript"
                        ],
                        [
                            "inputs[2]",
                            "Subscript"
                        ],
                        [
                            "KL.Lambda(lambda x: x / image_scale)(input_gt_boxes)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "roi_gt_box_assignment",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(positive_overlaps, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_522": {
                "variable": {
                    "value": "roi_gt_class_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "gt_class_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(gt_class_ids, non_zeros, name='trim_gt_class_ids')",
                            "Call"
                        ],
                        [
                            "tf.gather(gt_class_ids, non_crowd_ix)",
                            "Call"
                        ],
                        [
                            "gt_class_ids[instance_ids]",
                            "Subscript"
                        ],
                        [
                            "gt_class_ids[non_crowd_ix]",
                            "Subscript"
                        ],
                        [
                            "gt_class_ids[ids]",
                            "Subscript"
                        ],
                        [
                            "inputs[1]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "roi_gt_box_assignment",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(positive_overlaps, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_530": {
                "variable": {
                    "value": "transposed_masks",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.transpose(gt_masks, [2, 0, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_532": {
                "variable": {
                    "value": "roi_masks",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "transposed_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.transpose(gt_masks, [2, 0, 1]), -1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "roi_gt_box_assignment",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(positive_overlaps, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "crop_and_resize_549": {
                "variable": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "tf.cast(roi_masks, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "boxes": {
                    "value": "boxes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "positive_rois",
                            "variable"
                        ],
                        [
                            "tf.concat([y1, x1, y2, x2], 1)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(boxes, non_zeros, name=name)",
                            "Call"
                        ],
                        [
                            "utils.batch_slice([anchors, deltas], lambda x, y: apply_box_deltas_graph(x, y), self.config.IMAGES_PER_GPU, names=['refined_anchors'])",
                            "Call"
                        ],
                        [
                            "utils.batch_slice(boxes, lambda x: clip_boxes_graph(x, window), self.config.IMAGES_PER_GPU, names=['refined_anchors_clipped'])",
                            "Call"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "detections[:N, :4]",
                            "Subscript"
                        ],
                        [
                            "np.multiply(boxes - shifts, scales).astype(np.int32)",
                            "Call"
                        ],
                        [
                            "np.delete(boxes, exclude_ix, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "box_indices": {
                    "value": "box_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(0, tf.shape(roi_masks)[0])",
                            "Call"
                        ]
                    ]
                },
                "crop_size": {
                    "value": "config.MASK_SHAPE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "squeeze_553": {
                "variable": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.crop_and_resize(tf.cast(roi_masks, tf.float32), boxes, box_ids, config.MASK_SHAPE)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(masks, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.round(masks)",
                            "Call"
                        ],
                        [
                            "tf.pad(masks, [[0, N + P], (0, 0), (0, 0)])",
                            "Call"
                        ],
                        [
                            "np.zeros((config.TRAIN_ROIS_PER_IMAGE, config.MASK_SHAPE[0], config.MASK_SHAPE[1], config.NUM_CLASSES), dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "mrcnn_mask[np.arange(N), :, :, class_ids]",
                            "Subscript"
                        ],
                        [
                            "np.delete(masks, exclude_ix, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "round_557": {
                "variable": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.crop_and_resize(tf.cast(roi_masks, tf.float32), boxes, box_ids, config.MASK_SHAPE)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(masks, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.round(masks)",
                            "Call"
                        ],
                        [
                            "tf.pad(masks, [[0, N + P], (0, 0), (0, 0)])",
                            "Call"
                        ],
                        [
                            "np.zeros((config.TRAIN_ROIS_PER_IMAGE, config.MASK_SHAPE[0], config.MASK_SHAPE[1], config.NUM_CLASSES), dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "mrcnn_mask[np.arange(N), :, :, class_ids]",
                            "Subscript"
                        ],
                        [
                            "np.delete(masks, exclude_ix, axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_561": {
                "variable": {
                    "value": "rois",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[positive_rois, negative_rois]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "maximum_563": {
                "variable": {
                    "value": "P",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "config.TRAIN_ROIS_PER_IMAGE - tf.shape(rois)[0]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pad_564": {
                "variable": {
                    "value": "rois",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "rois",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([positive_rois, negative_rois], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.pad(rois, [(0, P), (0, 0)])",
                            "Call"
                        ],
                        [
                            "rpn_rois[keep]",
                            "Subscript"
                        ],
                        [
                            "np.zeros((count, 4), dtype=np.int32)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[(0, P), (0, 0)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "pad_565": {
                "variable": {
                    "value": "roi_gt_boxes",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "roi_gt_boxes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(gt_boxes, roi_gt_box_assignment)",
                            "Call"
                        ],
                        [
                            "tf.pad(roi_gt_boxes, [(0, N + P), (0, 0)])",
                            "Call"
                        ],
                        [
                            "rpn_roi_gt_boxes[keep]",
                            "Subscript"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[(0, N + P), (0, 0)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "pad_566": {
                "variable": {
                    "value": "roi_gt_class_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "roi_gt_class_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(gt_class_ids, roi_gt_box_assignment)",
                            "Call"
                        ],
                        [
                            "tf.pad(roi_gt_class_ids, [(0, N + P)])",
                            "Call"
                        ],
                        [
                            "rpn_roi_gt_class_ids[keep]",
                            "Subscript"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[(0, N + P)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "pad_567": {
                "variable": {
                    "value": "deltas",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "deltas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.box_refinement_graph(positive_rois, roi_gt_boxes)",
                            "Call"
                        ],
                        [
                            "deltas / config.BBOX_STD_DEV",
                            "BinOp"
                        ],
                        [
                            "tf.pad(deltas, [(0, N + P), (0, 0)])",
                            "Call"
                        ],
                        [
                            "inputs[1]",
                            "Subscript"
                        ],
                        [
                            "deltas * np.reshape(self.config.RPN_BBOX_STD_DEV, [1, 1, 4])",
                            "BinOp"
                        ],
                        [
                            "utils.batch_slice([deltas, ix], lambda x, y: tf.gather(x, y), self.config.IMAGES_PER_GPU)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[(0, N + P), (0, 0)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "pad_568": {
                "variable": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.crop_and_resize(tf.cast(roi_masks, tf.float32), boxes, box_ids, config.MASK_SHAPE)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(masks, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.round(masks)",
                            "Call"
                        ],
                        [
                            "tf.pad(masks, [[0, N + P], (0, 0), (0, 0)])",
                            "Call"
                        ],
                        [
                            "np.zeros((config.TRAIN_ROIS_PER_IMAGE, config.MASK_SHAPE[0], config.MASK_SHAPE[1], config.NUM_CLASSES), dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "mrcnn_mask[np.arange(N), :, :, class_ids]",
                            "Subscript"
                        ],
                        [
                            "np.delete(masks, exclude_ix, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, N + P], (0, 0), (0, 0)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "squeeze_950": {
                "variable": {
                    "value": "rpn_match",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "rpn_match",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(rpn_match, -1)",
                            "Call"
                        ],
                        [
                            "K.squeeze(rpn_match, -1)",
                            "Call"
                        ],
                        [
                            "np.zeros([anchors.shape[0]], dtype=np.int32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "where_955": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "K.not_equal(rpn_match, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_nd_957": {
                "variable": {
                    "value": "rpn_class_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "rpn_class_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "KL.Lambda(lambda t: tf.reshape(t, [tf.shape(t)[0], -1, 2]))(x)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(rpn_class_logits, indices)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(K.not_equal(rpn_match, 0))",
                            "Call"
                        ],
                        [
                            "tf.where(K.equal(rpn_match, 1))",
                            "Call"
                        ],
                        [
                            "tf.stack([positive_roi_ix, positive_roi_class_ids], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([positive_ix, positive_class_ids], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.image.non_max_suppression(normalized_boxes, scores, self.proposal_count, self.nms_threshold, name='rpn_non_max_suppression')",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_958": {
                "variable": {
                    "value": "anchor_class",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "anchor_class",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.cast(K.equal(rpn_match, 1), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(anchor_class, indices)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(K.not_equal(rpn_match, 0))",
                            "Call"
                        ],
                        [
                            "tf.where(K.equal(rpn_match, 1))",
                            "Call"
                        ],
                        [
                            "tf.stack([positive_roi_ix, positive_roi_class_ids], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([positive_ix, positive_class_ids], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.image.non_max_suppression(normalized_boxes, scores, self.proposal_count, self.nms_threshold, name='rpn_non_max_suppression')",
                            "Call"
                        ]
                    ]
                }
            },
            "where_980": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "K.equal(rpn_match, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_nd_983": {
                "variable": {
                    "value": "rpn_bbox",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "rpn_bbox",
                    "type": "variable",
                    "possible_values": [
                        [
                            "KL.Lambda(lambda t: tf.reshape(t, [tf.shape(t)[0], -1, 4]))(x)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(rpn_bbox, indices)",
                            "Call"
                        ],
                        [
                            "np.zeros((config.RPN_TRAIN_ANCHORS_PER_IMAGE, 4))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(K.not_equal(rpn_match, 0))",
                            "Call"
                        ],
                        [
                            "tf.where(K.equal(rpn_match, 1))",
                            "Call"
                        ],
                        [
                            "tf.stack([positive_roi_ix, positive_roi_class_ids], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([positive_ix, positive_class_ids], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.image.non_max_suppression(normalized_boxes, scores, self.proposal_count, self.nms_threshold, name='rpn_non_max_suppression')",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_1011": {
                "variable": {
                    "value": "target_class_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "target_class_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(target_class_ids, 'int64')",
                            "Call"
                        ],
                        [
                            "K.reshape(target_class_ids, (-1,))",
                            "Call"
                        ],
                        [
                            "K.reshape(target_class_ids, (-1,))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "int64",
                    "type": "str",
                    "possible_values": []
                }
            },
            "argmax_1014": {
                "variable": {
                    "value": "pred_class_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pred_class_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_1017": {
                "variable": {
                    "value": "pred_active",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "active_class_ids[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "indices": {
                    "value": "pred_class_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(pred_class_logits, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "sparse_softmax_cross_entropy_with_logits_1020": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "target_class_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(target_class_ids, 'int64')",
                            "Call"
                        ],
                        [
                            "K.reshape(target_class_ids, (-1,))",
                            "Call"
                        ],
                        [
                            "K.reshape(target_class_ids, (-1,))",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "pred_class_logits",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cast_1048": {
                "variable": {
                    "value": "positive_roi_class_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.gather(target_class_ids, positive_roi_ix)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_1050": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[positive_roi_ix, positive_roi_class_ids]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_1053": {
                "variable": {
                    "value": "target_bbox",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "target_bbox",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch_pack_graph(target_bbox, batch_counts, config.IMAGES_PER_GPU)",
                            "Call"
                        ],
                        [
                            "K.reshape(target_bbox, (-1, 4))",
                            "Call"
                        ],
                        [
                            "tf.gather(target_bbox, positive_roi_ix)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "positive_roi_ix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(target_class_ids > 0)[:, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "gather_nd_1054": {
                "variable": {
                    "value": "pred_bbox",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "pred_bbox",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.reshape(pred_bbox, (-1, K.int_shape(pred_bbox)[2], 4))",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(pred_bbox, indices)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(K.not_equal(rpn_match, 0))",
                            "Call"
                        ],
                        [
                            "tf.where(K.equal(rpn_match, 1))",
                            "Call"
                        ],
                        [
                            "tf.stack([positive_roi_ix, positive_roi_class_ids], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([positive_ix, positive_class_ids], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.image.non_max_suppression(normalized_boxes, scores, self.proposal_count, self.nms_threshold, name='rpn_non_max_suppression')",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_1076": {
                "variable": {
                    "value": "mask_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "target_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.reshape(target_masks, (-1, mask_shape[2], mask_shape[3]))",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_1078": {
                "variable": {
                    "value": "pred_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pred_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.reshape(pred_masks, (-1, pred_shape[2], pred_shape[3], pred_shape[4]))",
                            "Call"
                        ],
                        [
                            "tf.transpose(pred_masks, [0, 3, 1, 2])",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_1082": {
                "variable": {
                    "value": "pred_masks",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "pred_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.reshape(pred_masks, (-1, pred_shape[2], pred_shape[3], pred_shape[4]))",
                            "Call"
                        ],
                        [
                            "tf.transpose(pred_masks, [0, 3, 1, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 3, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_1087": {
                "variable": {
                    "value": "positive_class_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.gather(target_class_ids, positive_ix)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_1089": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[positive_ix, positive_class_ids]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_1092": {
                "variable": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "target_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.reshape(target_masks, (-1, mask_shape[2], mask_shape[3]))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "positive_ix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(target_class_ids > 0)[:, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "gather_nd_1093": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "pred_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.reshape(pred_masks, (-1, pred_shape[2], pred_shape[3], pred_shape[4]))",
                            "Call"
                        ],
                        [
                            "tf.transpose(pred_masks, [0, 3, 1, 2])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(K.not_equal(rpn_match, 0))",
                            "Call"
                        ],
                        [
                            "tf.where(K.equal(rpn_match, 1))",
                            "Call"
                        ],
                        [
                            "tf.stack([positive_roi_ix, positive_roi_class_ids], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([positive_ix, positive_class_ids], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.image.non_max_suppression(normalized_boxes, scores, self.proposal_count, self.nms_threshold, name='rpn_non_max_suppression')",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_2489": {
                "variable": {
                    "value": "non_zeros",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(tf.abs(boxes), axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "boolean_mask_2490": {
                "variable": {
                    "value": "boxes",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "boxes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "positive_rois",
                            "variable"
                        ],
                        [
                            "tf.concat([y1, x1, y2, x2], 1)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(boxes, non_zeros, name=name)",
                            "Call"
                        ],
                        [
                            "utils.batch_slice([anchors, deltas], lambda x, y: apply_box_deltas_graph(x, y), self.config.IMAGES_PER_GPU, names=['refined_anchors'])",
                            "Call"
                        ],
                        [
                            "utils.batch_slice(boxes, lambda x: clip_boxes_graph(x, window), self.config.IMAGES_PER_GPU, names=['refined_anchors_clipped'])",
                            "Call"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "detections[:N, :4]",
                            "Subscript"
                        ],
                        [
                            "np.multiply(boxes - shifts, scales).astype(np.int32)",
                            "Call"
                        ],
                        [
                            "np.delete(boxes, exclude_ix, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "non_zeros",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.reduce_sum(tf.abs(boxes), axis=1), tf.bool)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss_names",
                            "variable"
                        ],
                        [
                            "loss_names",
                            "variable"
                        ],
                        [
                            "re.compile(name.replace('/', '(\\\\_\\\\d+)*/'))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "exp_186": {
                "x": {
                    "value": "deltas[:, 2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "exp_187": {
                "x": {
                    "value": "deltas[:, 3]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "split_340": {
                "variable": {
                    "value": "(y1, x1, y2, x2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "boxes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "positive_rois",
                            "variable"
                        ],
                        [
                            "tf.concat([y1, x1, y2, x2], 1)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(boxes, non_zeros, name=name)",
                            "Call"
                        ],
                        [
                            "utils.batch_slice([anchors, deltas], lambda x, y: apply_box_deltas_graph(x, y), self.config.IMAGES_PER_GPU, names=['refined_anchors'])",
                            "Call"
                        ],
                        [
                            "utils.batch_slice(boxes, lambda x: clip_boxes_graph(x, window), self.config.IMAGES_PER_GPU, names=['refined_anchors_clipped'])",
                            "Call"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "detections[:N, :4]",
                            "Subscript"
                        ],
                        [
                            "np.multiply(boxes - shifts, scales).astype(np.int32)",
                            "Call"
                        ],
                        [
                            "np.delete(boxes, exclude_ix, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_346": {
                "variable": {
                    "value": "image_area",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.image_shape[0] * self.image_shape[1]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "minimum_349": {
                "variable": {
                    "value": "roi_level",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.maximum(2, 4 + tf.cast(tf.round(roi_level), tf.int32))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "squeeze_351": {
                "variable": {
                    "value": "roi_level",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "roi_level",
                    "type": "variable",
                    "possible_values": [
                        [
                            "log2_graph(tf.sqrt(h * w) / (224.0 / tf.sqrt(image_area)))",
                            "Call"
                        ],
                        [
                            "tf.minimum(5, tf.maximum(2, 4 + tf.cast(tf.round(roi_level), tf.int32)))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(roi_level, 2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_384": {
                "variable": {
                    "value": "pooled",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "pooled",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(pooled, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(pooled, ix)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pooled, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_388": {
                "variable": {
                    "value": "box_to_level",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "box_to_level",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(box_to_level, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.cast(box_to_level, tf.int32), box_range], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_389": {
                "variable": {
                    "value": "box_range",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.range(tf.shape(box_to_level)[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_390": {
                "variable": {
                    "value": "box_to_level",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.cast(box_to_level, tf.int32), box_range]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_399": {
                "variable": {
                    "value": "ix",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "box_to_level[:, 2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "indices": {
                    "value": "ix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "ix + 1",
                            "BinOp"
                        ],
                        [
                            "tf.nn.top_k(scores, pre_nms_limit, sorted=True, name='top_anchors').indices",
                            "Attribute"
                        ],
                        [
                            "tf.where(tf.equal(roi_level, level))",
                            "Call"
                        ],
                        [
                            "tf.nn.top_k(sorting_tensor, k=tf.shape(box_to_level)[0]).indices[::-1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(box_to_level[:, 2], ix)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_400": {
                "variable": {
                    "value": "pooled",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "pooled",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(pooled, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(pooled, ix)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pooled, 0)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "ix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "ix + 1",
                            "BinOp"
                        ],
                        [
                            "tf.nn.top_k(scores, pre_nms_limit, sorted=True, name='top_anchors').indices",
                            "Attribute"
                        ],
                        [
                            "tf.where(tf.equal(roi_level, level))",
                            "Call"
                        ],
                        [
                            "tf.nn.top_k(sorting_tensor, k=tf.shape(box_to_level)[0]).indices[::-1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(box_to_level[:, 2], ix)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_403": {
                "variable": {
                    "value": "pooled",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pooled",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(pooled, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(pooled, ix)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pooled, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "identity_467": {
                "variable": {
                    "value": "proposals",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "proposals",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(proposals)",
                            "Call"
                        ],
                        [
                            "utils.batch_slice([normalized_boxes, scores], nms, self.config.IMAGES_PER_GPU)",
                            "Call"
                        ],
                        [
                            "tf.gather(normalized_boxes, indices)",
                            "Call"
                        ],
                        [
                            "tf.pad(proposals, [(0, padding), (0, 0)])",
                            "Call"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "split_539": {
                "variable": {
                    "value": "(y1, x1, y2, x2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "positive_rois",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(proposals, positive_indices)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_540": {
                "variable": {
                    "value": "(gt_y1, gt_x1, gt_y2, gt_x2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "roi_gt_boxes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(gt_boxes, roi_gt_box_assignment)",
                            "Call"
                        ],
                        [
                            "tf.pad(roi_gt_boxes, [(0, N + P), (0, 0)])",
                            "Call"
                        ],
                        [
                            "rpn_roi_gt_boxes[keep]",
                            "Subscript"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_547": {
                "variable": {
                    "value": "boxes",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[y1, x1, y2, x2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_2501": {
                "values": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "rpn_graph(input_feature_map, anchors_per_location, anchor_stride)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "utils.batch_slice([proposals, gt_class_ids, gt_boxes, gt_masks], lambda w, x, y, z: detection_targets_graph(w, x, y, z, self.config), self.config.IMAGES_PER_GPU, names=names)",
                            "Call"
                        ],
                        [
                            "list(zip(*layer_outputs))",
                            "Call"
                        ],
                        [
                            "[KL.Concatenate(axis=1, name=n)(list(o)) for (o, n) in zip(outputs, output_names)]",
                            "ListComp"
                        ],
                        [
                            "[rpn_class_logits, rpn_class, rpn_bbox, mrcnn_class_logits, mrcnn_class, mrcnn_bbox, mrcnn_mask, rpn_rois, output_rois, rpn_class_loss, rpn_bbox_loss, class_loss, bbox_loss, mask_loss]",
                            "List"
                        ],
                        [
                            "OrderedDict(outputs)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "minimum_206": {
                "x": {
                    "value": "y1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "center_y - 0.5 * height",
                            "BinOp"
                        ],
                        [
                            "tf.maximum(tf.minimum(y1, wy2), wy1)",
                            "Call"
                        ],
                        [
                            "tf.maximum(b1_y1, b2_y1)",
                            "Call"
                        ],
                        [
                            "(y1 - gt_y1) / gt_h",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "wy2",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "minimum_207": {
                "x": {
                    "value": "x1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "center_x - 0.5 * width",
                            "BinOp"
                        ],
                        [
                            "tf.maximum(tf.minimum(x1, wx2), wx1)",
                            "Call"
                        ],
                        [
                            "tf.maximum(b1_x1, b2_x1)",
                            "Call"
                        ],
                        [
                            "(x1 - gt_x1) / gt_w",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "wx2",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "minimum_208": {
                "x": {
                    "value": "y2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "y1 + height",
                            "BinOp"
                        ],
                        [
                            "tf.maximum(tf.minimum(y2, wy2), wy1)",
                            "Call"
                        ],
                        [
                            "tf.minimum(b1_y2, b2_y2)",
                            "Call"
                        ],
                        [
                            "(y2 - gt_y1) / gt_h",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "wy2",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "minimum_209": {
                "x": {
                    "value": "x2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x1 + width",
                            "BinOp"
                        ],
                        [
                            "tf.maximum(tf.minimum(x2, wx2), wx1)",
                            "Call"
                        ],
                        [
                            "tf.minimum(b1_x2, b2_x2)",
                            "Call"
                        ],
                        [
                            "(x2 - gt_x1) / gt_w",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "wx2",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "non_max_suppression_285": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "boxes": {
                    "value": "normalized_boxes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "boxes / np.array([[height, width, height, width]])",
                            "BinOp"
                        ]
                    ]
                },
                "scores": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs[0][:, :, 1]",
                            "Subscript"
                        ],
                        [
                            "utils.batch_slice([scores, ix], lambda x, y: tf.gather(x, y), self.config.IMAGES_PER_GPU)",
                            "Call"
                        ],
                        [
                            "detections[:N, 5]",
                            "Subscript"
                        ],
                        [
                            "np.delete(scores, exclude_ix, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "max_output_size": {
                    "value": "self.proposal_count",
                    "type": "Attribute",
                    "possible_values": []
                },
                "iou_threshold": {
                    "value": "self.nms_threshold",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "rpn_non_max_suppression",
                    "type": "str",
                    "possible_values": []
                }
            },
            "gather_288": {
                "variable": {
                    "value": "proposals",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "normalized_boxes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "boxes / np.array([[height, width, height, width]])",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(K.not_equal(rpn_match, 0))",
                            "Call"
                        ],
                        [
                            "tf.where(K.equal(rpn_match, 1))",
                            "Call"
                        ],
                        [
                            "tf.stack([positive_roi_ix, positive_roi_class_ids], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([positive_ix, positive_class_ids], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.image.non_max_suppression(normalized_boxes, scores, self.proposal_count, self.nms_threshold, name='rpn_non_max_suppression')",
                            "Call"
                        ]
                    ]
                }
            },
            "maximum_290": {
                "variable": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.proposal_count - tf.shape(proposals)[0]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pad_291": {
                "variable": {
                    "value": "proposals",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "proposals",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(proposals)",
                            "Call"
                        ],
                        [
                            "utils.batch_slice([normalized_boxes, scores], nms, self.config.IMAGES_PER_GPU)",
                            "Call"
                        ],
                        [
                            "tf.gather(normalized_boxes, indices)",
                            "Call"
                        ],
                        [
                            "tf.pad(proposals, [(0, padding), (0, 0)])",
                            "Call"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[(0, padding), (0, 0)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "log_303": {
                "x": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "where_357": {
                "variable": {
                    "value": "ix",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.equal(roi_level, level)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_nd_358": {
                "variable": {
                    "value": "level_boxes",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "boxes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "positive_rois",
                            "variable"
                        ],
                        [
                            "tf.concat([y1, x1, y2, x2], 1)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(boxes, non_zeros, name=name)",
                            "Call"
                        ],
                        [
                            "utils.batch_slice([anchors, deltas], lambda x, y: apply_box_deltas_graph(x, y), self.config.IMAGES_PER_GPU, names=['refined_anchors'])",
                            "Call"
                        ],
                        [
                            "utils.batch_slice(boxes, lambda x: clip_boxes_graph(x, window), self.config.IMAGES_PER_GPU, names=['refined_anchors_clipped'])",
                            "Call"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "detections[:N, :4]",
                            "Subscript"
                        ],
                        [
                            "np.multiply(boxes - shifts, scales).astype(np.int32)",
                            "Call"
                        ],
                        [
                            "np.delete(boxes, exclude_ix, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "ix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "ix + 1",
                            "BinOp"
                        ],
                        [
                            "tf.nn.top_k(scores, pre_nms_limit, sorted=True, name='top_anchors').indices",
                            "Attribute"
                        ],
                        [
                            "tf.where(tf.equal(roi_level, level))",
                            "Call"
                        ],
                        [
                            "tf.nn.top_k(sorting_tensor, k=tf.shape(box_to_level)[0]).indices[::-1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(box_to_level[:, 2], ix)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_361": {
                "variable": {
                    "value": "box_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "ix[:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stop_gradient_367": {
                "variable": {
                    "value": "level_boxes",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "level_boxes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(boxes, ix)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(level_boxes)",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_368": {
                "variable": {
                    "value": "box_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "box_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(ix[:, 0], tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(box_indices)",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_418": {
                "input": {
                    "value": "tf.expand_dims(boxes1, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, tf.shape(boxes2)[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "maximum_428": {
                "x": {
                    "value": "y2 - y1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Assert_463": {
                "condition": {
                    "value": "tf.greater(tf.shape(proposals)[0], 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "data": {
                    "value": "[proposals]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "roi_assertion",
                    "type": "str",
                    "possible_values": []
                }
            },
            "control_dependencies_466": {
                "control_inputs": {
                    "value": "asserts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.Assert(tf.greater(tf.shape(proposals)[0], 0), [proposals], name='roi_assertion')]",
                            "List"
                        ]
                    ]
                }
            },
            "where_480": {
                "condition": {
                    "value": "gt_class_ids < 0",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "where_481": {
                "condition": {
                    "value": "gt_class_ids > 0",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "where_500": {
                "condition": {
                    "value": "positive_roi_bool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "roi_iou_max >= 0.5",
                            "Compare"
                        ]
                    ]
                }
            },
            "where_502": {
                "condition": {
                    "value": "tf.logical_and(roi_iou_max < 0.5, no_crowd_bool)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_509": {
                "input": {
                    "value": "positive_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(positive_roi_bool)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.random_shuffle(positive_indices)[:positive_count]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "cast_512": {
                "x": {
                    "value": "positive_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "int(config.TRAIN_ROIS_PER_IMAGE * config.ROI_POSITIVE_RATIO)",
                            "Call"
                        ],
                        [
                            "tf.shape(positive_indices)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "transpose_530": {
                "a": {
                    "value": "gt_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(gt_masks, tf.where(non_zeros)[:, 0], axis=2, name='trim_gt_masks')",
                            "Call"
                        ],
                        [
                            "tf.gather(gt_masks, non_crowd_ix, axis=2)",
                            "Call"
                        ],
                        [
                            "gt_masks[:, :, instance_ids]",
                            "Subscript"
                        ],
                        [
                            "gt_masks[:, :, ids]",
                            "Subscript"
                        ],
                        [
                            "inputs[3]",
                            "Subscript"
                        ]
                    ]
                },
                "perm": {
                    "value": "[2, 0, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_549": {
                "x": {
                    "value": "roi_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(transposed_masks, roi_gt_box_assignment)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_562": {
                "input": {
                    "value": "negative_rois",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(proposals, negative_indices)",
                            "Call"
                        ]
                    ]
                }
            },
            "py_func_752": {
                "func": {
                    "value": "wrapper",
                    "type": "variable",
                    "possible_values": []
                },
                "inp": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[batch_images, batch_image_meta, batch_rpn_match, batch_rpn_bbox, batch_gt_class_ids, batch_gt_boxes, batch_gt_masks]",
                            "List"
                        ],
                        [
                            "[input_image, input_image_meta, input_rpn_match, input_rpn_bbox, input_gt_class_ids, input_gt_boxes, input_gt_masks]",
                            "List"
                        ],
                        [
                            "model.inputs",
                            "Attribute"
                        ],
                        [
                            "inputs + [K.learning_phase()]",
                            "BinOp"
                        ]
                    ]
                },
                "Tout": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_963": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_996": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reduce_sum_1029": {
                "input_tensor": {
                    "value": "pred_active",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(active_class_ids[0], pred_class_ids)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_1047": {
                "condition": {
                    "value": "target_class_ids > 0",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "gather_1049": {
                "params": {
                    "value": "target_class_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(target_class_ids, 'int64')",
                            "Call"
                        ],
                        [
                            "K.reshape(target_class_ids, (-1,))",
                            "Call"
                        ],
                        [
                            "K.reshape(target_class_ids, (-1,))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "positive_roi_ix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(target_class_ids > 0)[:, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "constant_1059": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "where_1086": {
                "condition": {
                    "value": "target_class_ids > 0",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "gather_1088": {
                "params": {
                    "value": "target_class_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(target_class_ids, 'int64')",
                            "Call"
                        ],
                        [
                            "K.reshape(target_class_ids, (-1,))",
                            "Call"
                        ],
                        [
                            "K.reshape(target_class_ids, (-1,))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "positive_ix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(target_class_ids > 0)[:, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "constant_1099": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reduce_sum_2489": {
                "input_tensor": {
                    "value": "tf.abs(boxes)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "top_k_251": {
                "input": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs[0][:, :, 1]",
                            "Subscript"
                        ],
                        [
                            "utils.batch_slice([scores, ix], lambda x, y: tf.gather(x, y), self.config.IMAGES_PER_GPU)",
                            "Call"
                        ],
                        [
                            "detections[:N, 5]",
                            "Subscript"
                        ],
                        [
                            "np.delete(scores, exclude_ix, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "pre_nms_limit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "min(6000, self.anchors.shape[0])",
                            "Call"
                        ]
                    ]
                },
                "sorted": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "top_anchors",
                    "type": "str",
                    "possible_values": []
                }
            },
            "maximum_349": {
                "x": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "y": {
                    "value": "4 + tf.cast(tf.round(roi_level), tf.int32)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "range_389": {},
            "expand_dims_418": {
                "input": {
                    "value": "boxes1",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "greater_463": {
                "x": {
                    "value": "tf.shape(proposals)[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_474": {
                "condition": {
                    "value": "non_zeros",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.reduce_sum(tf.abs(boxes), axis=1), tf.bool)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_and_502": {
                "x": {
                    "value": "roi_iou_max < 0.5",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "no_crowd_bool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "crowd_iou_max < 0.001",
                            "Compare"
                        ],
                        [
                            "crowd_iou_max < 0.001",
                            "Compare"
                        ],
                        [
                            "np.ones([anchors.shape[0]], dtype=bool)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_548": {
                "input": {
                    "value": "roi_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(transposed_masks, roi_gt_box_assignment)",
                            "Call"
                        ]
                    ]
                }
            },
            "size_963": {
                "input": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "less_than_one * 0.5 * diff ** 2 + (1 - less_than_one) * (diff - 0.5)",
                            "BinOp"
                        ],
                        [
                            "K.sparse_categorical_crossentropy(target=anchor_class, output=rpn_class_logits, from_logits=True)",
                            "Call"
                        ],
                        [
                            "K.switch(tf.size(loss) > 0, K.mean(loss), tf.constant(0.0))",
                            "Call"
                        ],
                        [
                            "less_than_one * 0.5 * diff ** 2 + (1 - less_than_one) * (diff - 0.5)",
                            "BinOp"
                        ],
                        [
                            "K.switch(tf.size(loss) > 0, K.mean(loss), tf.constant(0.0))",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(labels=target_class_ids, logits=pred_class_logits)",
                            "Call"
                        ],
                        [
                            "loss * pred_active",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(loss) / tf.reduce_sum(pred_active)",
                            "BinOp"
                        ],
                        [
                            "K.switch(tf.size(target_bbox) > 0, smooth_l1_loss(y_true=target_bbox, y_pred=pred_bbox), tf.constant(0.0))",
                            "Call"
                        ],
                        [
                            "K.mean(loss)",
                            "Call"
                        ],
                        [
                            "K.reshape(loss, [1, 1])",
                            "Call"
                        ],
                        [
                            "K.switch(tf.size(y_true) > 0, K.binary_crossentropy(target=y_true, output=y_pred), tf.constant(0.0))",
                            "Call"
                        ],
                        [
                            "K.mean(loss)",
                            "Call"
                        ],
                        [
                            "K.reshape(loss, [1, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "size_996": {
                "input": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "less_than_one * 0.5 * diff ** 2 + (1 - less_than_one) * (diff - 0.5)",
                            "BinOp"
                        ],
                        [
                            "K.sparse_categorical_crossentropy(target=anchor_class, output=rpn_class_logits, from_logits=True)",
                            "Call"
                        ],
                        [
                            "K.switch(tf.size(loss) > 0, K.mean(loss), tf.constant(0.0))",
                            "Call"
                        ],
                        [
                            "less_than_one * 0.5 * diff ** 2 + (1 - less_than_one) * (diff - 0.5)",
                            "BinOp"
                        ],
                        [
                            "K.switch(tf.size(loss) > 0, K.mean(loss), tf.constant(0.0))",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(labels=target_class_ids, logits=pred_class_logits)",
                            "Call"
                        ],
                        [
                            "loss * pred_active",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(loss) / tf.reduce_sum(pred_active)",
                            "BinOp"
                        ],
                        [
                            "K.switch(tf.size(target_bbox) > 0, smooth_l1_loss(y_true=target_bbox, y_pred=pred_bbox), tf.constant(0.0))",
                            "Call"
                        ],
                        [
                            "K.mean(loss)",
                            "Call"
                        ],
                        [
                            "K.reshape(loss, [1, 1])",
                            "Call"
                        ],
                        [
                            "K.switch(tf.size(y_true) > 0, K.binary_crossentropy(target=y_true, output=y_pred), tf.constant(0.0))",
                            "Call"
                        ],
                        [
                            "K.mean(loss)",
                            "Call"
                        ],
                        [
                            "K.reshape(loss, [1, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "size_1057": {
                "input": {
                    "value": "target_bbox",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch_pack_graph(target_bbox, batch_counts, config.IMAGES_PER_GPU)",
                            "Call"
                        ],
                        [
                            "K.reshape(target_bbox, (-1, 4))",
                            "Call"
                        ],
                        [
                            "tf.gather(target_bbox, positive_roi_ix)",
                            "Call"
                        ]
                    ]
                }
            },
            "size_1097": {
                "input": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(target_masks, positive_ix)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_n_2017": {
                "inputs": {
                    "value": "reg_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[keras.regularizers.l2(self.config.WEIGHT_DECAY)(w) / tf.cast(tf.size(w), tf.float32) for w in self.keras_model.trainable_weights if 'gamma' not in w.name and 'beta' not in w.name]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "abs_2489": {
                "x": {
                    "value": "boxes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "positive_rois",
                            "variable"
                        ],
                        [
                            "tf.concat([y1, x1, y2, x2], 1)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(boxes, non_zeros, name=name)",
                            "Call"
                        ],
                        [
                            "utils.batch_slice([anchors, deltas], lambda x, y: apply_box_deltas_graph(x, y), self.config.IMAGES_PER_GPU, names=['refined_anchors'])",
                            "Call"
                        ],
                        [
                            "utils.batch_slice(boxes, lambda x: clip_boxes_graph(x, window), self.config.IMAGES_PER_GPU, names=['refined_anchors_clipped'])",
                            "Call"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "detections[:N, :4]",
                            "Subscript"
                        ],
                        [
                            "np.multiply(boxes - shifts, scales).astype(np.int32)",
                            "Call"
                        ],
                        [
                            "np.delete(boxes, exclude_ix, axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_253": {
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "KL.Conv2D(nb_filter1, (1, 1), name=conv_name_base + '2a', use_bias=use_bias)(input_tensor)",
                            "Call"
                        ],
                        [
                            "BatchNorm(axis=3, name=bn_name_base + '2a')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(nb_filter2, (kernel_size, kernel_size), padding='same', name=conv_name_base + '2b', use_bias=use_bias)(x)",
                            "Call"
                        ],
                        [
                            "BatchNorm(axis=3, name=bn_name_base + '2b')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(nb_filter3, (1, 1), name=conv_name_base + '2c', use_bias=use_bias)(x)",
                            "Call"
                        ],
                        [
                            "BatchNorm(axis=3, name=bn_name_base + '2c')(x)",
                            "Call"
                        ],
                        [
                            "KL.Add()([x, input_tensor])",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu', name='res' + str(stage) + block + '_out')(x)",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(nb_filter1, (1, 1), strides=strides, name=conv_name_base + '2a', use_bias=use_bias)(input_tensor)",
                            "Call"
                        ],
                        [
                            "BatchNorm(axis=3, name=bn_name_base + '2a')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(nb_filter2, (kernel_size, kernel_size), padding='same', name=conv_name_base + '2b', use_bias=use_bias)(x)",
                            "Call"
                        ],
                        [
                            "BatchNorm(axis=3, name=bn_name_base + '2b')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(nb_filter3, (1, 1), name=conv_name_base + '2c', use_bias=use_bias)(x)",
                            "Call"
                        ],
                        [
                            "BatchNorm(axis=3, name=bn_name_base + '2c')(x)",
                            "Call"
                        ],
                        [
                            "KL.Add()([x, shortcut])",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu', name='res' + str(stage) + block + '_out')(x)",
                            "Call"
                        ],
                        [
                            "KL.ZeroPadding2D((3, 3))(input_image)",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(64, (7, 7), strides=(2, 2), name='conv1', use_bias=True)(x)",
                            "Call"
                        ],
                        [
                            "BatchNorm(axis=3, name='bn_conv1')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "conv_block(x, 3, [64, 64, 256], stage=2, block='a', strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "identity_block(x, 3, [64, 64, 256], stage=2, block='b')",
                            "Call"
                        ],
                        [
                            "conv_block(x, 3, [128, 128, 512], stage=3, block='a')",
                            "Call"
                        ],
                        [
                            "identity_block(x, 3, [128, 128, 512], stage=3, block='b')",
                            "Call"
                        ],
                        [
                            "identity_block(x, 3, [128, 128, 512], stage=3, block='c')",
                            "Call"
                        ],
                        [
                            "conv_block(x, 3, [256, 256, 1024], stage=4, block='a')",
                            "Call"
                        ],
                        [
                            "identity_block(x, 3, [256, 256, 1024], stage=4, block=chr(98 + i))",
                            "Call"
                        ],
                        [
                            "conv_block(x, 3, [512, 512, 2048], stage=5, block='a')",
                            "Call"
                        ],
                        [
                            "identity_block(x, 3, [512, 512, 2048], stage=5, block='b')",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(2 * anchors_per_location, (1, 1), padding='valid', activation='linear', name='rpn_class_raw')(shared)",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(anchors_per_location * 4, (1, 1), padding='valid', activation='linear', name='rpn_bbox_pred')(shared)",
                            "Call"
                        ],
                        [
                            "PyramidROIAlign([pool_size, pool_size], image_shape, name='roi_align_classifier')([rois] + feature_maps)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2D(1024, (pool_size, pool_size), padding='valid'), name='mrcnn_class_conv1')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(BatchNorm(axis=3), name='mrcnn_class_bn1')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2D(1024, (1, 1)), name='mrcnn_class_conv2')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(BatchNorm(axis=3), name='mrcnn_class_bn2')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Dense(num_classes * 4, activation='linear'), name='mrcnn_bbox_fc')(shared)",
                            "Call"
                        ],
                        [
                            "PyramidROIAlign([pool_size, pool_size], image_shape, name='roi_align_mask')([rois] + feature_maps)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2D(256, (3, 3), padding='same'), name='mrcnn_mask_conv1')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(BatchNorm(axis=3), name='mrcnn_mask_bn1')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2D(256, (3, 3), padding='same'), name='mrcnn_mask_conv2')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(BatchNorm(axis=3), name='mrcnn_mask_bn2')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2D(256, (3, 3), padding='same'), name='mrcnn_mask_conv3')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(BatchNorm(axis=3), name='mrcnn_mask_bn3')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2D(256, (3, 3), padding='same'), name='mrcnn_mask_conv4')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(BatchNorm(axis=3), name='mrcnn_mask_bn4')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2DTranspose(256, (2, 2), strides=2, activation='relu'), name='mrcnn_mask_deconv')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2D(num_classes, (1, 1), strides=1, activation='sigmoid'), name='mrcnn_mask')(x)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "gather_255": {
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "KL.Conv2D(nb_filter1, (1, 1), name=conv_name_base + '2a', use_bias=use_bias)(input_tensor)",
                            "Call"
                        ],
                        [
                            "BatchNorm(axis=3, name=bn_name_base + '2a')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(nb_filter2, (kernel_size, kernel_size), padding='same', name=conv_name_base + '2b', use_bias=use_bias)(x)",
                            "Call"
                        ],
                        [
                            "BatchNorm(axis=3, name=bn_name_base + '2b')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(nb_filter3, (1, 1), name=conv_name_base + '2c', use_bias=use_bias)(x)",
                            "Call"
                        ],
                        [
                            "BatchNorm(axis=3, name=bn_name_base + '2c')(x)",
                            "Call"
                        ],
                        [
                            "KL.Add()([x, input_tensor])",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu', name='res' + str(stage) + block + '_out')(x)",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(nb_filter1, (1, 1), strides=strides, name=conv_name_base + '2a', use_bias=use_bias)(input_tensor)",
                            "Call"
                        ],
                        [
                            "BatchNorm(axis=3, name=bn_name_base + '2a')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(nb_filter2, (kernel_size, kernel_size), padding='same', name=conv_name_base + '2b', use_bias=use_bias)(x)",
                            "Call"
                        ],
                        [
                            "BatchNorm(axis=3, name=bn_name_base + '2b')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(nb_filter3, (1, 1), name=conv_name_base + '2c', use_bias=use_bias)(x)",
                            "Call"
                        ],
                        [
                            "BatchNorm(axis=3, name=bn_name_base + '2c')(x)",
                            "Call"
                        ],
                        [
                            "KL.Add()([x, shortcut])",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu', name='res' + str(stage) + block + '_out')(x)",
                            "Call"
                        ],
                        [
                            "KL.ZeroPadding2D((3, 3))(input_image)",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(64, (7, 7), strides=(2, 2), name='conv1', use_bias=True)(x)",
                            "Call"
                        ],
                        [
                            "BatchNorm(axis=3, name='bn_conv1')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "conv_block(x, 3, [64, 64, 256], stage=2, block='a', strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "identity_block(x, 3, [64, 64, 256], stage=2, block='b')",
                            "Call"
                        ],
                        [
                            "conv_block(x, 3, [128, 128, 512], stage=3, block='a')",
                            "Call"
                        ],
                        [
                            "identity_block(x, 3, [128, 128, 512], stage=3, block='b')",
                            "Call"
                        ],
                        [
                            "identity_block(x, 3, [128, 128, 512], stage=3, block='c')",
                            "Call"
                        ],
                        [
                            "conv_block(x, 3, [256, 256, 1024], stage=4, block='a')",
                            "Call"
                        ],
                        [
                            "identity_block(x, 3, [256, 256, 1024], stage=4, block=chr(98 + i))",
                            "Call"
                        ],
                        [
                            "conv_block(x, 3, [512, 512, 2048], stage=5, block='a')",
                            "Call"
                        ],
                        [
                            "identity_block(x, 3, [512, 512, 2048], stage=5, block='b')",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(2 * anchors_per_location, (1, 1), padding='valid', activation='linear', name='rpn_class_raw')(shared)",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(anchors_per_location * 4, (1, 1), padding='valid', activation='linear', name='rpn_bbox_pred')(shared)",
                            "Call"
                        ],
                        [
                            "PyramidROIAlign([pool_size, pool_size], image_shape, name='roi_align_classifier')([rois] + feature_maps)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2D(1024, (pool_size, pool_size), padding='valid'), name='mrcnn_class_conv1')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(BatchNorm(axis=3), name='mrcnn_class_bn1')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2D(1024, (1, 1)), name='mrcnn_class_conv2')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(BatchNorm(axis=3), name='mrcnn_class_bn2')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Dense(num_classes * 4, activation='linear'), name='mrcnn_bbox_fc')(shared)",
                            "Call"
                        ],
                        [
                            "PyramidROIAlign([pool_size, pool_size], image_shape, name='roi_align_mask')([rois] + feature_maps)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2D(256, (3, 3), padding='same'), name='mrcnn_mask_conv1')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(BatchNorm(axis=3), name='mrcnn_mask_bn1')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2D(256, (3, 3), padding='same'), name='mrcnn_mask_conv2')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(BatchNorm(axis=3), name='mrcnn_mask_bn2')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2D(256, (3, 3), padding='same'), name='mrcnn_mask_conv3')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(BatchNorm(axis=3), name='mrcnn_mask_bn3')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2D(256, (3, 3), padding='same'), name='mrcnn_mask_conv4')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(BatchNorm(axis=3), name='mrcnn_mask_bn4')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2DTranspose(256, (2, 2), strides=2, activation='relu'), name='mrcnn_mask_deconv')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2D(num_classes, (1, 1), strides=1, activation='sigmoid'), name='mrcnn_mask')(x)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "gather_257": {
                "params": {
                    "value": "anchors",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.generate_pyramid_anchors(config.RPN_ANCHOR_SCALES, config.RPN_ANCHOR_RATIOS, config.BACKBONE_SHAPES, config.BACKBONE_STRIDES, config.RPN_ANCHOR_STRIDE)",
                            "Call"
                        ],
                        [
                            "self.anchors",
                            "Attribute"
                        ],
                        [
                            "utils.batch_slice(ix, lambda x: tf.gather(anchors, x), self.config.IMAGES_PER_GPU, names=['pre_nms_anchors'])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "KL.Conv2D(nb_filter1, (1, 1), name=conv_name_base + '2a', use_bias=use_bias)(input_tensor)",
                            "Call"
                        ],
                        [
                            "BatchNorm(axis=3, name=bn_name_base + '2a')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(nb_filter2, (kernel_size, kernel_size), padding='same', name=conv_name_base + '2b', use_bias=use_bias)(x)",
                            "Call"
                        ],
                        [
                            "BatchNorm(axis=3, name=bn_name_base + '2b')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(nb_filter3, (1, 1), name=conv_name_base + '2c', use_bias=use_bias)(x)",
                            "Call"
                        ],
                        [
                            "BatchNorm(axis=3, name=bn_name_base + '2c')(x)",
                            "Call"
                        ],
                        [
                            "KL.Add()([x, input_tensor])",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu', name='res' + str(stage) + block + '_out')(x)",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(nb_filter1, (1, 1), strides=strides, name=conv_name_base + '2a', use_bias=use_bias)(input_tensor)",
                            "Call"
                        ],
                        [
                            "BatchNorm(axis=3, name=bn_name_base + '2a')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(nb_filter2, (kernel_size, kernel_size), padding='same', name=conv_name_base + '2b', use_bias=use_bias)(x)",
                            "Call"
                        ],
                        [
                            "BatchNorm(axis=3, name=bn_name_base + '2b')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(nb_filter3, (1, 1), name=conv_name_base + '2c', use_bias=use_bias)(x)",
                            "Call"
                        ],
                        [
                            "BatchNorm(axis=3, name=bn_name_base + '2c')(x)",
                            "Call"
                        ],
                        [
                            "KL.Add()([x, shortcut])",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu', name='res' + str(stage) + block + '_out')(x)",
                            "Call"
                        ],
                        [
                            "KL.ZeroPadding2D((3, 3))(input_image)",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(64, (7, 7), strides=(2, 2), name='conv1', use_bias=True)(x)",
                            "Call"
                        ],
                        [
                            "BatchNorm(axis=3, name='bn_conv1')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "conv_block(x, 3, [64, 64, 256], stage=2, block='a', strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "identity_block(x, 3, [64, 64, 256], stage=2, block='b')",
                            "Call"
                        ],
                        [
                            "conv_block(x, 3, [128, 128, 512], stage=3, block='a')",
                            "Call"
                        ],
                        [
                            "identity_block(x, 3, [128, 128, 512], stage=3, block='b')",
                            "Call"
                        ],
                        [
                            "identity_block(x, 3, [128, 128, 512], stage=3, block='c')",
                            "Call"
                        ],
                        [
                            "conv_block(x, 3, [256, 256, 1024], stage=4, block='a')",
                            "Call"
                        ],
                        [
                            "identity_block(x, 3, [256, 256, 1024], stage=4, block=chr(98 + i))",
                            "Call"
                        ],
                        [
                            "conv_block(x, 3, [512, 512, 2048], stage=5, block='a')",
                            "Call"
                        ],
                        [
                            "identity_block(x, 3, [512, 512, 2048], stage=5, block='b')",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(2 * anchors_per_location, (1, 1), padding='valid', activation='linear', name='rpn_class_raw')(shared)",
                            "Call"
                        ],
                        [
                            "KL.Conv2D(anchors_per_location * 4, (1, 1), padding='valid', activation='linear', name='rpn_bbox_pred')(shared)",
                            "Call"
                        ],
                        [
                            "PyramidROIAlign([pool_size, pool_size], image_shape, name='roi_align_classifier')([rois] + feature_maps)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2D(1024, (pool_size, pool_size), padding='valid'), name='mrcnn_class_conv1')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(BatchNorm(axis=3), name='mrcnn_class_bn1')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2D(1024, (1, 1)), name='mrcnn_class_conv2')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(BatchNorm(axis=3), name='mrcnn_class_bn2')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Dense(num_classes * 4, activation='linear'), name='mrcnn_bbox_fc')(shared)",
                            "Call"
                        ],
                        [
                            "PyramidROIAlign([pool_size, pool_size], image_shape, name='roi_align_mask')([rois] + feature_maps)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2D(256, (3, 3), padding='same'), name='mrcnn_mask_conv1')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(BatchNorm(axis=3), name='mrcnn_mask_bn1')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2D(256, (3, 3), padding='same'), name='mrcnn_mask_conv2')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(BatchNorm(axis=3), name='mrcnn_mask_bn2')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2D(256, (3, 3), padding='same'), name='mrcnn_mask_conv3')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(BatchNorm(axis=3), name='mrcnn_mask_bn3')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2D(256, (3, 3), padding='same'), name='mrcnn_mask_conv4')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(BatchNorm(axis=3), name='mrcnn_mask_bn4')(x)",
                            "Call"
                        ],
                        [
                            "KL.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2DTranspose(256, (2, 2), strides=2, activation='relu'), name='mrcnn_mask_deconv')(x)",
                            "Call"
                        ],
                        [
                            "KL.TimeDistributed(KL.Conv2D(num_classes, (1, 1), strides=1, activation='sigmoid'), name='mrcnn_mask')(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_348": {
                "x": {
                    "value": "image_area",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(self.image_shape[0] * self.image_shape[1], tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_357": {
                "x": {
                    "value": "roi_level",
                    "type": "variable",
                    "possible_values": [
                        [
                            "log2_graph(tf.sqrt(h * w) / (224.0 / tf.sqrt(image_area)))",
                            "Call"
                        ],
                        [
                            "tf.minimum(5, tf.maximum(2, 4 + tf.cast(tf.round(roi_level), tf.int32)))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(roi_level, 2)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "level",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "crop_and_resize_379": {
                "image": {
                    "value": "feature_maps[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "boxes": {
                    "value": "level_boxes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(boxes, ix)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(level_boxes)",
                            "Call"
                        ]
                    ]
                },
                "box_indices": {
                    "value": "box_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(ix[:, 0], tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(box_indices)",
                            "Call"
                        ]
                    ]
                },
                "crop_size": {
                    "value": "self.pool_shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "method": {
                    "value": "bilinear",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_390": {
                "x": {
                    "value": "box_to_level",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(box_to_level, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.cast(box_to_level, tf.int32), box_range], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "top_k_397": {
                "input": {
                    "value": "sorting_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "box_to_level[:, 0] * 100000 + box_to_level[:, 1]",
                            "BinOp"
                        ]
                    ]
                },
                "k": {
                    "value": "tf.shape(box_to_level)[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_420": {
                "input": {
                    "value": "boxes1",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_435": {
                "input": {
                    "value": "boxes2",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_563": {
                "input": {
                    "value": "rois",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([positive_rois, negative_rois], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.pad(rois, [(0, P), (0, 0)])",
                            "Call"
                        ],
                        [
                            "rpn_rois[keep]",
                            "Subscript"
                        ],
                        [
                            "np.zeros((count, 4), dtype=np.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_787": {
                "tensor": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[tf.shape(t)[0], -1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_799": {
                "tensor": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[tf.shape(t)[0], -1, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_2010": {
                "input_tensor": {
                    "value": "layer.output",
                    "type": "Attribute",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cast_2014": {
                "x": {
                    "value": "tf.size(w)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_2029": {
                "input_tensor": {
                    "value": "layer.output",
                    "type": "Attribute",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cast_350": {
                "x": {
                    "value": "tf.round(roi_level)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_389": {
                "input": {
                    "value": "box_to_level",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(box_to_level, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.cast(box_to_level, tf.int32), box_range], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_419": {
                "input": {
                    "value": "boxes2",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_463": {
                "input": {
                    "value": "proposals",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(proposals)",
                            "Call"
                        ],
                        [
                            "utils.batch_slice([normalized_boxes, scores], nms, self.config.IMAGES_PER_GPU)",
                            "Call"
                        ],
                        [
                            "tf.gather(normalized_boxes, indices)",
                            "Call"
                        ],
                        [
                            "tf.pad(proposals, [(0, padding), (0, 0)])",
                            "Call"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "size_2014": {
                "input": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gt_x2 - gt_x1",
                            "BinOp"
                        ],
                        [
                            "x2 - x1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_290": {
                "input": {
                    "value": "proposals",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(proposals)",
                            "Call"
                        ],
                        [
                            "utils.batch_slice([normalized_boxes, scores], nms, self.config.IMAGES_PER_GPU)",
                            "Call"
                        ],
                        [
                            "tf.gather(normalized_boxes, indices)",
                            "Call"
                        ],
                        [
                            "tf.pad(proposals, [(0, padding), (0, 0)])",
                            "Call"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "round_350": {
                "x": {
                    "value": "roi_level",
                    "type": "variable",
                    "possible_values": [
                        [
                            "log2_graph(tf.sqrt(h * w) / (224.0 / tf.sqrt(image_area)))",
                            "Call"
                        ],
                        [
                            "tf.minimum(5, tf.maximum(2, 4 + tf.cast(tf.round(roi_level), tf.int32)))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(roi_level, 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_397": {
                "input": {
                    "value": "box_to_level",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(box_to_level, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.cast(box_to_level, tf.int32), box_range], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_787": {
                "input": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_799": {
                "input": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "driving/util.py": {
        "tensorflow": {
            "cast_154": {
                "variable": {
                    "value": "box",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "box",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(box, tf.float32)",
                            "Call"
                        ],
                        [
                            "box.astype(np.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_155": {
                "variable": {
                    "value": "gt_box",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "gt_box",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(gt_box, tf.float32)",
                            "Call"
                        ],
                        [
                            "gt_box.astype(np.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "log_169": {
                "variable": {
                    "value": "dh",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "gt_height / height",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_170": {
                "variable": {
                    "value": "dw",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "gt_width / width",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "stack_172": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[dy, dx, dh, dw]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_677": {
                "values": {
                    "value": "o",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "n",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "driving/convolution_bilstm.py": {
        "torch": {
            "manual_seed_8": {
                "seed": {
                    "value": "seed_num",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Embedding_35": {
                "variable": {
                    "value": "self.embed",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "V",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.embed_num",
                            "Attribute"
                        ]
                    ]
                },
                "embedding_dim": {
                    "value": "D",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.embed_dim",
                            "Attribute"
                        ]
                    ]
                },
                "padding_idx": {
                    "value": "args.paddingId",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "LSTM_49": {
                "variable": {
                    "value": "self.bilstm",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "D",
                    "type": "variable",
                    "possible_values": []
                },
                "num_layers": {
                    "value": "self.num_layers",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dropout": {
                    "value": "args.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bidirectional": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_53": {
                "variable": {
                    "value": "self.hidden2label1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "L",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(Ks) * Co + self.hidden_dim * 2",
                            "BinOp"
                        ]
                    ]
                },
                "out_features": {
                    "value": "L // 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Linear_54": {
                "variable": {
                    "value": "self.hidden2label2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "L // 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "C",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.class_num",
                            "Attribute"
                        ]
                    ]
                }
            },
            "Dropout_57": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "args.dropout",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "transpose_64": {
                "variable": {
                    "value": "cnn_x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "cnn_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embed",
                            "variable"
                        ],
                        [
                            "torch.transpose(cnn_x, 0, 1)",
                            "Call"
                        ],
                        [
                            "cnn_x.unsqueeze(1)",
                            "Call"
                        ],
                        [
                            "[conv(cnn_x).squeeze(3) for conv in self.convs1]",
                            "ListComp"
                        ],
                        [
                            "[F.tanh(F.max_pool1d(i, i.size(2)).squeeze(2)) for i in cnn_x]",
                            "ListComp"
                        ],
                        [
                            "torch.cat(cnn_x, 1)",
                            "Call"
                        ],
                        [
                            "self.dropout(cnn_x)",
                            "Call"
                        ],
                        [
                            "torch.transpose(cnn_x, 0, 1)",
                            "Call"
                        ]
                    ]
                },
                "dim0": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dim1": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_68": {
                "variable": {
                    "value": "cnn_x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "cnn_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embed",
                            "variable"
                        ],
                        [
                            "torch.transpose(cnn_x, 0, 1)",
                            "Call"
                        ],
                        [
                            "cnn_x.unsqueeze(1)",
                            "Call"
                        ],
                        [
                            "[conv(cnn_x).squeeze(3) for conv in self.convs1]",
                            "ListComp"
                        ],
                        [
                            "[F.tanh(F.max_pool1d(i, i.size(2)).squeeze(2)) for i in cnn_x]",
                            "ListComp"
                        ],
                        [
                            "torch.cat(cnn_x, 1)",
                            "Call"
                        ],
                        [
                            "self.dropout(cnn_x)",
                            "Call"
                        ],
                        [
                            "torch.transpose(cnn_x, 0, 1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_74": {
                "variable": {
                    "value": "bilstm_out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "bilstm_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.transpose(bilstm_out, 0, 1)",
                            "Call"
                        ],
                        [
                            "torch.transpose(bilstm_out, 1, 2)",
                            "Call"
                        ],
                        [
                            "F.max_pool1d(bilstm_out, bilstm_out.size(2)).squeeze(2)",
                            "Call"
                        ],
                        [
                            "F.tanh(bilstm_out)",
                            "Call"
                        ],
                        [
                            "torch.transpose(bilstm_out, 0, 1)",
                            "Call"
                        ]
                    ]
                },
                "dim0": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dim1": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_75": {
                "variable": {
                    "value": "bilstm_out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "bilstm_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.transpose(bilstm_out, 0, 1)",
                            "Call"
                        ],
                        [
                            "torch.transpose(bilstm_out, 1, 2)",
                            "Call"
                        ],
                        [
                            "F.max_pool1d(bilstm_out, bilstm_out.size(2)).squeeze(2)",
                            "Call"
                        ],
                        [
                            "F.tanh(bilstm_out)",
                            "Call"
                        ],
                        [
                            "torch.transpose(bilstm_out, 0, 1)",
                            "Call"
                        ]
                    ]
                },
                "dim0": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dim1": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "max_pool1d_76": {
                "variable": {
                    "value": "bilstm_out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "bilstm_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.transpose(bilstm_out, 0, 1)",
                            "Call"
                        ],
                        [
                            "torch.transpose(bilstm_out, 1, 2)",
                            "Call"
                        ],
                        [
                            "F.max_pool1d(bilstm_out, bilstm_out.size(2)).squeeze(2)",
                            "Call"
                        ],
                        [
                            "F.tanh(bilstm_out)",
                            "Call"
                        ],
                        [
                            "torch.transpose(bilstm_out, 0, 1)",
                            "Call"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "bilstm_out.size(2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "squeeze_76": {
                "variable": {
                    "value": "bilstm_out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tanh_77": {
                "variable": {
                    "value": "bilstm_out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "bilstm_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.transpose(bilstm_out, 0, 1)",
                            "Call"
                        ],
                        [
                            "torch.transpose(bilstm_out, 1, 2)",
                            "Call"
                        ],
                        [
                            "F.max_pool1d(bilstm_out, bilstm_out.size(2)).squeeze(2)",
                            "Call"
                        ],
                        [
                            "F.tanh(bilstm_out)",
                            "Call"
                        ],
                        [
                            "torch.transpose(bilstm_out, 0, 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_80": {
                "variable": {
                    "value": "cnn_x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "cnn_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embed",
                            "variable"
                        ],
                        [
                            "torch.transpose(cnn_x, 0, 1)",
                            "Call"
                        ],
                        [
                            "cnn_x.unsqueeze(1)",
                            "Call"
                        ],
                        [
                            "[conv(cnn_x).squeeze(3) for conv in self.convs1]",
                            "ListComp"
                        ],
                        [
                            "[F.tanh(F.max_pool1d(i, i.size(2)).squeeze(2)) for i in cnn_x]",
                            "ListComp"
                        ],
                        [
                            "torch.cat(cnn_x, 1)",
                            "Call"
                        ],
                        [
                            "self.dropout(cnn_x)",
                            "Call"
                        ],
                        [
                            "torch.transpose(cnn_x, 0, 1)",
                            "Call"
                        ]
                    ]
                },
                "dim0": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dim1": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_81": {
                "variable": {
                    "value": "bilstm_out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "bilstm_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.transpose(bilstm_out, 0, 1)",
                            "Call"
                        ],
                        [
                            "torch.transpose(bilstm_out, 1, 2)",
                            "Call"
                        ],
                        [
                            "F.max_pool1d(bilstm_out, bilstm_out.size(2)).squeeze(2)",
                            "Call"
                        ],
                        [
                            "F.tanh(bilstm_out)",
                            "Call"
                        ],
                        [
                            "torch.transpose(bilstm_out, 0, 1)",
                            "Call"
                        ]
                    ]
                },
                "dim0": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dim1": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_82": {
                "variable": {
                    "value": "cnn_bilstm_out",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(cnn_x, bilstm_out)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_83": {
                "variable": {
                    "value": "cnn_bilstm_out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "cnn_bilstm_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.cat((cnn_x, bilstm_out), 0)",
                            "Call"
                        ],
                        [
                            "torch.transpose(cnn_bilstm_out, 0, 1)",
                            "Call"
                        ],
                        [
                            "self.hidden2label1(F.tanh(cnn_bilstm_out))",
                            "Call"
                        ],
                        [
                            "self.hidden2label2(F.tanh(cnn_bilstm_out))",
                            "Call"
                        ]
                    ]
                },
                "dim0": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dim1": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Conv2d_41": {
                "in_channels": {
                    "value": "Ci",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "int"
                        ]
                    ]
                },
                "out_channels": {
                    "value": "Co",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.kernel_num",
                            "Attribute"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "(K, D)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "(K // 2, 0)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tanh_67": {
                "input": {
                    "value": "F.max_pool1d(i, i.size(2)).squeeze(2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tanh_86": {
                "input": {
                    "value": "cnn_bilstm_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.cat((cnn_x, bilstm_out), 0)",
                            "Call"
                        ],
                        [
                            "torch.transpose(cnn_bilstm_out, 0, 1)",
                            "Call"
                        ],
                        [
                            "self.hidden2label1(F.tanh(cnn_bilstm_out))",
                            "Call"
                        ],
                        [
                            "self.hidden2label2(F.tanh(cnn_bilstm_out))",
                            "Call"
                        ]
                    ]
                }
            },
            "tanh_87": {
                "input": {
                    "value": "cnn_bilstm_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.cat((cnn_x, bilstm_out), 0)",
                            "Call"
                        ],
                        [
                            "torch.transpose(cnn_bilstm_out, 0, 1)",
                            "Call"
                        ],
                        [
                            "self.hidden2label1(F.tanh(cnn_bilstm_out))",
                            "Call"
                        ],
                        [
                            "self.hidden2label2(F.tanh(cnn_bilstm_out))",
                            "Call"
                        ]
                    ]
                }
            },
            "max_pool1d_67": {
                "input": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "i.size(2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "squeeze_67": {
                "input": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "driving/driving.py": {
        "torch": {}
    },
    "driving/train_cnn.py": {
        "torch": {
            "manual_seed_15": {
                "seed": {
                    "value": "seed_num",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Adam_25": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "model.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "args.lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "weight_decay": {
                    "value": "args.init_weight_decay",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cross_entropy_97": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model(feature)",
                            "Call"
                        ],
                        [
                            "model(feature)",
                            "Call"
                        ]
                    ]
                },
                "target": {
                    "value": "target",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "SGD_28": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "model.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "args.lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "weight_decay": {
                    "value": "args.init_weight_decay",
                    "type": "Attribute",
                    "possible_values": []
                },
                "momentum": {
                    "value": "args.momentum_value",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cross_entropy_52": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model(feature)",
                            "Call"
                        ],
                        [
                            "model(feature)",
                            "Call"
                        ]
                    ]
                },
                "target": {
                    "value": "target",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Adadelta_32": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "model.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "args.lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "weight_decay": {
                    "value": "args.init_weight_decay",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "clip_grad_norm__55": {
                "parameters": {
                    "value": "model.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "max_norm": {
                    "value": "args.init_clip_max_norm",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "save_80": {
                "obj": {
                    "value": "model.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "save_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'{}_steps{}.pt'.format(save_prefix, steps)",
                            "Call"
                        ]
                    ]
                }
            },
            "max_99": {
                "input": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model(feature)",
                            "Call"
                        ],
                        [
                            "model(feature)",
                            "Call"
                        ]
                    ]
                }
            },
            "max_61": {
                "input": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model(feature)",
                            "Call"
                        ],
                        [
                            "model(feature)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "driving/train_lstm.py": {
        "torch": {
            "manual_seed_17": {
                "seed": {
                    "value": "seed_num",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Adam_27": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "model.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "args.lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "weight_decay": {
                    "value": "args.init_weight_decay",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cross_entropy_94": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model(feature)",
                            "Call"
                        ],
                        [
                            "model(feature)",
                            "Call"
                        ]
                    ]
                },
                "target": {
                    "value": "target",
                    "type": "variable",
                    "possible_values": [
                        [
                            "autograd.Variable(target)",
                            "Call"
                        ]
                    ]
                }
            },
            "SGD_30": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "model.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "args.lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "weight_decay": {
                    "value": "args.init_weight_decay",
                    "type": "Attribute",
                    "possible_values": []
                },
                "momentum": {
                    "value": "args.momentum_value",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cross_entropy_51": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model(feature)",
                            "Call"
                        ],
                        [
                            "model(feature)",
                            "Call"
                        ]
                    ]
                },
                "target": {
                    "value": "target",
                    "type": "variable",
                    "possible_values": [
                        [
                            "autograd.Variable(target)",
                            "Call"
                        ]
                    ]
                }
            },
            "Adadelta_34": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "model.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "args.lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "weight_decay": {
                    "value": "args.init_weight_decay",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "clip_grad_norm__54": {
                "parameters": {
                    "value": "model.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "max_norm": {
                    "value": "args.init_clip_max_norm",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "save_78": {
                "obj": {
                    "value": "model.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "save_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'{}_steps{}.pt'.format(save_prefix, steps)",
                            "Call"
                        ]
                    ]
                }
            },
            "max_97": {
                "input": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model(feature)",
                            "Call"
                        ],
                        [
                            "model(feature)",
                            "Call"
                        ]
                    ]
                }
            },
            "max_60": {
                "input": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model(feature)",
                            "Call"
                        ],
                        [
                            "model(feature)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "visual/instanceSegmentation.py": {
        "torch": {}
    },
    "visual/visual.py": {
        "torch": {}
    }
}