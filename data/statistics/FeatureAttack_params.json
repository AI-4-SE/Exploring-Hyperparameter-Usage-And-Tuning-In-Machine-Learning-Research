{
    "cifar10_challenge/cifar10_input.py": {
        "tensorflow": {
            "placeholder_95": {
                "variable": {
                    "value": "self.x_input_placeholder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, 32, 32, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "map_fn_96": {
                "variable": {
                    "value": "padded",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda img: tf.image.resize_image_with_crop_or_pad(img, self.image_size + 4, self.image_size + 4)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "self.x_input_placeholder",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_fn_99": {
                "variable": {
                    "value": "cropped",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda img: tf.random_crop(img, [self.image_size, self.image_size, 3])",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "padded",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(lambda img: tf.image.resize_image_with_crop_or_pad(img, self.image_size + 4, self.image_size + 4), self.x_input_placeholder)",
                            "Call"
                        ]
                    ]
                }
            },
            "map_fn_102": {
                "variable": {
                    "value": "flipped",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda img: tf.image.random_flip_left_right(img)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "cropped",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(lambda img: tf.random_crop(img, [self.image_size, self.image_size, 3]), padded)",
                            "Call"
                        ]
                    ]
                }
            },
            "random_crop_99": {
                "value": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": []
                },
                "size": {
                    "value": "[self.image_size, self.image_size, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "random_flip_left_right_102": {
                "image": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "cifar10_challenge/eval.py": {
        "tensorflow": {
            "get_or_create_global_step_54": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_66": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FileWriter_67": {
                "variable": {
                    "value": "summary_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "eval_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(model_dir, 'eval')",
                            "Call"
                        ]
                    ]
                }
            },
            "latest_checkpoint_133": {
                "variable": {
                    "value": "cur_checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "model_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config['model_dir']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "Summary_117": {
                "variable": {
                    "value": "summary",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[tf.Summary.Value(tag='xent adv eval', simple_value=avg_xent_adv), tf.Summary.Value(tag='xent adv', simple_value=avg_xent_adv), tf.Summary.Value(tag='xent nat', simple_value=avg_xent_nat), tf.Summary.Value(tag='accuracy adv eval', simple_value=acc_adv), tf.Summary.Value(tag='accuracy adv', simple_value=acc_adv), tf.Summary.Value(tag='accuracy nat', simple_value=acc_nat)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "device_37": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Session_71": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "cifar10_challenge/feature_attack_batch_tf_early_stop.py": {
        "tensorflow": {
            "latest_checkpoint_93": {
                "variable": {
                    "value": "model_file",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "config['model_dir']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "Saver_102": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_28": {
                "variable": {
                    "value": "self.target_feats",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, feat_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "l2_normalize_31": {
                "variable": {
                    "value": "normalized_input_feats",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.model.feat",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_32": {
                "variable": {
                    "value": "normalized_target_feats",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.target_feats",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_34": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "cos_dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0 - tf.reduce_sum(normalized_input_feats * normalized_target_feats, axis=1)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "Session_107": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "l2_normalize_36": {
                "variable": {
                    "value": "normalized_input_feats",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.model.feat",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_37": {
                "variable": {
                    "value": "normalized_target_feats",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.target_feats",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_38": {
                "variable": {
                    "value": "euclid_dist",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.pow(normalized_input_feats - normalized_target_feats, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_39": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "euclid_dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.pow(normalized_input_feats - normalized_target_feats, 2), axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gradients_45": {
                "ys": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(cos_dist)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(euclid_dist)",
                            "Call"
                        ]
                    ]
                },
                "xs": {
                    "value": "model.x_input",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_33": {
                "input_tensor": {
                    "value": "normalized_input_feats * normalized_target_feats",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pow_38": {
                "x": {
                    "value": "normalized_input_feats - normalized_target_feats",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "cifar10_challenge/model.py": {
        "tensorflow": {
            "argmax_86": {
                "variable": {
                    "value": "self.predictions",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.pre_softmax",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_87": {
                "variable": {
                    "value": "self.correct_prediction",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.predictions",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.y_input",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_88": {
                "variable": {
                    "value": "self.num_correct",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(self.correct_prediction, tf.int64)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_90": {
                "variable": {
                    "value": "self.accuracy",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(self.correct_prediction, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_173": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv('init_conv', input_standardized, 3, 3, 16, self._stride_arr(1))",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[0], filters[1], self._stride_arr(strides[0]), activate_before_residual[0])",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[1], filters[1], self._stride_arr(1), False)",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[1], filters[2], self._stride_arr(strides[1]), activate_before_residual[1])",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[2], filters[2], self._stride_arr(1), False)",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[2], filters[3], self._stride_arr(strides[2]), activate_before_residual[2])",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[3], filters[3], self._stride_arr(1), False)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('final_bn', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('init_bn', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('init_bn', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._conv('conv1', x, 3, in_filter, out_filter, stride)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('bn2', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._conv('conv2', x, 3, out_filter, out_filter, [1, 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "x + orig_x",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[tf.shape(x)[0], -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_174": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "DW",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[prod_non_batch_dimensions, out_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.uniform_unit_scaling_initializer(factor=1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_177": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "biases",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[out_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "placeholder_33": {
                "variable": {
                    "value": "self.x_input",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, 32, 32, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_37": {
                "variable": {
                    "value": "self.y_input",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "map_fn_40": {
                "variable": {
                    "value": "input_standardized",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda img: tf.image.per_image_standardization(img)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "self.x_input",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_94": {
                "variable": {
                    "value": "self.y_xent",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.pre_softmax",
                    "type": "Attribute",
                    "possible_values": []
                },
                "labels": {
                    "value": "self.y_input",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_96": {
                "variable": {
                    "value": "self.xent",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.y_xent",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "y_xent",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_97": {
                "variable": {
                    "value": "self.mean_xent",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.y_xent",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "debug_142": {
                "msg": {
                    "value": "image after unit %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "x.get_shape()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "trainable_variables_148": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "add_n_151": {
                "inputs": {
                    "value": "costs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "get_variable_157": {
                "variable": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "DW",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[filter_size, filter_size, in_filters, out_filters]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(stddev=np.sqrt(2.0 / n))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_165": {
                "condition": {
                    "value": "tf.less(x, 0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "leakiness * x",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv('init_conv', input_standardized, 3, 3, 16, self._stride_arr(1))",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[0], filters[1], self._stride_arr(strides[0]), activate_before_residual[0])",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[1], filters[1], self._stride_arr(1), False)",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[1], filters[2], self._stride_arr(strides[1]), activate_before_residual[1])",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[2], filters[2], self._stride_arr(1), False)",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[2], filters[3], self._stride_arr(strides[2]), activate_before_residual[2])",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[3], filters[3], self._stride_arr(1), False)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('final_bn', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('init_bn', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('init_bn', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._conv('conv1', x, 3, in_filter, out_filter, stride)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('bn2', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._conv('conv2', x, 3, out_filter, out_filter, [1, 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "x + orig_x",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "leaky_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "xw_plus_b_179": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv('init_conv', input_standardized, 3, 3, 16, self._stride_arr(1))",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[0], filters[1], self._stride_arr(strides[0]), activate_before_residual[0])",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[1], filters[1], self._stride_arr(1), False)",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[1], filters[2], self._stride_arr(strides[1]), activate_before_residual[1])",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[2], filters[2], self._stride_arr(1), False)",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[2], filters[3], self._stride_arr(strides[2]), activate_before_residual[2])",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[3], filters[3], self._stride_arr(1), False)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('final_bn', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('init_bn', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('init_bn', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._conv('conv1', x, 3, in_filter, out_filter, stride)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('bn2', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._conv('conv2', x, 3, out_filter, out_filter, [1, 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "x + orig_x",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "weights": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('DW', [prod_non_batch_dimensions, out_dim], initializer=tf.uniform_unit_scaling_initializer(factor=1.0))",
                            "Call"
                        ]
                    ]
                },
                "biases": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('biases', [out_dim], initializer=tf.constant_initializer())",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_183": {
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv('init_conv', input_standardized, 3, 3, 16, self._stride_arr(1))",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[0], filters[1], self._stride_arr(strides[0]), activate_before_residual[0])",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[1], filters[1], self._stride_arr(1), False)",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[1], filters[2], self._stride_arr(strides[1]), activate_before_residual[1])",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[2], filters[2], self._stride_arr(1), False)",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[2], filters[3], self._stride_arr(strides[2]), activate_before_residual[2])",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[3], filters[3], self._stride_arr(1), False)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('final_bn', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('init_bn', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('init_bn', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._conv('conv1', x, 3, in_filter, out_filter, stride)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('bn2', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._conv('conv2', x, 3, out_filter, out_filter, [1, 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "x + orig_x",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_31": {
                "name_or_scope": {
                    "value": "input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_57": {
                "name_or_scope": {
                    "value": "unit_1_0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_64": {
                "name_or_scope": {
                    "value": "unit_2_0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_71": {
                "name_or_scope": {
                    "value": "unit_3_0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_78": {
                "name_or_scope": {
                    "value": "unit_last",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_83": {
                "name_or_scope": {
                    "value": "logit",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_89": {
                "x": {
                    "value": "self.correct_prediction",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_91": {
                "x": {
                    "value": "self.correct_prediction",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_93": {
                "name_or_scope": {
                    "value": "costs",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_102": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name",
                            "Method Argument"
                        ],
                        [
                            "name",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_126": {
                "name_or_scope": {
                    "value": "sub1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_129": {
                "name_or_scope": {
                    "value": "sub2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_134": {
                "name_or_scope": {
                    "value": "sub_add",
                    "type": "str",
                    "possible_values": []
                }
            },
            "avg_pool_136": {
                "variable": {
                    "value": "orig_x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "orig_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "tf.nn.avg_pool(orig_x, stride, stride, 'VALID')",
                            "Call"
                        ],
                        [
                            "tf.pad(orig_x, [[0, 0], [0, 0], [0, 0], [(out_filter - in_filter) // 2, (out_filter - in_filter) // 2]])",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "stride",
                            "Method Argument"
                        ],
                        [
                            "stride",
                            "Method Argument"
                        ]
                    ]
                },
                "strides": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "stride",
                            "Method Argument"
                        ],
                        [
                            "stride",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pad_137": {
                "variable": {
                    "value": "orig_x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "orig_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "tf.nn.avg_pool(orig_x, stride, stride, 'VALID')",
                            "Call"
                        ],
                        [
                            "tf.pad(orig_x, [[0, 0], [0, 0], [0, 0], [(out_filter - in_filter) // 2, (out_filter - in_filter) // 2]])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [0, 0], [0, 0], [(out_filter - in_filter) // 2, (out_filter - in_filter) // 2]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_155": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name",
                            "Method Argument"
                        ],
                        [
                            "name",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "conv2d_161": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv('init_conv', input_standardized, 3, 3, 16, self._stride_arr(1))",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[0], filters[1], self._stride_arr(strides[0]), activate_before_residual[0])",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[1], filters[1], self._stride_arr(1), False)",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[1], filters[2], self._stride_arr(strides[1]), activate_before_residual[1])",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[2], filters[2], self._stride_arr(1), False)",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[2], filters[3], self._stride_arr(strides[2]), activate_before_residual[2])",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[3], filters[3], self._stride_arr(1), False)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('final_bn', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('init_bn', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('init_bn', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._conv('conv1', x, 3, in_filter, out_filter, stride)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('bn2', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._conv('conv2', x, 3, out_filter, out_filter, [1, 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "x + orig_x",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('DW', [filter_size, filter_size, in_filters, out_filters], tf.float32, initializer=tf.random_normal_initializer(stddev=np.sqrt(2.0 / n)))",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 2, 2]",
                            "List"
                        ],
                        [
                            "strides",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "less_165": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv('init_conv', input_standardized, 3, 3, 16, self._stride_arr(1))",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[0], filters[1], self._stride_arr(strides[0]), activate_before_residual[0])",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[1], filters[1], self._stride_arr(1), False)",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[1], filters[2], self._stride_arr(strides[1]), activate_before_residual[1])",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[2], filters[2], self._stride_arr(1), False)",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[2], filters[3], self._stride_arr(strides[2]), activate_before_residual[2])",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[3], filters[3], self._stride_arr(1), False)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('final_bn', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('init_bn', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('init_bn', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._conv('conv1', x, 3, in_filter, out_filter, stride)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('bn2', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._conv('conv2', x, 3, out_filter, out_filter, [1, 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "x + orig_x",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "variable_scope_61": {
                "name_or_scope": {
                    "value": "'unit_1_%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_68": {
                "name_or_scope": {
                    "value": "'unit_2_%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_75": {
                "name_or_scope": {
                    "value": "'unit_3_%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_116": {
                "name_or_scope": {
                    "value": "shared_activation",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_121": {
                "name_or_scope": {
                    "value": "residual_only_activation",
                    "type": "str",
                    "possible_values": []
                }
            },
            "uniform_unit_scaling_initializer_176": {
                "factor": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_178": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "per_image_standardization_40": {
                "image": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "l2_loss_150": {
                "t": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ]
                    ]
                }
            },
            "random_normal_initializer_159": {
                "stddev": {
                    "value": "np.sqrt(2.0 / n)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_173": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv('init_conv', input_standardized, 3, 3, 16, self._stride_arr(1))",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[0], filters[1], self._stride_arr(strides[0]), activate_before_residual[0])",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[1], filters[1], self._stride_arr(1), False)",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[1], filters[2], self._stride_arr(strides[1]), activate_before_residual[1])",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[2], filters[2], self._stride_arr(1), False)",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[2], filters[3], self._stride_arr(strides[2]), activate_before_residual[2])",
                            "Call"
                        ],
                        [
                            "res_func(x, filters[3], filters[3], self._stride_arr(1), False)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('final_bn', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('init_bn', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('init_bn', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._conv('conv1', x, 3, in_filter, out_filter, stride)",
                            "Call"
                        ],
                        [
                            "self._batch_norm('bn2', x)",
                            "Call"
                        ],
                        [
                            "self._relu(x, 0.1)",
                            "Call"
                        ],
                        [
                            "self._conv('conv2', x, 3, out_filter, out_filter, [1, 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "x + orig_x",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "cifar10_challenge/model_robustml.py": {
        "tensorflow": {
            "Saver_10": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "latest_checkpoint_11": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "models/model_0",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "cifar10_challenge/pgd_attack.py": {
        "tensorflow": {
            "latest_checkpoint_75": {
                "variable": {
                    "value": "model_file",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "config['model_dir']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "Saver_87": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_92": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "one_hot_29": {
                "variable": {
                    "value": "label_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "model.y_input",
                    "type": "Attribute",
                    "possible_values": []
                },
                "depth": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "on_value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "off_value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_34": {
                "variable": {
                    "value": "correct_logit",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "label_mask * model.pre_softmax",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_35": {
                "variable": {
                    "value": "wrong_logit",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "(1 - label_mask) * model.pre_softmax - 10000.0 * label_mask",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gradients_41": {
                "ys": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.xent",
                            "Attribute"
                        ],
                        [
                            "-tf.nn.relu(correct_logit - wrong_logit + 50)",
                            "UnaryOp"
                        ],
                        [
                            "model.xent",
                            "Attribute"
                        ]
                    ]
                },
                "xs": {
                    "value": "model.x_input",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_36": {
                "features": {
                    "value": "correct_logit - wrong_logit + 50",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "cifar10_challenge/run_attack.py": {
        "tensorflow": {
            "Saver_30": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "latest_checkpoint_83": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "model_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config['model_dir']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "Session_48": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "cifar10_challenge/train.py": {
        "tensorflow": {
            "get_or_create_global_step_40": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "piecewise_constant_47": {
                "variable": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.cast(global_step, tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "boundaries": {
                    "value": "boundaries",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[int(sss[0]) for sss in step_size_schedule]",
                            "ListComp"
                        ],
                        [
                            "boundaries[1:]",
                            "Subscript"
                        ]
                    ]
                },
                "values": {
                    "value": "values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[sss[1] for sss in step_size_schedule]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "MomentumOptimizer_52": {
                "variable": {
                    "value": "train_step",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.piecewise_constant(tf.cast(global_step, tf.int32), boundaries, values)",
                            "Call"
                        ]
                    ]
                },
                "momentum": {
                    "value": "momentum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config['momentum']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "Saver_75": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "merge_all_81": {
                "variable": {
                    "value": "merged_summaries",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "set_random_seed_24": {
                "seed": {
                    "value": "config['tf_random_seed']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "scalar_76": {
                "name": {
                    "value": "accuracy adv train",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model.accuracy",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_77": {
                "name": {
                    "value": "accuracy adv",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model.accuracy",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_78": {
                "name": {
                    "value": "xent adv train",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model.xent / batch_size",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scalar_79": {
                "name": {
                    "value": "xent adv",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model.xent / batch_size",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "image_80": {
                "name": {
                    "value": "images adv train",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model.x_input",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FileWriter_92": {
                "variable": {
                    "value": "summary_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "model_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config['model_dir']",
                            "Subscript"
                        ]
                    ]
                },
                "graph": {
                    "value": "sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_48": {
                "x": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.framework.get_or_create_global_step()",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Session_86": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_93": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "attack_methods.py": {
        "torch": {
            "arange_220": {
                "variable": {
                    "value": "inv_idx",
                    "type": "variable",
                    "possible_values": []
                },
                "start": {
                    "value": "inputs.size(0) - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "end": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "step": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "is_available_17": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "softmax_74": {
                "variable": {
                    "value": "targets_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits_pred_nat.float()",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_79": {
                "variable": {
                    "value": "targets_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "outputs.float()",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_161": {
                "variable": {
                    "value": "targets_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "outputs.float()",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "min_240": {
                "variable": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "torch.max(x_adv, inputs - epsilon)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "clamp_241": {
                "variable": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.data - step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - epsilon), inputs + epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "x.data + step_sign * self.step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - self.epsilon), inputs + self.epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "x.data + self.step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - self.epsilon), inputs + self.epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "min": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "min_103": {
                "variable": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "torch.max(x_adv, inputs - self.epsilon)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "clamp_105": {
                "variable": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.data - step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - epsilon), inputs + epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "x.data + step_sign * self.step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - self.epsilon), inputs + self.epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "x.data + self.step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - self.epsilon), inputs + self.epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "min": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "min_200": {
                "variable": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "torch.max(x_adv, inputs - self.epsilon)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "clamp_202": {
                "variable": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.data - step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - epsilon), inputs + epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "x.data + step_sign * self.step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - self.epsilon), inputs + self.epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "x.data + self.step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - self.epsilon), inputs + self.epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "min": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "zeros_like_222": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.detach()",
                            "Call"
                        ],
                        [
                            "x + torch.zeros_like(x).uniform_(-epsilon, epsilon)",
                            "BinOp"
                        ],
                        [
                            "Variable(x_adv)",
                            "Call"
                        ],
                        [
                            "inputs.detach()",
                            "Call"
                        ],
                        [
                            "x + torch.zeros_like(x).uniform_(-self.epsilon, self.epsilon)",
                            "BinOp"
                        ],
                        [
                            "Variable(x_adv)",
                            "Call"
                        ],
                        [
                            "inputs.detach()",
                            "Call"
                        ],
                        [
                            "x + torch.zeros_like(x).uniform_(-self.epsilon, self.epsilon)",
                            "BinOp"
                        ],
                        [
                            "Variable(x_adv)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_168": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.detach()",
                            "Call"
                        ],
                        [
                            "x + torch.zeros_like(x).uniform_(-epsilon, epsilon)",
                            "BinOp"
                        ],
                        [
                            "Variable(x_adv)",
                            "Call"
                        ],
                        [
                            "inputs.detach()",
                            "Call"
                        ],
                        [
                            "x + torch.zeros_like(x).uniform_(-self.epsilon, self.epsilon)",
                            "BinOp"
                        ],
                        [
                            "Variable(x_adv)",
                            "Call"
                        ],
                        [
                            "inputs.detach()",
                            "Call"
                        ],
                        [
                            "x + torch.zeros_like(x).uniform_(-self.epsilon, self.epsilon)",
                            "BinOp"
                        ],
                        [
                            "Variable(x_adv)",
                            "Call"
                        ]
                    ]
                }
            },
            "max_240": {
                "input": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.data - step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - epsilon), inputs + epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "x.data + step_sign * self.step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - self.epsilon), inputs + self.epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "x.data + self.step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - self.epsilon), inputs + self.epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_85": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.detach()",
                            "Call"
                        ],
                        [
                            "x + torch.zeros_like(x).uniform_(-epsilon, epsilon)",
                            "BinOp"
                        ],
                        [
                            "Variable(x_adv)",
                            "Call"
                        ],
                        [
                            "inputs.detach()",
                            "Call"
                        ],
                        [
                            "x + torch.zeros_like(x).uniform_(-self.epsilon, self.epsilon)",
                            "BinOp"
                        ],
                        [
                            "Variable(x_adv)",
                            "Call"
                        ],
                        [
                            "inputs.detach()",
                            "Call"
                        ],
                        [
                            "x + torch.zeros_like(x).uniform_(-self.epsilon, self.epsilon)",
                            "BinOp"
                        ],
                        [
                            "Variable(x_adv)",
                            "Call"
                        ]
                    ]
                }
            },
            "max_103": {
                "input": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.data - step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - epsilon), inputs + epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "x.data + step_sign * self.step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - self.epsilon), inputs + self.epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "x.data + self.step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - self.epsilon), inputs + self.epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "max_200": {
                "input": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.data - step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - epsilon), inputs + epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "x.data + step_sign * self.step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - self.epsilon), inputs + self.epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "x.data + self.step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - self.epsilon), inputs + self.epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "sign_239": {
                "input": {
                    "value": "x.grad.data",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sign_101": {
                "input": {
                    "value": "x.grad.data",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sign_199": {
                "input": {
                    "value": "x.grad.data",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "feature_attack_batch.py": {
        "torch": {
            "DataLoader_103": {
                "variable": {
                    "value": "testloader",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "testset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torchvision.datasets.CIFAR10(root='./data', train=False, download=True, transform=transform_test)",
                            "Call"
                        ],
                        [
                            "torchvision.datasets.CIFAR100(root='./data', train=False, download=True, transform=transform_test)",
                            "Call"
                        ],
                        [
                            "torchvision.datasets.SVHN(root='./data', split='test', download=True, transform=transform_test)",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "10000",
                    "type": "int",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "num_workers": {
                    "value": "20",
                    "type": "int",
                    "possible_values": []
                }
            },
            "CrossEntropyLoss_153": {
                "variable": {
                    "value": "criterion",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cat_281": {
                "variable": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(x_adv, dim=0)",
                            "Call"
                        ],
                        [
                            "x.data - step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - epsilon), inputs + epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "DataParallel_118": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "module": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "basic_net.to(device)",
                            "Call"
                        ],
                        [
                            "torch.nn.DataParallel(net)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_232": {
                "variable": {
                    "value": "candidate_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "num_total_target_images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config_feature_attack['num_total_target_images']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "save_282": {
                "obj": {
                    "value": "{'x_adv': x_adv}",
                    "type": "Dict",
                    "possible_values": []
                },
                "f": {
                    "value": "path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.store_adv_path",
                            "Attribute"
                        ]
                    ]
                }
            },
            "is_available_69": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "clamp_177": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.detach()",
                            "Call"
                        ],
                        [
                            "x + torch.zeros_like(x).uniform_(-epsilon, epsilon)",
                            "BinOp"
                        ],
                        [
                            "torch.clamp(x, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "Variable(x_adv)",
                            "Call"
                        ]
                    ]
                },
                "min": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "min_197": {
                "variable": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "torch.max(x_adv, inputs - epsilon)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "clamp_198": {
                "variable": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(x_adv, dim=0)",
                            "Call"
                        ],
                        [
                            "x.data - step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - epsilon), inputs + epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "min": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "load_131": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "f_path_latest",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(args.model_dir, 'latest')",
                            "Call"
                        ]
                    ]
                }
            },
            "load_146": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "f_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(args.model_dir, 'checkpoint-%s' % args.init_model_pass)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_176": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.detach()",
                            "Call"
                        ],
                        [
                            "x + torch.zeros_like(x).uniform_(-epsilon, epsilon)",
                            "BinOp"
                        ],
                        [
                            "torch.clamp(x, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "Variable(x_adv)",
                            "Call"
                        ]
                    ]
                }
            },
            "max_197": {
                "input": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(x_adv, dim=0)",
                            "Call"
                        ],
                        [
                            "x.data - step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - epsilon), inputs + epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "sign_196": {
                "input": {
                    "value": "x.grad.data",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "feature_attack_kl.py": {
        "torch": {
            "DataLoader_113": {
                "variable": {
                    "value": "testloader",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "testset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torchvision.datasets.CIFAR10(root='./data', train=False, download=True, transform=transform_test)",
                            "Call"
                        ],
                        [
                            "torchvision.datasets.CIFAR100(root='./data', train=False, download=True, transform=transform_test)",
                            "Call"
                        ],
                        [
                            "torchvision.datasets.SVHN(root='./data', split='test', download=True, transform=transform_test)",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "10000",
                    "type": "int",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "num_workers": {
                    "value": "20",
                    "type": "int",
                    "possible_values": []
                }
            },
            "CrossEntropyLoss_166": {
                "variable": {
                    "value": "criterion",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "DataParallel_128": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "module": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "basic_net.to(device)",
                            "Call"
                        ],
                        [
                            "torch.nn.DataParallel(net)",
                            "Call"
                        ]
                    ]
                }
            },
            "KLDivLoss_201": {
                "variable": {
                    "value": "criterion_kl",
                    "type": "variable",
                    "possible_values": []
                },
                "size_average": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cat_327": {
                "variable": {
                    "value": "x_adv_all",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "x_adv_all",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(x_adv_all, dim=0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "is_available_79": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "min_225": {
                "variable": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "torch.max(x_adv, inputs - epsilon)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "arange_256": {
                "variable": {
                    "value": "protected_img_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "start": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "end": {
                    "value": "num_protected_imgs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "protected_img_indices.size(0)",
                            "Call"
                        ],
                        [
                            "all_test_data.size(0)",
                            "Call"
                        ]
                    ]
                },
                "step": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_278": {
                "variable": {
                    "value": "candidate_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "num_total_target_images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config_feature_attack['num_total_target_images']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "save_329": {
                "obj": {
                    "value": "x_adv_all",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(x_adv_all, dim=0)",
                            "Call"
                        ]
                    ]
                },
                "f": {
                    "value": "args.method + '_cifar10_adv_test.pt'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "load_142": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "f_path_latest",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(args.model_dir, 'latest')",
                            "Call"
                        ],
                        [
                            "'./models/test/model_cifar_wrn.pt'",
                            "str"
                        ]
                    ]
                }
            },
            "clamp_193": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.detach()",
                            "Call"
                        ],
                        [
                            "x + torch.zeros_like(x).uniform_(-epsilon, epsilon)",
                            "BinOp"
                        ],
                        [
                            "torch.clamp(x, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "Variable(x_adv)",
                            "Call"
                        ]
                    ]
                },
                "min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "clamp_227": {
                "variable": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.data - step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - epsilon), inputs + epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "load_159": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "f_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(args.model_dir, 'checkpoint-%s' % args.init_model_pass)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_191": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.detach()",
                            "Call"
                        ],
                        [
                            "x + torch.zeros_like(x).uniform_(-epsilon, epsilon)",
                            "BinOp"
                        ],
                        [
                            "torch.clamp(x, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "Variable(x_adv)",
                            "Call"
                        ]
                    ]
                }
            },
            "clamp_195": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.detach()",
                            "Call"
                        ],
                        [
                            "x + torch.zeros_like(x).uniform_(-epsilon, epsilon)",
                            "BinOp"
                        ],
                        [
                            "torch.clamp(x, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "Variable(x_adv)",
                            "Call"
                        ]
                    ]
                },
                "min": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "log_softmax_219": {
                "input": {
                    "value": "logits_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model(x)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_220": {
                "input": {
                    "value": "target_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model(target_inputs)",
                            "Call"
                        ],
                        [
                            "target_logits.detach()",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "max_225": {
                "input": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.data - step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - epsilon), inputs + epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "clamp_229": {
                "variable": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.data - step_size * torch.sign(x.grad.data)",
                            "BinOp"
                        ],
                        [
                            "torch.min(torch.max(x_adv, inputs - epsilon), inputs + epsilon)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "torch.clamp(x_adv, -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "min": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "sign_224": {
                "input": {
                    "value": "x.grad.data",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "fs_eval.py": {
        "torch": {
            "DataLoader_112": {
                "variable": {
                    "value": "testloader",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "testset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torchvision.datasets.CIFAR10(root='./data', train=False, download=True, transform=transform_test)",
                            "Call"
                        ],
                        [
                            "torchvision.datasets.CIFAR100(root='./data', train=False, download=True, transform=transform_test)",
                            "Call"
                        ],
                        [
                            "torchvision.datasets.SVHN(root='./data', split='test', download=True, transform=transform_test)",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "args.batch_size_test",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "num_workers": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "CrossEntropyLoss_257": {
                "variable": {
                    "value": "criterion",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "is_available_78": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "CrossEntropyLoss_136": {
                "reduction": {
                    "value": "none",
                    "type": "str",
                    "possible_values": []
                }
            },
            "CrossEntropyLoss_146": {
                "reduction": {
                    "value": "none",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DataParallel_225": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "module": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Attack_None(basic_net, config_natural)",
                            "Call"
                        ],
                        [
                            "Attack_PGD(basic_net, config_fgsm)",
                            "Call"
                        ],
                        [
                            "torch.nn.DataParallel(net)",
                            "Call"
                        ],
                        [
                            "Attack_PGD(basic_net, config_pgd)",
                            "Call"
                        ],
                        [
                            "Attack_PGD(basic_net, config_cw)",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "load_238": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "f_path_latest",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(args.model_dir, 'latest')",
                            "Call"
                        ]
                    ]
                }
            },
            "load_250": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "f_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(args.model_dir, 'checkpoint-%s' % args.init_model_pass)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "fs_main.py": {
        "torch": {
            "DataLoader_167": {
                "variable": {
                    "value": "trainloader",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "trainset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torchvision.datasets.CIFAR10(root='./data', train=True, download=True, transform=transform_train)",
                            "Call"
                        ],
                        [
                            "torchvision.datasets.CIFAR100(root='./data', train=True, download=True, transform=transform_train)",
                            "Call"
                        ],
                        [
                            "torchvision.datasets.SVHN(root='./data', split='train', download=True, transform=transform_train)",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "args.batch_size_train",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "num_workers": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "SGD_214": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "net.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "args.lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "momentum": {
                    "value": "args.momentum",
                    "type": "Attribute",
                    "possible_values": []
                },
                "weight_decay": {
                    "value": "args.weight_decay",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "set_printoptions_32": {
                "threshold": {
                    "value": "10000",
                    "type": "int",
                    "possible_values": []
                }
            },
            "DataParallel_211": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "module": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Attack_FeaScatter(basic_net, config_feature_scatter)",
                            "Call"
                        ],
                        [
                            "basic_net",
                            "variable"
                        ],
                        [
                            "torch.nn.DataParallel(net)",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "is_available_106": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "load_228": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "f_path_latest",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(args.model_dir, 'latest')",
                            "Call"
                        ]
                    ]
                }
            },
            "save_309": {
                "obj": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'net': net.state_dict()}",
                            "Dict"
                        ],
                        [
                            "{'net': net.state_dict(), 'epoch': epoch, 'optimizer': optimizer.state_dict()}",
                            "Dict"
                        ]
                    ]
                },
                "f": {
                    "value": "f_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(args.model_dir, 'checkpoint-%s' % args.init_model_pass)",
                            "Call"
                        ],
                        [
                            "os.path.join(args.model_dir, 'checkpoint-%s' % epoch)",
                            "Call"
                        ],
                        [
                            "os.path.join(args.model_dir, 'latest')",
                            "Call"
                        ]
                    ]
                }
            },
            "save_321": {
                "obj": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'net': net.state_dict()}",
                            "Dict"
                        ],
                        [
                            "{'net': net.state_dict(), 'epoch': epoch, 'optimizer': optimizer.state_dict()}",
                            "Dict"
                        ]
                    ]
                },
                "f": {
                    "value": "f_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(args.model_dir, 'checkpoint-%s' % args.init_model_pass)",
                            "Call"
                        ],
                        [
                            "os.path.join(args.model_dir, 'checkpoint-%s' % epoch)",
                            "Call"
                        ],
                        [
                            "os.path.join(args.model_dir, 'latest')",
                            "Call"
                        ]
                    ]
                }
            },
            "load_233": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "f_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(args.model_dir, 'checkpoint-%s' % args.init_model_pass)",
                            "Call"
                        ],
                        [
                            "os.path.join(args.model_dir, 'checkpoint-%s' % epoch)",
                            "Call"
                        ],
                        [
                            "os.path.join(args.model_dir, 'latest')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "models/wideresnet.py": {
        "torch": {
            "BatchNorm2d_10": {
                "variable": {
                    "value": "self.bn1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_features": {
                    "value": "in_planes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "in_planes",
                            "Method Argument"
                        ],
                        [
                            "in_planes",
                            "Method Argument"
                        ],
                        [
                            "in_planes",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ReLU_11": {
                "variable": {
                    "value": "self.relu1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_12": {
                "variable": {
                    "value": "self.conv1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "in_planes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "in_planes",
                            "Method Argument"
                        ],
                        [
                            "in_planes",
                            "Method Argument"
                        ],
                        [
                            "in_planes",
                            "Method Argument"
                        ]
                    ]
                },
                "out_channels": {
                    "value": "out_planes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "out_planes",
                            "Method Argument"
                        ],
                        [
                            "out_planes",
                            "Method Argument"
                        ],
                        [
                            "out_planes",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "stride",
                            "Method Argument"
                        ],
                        [
                            "stride",
                            "Method Argument"
                        ],
                        [
                            "stride",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "BatchNorm2d_18": {
                "variable": {
                    "value": "self.bn2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_features": {
                    "value": "out_planes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "out_planes",
                            "Method Argument"
                        ],
                        [
                            "out_planes",
                            "Method Argument"
                        ],
                        [
                            "out_planes",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ReLU_19": {
                "variable": {
                    "value": "self.relu2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_20": {
                "variable": {
                    "value": "self.conv2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "out_planes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "out_planes",
                            "Method Argument"
                        ],
                        [
                            "out_planes",
                            "Method Argument"
                        ],
                        [
                            "out_planes",
                            "Method Argument"
                        ]
                    ]
                },
                "out_channels": {
                    "value": "out_planes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "out_planes",
                            "Method Argument"
                        ],
                        [
                            "out_planes",
                            "Method Argument"
                        ],
                        [
                            "out_planes",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_83": {
                "variable": {
                    "value": "self.conv1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "nChannels[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "BatchNorm2d_99": {
                "variable": {
                    "value": "self.bn1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_features": {
                    "value": "nChannels[3]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ReLU_100": {
                "variable": {
                    "value": "self.relu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_101": {
                "variable": {
                    "value": "self.fc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "nChannels[3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_features": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_classes",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "avg_pool2d_120": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.relu1(self.bn1(x))",
                            "Call"
                        ],
                        [
                            "self.relu2(self.bn2(self.conv1(out if self.equalInOut else x)))",
                            "Call"
                        ],
                        [
                            "F.dropout(out, p=self.droprate, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.conv2(out)",
                            "Call"
                        ],
                        [
                            "self.conv1(x)",
                            "Call"
                        ],
                        [
                            "self.block1(out)",
                            "Call"
                        ],
                        [
                            "self.block2(out)",
                            "Call"
                        ],
                        [
                            "self.block3(out)",
                            "Call"
                        ],
                        [
                            "self.relu(self.bn1(out))",
                            "Call"
                        ],
                        [
                            "F.avg_pool2d(out, 8)",
                            "Call"
                        ],
                        [
                            "out.view(-1, self.nChannels)",
                            "Call"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "8",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dropout_43": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.relu1(self.bn1(x))",
                            "Call"
                        ],
                        [
                            "self.relu2(self.bn2(self.conv1(out if self.equalInOut else x)))",
                            "Call"
                        ],
                        [
                            "F.dropout(out, p=self.droprate, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.conv2(out)",
                            "Call"
                        ],
                        [
                            "self.conv1(x)",
                            "Call"
                        ],
                        [
                            "self.block1(out)",
                            "Call"
                        ],
                        [
                            "self.block2(out)",
                            "Call"
                        ],
                        [
                            "self.block3(out)",
                            "Call"
                        ],
                        [
                            "self.relu(self.bn1(out))",
                            "Call"
                        ],
                        [
                            "F.avg_pool2d(out, 8)",
                            "Call"
                        ],
                        [
                            "out.view(-1, self.nChannels)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.droprate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_45": {
                "input": {
                    "value": "x if self.equalInOut else self.convShortcut(x)",
                    "type": "IfExp",
                    "possible_values": []
                },
                "other": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.relu1(self.bn1(x))",
                            "Call"
                        ],
                        [
                            "self.relu2(self.bn2(self.conv1(out if self.equalInOut else x)))",
                            "Call"
                        ],
                        [
                            "F.dropout(out, p=self.droprate, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.conv2(out)",
                            "Call"
                        ],
                        [
                            "self.conv1(x)",
                            "Call"
                        ],
                        [
                            "self.block1(out)",
                            "Call"
                        ],
                        [
                            "self.block2(out)",
                            "Call"
                        ],
                        [
                            "self.block3(out)",
                            "Call"
                        ],
                        [
                            "self.relu(self.bn1(out))",
                            "Call"
                        ],
                        [
                            "F.avg_pool2d(out, 8)",
                            "Call"
                        ],
                        [
                            "out.view(-1, self.nChannels)",
                            "Call"
                        ]
                    ]
                }
            },
            "Sequential_67": {
                "*args": {
                    "value": "*layers",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "Conv2d_28": {
                "in_channels": {
                    "value": "in_planes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "in_planes",
                            "Method Argument"
                        ],
                        [
                            "in_planes",
                            "Method Argument"
                        ],
                        [
                            "in_planes",
                            "Method Argument"
                        ]
                    ]
                },
                "out_channels": {
                    "value": "out_planes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "out_planes",
                            "Method Argument"
                        ],
                        [
                            "out_planes",
                            "Method Argument"
                        ],
                        [
                            "out_planes",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "stride",
                            "Method Argument"
                        ],
                        [
                            "stride",
                            "Method Argument"
                        ],
                        [
                            "stride",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "ot.py": {
        "torch": {
            "sum_25": {
                "variable": {
                    "value": "cost_ot",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "T * C",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_76": {
                "variable": {
                    "value": "pi",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "M(U, V)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_86": {
                "variable": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "[m, n]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "exp_87": {
                "variable": {
                    "value": "A",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "-cost_matrix / beta",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_105": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "[n, n]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "CosineSimilarity_123": {
                "variable": {
                    "value": "cos",
                    "type": "variable",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "eps": {
                    "value": "1e-06",
                    "type": "float",
                    "possible_values": []
                }
            },
            "clamp_124": {
                "variable": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "1 - cos(x_col, y_lin)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "CosineSimilarity_129": {
                "variable": {
                    "value": "cos",
                    "type": "variable",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "eps": {
                    "value": "1e-06",
                    "type": "float",
                    "possible_values": []
                }
            },
            "clamp_130": {
                "variable": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "1 - cos(x, y)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "mm_97": {
                "variable": {
                    "value": "tmp",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "construct_diag(torch.squeeze(delta))",
                    "type": "Call",
                    "possible_values": []
                },
                "mat2": {
                    "value": "Q",
                    "type": "variable",
                    "possible_values": [
                        [
                            "A * T",
                            "BinOp"
                        ]
                    ]
                }
            },
            "mm_98": {
                "variable": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tmp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.mm(construct_diag(torch.squeeze(delta)), Q)",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "construct_diag(torch.squeeze(sigma))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_55": {
                "input": {
                    "value": "torch.exp(A).sum(1, keepdim=True) + 1e-06",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ones_84": {
                "*size": {
                    "value": "[n, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "exp_55": {
                "input": {
                    "value": "A",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.exp(-cost_matrix / beta)",
                            "Call"
                        ],
                        [
                            "A",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sum_55": {
                "input": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdim": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "squeeze_97": {
                "input": {
                    "value": "delta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0 / (m * torch.mm(Q, sigma))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "squeeze_98": {
                "input": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0 / n * torch.ones([n, 1]).to(device)",
                            "BinOp"
                        ],
                        [
                            "1.0 / (n * torch.mm(delta.t(), Q)).t()",
                            "BinOp"
                        ]
                    ]
                }
            },
            "log_64": {
                "input": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Variable(1.0 / m * torch.FloatTensor(m).fill_(1).to('cuda'), requires_grad=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "log_65": {
                "input": {
                    "value": "nu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Variable(1.0 / n * torch.FloatTensor(n).fill_(1).to('cuda'), requires_grad=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "mm_94": {
                "input": {
                    "value": "Q",
                    "type": "variable",
                    "possible_values": [
                        [
                            "A * T",
                            "BinOp"
                        ]
                    ]
                },
                "mat2": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0 / n * torch.ones([n, 1]).to(device)",
                            "BinOp"
                        ],
                        [
                            "1.0 / (n * torch.mm(delta.t(), Q)).t()",
                            "BinOp"
                        ]
                    ]
                }
            },
            "mm_95": {
                "input": {
                    "value": "delta.t()",
                    "type": "Call",
                    "possible_values": []
                },
                "mat2": {
                    "value": "Q",
                    "type": "variable",
                    "possible_values": [
                        [
                            "A * T",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "utils.py": {
        "torch": {
            "sum_77": {
                "variable": {
                    "value": "self_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "onehot_targets * logits",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sum_55": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "torch.mul(log_likelihood, targets)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_softmax_50": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "max_78": {
                "input": {
                    "value": "(1 - onehot_targets) * logits - onehot_targets * 1000",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sum_81": {
                "input": {
                    "value": "torch.clamp(self_loss - other_loss + self.margin, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sum_53": {
                "input": {
                    "value": "torch.mul(log_likelihood, targets)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mul_55": {
                "input": {
                    "value": "log_likelihood",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-F.log_softmax(inputs, dim=1)",
                            "UnaryOp"
                        ]
                    ]
                },
                "other": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "targets",
                            "Method Argument"
                        ],
                        [
                            "targets",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "clamp_81": {
                "input": {
                    "value": "self_loss - other_loss + self.margin",
                    "type": "BinOp",
                    "possible_values": []
                },
                "min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "mul_53": {
                "input": {
                    "value": "log_likelihood",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-F.log_softmax(inputs, dim=1)",
                            "UnaryOp"
                        ]
                    ]
                },
                "other": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "targets",
                            "Method Argument"
                        ],
                        [
                            "targets",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    }
}