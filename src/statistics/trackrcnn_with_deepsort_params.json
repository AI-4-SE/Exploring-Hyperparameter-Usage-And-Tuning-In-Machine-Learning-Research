{
    "forwarding/Util.py": {
        "sklearn": {
            "silhouette_score_55": {
                "X": {
                    "value": "X",
                    "possible_values": []
                },
                "labels": {
                    "value": "self.clusterers[n_clusters - 1].labels_",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "FileWriter_95": {
                "variable": {
                    "value": "writer",
                    "possible_values": []
                },
                "logdir": {
                    "value": "os.path.join(save_dir)",
                    "possible_values": []
                },
                "graph": {
                    "value": "None",
                    "possible_values": []
                }
            },
            "Session_96": {
                "variable": {
                    "value": "sess",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "Saver_126": {
                "variable": {
                    "value": "saver",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "reset_default_graph_94": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "Variable_113": {
                "variable": {
                    "value": "embedding_var",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "fts",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "possible_values": [
                        [
                            "list(images_features_labels.keys())",
                            "Call"
                        ]
                    ]
                },
                "trainable": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "global_variables_initializer_127": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            }
        }
    },
    "forwarding/tracking/tracking_deepsort/linear_assignment.py": {
        "sklearn": {}
    },
    "core/Engine.py": {
        "tensorflow": {
            "Variable_28": {
                "variable": {
                    "value": "self.global_step",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "global_variables_initializer_64": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "run_64": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "local_variables_initializer_65": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "run_65": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "ConfigProto_73": {
                "variable": {
                    "value": "sess_config",
                    "possible_values": []
                },
                "allow_soft_placement": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "InteractiveSession_75": {
                "variable": {
                    "value": "sess",
                    "possible_values": []
                },
                "config": {
                    "value": "sess_config",
                    "possible_values": [
                        [
                            "tf.ConfigProto(allow_soft_placement=True)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "core/Measures.py": {
        "tensorflow": {
            "py_func_85": {
                "variable": {
                    "value": "res",
                    "possible_values": []
                },
                "func": {
                    "value": "f",
                    "possible_values": []
                },
                "inp": {
                    "value": "[predictions, targets]",
                    "possible_values": []
                },
                "Tout": {
                    "value": "[tf.float32, tf.float32, tf.float32]",
                    "possible_values": []
                }
            }
        }
    },
    "core/Saver.py": {
        "tensorflow": {
            "global_variables_128": {
                "variable": {
                    "value": "vars_",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "Saver_17": {
                "variable": {
                    "value": "self.tf_saver",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "max_saves_to_keep",
                    "possible_values": [
                        [
                            "config.int('max_saves_to_keep', 0)",
                            "Call"
                        ]
                    ]
                },
                "keep_checkpoint_every_n_hours": {
                    "value": "keep_checkpoint_every_n_hours",
                    "possible_values": [
                        [
                            "config.float('keep_checkpoint_every_n_hours', 10000.0)",
                            "Call"
                        ]
                    ]
                },
                "pad_step_number": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "global_variables_89": {
                "variable": {
                    "value": "vars_model",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "global_variables_113": {
                "variable": {
                    "value": "vars_",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "load_variable_118": {
                "variable": {
                    "value": "w",
                    "possible_values": []
                },
                "ckpt_dir_or_file": {
                    "value": "fn",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "self.load.replace('.index', '')",
                            "Call"
                        ],
                        [
                            "files[-1].replace('.index', '')",
                            "Call"
                        ],
                        [
                            "fn.replace('DeepLabRGB:', '')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "xception_65/entry_flow/conv1_1/weights",
                    "possible_values": []
                }
            },
            "placeholder_121": {
                "variable": {
                    "value": "placeholder_w",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "assign_122": {
                "variable": {
                    "value": "assign_op_w",
                    "possible_values": []
                },
                "ref": {
                    "value": "var_w",
                    "possible_values": [
                        [
                            "[x for x in vars_ if x.name == 'xception_65/entry_flow/conv1_1/weights:0']",
                            "ListComp"
                        ],
                        [
                            "var_w[0]",
                            "Subscript"
                        ]
                    ]
                },
                "value": {
                    "value": "placeholder_w",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "MakeDirs_34": {
                "dirname": {
                    "value": "self.model_dir",
                    "possible_values": []
                }
            },
            "Saver_110": {
                "var_list": {
                    "value": "vars_intersection",
                    "possible_values": [
                        [
                            "[x for x in vars_model if x.name[:-2] in vars_file]",
                            "ListComp"
                        ],
                        [
                            "[x for x in vars_intersection if x not in vars_shape_mismatch]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "placeholder_178": {
                "variable": {
                    "value": "placeholder",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "assign_179": {
                "variable": {
                    "value": "op",
                    "possible_values": []
                },
                "ref": {
                    "value": "var",
                    "possible_values": [
                        [
                            "var_dict[k]",
                            "Subscript"
                        ]
                    ]
                },
                "value": {
                    "value": "placeholder",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "placeholder_187": {
                "variable": {
                    "value": "placeholder",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "assign_188": {
                "variable": {
                    "value": "op",
                    "possible_values": []
                },
                "ref": {
                    "value": "var",
                    "possible_values": [
                        [
                            "var_dict[k]",
                            "Subscript"
                        ]
                    ]
                },
                "value": {
                    "value": "placeholder",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "list_variables_86": {
                "ckpt_dir_or_file": {
                    "value": "filename",
                    "possible_values": []
                }
            }
        }
    },
    "core/Trainer.py": {
        "tensorflow": {
            "placeholder_23": {
                "variable": {
                    "value": "self.lr_var",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "possible_values": []
                },
                "name": {
                    "value": "learning_rate",
                    "possible_values": []
                }
            },
            "placeholder_with_default_24": {
                "variable": {
                    "value": "self.loss_scale_var",
                    "possible_values": []
                },
                "input": {
                    "value": "1.0",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "possible_values": []
                },
                "name": {
                    "value": "loss_scale",
                    "possible_values": []
                }
            },
            "MakeDirs_75": {
                "dirname": {
                    "value": "summdir",
                    "possible_values": [
                        [
                            "config.dir('summary_dir', 'summaries')",
                            "Call"
                        ],
                        [
                            "summdir + (model + '/')",
                            "BinOp"
                        ]
                    ]
                }
            },
            "FileWriter_80": {
                "variable": {
                    "value": "summary_writer",
                    "possible_values": []
                },
                "logdir": {
                    "value": "summdir",
                    "possible_values": [
                        [
                            "config.dir('summary_dir', 'summaries')",
                            "Call"
                        ],
                        [
                            "summdir + (model + '/')",
                            "BinOp"
                        ]
                    ]
                },
                "graph": {
                    "value": "self.session.graph",
                    "possible_values": []
                }
            },
            "RunOptions_178": {
                "variable": {
                    "value": "run_options",
                    "possible_values": []
                },
                "trace_level": {
                    "value": "tf.RunOptions.FULL_TRACE",
                    "possible_values": []
                }
            },
            "RunMetadata_179": {
                "variable": {
                    "value": "run_metadata",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "merge_92": {
                "variable": {
                    "value": "summary_op_test",
                    "possible_values": []
                },
                "inputs": {
                    "value": "self.test_network.summaries",
                    "possible_values": []
                }
            },
            "device_129": {
                "device_name": {
                    "value": "setups[0].variable_device",
                    "possible_values": []
                }
            },
            "MomentumOptimizer_50": {
                "learning_rate": {
                    "value": "self.lr_var",
                    "possible_values": []
                },
                "momentum": {
                    "value": "momentum",
                    "possible_values": [
                        [
                            "config.float('momentum', 0.9)",
                            "Call"
                        ]
                    ]
                },
                "use_nesterov": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "scalar_84": {
                "variable": {
                    "value": "grad_norm_summary",
                    "possible_values": []
                },
                "name": {
                    "value": "grad_norm",
                    "possible_values": []
                },
                "data": {
                    "value": "grad_norm",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "merge_90": {
                "variable": {
                    "value": "summary_op",
                    "possible_values": []
                },
                "inputs": {
                    "value": "train_summs",
                    "possible_values": [
                        [
                            "self.train_network.summaries",
                            "Attribute"
                        ]
                    ]
                }
            },
            "no_op_110": {
                "name": {
                    "value": "dummy_step_op",
                    "possible_values": []
                }
            },
            "device_117": {
                "device_name": {
                    "value": "gpu_str",
                    "possible_values": [
                        [
                            "'/gpu:' + str(s.gpu_idx)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "name_scope_117": {
                "name": {
                    "value": "tower_gpu_ + str(s.gpu_idx) + _opt",
                    "possible_values": []
                }
            },
            "MomentumOptimizer_52": {
                "learning_rate": {
                    "value": "self.lr_var",
                    "possible_values": []
                },
                "momentum": {
                    "value": "momentum",
                    "possible_values": [
                        [
                            "config.float('momentum', 0.9)",
                            "Call"
                        ]
                    ]
                }
            },
            "AdamOptimizer_56": {
                "variable": {
                    "value": "opt",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.lr_var",
                    "possible_values": []
                }
            },
            "global_variables_57": {
                "variable": {
                    "value": "all_vars",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "variables_initializer_59": {
                "variable": {
                    "value": "reset_opt_op",
                    "possible_values": []
                },
                "var_list": {
                    "value": "opt_vars",
                    "possible_values": [
                        [
                            "[v for v in all_vars if 'Adam' in v.name]",
                            "ListComp"
                        ]
                    ]
                },
                "name": {
                    "value": "reset_optimizer",
                    "possible_values": []
                }
            },
            "trainable_variables_119": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "get_collection_120": {
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_RESOURCE_VARIABLES",
                    "possible_values": []
                }
            },
            "no_op_143": {
                "name": {
                    "value": "dummy_step_op",
                    "possible_values": []
                }
            },
            "GradientDescentOptimizer_54": {
                "learning_rate": {
                    "value": "self.lr_var",
                    "possible_values": []
                }
            }
        }
    },
    "core/Util.py": {
        "tensorflow": {
            "shape_11": {
                "variable": {
                    "value": "tf_shape",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "possible_values": []
                }
            },
            "clip_by_global_norm_57": {
                "variable": {
                    "value": "(gradients, norm)",
                    "possible_values": []
                },
                "t_list": {
                    "value": "gradients",
                    "possible_values": []
                },
                "clip_norm": {
                    "value": "threshold",
                    "possible_values": []
                }
            },
            "concat_43": {
                "variable": {
                    "value": "grad",
                    "possible_values": []
                },
                "values": {
                    "value": "grads",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "zip(gradients, variables)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "reduce_mean_44": {
                "variable": {
                    "value": "grad",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "grad",
                    "possible_values": [
                        [
                            "tf.concat(grads, 0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(grad, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "expand_dims_37": {
                "variable": {
                    "value": "expanded_g",
                    "possible_values": []
                },
                "input": {
                    "value": "g",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            }
        }
    },
    "datasets/Augmentors.py": {
        "tensorflow": {
            "unstack_108": {
                "variable": {
                    "value": "(y0, x0, y1, x1)",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.cast(tensors[DataKeys.BBOXES_y0x0y1x1], tf.float32)",
                    "possible_values": []
                }
            },
            "clip_by_value_112": {
                "variable": {
                    "value": "g",
                    "possible_values": []
                },
                "t": {
                    "value": "g",
                    "possible_values": [
                        [
                            "self._sample_g()",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(g, -2.5, 2.5)",
                            "Call"
                        ],
                        [
                            "self._sample_g()",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "-2.5",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "2.5",
                    "possible_values": []
                }
            },
            "shape_121": {
                "variable": {
                    "value": "shape",
                    "possible_values": []
                },
                "input": {
                    "value": "tensors[DataKeys.IMAGES]",
                    "possible_values": []
                }
            },
            "maximum_122": {
                "variable": {
                    "value": "y0",
                    "possible_values": []
                },
                "x": {
                    "value": "y0",
                    "possible_values": [
                        [
                            "y0 + self.v * g[0] * h",
                            "BinOp"
                        ],
                        [
                            "tf.maximum(y0, 0)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "maximum_123": {
                "variable": {
                    "value": "x0",
                    "possible_values": []
                },
                "x": {
                    "value": "x0",
                    "possible_values": [
                        [
                            "x0 + self.v * g[1] * w",
                            "BinOp"
                        ],
                        [
                            "tf.maximum(x0, 0)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "minimum_124": {
                "variable": {
                    "value": "y1",
                    "possible_values": []
                },
                "x": {
                    "value": "y1",
                    "possible_values": [
                        [
                            "y1 + self.v * g[2] * h",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(y1, tf.cast(shape[0], tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.cast(shape[0], tf.float32)",
                    "possible_values": []
                }
            },
            "minimum_125": {
                "variable": {
                    "value": "x1",
                    "possible_values": []
                },
                "x": {
                    "value": "x1",
                    "possible_values": [
                        [
                            "x1 + self.v * g[3] * w",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(x1, tf.cast(shape[1], tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.cast(shape[1], tf.float32)",
                    "possible_values": []
                }
            },
            "stack_127": {
                "variable": {
                    "value": "bbox_jittered",
                    "possible_values": []
                },
                "values": {
                    "value": "[y0, x0, y1, x1]",
                    "possible_values": []
                }
            },
            "name_scope_31": {
                "name": {
                    "value": "gamma_augmentor",
                    "possible_values": []
                }
            },
            "name_scope_62": {
                "name": {
                    "value": "flip_augmentor",
                    "possible_values": []
                }
            },
            "log_37": {
                "x": {
                    "value": "0.5 - 1 / math.sqrt(2) * factor",
                    "possible_values": []
                }
            },
            "cond_77": {
                "variable": {
                    "value": "aug",
                    "possible_values": []
                },
                "pred": {
                    "value": "doit",
                    "possible_values": [
                        [
                            "self._sample_doit()",
                            "Call"
                        ],
                        [
                            "self._sample_doit()",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : flipped",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : val",
                    "possible_values": []
                }
            },
            "cast_108": {
                "x": {
                    "value": "tensors[DataKeys.BBOXES_y0x0y1x1]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "cast_124": {
                "x": {
                    "value": "shape[0]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "cast_125": {
                "x": {
                    "value": "shape[1]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "flip_left_right_72": {
                "variable": {
                    "value": "flipped",
                    "possible_values": []
                },
                "image": {
                    "value": "val",
                    "possible_values": [
                        [
                            "tensors[key_]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_74": {
                "input": {
                    "value": "tensors[DataKeys.IMAGES]",
                    "possible_values": []
                }
            },
            "shape_76": {
                "input": {
                    "value": "tensors[DataKeys.IMAGES]",
                    "possible_values": []
                }
            }
        }
    },
    "datasets/Dataset.py": {
        "tensorflow": {
            "read_file_78": {
                "variable": {
                    "value": "img_data",
                    "possible_values": []
                },
                "filename": {
                    "value": "img_filename",
                    "possible_values": []
                }
            },
            "decode_image_79": {
                "variable": {
                    "value": "img",
                    "possible_values": []
                },
                "contents": {
                    "value": "img_data",
                    "possible_values": [
                        [
                            "tf.read_file(img_filename)",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "possible_values": []
                }
            },
            "convert_image_dtype_80": {
                "variable": {
                    "value": "img",
                    "possible_values": []
                },
                "image": {
                    "value": "img",
                    "possible_values": [
                        [
                            "tf.image.decode_image(img_data, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(img, tf.float32)",
                            "Call"
                        ],
                        [
                            "tensors[DataKeys.IMAGES]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "read_file_85": {
                "variable": {
                    "value": "ann_data",
                    "possible_values": []
                },
                "filename": {
                    "value": "annotation_filename",
                    "possible_values": []
                }
            },
            "decode_image_86": {
                "variable": {
                    "value": "ann",
                    "possible_values": []
                },
                "contents": {
                    "value": "ann_data",
                    "possible_values": [
                        [
                            "tf.read_file(annotation_filename)",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "cast_182": {
                "variable": {
                    "value": "bbox_guidance",
                    "possible_values": []
                },
                "x": {
                    "value": "tensors[DataKeys.BBOX_GUIDANCE]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "cast_186": {
                "variable": {
                    "value": "laser_guidance",
                    "possible_values": []
                },
                "x": {
                    "value": "tensors[DataKeys.LASER_GUIDANCE]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "cast_196": {
                "variable": {
                    "value": "mask",
                    "possible_values": []
                },
                "x": {
                    "value": "tensors[DataKeys.SEGMENTATION_LABELS]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "concat_199": {
                "variable": {
                    "value": "inputs",
                    "possible_values": []
                },
                "values": {
                    "value": "inputs_to_concat",
                    "possible_values": [
                        [
                            "[tensors[DataKeys.IMAGES]]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "zeros_like_214": {
                "variable": {
                    "value": "pad",
                    "possible_values": []
                },
                "input": {
                    "value": "unnormed[:, :, :, :1]",
                    "possible_values": []
                }
            },
            "concat_215": {
                "variable": {
                    "value": "unnormed",
                    "possible_values": []
                },
                "values": {
                    "value": "[unnormed, pad]",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "possible_values": []
                }
            },
            "shape_152": {
                "input": {
                    "value": "tensors[DataKeys.IMAGES]",
                    "possible_values": []
                }
            },
            "shape_172": {
                "input": {
                    "value": "img",
                    "possible_values": [
                        [
                            "tf.image.decode_image(img_data, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(img, tf.float32)",
                            "Call"
                        ],
                        [
                            "tensors[DataKeys.IMAGES]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "image_216": {
                "name": {
                    "value": "self.subset + 'data/images'",
                    "possible_values": []
                },
                "data": {
                    "value": "unnormed",
                    "possible_values": [
                        [
                            "unnormalize(data[DataKeys.IMAGES])",
                            "Call"
                        ],
                        [
                            "data[DataKeys.IMAGES]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([unnormed, pad], axis=3)",
                            "Call"
                        ]
                    ]
                }
            },
            "image_218": {
                "name": {
                    "value": "self.subset + 'data/ground truth segmentation labels'",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.cast(data[DataKeys.SEGMENTATION_LABELS], tf.float32)",
                    "possible_values": []
                }
            },
            "image_221": {
                "name": {
                    "value": "self.subset + 'data/ground truth segmentation instance labels'",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.cast(data[DataKeys.SEGMENTATION_INSTANCE_LABELS], tf.float32)",
                    "possible_values": []
                }
            },
            "image_224": {
                "name": {
                    "value": "self.subset + 'data/bbox guidance'",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.cast(data[DataKeys.BBOX_GUIDANCE], tf.float32)",
                    "possible_values": []
                }
            },
            "image_227": {
                "name": {
                    "value": "self.subset + 'data/signed_distance_transform_guidance'",
                    "possible_values": []
                },
                "data": {
                    "value": "data[DataKeys.SIGNED_DISTANCE_TRANSFORM_GUIDANCE]",
                    "possible_values": []
                }
            },
            "image_230": {
                "name": {
                    "value": "self.subset + 'data/unsigned_distance_transform_guidance'",
                    "possible_values": []
                },
                "data": {
                    "value": "data[DataKeys.UNSIGNED_DISTANCE_TRANSFORM_GUIDANCE]",
                    "possible_values": []
                }
            },
            "image_233": {
                "name": {
                    "value": "self.subset + 'data/laser guidance'",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.cast(data[DataKeys.LASER_GUIDANCE], tf.float32)",
                    "possible_values": []
                }
            },
            "logical_not_292": {
                "x": {
                    "value": "tensors[DataKeys.SKIP_EXAMPLE]",
                    "possible_values": []
                }
            },
            "constant_294": {
                "value": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "cast_219": {
                "x": {
                    "value": "data[DataKeys.SEGMENTATION_LABELS]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "cast_222": {
                "x": {
                    "value": "data[DataKeys.SEGMENTATION_INSTANCE_LABELS]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "cast_225": {
                "x": {
                    "value": "data[DataKeys.BBOX_GUIDANCE]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "cast_234": {
                "x": {
                    "value": "data[DataKeys.LASER_GUIDANCE]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "expand_dims_314": {
                "input": {
                    "value": "v",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            }
        }
    },
    "datasets/DetectionDataset.py": {
        "tensorflow": {
            "py_func_72": {
                "variable": {
                    "value": "(bboxes, ids, classes, is_crowd, mask)",
                    "possible_values": []
                },
                "func": {
                    "value": "self._load_ann_np",
                    "possible_values": []
                },
                "inp": {
                    "value": "[annotation_filename]",
                    "possible_values": []
                },
                "Tout": {
                    "value": "[tf.float32, tf.int32, tf.int32, tf.int32, tf.uint8]",
                    "possible_values": []
                },
                "name": {
                    "value": "postproc_ann_np",
                    "possible_values": []
                }
            },
            "py_func_65": {
                "variable": {
                    "value": "img",
                    "possible_values": []
                },
                "func": {
                    "value": "self._imgs_preload_dict_lookup",
                    "possible_values": []
                },
                "inp": {
                    "value": "[img_filename]",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.float32",
                    "possible_values": []
                },
                "name": {
                    "value": "imgs_preload_dict_lookup_np",
                    "possible_values": []
                }
            }
        }
    },
    "datasets/FeedDataset.py": {
        "tensorflow": {
            "expand_dims_62": {
                "variable": {
                    "value": "data[k]",
                    "possible_values": []
                },
                "input": {
                    "value": "examples[0][k]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "placeholder_40": {
                "dtype": {
                    "value": "dtype",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "possible_values": []
                },
                "name": {
                    "value": "key + '_placeholder_{}'.format(idx)",
                    "possible_values": []
                }
            },
            "stack_60": {
                "variable": {
                    "value": "data[k]",
                    "possible_values": []
                },
                "values": {
                    "value": "[example[k] for example in examples]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            }
        }
    },
    "datasets/KITTI/segtrack/KITTI_segtrack.py": {
        "tensorflow": {
            "py_func_124": {
                "func": {
                    "value": "successor_frame_filename_np",
                    "possible_values": []
                },
                "inp": {
                    "value": "[filename, offset]",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.string",
                    "possible_values": []
                }
            },
            "reduce_any_108": {
                "variable": {
                    "value": "stacked",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "[example[key] for example in examples]",
                    "possible_values": []
                }
            },
            "stack_110": {
                "variable": {
                    "value": "stacked",
                    "possible_values": []
                },
                "values": {
                    "value": "[example[key] for example in examples]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            }
        }
    },
    "datasets/KITTI/segtrack/KITTI_segtrack_amodal.py": {
        "tensorflow": {
            "py_func_38": {
                "variable": {
                    "value": "(amodal_bbox_is_invalid, amodal_bbox)",
                    "possible_values": []
                },
                "func": {
                    "value": "_lookup_amodal_bbox",
                    "possible_values": []
                },
                "inp": {
                    "value": "[ann_filename]",
                    "possible_values": []
                },
                "Tout": {
                    "value": "[tf.bool, tf.float32]",
                    "possible_values": []
                },
                "name": {
                    "value": "lookup_amodal_bbox",
                    "possible_values": []
                }
            }
        }
    },
    "datasets/KITTI/segtrack/KITTI_segtrack_bbox.py": {
        "tensorflow": {
            "py_func_43": {
                "variable": {
                    "value": "(bbox_is_invalid, bbox)",
                    "possible_values": []
                },
                "func": {
                    "value": "_lookup_bbox",
                    "possible_values": []
                },
                "inp": {
                    "value": "[ann_filename]",
                    "possible_values": []
                },
                "Tout": {
                    "value": "[tf.bool, tf.float32]",
                    "possible_values": []
                },
                "name": {
                    "value": "lookup_bbox",
                    "possible_values": []
                }
            }
        }
    },
    "datasets/KITTI/segtrack/KITTI_segtrack_bbox_detection_refinement.py": {
        "tensorflow": {
            "py_func_36": {
                "variable": {
                    "value": "(boxes_to_refine, ids)",
                    "possible_values": []
                },
                "func": {
                    "value": "_load_boxes_to_refine",
                    "possible_values": []
                },
                "inp": {
                    "value": "[annotation_filename]",
                    "possible_values": []
                },
                "Tout": {
                    "value": "[tf.float32, tf.int32]",
                    "possible_values": []
                },
                "name": {
                    "value": "load_boxes_to_refine",
                    "possible_values": []
                }
            }
        }
    },
    "datasets/KITTI/segtrack/KITTI_segtrack_bbox_fwd.py": {
        "tensorflow": {
            "py_func_43": {
                "variable": {
                    "value": "mask",
                    "possible_values": []
                },
                "func": {
                    "value": "_load_mask",
                    "possible_values": []
                },
                "inp": {
                    "value": "[ann_string, tf.shape(img)]",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.uint8",
                    "possible_values": []
                }
            },
            "shape_43": {
                "input": {
                    "value": "img",
                    "possible_values": []
                }
            }
        }
    },
    "datasets/KITTI/segtrack/KITTI_segtrack_bbox_refinement.py": {
        "tensorflow": {
            "py_func_35": {
                "variable": {
                    "value": "(boxes_to_refine, ids)",
                    "possible_values": []
                },
                "func": {
                    "value": "_load_boxes_to_refine",
                    "possible_values": []
                },
                "inp": {
                    "value": "[annotation_filename]",
                    "possible_values": []
                },
                "Tout": {
                    "value": "[tf.float32, tf.int32]",
                    "possible_values": []
                },
                "name": {
                    "value": "load_boxes_to_refine",
                    "possible_values": []
                }
            }
        }
    },
    "datasets/KITTI/segtrack/KITTI_segtrack_detection_merging.py": {
        "tensorflow": {
            "py_func_59": {
                "variable": {
                    "value": "img",
                    "possible_values": []
                },
                "func": {
                    "value": "_load_and_encode_detections",
                    "possible_values": []
                },
                "inp": {
                    "value": "[img_filename]",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.float32",
                    "possible_values": []
                },
                "name": {
                    "value": "load_and_encode_detections",
                    "possible_values": []
                }
            }
        }
    },
    "datasets/KITTI/segtrack/KITTI_segtrack_nomasks.py": {
        "tensorflow": {
            "py_func_51": {
                "variable": {
                    "value": "(bboxes, ids, classes, is_crowd)",
                    "possible_values": []
                },
                "func": {
                    "value": "_load_ann",
                    "possible_values": []
                },
                "inp": {
                    "value": "[annotation_filename]",
                    "possible_values": []
                },
                "Tout": {
                    "value": "[tf.float32, tf.int32, tf.int32, tf.int32]",
                    "possible_values": []
                },
                "name": {
                    "value": "postproc_ann_np",
                    "possible_values": []
                }
            }
        }
    },
    "datasets/MOT/MOT_common.py": {
        "tensorflow": {
            "shape_38": {
                "variable": {
                    "value": "img_shape",
                    "possible_values": []
                },
                "input": {
                    "value": "img",
                    "possible_values": []
                }
            },
            "py_func_39": {
                "variable": {
                    "value": "(bboxes, ids, classes, is_crowd)",
                    "possible_values": []
                },
                "func": {
                    "value": "self.get_data_arrays_for_file",
                    "possible_values": []
                },
                "inp": {
                    "value": "[img_filename, img_shape[0], img_shape[1]]",
                    "possible_values": []
                },
                "Tout": {
                    "value": "[tf.float32, tf.int32, tf.int32, tf.int32]",
                    "possible_values": []
                },
                "name": {
                    "value": "get_data_arrays_for_file",
                    "possible_values": []
                }
            },
            "py_func_116": {
                "func": {
                    "value": "successor_frame_filename_np",
                    "possible_values": []
                },
                "inp": {
                    "value": "[filename, offset]",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.string",
                    "possible_values": []
                }
            },
            "reduce_any_100": {
                "variable": {
                    "value": "stacked",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "[example[key] for example in examples]",
                    "possible_values": []
                }
            },
            "stack_102": {
                "variable": {
                    "value": "stacked",
                    "possible_values": []
                },
                "values": {
                    "value": "[example[key] for example in examples]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            }
        }
    },
    "datasets/MOT/MOT_crop.py": {
        "tensorflow": {
            "py_func_37": {
                "variable": {
                    "value": "(class_, bbox)",
                    "possible_values": []
                },
                "func": {
                    "value": "self._load_annotation",
                    "possible_values": []
                },
                "inp": {
                    "value": "[img_filename]",
                    "possible_values": []
                },
                "Tout": {
                    "value": "[tf.int64, tf.float32]",
                    "possible_values": []
                }
            },
            "string_split_33": {
                "source": {
                    "value": "[img_filename]",
                    "possible_values": []
                },
                "sep": {
                    "value": ":",
                    "possible_values": []
                }
            }
        }
    },
    "datasets/Mapillary/MapillaryLike_instance.py": {
        "tensorflow": {
            "read_file_51": {
                "variable": {
                    "value": "ann_data",
                    "possible_values": []
                },
                "filename": {
                    "value": "annotation_filename_without_id",
                    "possible_values": [
                        [
                            "tf.string_split([annotation_filename], ':').values[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "decode_png_52": {
                "variable": {
                    "value": "ann",
                    "possible_values": []
                },
                "contents": {
                    "value": "ann_data",
                    "possible_values": [
                        [
                            "tf.read_file(annotation_filename_without_id)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.uint16",
                    "possible_values": []
                },
                "channels": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "string_to_number_59": {
                "variable": {
                    "value": "id_",
                    "possible_values": []
                },
                "string_tensor": {
                    "value": "id_str",
                    "possible_values": [
                        [
                            "tf.string_split([ann_filename], ':').values[1]",
                            "Subscript"
                        ]
                    ]
                },
                "out_type": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "cast_60": {
                "x": {
                    "value": "ann",
                    "possible_values": [
                        [
                            "tf.image.decode_png(ann_data, dtype=tf.uint16, channels=1)",
                            "Call"
                        ],
                        [
                            "self.postproc_annotation(annotation_filename, ann)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "equal_60": {
                "x": {
                    "value": "tf.cast(ann, tf.int32)",
                    "possible_values": []
                },
                "y": {
                    "value": "id_",
                    "possible_values": [
                        [
                            "id_and_size.split(':')[0]",
                            "Subscript"
                        ],
                        [
                            "tf.string_to_number(id_str, out_type=tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "string_split_50": {
                "source": {
                    "value": "[annotation_filename]",
                    "possible_values": []
                },
                "sep": {
                    "value": ":",
                    "possible_values": []
                }
            },
            "string_split_58": {
                "source": {
                    "value": "[ann_filename]",
                    "possible_values": []
                },
                "sep": {
                    "value": ":",
                    "possible_values": []
                }
            }
        }
    },
    "datasets/Mapillary/Mapillary_crop.py": {
        "tensorflow": {
            "read_file_65": {
                "variable": {
                    "value": "ann_data",
                    "possible_values": []
                },
                "filename": {
                    "value": "annotation_filename",
                    "possible_values": []
                }
            },
            "decode_image_66": {
                "variable": {
                    "value": "ann",
                    "possible_values": []
                },
                "contents": {
                    "value": "ann_data",
                    "possible_values": [
                        [
                            "tf.read_file(annotation_filename)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.uint16",
                    "possible_values": []
                },
                "channels": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "py_func_72": {
                "variable": {
                    "value": "(class_, bbox, mask)",
                    "possible_values": []
                },
                "func": {
                    "value": "self._postproc_annotation",
                    "possible_values": []
                },
                "inp": {
                    "value": "[ann_filename, ann]",
                    "possible_values": []
                },
                "Tout": {
                    "value": "[tf.int64, tf.float32, tf.uint8]",
                    "possible_values": []
                }
            }
        }
    },
    "datasets/Resize.py": {
        "tensorflow": {
            "cast_94": {
                "variable": {
                    "value": "h",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.shape(tensors[DataKeys.IMAGES])[0]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "cast_95": {
                "variable": {
                    "value": "w",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.shape(tensors[DataKeys.IMAGES])[1]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "multiply_97": {
                "variable": {
                    "value": "newh",
                    "possible_values": []
                },
                "x": {
                    "value": "percentage",
                    "possible_values": [
                        [
                            "float(size[0]) / 100.0",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "h",
                    "possible_values": [
                        [
                            "tf.cast(tf.shape(tensors[DataKeys.IMAGES])[0], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.shape(tensors[DataKeys.IMAGES])[0], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(y1 - y0, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.shape(img)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(img)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "multiply_98": {
                "variable": {
                    "value": "neww",
                    "possible_values": []
                },
                "x": {
                    "value": "percentage",
                    "possible_values": [
                        [
                            "float(size[0]) / 100.0",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "w",
                    "possible_values": [
                        [
                            "tf.cast(tf.shape(tensors[DataKeys.IMAGES])[1], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.shape(tensors[DataKeys.IMAGES])[1], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(x1 - x0, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.shape(img)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(img)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "cast_100": {
                "variable": {
                    "value": "newh",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.round(newh)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "cast_101": {
                "variable": {
                    "value": "neww",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.round(neww)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "cast_112": {
                "variable": {
                    "value": "h",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.shape(tensors[DataKeys.IMAGES])[0]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "cast_113": {
                "variable": {
                    "value": "w",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.shape(tensors[DataKeys.IMAGES])[1]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "less_116": {
                "variable": {
                    "value": "less_val",
                    "possible_values": []
                },
                "x": {
                    "value": "h",
                    "possible_values": [
                        [
                            "tf.cast(tf.shape(tensors[DataKeys.IMAGES])[0], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.shape(tensors[DataKeys.IMAGES])[0], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(y1 - y0, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.shape(img)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(img)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "w",
                    "possible_values": [
                        [
                            "tf.cast(tf.shape(tensors[DataKeys.IMAGES])[1], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.shape(tensors[DataKeys.IMAGES])[1], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(x1 - x0, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.shape(img)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(img)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "where_117": {
                "variable": {
                    "value": "newh",
                    "possible_values": []
                },
                "condition": {
                    "value": "less_val",
                    "possible_values": [
                        [
                            "tf.less(h, w)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "min_short_edge",
                    "possible_values": [
                        [
                            "float(size[0])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.multiply(scale, h)",
                    "possible_values": []
                }
            },
            "where_118": {
                "variable": {
                    "value": "neww",
                    "possible_values": []
                },
                "condition": {
                    "value": "less_val",
                    "possible_values": [
                        [
                            "tf.less(h, w)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "tf.multiply(scale, w)",
                    "possible_values": []
                },
                "y": {
                    "value": "min_short_edge",
                    "possible_values": [
                        [
                            "float(size[0])",
                            "Call"
                        ]
                    ]
                }
            },
            "greater_121": {
                "variable": {
                    "value": "greater_val",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.maximum(newh, neww)",
                    "possible_values": []
                },
                "y": {
                    "value": "max_long_edge",
                    "possible_values": [
                        [
                            "float(size[1])",
                            "Call"
                        ]
                    ]
                }
            },
            "where_122": {
                "variable": {
                    "value": "newh",
                    "possible_values": []
                },
                "condition": {
                    "value": "greater_val",
                    "possible_values": [
                        [
                            "tf.greater(tf.maximum(newh, neww), max_long_edge)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "tf.multiply(scale, newh)",
                    "possible_values": []
                },
                "y": {
                    "value": "newh",
                    "possible_values": [
                        [
                            "tf.multiply(percentage, h)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(newh), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.where(less_val, min_short_edge, tf.multiply(scale, h))",
                            "Call"
                        ],
                        [
                            "tf.where(greater_val, tf.multiply(scale, newh), newh)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(newh), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_123": {
                "variable": {
                    "value": "neww",
                    "possible_values": []
                },
                "condition": {
                    "value": "greater_val",
                    "possible_values": [
                        [
                            "tf.greater(tf.maximum(newh, neww), max_long_edge)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "tf.multiply(scale, neww)",
                    "possible_values": []
                },
                "y": {
                    "value": "neww",
                    "possible_values": [
                        [
                            "tf.multiply(percentage, w)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(neww), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.where(less_val, tf.multiply(scale, w), min_short_edge)",
                            "Call"
                        ],
                        [
                            "tf.where(greater_val, tf.multiply(scale, neww), neww)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(neww), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_125": {
                "variable": {
                    "value": "newh",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.round(newh)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "cast_126": {
                "variable": {
                    "value": "neww",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.round(neww)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "cast_212": {
                "variable": {
                    "value": "object_locations",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(tf.not_equal(label, 0))[:, :2]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "maximum_213": {
                "variable": {
                    "value": "min_val",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.constant([0, 0])",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_max(object_locations, axis=0) - size",
                    "possible_values": []
                }
            },
            "concat_215": {
                "variable": {
                    "value": "offset",
                    "possible_values": []
                },
                "values": {
                    "value": "[min_val, [0]]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "cast_229": {
                "variable": {
                    "value": "bbox_rounded",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.round(bbox)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "unstack_230": {
                "variable": {
                    "value": "(y0, x0, y1, x1)",
                    "possible_values": []
                },
                "value": {
                    "value": "bbox_rounded",
                    "possible_values": [
                        [
                            "tf.cast(tf.round(bbox), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_233": {
                "variable": {
                    "value": "shape",
                    "possible_values": []
                },
                "input": {
                    "value": "tensors[DataKeys.IMAGES]",
                    "possible_values": []
                }
            },
            "maximum_234": {
                "variable": {
                    "value": "y0",
                    "possible_values": []
                },
                "x": {
                    "value": "y0 - MARGIN",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "maximum_235": {
                "variable": {
                    "value": "x0",
                    "possible_values": []
                },
                "x": {
                    "value": "x0 - MARGIN",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "minimum_236": {
                "variable": {
                    "value": "y1",
                    "possible_values": []
                },
                "x": {
                    "value": "y1 + MARGIN",
                    "possible_values": []
                },
                "y": {
                    "value": "shape[0]",
                    "possible_values": []
                }
            },
            "minimum_237": {
                "variable": {
                    "value": "x1",
                    "possible_values": []
                },
                "x": {
                    "value": "x1 + MARGIN",
                    "possible_values": []
                },
                "y": {
                    "value": "shape[1]",
                    "possible_values": []
                }
            },
            "stack_264": {
                "variable": {
                    "value": "tensors_cropped[DataKeys.CROP_BOXES_y0x0y1x1]",
                    "possible_values": []
                },
                "values": {
                    "value": "[y0, x0, y1, x1]",
                    "possible_values": []
                }
            },
            "minimum_293": {
                "variable": {
                    "value": "shorter_side",
                    "possible_values": []
                },
                "x": {
                    "value": "img_h",
                    "possible_values": [
                        [
                            "tf.shape(img)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "img_w",
                    "possible_values": [
                        [
                            "tf.shape(img)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "maximum_295": {
                "variable": {
                    "value": "min_scale",
                    "possible_values": []
                },
                "x": {
                    "value": "min_scale",
                    "possible_values": [
                        [
                            "tf.maximum(min_scale, min_scale_factor)",
                            "Call"
                        ],
                        [
                            "0.7",
                            "MethodArgument"
                        ],
                        [
                            "0.7",
                            "MethodArgument"
                        ],
                        [
                            "0.7",
                            "MethodArgument"
                        ]
                    ]
                },
                "y": {
                    "value": "min_scale_factor",
                    "possible_values": [
                        [
                            "tf.cast(min_size, tf.float32) / tf.cast(shorter_side, tf.float32)",
                            "BinOp"
                        ],
                        [
                            "tf.cast(min_size, tf.float32) / tf.cast(shorter_side, tf.float32)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "maximum_296": {
                "variable": {
                    "value": "max_scale",
                    "possible_values": []
                },
                "x": {
                    "value": "max_scale",
                    "possible_values": [
                        [
                            "tf.maximum(max_scale, min_scale_factor)",
                            "Call"
                        ],
                        [
                            "1.3",
                            "MethodArgument"
                        ],
                        [
                            "1.3",
                            "MethodArgument"
                        ],
                        [
                            "1.3",
                            "MethodArgument"
                        ]
                    ]
                },
                "y": {
                    "value": "min_scale_factor",
                    "possible_values": [
                        [
                            "tf.cast(min_size, tf.float32) / tf.cast(shorter_side, tf.float32)",
                            "BinOp"
                        ],
                        [
                            "tf.cast(min_size, tf.float32) / tf.cast(shorter_side, tf.float32)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "cast_298": {
                "x": {
                    "value": "[img_h, img_w]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "minimum_318": {
                "variable": {
                    "value": "shorter_side",
                    "possible_values": []
                },
                "x": {
                    "value": "h",
                    "possible_values": [
                        [
                            "tf.cast(tf.shape(tensors[DataKeys.IMAGES])[0], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.shape(tensors[DataKeys.IMAGES])[0], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(y1 - y0, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.shape(img)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(img)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "w",
                    "possible_values": [
                        [
                            "tf.cast(tf.shape(tensors[DataKeys.IMAGES])[1], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.shape(tensors[DataKeys.IMAGES])[1], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(x1 - x0, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.shape(img)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(img)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "cast_320": {
                "x": {
                    "value": "tf.shape(img)[:2]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "py_func_327": {
                "variable": {
                    "value": "laser",
                    "possible_values": []
                },
                "func": {
                    "value": "f",
                    "possible_values": [
                        [
                            "partial(resize_laser_to_fixed_size_np, size=size)",
                            "Call"
                        ]
                    ]
                },
                "inp": {
                    "value": "[laser]",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.float32",
                    "possible_values": []
                },
                "name": {
                    "value": "resize_laser_to_fixed_size",
                    "possible_values": []
                }
            },
            "unstack_269": {
                "variable": {
                    "value": "(x02, y02, x12, y12)",
                    "possible_values": []
                },
                "value": {
                    "value": "tensors[DataKeys.BBOXES_x0y0x1y1]",
                    "possible_values": []
                }
            },
            "cast_278": {
                "variable": {
                    "value": "h",
                    "possible_values": []
                },
                "x": {
                    "value": "y1 - y0",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "cast_279": {
                "variable": {
                    "value": "w",
                    "possible_values": []
                },
                "x": {
                    "value": "x1 - x0",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "stack_284": {
                "variable": {
                    "value": "tensors_cropped[DataKeys.BBOXES_x0y0x1y1]",
                    "possible_values": []
                },
                "values": {
                    "value": "[x0_new, y0_new, x1_new, y1_new]",
                    "possible_values": []
                }
            },
            "shape_55": {
                "input": {
                    "value": "tensors[DataKeys.IMAGES]",
                    "possible_values": []
                }
            },
            "round_100": {
                "x": {
                    "value": "newh",
                    "possible_values": [
                        [
                            "tf.multiply(percentage, h)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(newh), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.where(less_val, min_short_edge, tf.multiply(scale, h))",
                            "Call"
                        ],
                        [
                            "tf.where(greater_val, tf.multiply(scale, newh), newh)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(newh), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "round_101": {
                "x": {
                    "value": "neww",
                    "possible_values": [
                        [
                            "tf.multiply(percentage, w)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(neww), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.where(less_val, tf.multiply(scale, w), min_short_edge)",
                            "Call"
                        ],
                        [
                            "tf.where(greater_val, tf.multiply(scale, neww), neww)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(neww), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_103": {
                "values": {
                    "value": "[newh, neww]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "minimum_115": {
                "x": {
                    "value": "h",
                    "possible_values": [
                        [
                            "tf.cast(tf.shape(tensors[DataKeys.IMAGES])[0], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.shape(tensors[DataKeys.IMAGES])[0], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(y1 - y0, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.shape(img)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(img)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "w",
                    "possible_values": [
                        [
                            "tf.cast(tf.shape(tensors[DataKeys.IMAGES])[1], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.shape(tensors[DataKeys.IMAGES])[1], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(x1 - x0, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.shape(img)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(img)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "multiply_117": {
                "x": {
                    "value": "scale",
                    "possible_values": [
                        [
                            "min_short_edge * 1.0 / tf.minimum(h, w)",
                            "BinOp"
                        ],
                        [
                            "max_long_edge * 1.0 / tf.maximum(newh, neww)",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "h",
                    "possible_values": [
                        [
                            "tf.cast(tf.shape(tensors[DataKeys.IMAGES])[0], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.shape(tensors[DataKeys.IMAGES])[0], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(y1 - y0, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.shape(img)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(img)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "multiply_118": {
                "x": {
                    "value": "scale",
                    "possible_values": [
                        [
                            "min_short_edge * 1.0 / tf.minimum(h, w)",
                            "BinOp"
                        ],
                        [
                            "max_long_edge * 1.0 / tf.maximum(newh, neww)",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "w",
                    "possible_values": [
                        [
                            "tf.cast(tf.shape(tensors[DataKeys.IMAGES])[1], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.shape(tensors[DataKeys.IMAGES])[1], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(x1 - x0, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.shape(img)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(img)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "maximum_120": {
                "x": {
                    "value": "newh",
                    "possible_values": [
                        [
                            "tf.multiply(percentage, h)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(newh), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.where(less_val, min_short_edge, tf.multiply(scale, h))",
                            "Call"
                        ],
                        [
                            "tf.where(greater_val, tf.multiply(scale, newh), newh)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(newh), tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "neww",
                    "possible_values": [
                        [
                            "tf.multiply(percentage, w)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(neww), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.where(less_val, tf.multiply(scale, w), min_short_edge)",
                            "Call"
                        ],
                        [
                            "tf.where(greater_val, tf.multiply(scale, neww), neww)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(neww), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "maximum_121": {
                "x": {
                    "value": "newh",
                    "possible_values": [
                        [
                            "tf.multiply(percentage, h)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(newh), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.where(less_val, min_short_edge, tf.multiply(scale, h))",
                            "Call"
                        ],
                        [
                            "tf.where(greater_val, tf.multiply(scale, newh), newh)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(newh), tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "neww",
                    "possible_values": [
                        [
                            "tf.multiply(percentage, w)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(neww), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.where(less_val, tf.multiply(scale, w), min_short_edge)",
                            "Call"
                        ],
                        [
                            "tf.where(greater_val, tf.multiply(scale, neww), neww)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(neww), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_122": {
                "x": {
                    "value": "scale",
                    "possible_values": [
                        [
                            "min_short_edge * 1.0 / tf.minimum(h, w)",
                            "BinOp"
                        ],
                        [
                            "max_long_edge * 1.0 / tf.maximum(newh, neww)",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "newh",
                    "possible_values": [
                        [
                            "tf.multiply(percentage, h)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(newh), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.where(less_val, min_short_edge, tf.multiply(scale, h))",
                            "Call"
                        ],
                        [
                            "tf.where(greater_val, tf.multiply(scale, newh), newh)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(newh), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_123": {
                "x": {
                    "value": "scale",
                    "possible_values": [
                        [
                            "min_short_edge * 1.0 / tf.minimum(h, w)",
                            "BinOp"
                        ],
                        [
                            "max_long_edge * 1.0 / tf.maximum(newh, neww)",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "neww",
                    "possible_values": [
                        [
                            "tf.multiply(percentage, w)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(neww), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.where(less_val, tf.multiply(scale, w), min_short_edge)",
                            "Call"
                        ],
                        [
                            "tf.where(greater_val, tf.multiply(scale, neww), neww)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(neww), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "round_125": {
                "x": {
                    "value": "newh",
                    "possible_values": [
                        [
                            "tf.multiply(percentage, h)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(newh), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.where(less_val, min_short_edge, tf.multiply(scale, h))",
                            "Call"
                        ],
                        [
                            "tf.where(greater_val, tf.multiply(scale, newh), newh)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(newh), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "round_126": {
                "x": {
                    "value": "neww",
                    "possible_values": [
                        [
                            "tf.multiply(percentage, w)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(neww), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.where(less_val, tf.multiply(scale, w), min_short_edge)",
                            "Call"
                        ],
                        [
                            "tf.where(greater_val, tf.multiply(scale, neww), neww)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.round(neww), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_128": {
                "values": {
                    "value": "[newh, neww]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "shape_158": {
                "input": {
                    "value": "img",
                    "possible_values": [
                        [
                            "tensors_batch[0][DataKeys.IMAGES]",
                            "Subscript"
                        ],
                        [
                            "tensors[DataKeys.IMAGES]",
                            "Subscript"
                        ],
                        [
                            "tensors[DataKeys.IMAGES]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_159": {
                "input": {
                    "value": "img",
                    "possible_values": [
                        [
                            "tensors_batch[0][DataKeys.IMAGES]",
                            "Subscript"
                        ],
                        [
                            "tensors[DataKeys.IMAGES]",
                            "Subscript"
                        ],
                        [
                            "tensors[DataKeys.IMAGES]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "constant_213": {
                "value": {
                    "value": "[0, 0]",
                    "possible_values": []
                }
            },
            "round_229": {
                "x": {
                    "value": "bbox",
                    "possible_values": [
                        [
                            "tensors[DataKeys.BBOXES_y0x0y1x1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "cast_270": {
                "x": {
                    "value": "x0",
                    "possible_values": [
                        [
                            "tf.maximum(x0 - MARGIN, 0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "cast_271": {
                "x": {
                    "value": "x0",
                    "possible_values": [
                        [
                            "tf.maximum(x0 - MARGIN, 0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "cast_272": {
                "x": {
                    "value": "y0",
                    "possible_values": [
                        [
                            "tf.maximum(y0 - MARGIN, 0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "cast_273": {
                "x": {
                    "value": "y0",
                    "possible_values": [
                        [
                            "tf.maximum(y0 - MARGIN, 0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "cast_294": {
                "x": {
                    "value": "shorter_side",
                    "possible_values": [
                        [
                            "tf.minimum(img_h, img_w)",
                            "Call"
                        ],
                        [
                            "tf.minimum(h, w)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "round_298": {
                "x": {
                    "value": "tf.cast([img_h, img_w], tf.float32) * scale_factor",
                    "possible_values": []
                }
            },
            "shape_305": {
                "input": {
                    "value": "img",
                    "possible_values": [
                        [
                            "tensors_batch[0][DataKeys.IMAGES]",
                            "Subscript"
                        ],
                        [
                            "tensors[DataKeys.IMAGES]",
                            "Subscript"
                        ],
                        [
                            "tensors[DataKeys.IMAGES]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_306": {
                "input": {
                    "value": "img",
                    "possible_values": [
                        [
                            "tensors_batch[0][DataKeys.IMAGES]",
                            "Subscript"
                        ],
                        [
                            "tensors[DataKeys.IMAGES]",
                            "Subscript"
                        ],
                        [
                            "tensors[DataKeys.IMAGES]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_316": {
                "input": {
                    "value": "img",
                    "possible_values": [
                        [
                            "tensors_batch[0][DataKeys.IMAGES]",
                            "Subscript"
                        ],
                        [
                            "tensors[DataKeys.IMAGES]",
                            "Subscript"
                        ],
                        [
                            "tensors[DataKeys.IMAGES]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_317": {
                "input": {
                    "value": "img",
                    "possible_values": [
                        [
                            "tensors_batch[0][DataKeys.IMAGES]",
                            "Subscript"
                        ],
                        [
                            "tensors[DataKeys.IMAGES]",
                            "Subscript"
                        ],
                        [
                            "tensors[DataKeys.IMAGES]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "cast_319": {
                "x": {
                    "value": "shorter_side",
                    "possible_values": [
                        [
                            "tf.minimum(img_h, img_w)",
                            "Call"
                        ],
                        [
                            "tf.minimum(h, w)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "round_320": {
                "x": {
                    "value": "tf.cast(tf.shape(img)[:2], tf.float32) * min_scale_factor",
                    "possible_values": []
                }
            },
            "shape_94": {
                "input": {
                    "value": "tensors[DataKeys.IMAGES]",
                    "possible_values": []
                }
            },
            "shape_95": {
                "input": {
                    "value": "tensors[DataKeys.IMAGES]",
                    "possible_values": []
                }
            },
            "shape_112": {
                "input": {
                    "value": "tensors[DataKeys.IMAGES]",
                    "possible_values": []
                }
            },
            "shape_113": {
                "input": {
                    "value": "tensors[DataKeys.IMAGES]",
                    "possible_values": []
                }
            },
            "where_212": {
                "condition": {
                    "value": "tf.not_equal(label, 0)",
                    "possible_values": []
                }
            },
            "reduce_max_214": {
                "input_tensor": {
                    "value": "object_locations",
                    "possible_values": [
                        [
                            "tf.cast(tf.where(tf.not_equal(label, 0))[:, :2], tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "not_equal_212": {
                "x": {
                    "value": "label",
                    "possible_values": [
                        [
                            "tensors[DataKeys.SEGMENTATION_LABELS]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "shape_320": {
                "input": {
                    "value": "img",
                    "possible_values": [
                        [
                            "tensors_batch[0][DataKeys.IMAGES]",
                            "Subscript"
                        ],
                        [
                            "tensors[DataKeys.IMAGES]",
                            "Subscript"
                        ],
                        [
                            "tensors[DataKeys.IMAGES]",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "datasets/util/BoundingBox.py": {
        "tensorflow": {
            "cast_6": {
                "variable": {
                    "value": "object_locations",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(tf.equal(mask, 1))[:, :2]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "reduce_min_7": {
                "variable": {
                    "value": "y0",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "object_locations[:, 0]",
                    "possible_values": []
                }
            },
            "reduce_min_8": {
                "variable": {
                    "value": "x0",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "object_locations[:, 1]",
                    "possible_values": []
                }
            },
            "stack_11": {
                "variable": {
                    "value": "bbox",
                    "possible_values": []
                },
                "values": {
                    "value": "[y0, x0, y1, x1]",
                    "possible_values": []
                }
            },
            "py_func_36": {
                "variable": {
                    "value": "encoded",
                    "possible_values": []
                },
                "func": {
                    "value": "encode_bbox_as_mask_np",
                    "possible_values": []
                },
                "inp": {
                    "value": "[bbox, shape]",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.uint8",
                    "possible_values": []
                },
                "name": {
                    "value": "encode_bbox_as_mask",
                    "possible_values": []
                }
            },
            "reduce_max_9": {
                "input_tensor": {
                    "value": "object_locations[:, 0]",
                    "possible_values": []
                }
            },
            "reduce_max_10": {
                "input_tensor": {
                    "value": "object_locations[:, 1]",
                    "possible_values": []
                }
            },
            "where_6": {
                "condition": {
                    "value": "tf.equal(mask, 1)",
                    "possible_values": []
                }
            },
            "equal_6": {
                "x": {
                    "value": "mask",
                    "possible_values": []
                },
                "y": {
                    "value": "1",
                    "possible_values": []
                }
            }
        }
    },
    "datasets/util/Detection.py": {
        "tensorflow": {
            "split_314": {
                "variable": {
                    "value": "gt_boxes",
                    "possible_values": []
                },
                "value": {
                    "value": "return_dict[DataKeys.BBOXES_y0x0y1x1]",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "4",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "concat_315": {
                "variable": {
                    "value": "gt_boxes_xyxy",
                    "possible_values": []
                },
                "values": {
                    "value": "[gt_boxes[1], gt_boxes[0], gt_boxes[3], gt_boxes[2]]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "shape_318": {
                "variable": {
                    "value": "img_shape",
                    "possible_values": []
                },
                "input": {
                    "value": "return_dict[DataKeys.IMAGES]",
                    "possible_values": []
                }
            },
            "py_func_325": {
                "variable": {
                    "value": "(fm_labels, fm_boxes, invalid_bgfg)",
                    "possible_values": []
                },
                "func": {
                    "value": "get_rpn_anchor_input_part",
                    "possible_values": [
                        [
                            "partial(get_rpn_anchor_input, prefer_gt_to_ignore=prefer_gt_to_ignore, use_ioa_for_ignore=use_ioa_for_ignore, use_masks_for_ignore=use_masks_for_ignore)",
                            "Call"
                        ]
                    ]
                },
                "inp": {
                    "value": "[gt_boxes_xyxy, return_dict[DataKeys.IDS], return_dict[DataKeys.IS_CROWD], img_shape[0], img_shape[1], masks]",
                    "possible_values": []
                },
                "Tout": {
                    "value": "[tf.int32, tf.float32, tf.bool]",
                    "possible_values": []
                },
                "name": {
                    "value": "get_rpn_anchor_input",
                    "possible_values": []
                }
            }
        }
    },
    "datasets/util/Util.py": {
        "tensorflow": {
            "cast_50": {
                "variable": {
                    "value": "original_width_f",
                    "possible_values": []
                },
                "x": {
                    "value": "original_width",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tensor.dtype",
                    "possible_values": []
                }
            },
            "cast_56": {
                "variable": {
                    "value": "original_width_f",
                    "possible_values": []
                },
                "x": {
                    "value": "original_width",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tensor.dtype",
                    "possible_values": []
                }
            },
            "shape_63": {
                "variable": {
                    "value": "shape",
                    "possible_values": []
                },
                "input": {
                    "value": "img",
                    "possible_values": [
                        [
                            "tf.image.resize_images(img, out_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_nearest_neighbor(tf.expand_dims(img, 0), out_size)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(img, 0)",
                            "Call"
                        ],
                        [
                            "images[idx]",
                            "Subscript"
                        ],
                        [
                            "img[np.newaxis, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.image.hsv_to_rgb(hsv) * 255",
                            "BinOp"
                        ],
                        [
                            "tf.image.hsv_to_rgb(hsv) * 255",
                            "BinOp"
                        ],
                        [
                            "occurrences * 255",
                            "BinOp"
                        ]
                    ]
                }
            },
            "stack_74": {
                "variable": {
                    "value": "size_im",
                    "possible_values": []
                },
                "values": {
                    "value": "[size[0], size[1], img.get_shape().as_list()[2]]",
                    "possible_values": []
                }
            },
            "slice_75": {
                "variable": {
                    "value": "img_cropped",
                    "possible_values": []
                },
                "input_": {
                    "value": "img",
                    "possible_values": [
                        [
                            "tf.image.resize_images(img, out_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_nearest_neighbor(tf.expand_dims(img, 0), out_size)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(img, 0)",
                            "Call"
                        ],
                        [
                            "images[idx]",
                            "Subscript"
                        ],
                        [
                            "img[np.newaxis, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.image.hsv_to_rgb(hsv) * 255",
                            "BinOp"
                        ],
                        [
                            "tf.image.hsv_to_rgb(hsv) * 255",
                            "BinOp"
                        ],
                        [
                            "occurrences * 255",
                            "BinOp"
                        ]
                    ]
                },
                "begin": {
                    "value": "offset",
                    "possible_values": [
                        [
                            "get_crop_offset(shape, size)",
                            "Call"
                        ],
                        [
                            "tf.random_uniform(shape=(2,), dtype=dtype, maxval=dtype.max, seed=None) % limit",
                            "BinOp"
                        ],
                        [
                            "tf.stack([offset[0], offset[1], 0])",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "size": {
                    "value": "size_im",
                    "possible_values": [
                        [
                            "tf.stack([size[0], size[1], img.get_shape().as_list()[2]])",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_85": {
                "variable": {
                    "value": "offset",
                    "possible_values": []
                },
                "values": {
                    "value": "[offset[0], offset[1], 0]",
                    "possible_values": []
                }
            },
            "sqrt_260": {
                "variable": {
                    "value": "flow_magnitude",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.add(tf.square(x), tf.square(y))",
                    "possible_values": []
                }
            },
            "atan2_261": {
                "variable": {
                    "value": "flow_angle",
                    "possible_values": []
                },
                "y": {
                    "value": "y",
                    "possible_values": [
                        [
                            "offsets[..., 1]",
                            "Subscript"
                        ]
                    ]
                },
                "x": {
                    "value": "x",
                    "possible_values": [
                        [
                            "offsets[..., 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "ones_like_268": {
                "variable": {
                    "value": "s",
                    "possible_values": []
                },
                "input": {
                    "value": "h",
                    "possible_values": [
                        [
                            "normalize(tf.multiply(flow_angle, 180.0 / np.pi))",
                            "Call"
                        ],
                        [
                            "tf.cast(offsets, dtype=tf.float32) / batch_size_f",
                            "BinOp"
                        ]
                    ]
                }
            },
            "stack_270": {
                "variable": {
                    "value": "hsv",
                    "possible_values": []
                },
                "values": {
                    "value": "[h, s, v]",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "cast_277": {
                "variable": {
                    "value": "batch_size_f",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.shape(offsets)[0]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "ones_like_279": {
                "variable": {
                    "value": "sv",
                    "possible_values": []
                },
                "input": {
                    "value": "h",
                    "possible_values": [
                        [
                            "normalize(tf.multiply(flow_angle, 180.0 / np.pi))",
                            "Call"
                        ],
                        [
                            "tf.cast(offsets, dtype=tf.float32) / batch_size_f",
                            "BinOp"
                        ]
                    ]
                }
            },
            "concat_280": {
                "variable": {
                    "value": "hsv",
                    "possible_values": []
                },
                "values": {
                    "value": "[h, sv, sv]",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "resize_nearest_neighbor_28": {
                "variable": {
                    "value": "img",
                    "possible_values": []
                },
                "images": {
                    "value": "tf.expand_dims(img, 0)",
                    "possible_values": []
                },
                "size": {
                    "value": "out_size",
                    "possible_values": []
                }
            },
            "squeeze_29": {
                "variable": {
                    "value": "img",
                    "possible_values": []
                },
                "input": {
                    "value": "img",
                    "possible_values": [
                        [
                            "tf.image.resize_images(img, out_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_nearest_neighbor(tf.expand_dims(img, 0), out_size)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(img, 0)",
                            "Call"
                        ],
                        [
                            "images[idx]",
                            "Subscript"
                        ],
                        [
                            "img[np.newaxis, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.image.hsv_to_rgb(hsv) * 255",
                            "BinOp"
                        ],
                        [
                            "tf.image.hsv_to_rgb(hsv) * 255",
                            "BinOp"
                        ],
                        [
                            "occurrences * 255",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "stack_51": {
                "values": {
                    "value": "[tensor[..., 0], original_width_f - tensor[..., 3], tensor[..., 2], original_width_f - tensor[..., 1]]",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "stack_57": {
                "values": {
                    "value": "[original_width_f - tensor[..., 2], tensor[..., 1], original_width_f - tensor[..., 0], tensor[..., 3]]",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "cast_272": {
                "x": {
                    "value": "img",
                    "possible_values": [
                        [
                            "tf.image.resize_images(img, out_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_nearest_neighbor(tf.expand_dims(img, 0), out_size)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(img, 0)",
                            "Call"
                        ],
                        [
                            "images[idx]",
                            "Subscript"
                        ],
                        [
                            "img[np.newaxis, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.image.hsv_to_rgb(hsv) * 255",
                            "BinOp"
                        ],
                        [
                            "tf.image.hsv_to_rgb(hsv) * 255",
                            "BinOp"
                        ],
                        [
                            "occurrences * 255",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.uint8",
                    "possible_values": []
                }
            },
            "cast_282": {
                "x": {
                    "value": "img",
                    "possible_values": [
                        [
                            "tf.image.resize_images(img, out_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_nearest_neighbor(tf.expand_dims(img, 0), out_size)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(img, 0)",
                            "Call"
                        ],
                        [
                            "images[idx]",
                            "Subscript"
                        ],
                        [
                            "img[np.newaxis, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.image.hsv_to_rgb(hsv) * 255",
                            "BinOp"
                        ],
                        [
                            "tf.image.hsv_to_rgb(hsv) * 255",
                            "BinOp"
                        ],
                        [
                            "occurrences * 255",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.uint8",
                    "possible_values": []
                }
            },
            "cast_288": {
                "x": {
                    "value": "img",
                    "possible_values": [
                        [
                            "tf.image.resize_images(img, out_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_nearest_neighbor(tf.expand_dims(img, 0), out_size)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(img, 0)",
                            "Call"
                        ],
                        [
                            "images[idx]",
                            "Subscript"
                        ],
                        [
                            "img[np.newaxis, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.image.hsv_to_rgb(hsv) * 255",
                            "BinOp"
                        ],
                        [
                            "tf.image.hsv_to_rgb(hsv) * 255",
                            "BinOp"
                        ],
                        [
                            "occurrences * 255",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.uint8",
                    "possible_values": []
                }
            },
            "ones_34": {
                "shape": {
                    "value": "[tf.shape(tensor)[0], 1]",
                    "possible_values": []
                }
            },
            "cast_34": {
                "x": {
                    "value": "out_size[0] / original_size[0]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "ones_35": {
                "shape": {
                    "value": "[tf.shape(tensor)[0], 1]",
                    "possible_values": []
                }
            },
            "cast_35": {
                "x": {
                    "value": "out_size[1] / original_size[1]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "cast_37": {
                "x": {
                    "value": "tensor",
                    "possible_values": [
                        [
                            "tf.cast(tensor, tf.float32) * tf.concat([y_ratio, x_ratio, y_ratio, x_ratio], axis=1)",
                            "BinOp"
                        ],
                        [
                            "tf.cast(tensor, tf.float32) * tf.stack([x_ratio, y_ratio])",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "concat_37": {
                "values": {
                    "value": "[y_ratio, x_ratio, y_ratio, x_ratio]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "cast_42": {
                "x": {
                    "value": "original_size[0]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "cast_43": {
                "x": {
                    "value": "original_size[1]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "cast_45": {
                "x": {
                    "value": "tensor",
                    "possible_values": [
                        [
                            "tf.cast(tensor, tf.float32) * tf.concat([y_ratio, x_ratio, y_ratio, x_ratio], axis=1)",
                            "BinOp"
                        ],
                        [
                            "tf.cast(tensor, tf.float32) * tf.stack([x_ratio, y_ratio])",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "stack_45": {
                "values": {
                    "value": "[x_ratio, y_ratio]",
                    "possible_values": []
                }
            },
            "div_255": {
                "x": {
                    "value": "tf.multiply(tf.subtract(tensor, tf.reduce_min(tensor)), b - a)",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.subtract(tf.reduce_max(tensor), tf.reduce_min(tensor))",
                    "possible_values": []
                }
            },
            "add_260": {
                "x": {
                    "value": "tf.square(x)",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.square(y)",
                    "possible_values": []
                }
            },
            "multiply_264": {
                "x": {
                    "value": "flow_angle",
                    "possible_values": [
                        [
                            "tf.math.atan2(y, x)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "180.0 / np.pi",
                    "possible_values": []
                }
            },
            "hsv_to_rgb_271": {
                "images": {
                    "value": "hsv",
                    "possible_values": [
                        [
                            "tf.stack([h, s, v], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([h, sv, sv], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_278": {
                "x": {
                    "value": "offsets",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "hsv_to_rgb_281": {
                "images": {
                    "value": "hsv",
                    "possible_values": [
                        [
                            "tf.stack([h, s, v], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([h, sv, sv], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_28": {
                "input": {
                    "value": "img",
                    "possible_values": [
                        [
                            "tf.image.resize_images(img, out_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_nearest_neighbor(tf.expand_dims(img, 0), out_size)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(img, 0)",
                            "Call"
                        ],
                        [
                            "images[idx]",
                            "Subscript"
                        ],
                        [
                            "img[np.newaxis, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.image.hsv_to_rgb(hsv) * 255",
                            "BinOp"
                        ],
                        [
                            "tf.image.hsv_to_rgb(hsv) * 255",
                            "BinOp"
                        ],
                        [
                            "occurrences * 255",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "multiply_255": {
                "x": {
                    "value": "tf.subtract(tensor, tf.reduce_min(tensor))",
                    "possible_values": []
                },
                "y": {
                    "value": "b - a",
                    "possible_values": []
                }
            },
            "subtract_256": {
                "x": {
                    "value": "tf.reduce_max(tensor)",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_min(tensor)",
                    "possible_values": []
                }
            },
            "square_260": {
                "x": {
                    "value": "y",
                    "possible_values": [
                        [
                            "offsets[..., 1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_277": {
                "input": {
                    "value": "offsets",
                    "possible_values": []
                }
            },
            "subtract_255": {
                "x": {
                    "value": "tensor",
                    "possible_values": [
                        [
                            "tf.cast(tensor, tf.float32) * tf.concat([y_ratio, x_ratio, y_ratio, x_ratio], axis=1)",
                            "BinOp"
                        ],
                        [
                            "tf.cast(tensor, tf.float32) * tf.stack([x_ratio, y_ratio])",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.reduce_min(tensor)",
                    "possible_values": []
                }
            },
            "reduce_max_256": {
                "input_tensor": {
                    "value": "tensor",
                    "possible_values": [
                        [
                            "tf.cast(tensor, tf.float32) * tf.concat([y_ratio, x_ratio, y_ratio, x_ratio], axis=1)",
                            "BinOp"
                        ],
                        [
                            "tf.cast(tensor, tf.float32) * tf.stack([x_ratio, y_ratio])",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_min_256": {
                "input_tensor": {
                    "value": "tensor",
                    "possible_values": [
                        [
                            "tf.cast(tensor, tf.float32) * tf.concat([y_ratio, x_ratio, y_ratio, x_ratio], axis=1)",
                            "BinOp"
                        ],
                        [
                            "tf.cast(tensor, tf.float32) * tf.stack([x_ratio, y_ratio])",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_34": {
                "input": {
                    "value": "tensor",
                    "possible_values": [
                        [
                            "tf.cast(tensor, tf.float32) * tf.concat([y_ratio, x_ratio, y_ratio, x_ratio], axis=1)",
                            "BinOp"
                        ],
                        [
                            "tf.cast(tensor, tf.float32) * tf.stack([x_ratio, y_ratio])",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_35": {
                "input": {
                    "value": "tensor",
                    "possible_values": [
                        [
                            "tf.cast(tensor, tf.float32) * tf.concat([y_ratio, x_ratio, y_ratio, x_ratio], axis=1)",
                            "BinOp"
                        ],
                        [
                            "tf.cast(tensor, tf.float32) * tf.stack([x_ratio, y_ratio])",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_min_255": {
                "input_tensor": {
                    "value": "tensor",
                    "possible_values": [
                        [
                            "tf.cast(tensor, tf.float32) * tf.concat([y_ratio, x_ratio, y_ratio, x_ratio], axis=1)",
                            "BinOp"
                        ],
                        [
                            "tf.cast(tensor, tf.float32) * tf.stack([x_ratio, y_ratio])",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "forwarding/BboxDetectionRefinementForwarder.py": {
        "tensorflow": {
            "MakeDirs_19": {
                "dirname": {
                    "value": "out_folder",
                    "possible_values": [
                        [
                            "'forwarded/' + self.model_name + '/detection_bbox_refined/'",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "forwarding/BboxRefinementForwarder.py": {
        "tensorflow": {
            "MakeDirs_20": {
                "dirname": {
                    "value": "out_folder",
                    "possible_values": [
                        [
                            "'forwarded/' + self.model_name + '/tracking_data_bbox_refined/'",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "forwarding/RecurrentDetectionForwarder.py": {
        "tensorflow": {
            "MakeDirs_113": {
                "dirname": {
                    "value": "out_folder + 'pred_list/'",
                    "possible_values": []
                }
            },
            "MakeDirs_114": {
                "dirname": {
                    "value": "out_folder + 'pred_img/'",
                    "possible_values": []
                }
            },
            "MakeDirs_82": {
                "dirname": {
                    "value": "out_folder",
                    "possible_values": [
                        [
                            "'forwarded/' + self.config.string('model') + '/seg_data/'",
                            "BinOp"
                        ],
                        [
                            "'forwarded/' + self.config.string('model') + '/vis/' + tag",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "main.py": {
        "tensorflow": {
            "run_39": {
                "main": {
                    "value": "main",
                    "possible_values": []
                }
            }
        }
    },
    "network/ConvolutionalLayers.py": {
        "tensorflow": {
            "resize_nearest_neighbor_192": {
                "variable": {
                    "value": "curr",
                    "possible_values": []
                },
                "images": {
                    "value": "curr",
                    "possible_values": [
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, W, dilation, padding=padding)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features_inp, batch_norm_decay, tower_setup, freeze_batchnorm_override=freeze_batchnorm_override)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, W, dilation, padding=padding)",
                            "Call"
                        ],
                        [
                            "curr + b",
                            "BinOp"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features, batch_norm_decay, tower_setup, freeze_batchnorm_override=freeze_batchnorm_override)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "max_pool(curr, pool_size, pool_strides)",
                            "Call"
                        ],
                        [
                            "conv2d_transpose(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(curr, b)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features, batch_norm_decay, tower_setup, freeze_batchnorm_override=freeze_batchnorm_override)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features_inp, batch_norm_decay, tower_setup, 'bn0')",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W1, strides[0])",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, W1, dilations[0])",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features[idx - 1], batch_norm_decay, tower_setup, 'bn' + str(idx + 1))",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, Wi, strides[idx])",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, Wi, dilations[idx])",
                            "Call"
                        ],
                        [
                            "tf.image.resize_nearest_neighbor(curr, tf.shape(concat_inp)[1:3])",
                            "Call"
                        ],
                        [
                            "tf.concat([curr, concat_inp], axis=3)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W) + b",
                            "BinOp"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(curr, axis=0)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features_inp, batch_norm_decay, tower_setup)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features, batch_norm_decay, tower_setup)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "max_pool3d(curr, pool_size, pool_strides)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(curr, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(curr, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat(curr_split, axis=-1)",
                            "Call"
                        ],
                        [
                            "curr_split[channel]",
                            "Subscript"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "max_pool3d(curr, pool_size, pool_strides)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(curr, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "tf.shape(concat_inp)[1:3]",
                    "possible_values": []
                }
            },
            "concat_193": {
                "variable": {
                    "value": "curr",
                    "possible_values": []
                },
                "values": {
                    "value": "[curr, concat_inp]",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "possible_values": []
                }
            },
            "expand_dims_224": {
                "variable": {
                    "value": "curr",
                    "possible_values": []
                },
                "input": {
                    "value": "curr",
                    "possible_values": [
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, W, dilation, padding=padding)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features_inp, batch_norm_decay, tower_setup, freeze_batchnorm_override=freeze_batchnorm_override)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, W, dilation, padding=padding)",
                            "Call"
                        ],
                        [
                            "curr + b",
                            "BinOp"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features, batch_norm_decay, tower_setup, freeze_batchnorm_override=freeze_batchnorm_override)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "max_pool(curr, pool_size, pool_strides)",
                            "Call"
                        ],
                        [
                            "conv2d_transpose(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(curr, b)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features, batch_norm_decay, tower_setup, freeze_batchnorm_override=freeze_batchnorm_override)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features_inp, batch_norm_decay, tower_setup, 'bn0')",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W1, strides[0])",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, W1, dilations[0])",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features[idx - 1], batch_norm_decay, tower_setup, 'bn' + str(idx + 1))",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, Wi, strides[idx])",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, Wi, dilations[idx])",
                            "Call"
                        ],
                        [
                            "tf.image.resize_nearest_neighbor(curr, tf.shape(concat_inp)[1:3])",
                            "Call"
                        ],
                        [
                            "tf.concat([curr, concat_inp], axis=3)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W) + b",
                            "BinOp"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(curr, axis=0)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features_inp, batch_norm_decay, tower_setup)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features, batch_norm_decay, tower_setup)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "max_pool3d(curr, pool_size, pool_strides)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(curr, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(curr, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat(curr_split, axis=-1)",
                            "Call"
                        ],
                        [
                            "curr_split[channel]",
                            "Subscript"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "max_pool3d(curr, pool_size, pool_strides)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(curr, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "squeeze_270": {
                "variable": {
                    "value": "curr",
                    "possible_values": []
                },
                "input": {
                    "value": "curr",
                    "possible_values": [
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, W, dilation, padding=padding)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features_inp, batch_norm_decay, tower_setup, freeze_batchnorm_override=freeze_batchnorm_override)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, W, dilation, padding=padding)",
                            "Call"
                        ],
                        [
                            "curr + b",
                            "BinOp"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features, batch_norm_decay, tower_setup, freeze_batchnorm_override=freeze_batchnorm_override)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "max_pool(curr, pool_size, pool_strides)",
                            "Call"
                        ],
                        [
                            "conv2d_transpose(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(curr, b)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features, batch_norm_decay, tower_setup, freeze_batchnorm_override=freeze_batchnorm_override)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features_inp, batch_norm_decay, tower_setup, 'bn0')",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W1, strides[0])",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, W1, dilations[0])",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features[idx - 1], batch_norm_decay, tower_setup, 'bn' + str(idx + 1))",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, Wi, strides[idx])",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, Wi, dilations[idx])",
                            "Call"
                        ],
                        [
                            "tf.image.resize_nearest_neighbor(curr, tf.shape(concat_inp)[1:3])",
                            "Call"
                        ],
                        [
                            "tf.concat([curr, concat_inp], axis=3)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W) + b",
                            "BinOp"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(curr, axis=0)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features_inp, batch_norm_decay, tower_setup)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features, batch_norm_decay, tower_setup)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "max_pool3d(curr, pool_size, pool_strides)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(curr, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(curr, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat(curr_split, axis=-1)",
                            "Call"
                        ],
                        [
                            "curr_split[channel]",
                            "Subscript"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "max_pool3d(curr, pool_size, pool_strides)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(curr, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "expand_dims_298": {
                "variable": {
                    "value": "curr",
                    "possible_values": []
                },
                "input": {
                    "value": "curr",
                    "possible_values": [
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, W, dilation, padding=padding)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features_inp, batch_norm_decay, tower_setup, freeze_batchnorm_override=freeze_batchnorm_override)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, W, dilation, padding=padding)",
                            "Call"
                        ],
                        [
                            "curr + b",
                            "BinOp"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features, batch_norm_decay, tower_setup, freeze_batchnorm_override=freeze_batchnorm_override)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "max_pool(curr, pool_size, pool_strides)",
                            "Call"
                        ],
                        [
                            "conv2d_transpose(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(curr, b)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features, batch_norm_decay, tower_setup, freeze_batchnorm_override=freeze_batchnorm_override)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features_inp, batch_norm_decay, tower_setup, 'bn0')",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W1, strides[0])",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, W1, dilations[0])",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features[idx - 1], batch_norm_decay, tower_setup, 'bn' + str(idx + 1))",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, Wi, strides[idx])",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, Wi, dilations[idx])",
                            "Call"
                        ],
                        [
                            "tf.image.resize_nearest_neighbor(curr, tf.shape(concat_inp)[1:3])",
                            "Call"
                        ],
                        [
                            "tf.concat([curr, concat_inp], axis=3)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W) + b",
                            "BinOp"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(curr, axis=0)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features_inp, batch_norm_decay, tower_setup)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features, batch_norm_decay, tower_setup)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "max_pool3d(curr, pool_size, pool_strides)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(curr, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(curr, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat(curr_split, axis=-1)",
                            "Call"
                        ],
                        [
                            "curr_split[channel]",
                            "Subscript"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "max_pool3d(curr, pool_size, pool_strides)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(curr, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "squeeze_349": {
                "variable": {
                    "value": "curr",
                    "possible_values": []
                },
                "input": {
                    "value": "curr",
                    "possible_values": [
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, W, dilation, padding=padding)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features_inp, batch_norm_decay, tower_setup, freeze_batchnorm_override=freeze_batchnorm_override)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, W, dilation, padding=padding)",
                            "Call"
                        ],
                        [
                            "curr + b",
                            "BinOp"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features, batch_norm_decay, tower_setup, freeze_batchnorm_override=freeze_batchnorm_override)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "max_pool(curr, pool_size, pool_strides)",
                            "Call"
                        ],
                        [
                            "conv2d_transpose(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(curr, b)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features, batch_norm_decay, tower_setup, freeze_batchnorm_override=freeze_batchnorm_override)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features_inp, batch_norm_decay, tower_setup, 'bn0')",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W1, strides[0])",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, W1, dilations[0])",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features[idx - 1], batch_norm_decay, tower_setup, 'bn' + str(idx + 1))",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, Wi, strides[idx])",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, Wi, dilations[idx])",
                            "Call"
                        ],
                        [
                            "tf.image.resize_nearest_neighbor(curr, tf.shape(concat_inp)[1:3])",
                            "Call"
                        ],
                        [
                            "tf.concat([curr, concat_inp], axis=3)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W) + b",
                            "BinOp"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(curr, axis=0)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features_inp, batch_norm_decay, tower_setup)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features, batch_norm_decay, tower_setup)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "max_pool3d(curr, pool_size, pool_strides)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(curr, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(curr, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat(curr_split, axis=-1)",
                            "Call"
                        ],
                        [
                            "curr_split[channel]",
                            "Subscript"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "max_pool3d(curr, pool_size, pool_strides)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(curr, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "reduce_mean_359": {
                "variable": {
                    "value": "out",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inp",
                    "possible_values": [
                        [
                            "get_activation(input_activation)(inp)",
                            "Call"
                        ],
                        [
                            "apply_dropout(inp, dropout)",
                            "Call"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "possible_values": []
                }
            },
            "split_302": {
                "variable": {
                    "value": "curr_split",
                    "possible_values": []
                },
                "value": {
                    "value": "curr",
                    "possible_values": [
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, W, dilation, padding=padding)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features_inp, batch_norm_decay, tower_setup, freeze_batchnorm_override=freeze_batchnorm_override)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, W, dilation, padding=padding)",
                            "Call"
                        ],
                        [
                            "curr + b",
                            "BinOp"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features, batch_norm_decay, tower_setup, freeze_batchnorm_override=freeze_batchnorm_override)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "max_pool(curr, pool_size, pool_strides)",
                            "Call"
                        ],
                        [
                            "conv2d_transpose(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(curr, b)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features, batch_norm_decay, tower_setup, freeze_batchnorm_override=freeze_batchnorm_override)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features_inp, batch_norm_decay, tower_setup, 'bn0')",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W1, strides[0])",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, W1, dilations[0])",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features[idx - 1], batch_norm_decay, tower_setup, 'bn' + str(idx + 1))",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, Wi, strides[idx])",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, Wi, dilations[idx])",
                            "Call"
                        ],
                        [
                            "tf.image.resize_nearest_neighbor(curr, tf.shape(concat_inp)[1:3])",
                            "Call"
                        ],
                        [
                            "tf.concat([curr, concat_inp], axis=3)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W) + b",
                            "BinOp"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(curr, axis=0)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features_inp, batch_norm_decay, tower_setup)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features, batch_norm_decay, tower_setup)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "max_pool3d(curr, pool_size, pool_strides)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(curr, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(curr, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat(curr_split, axis=-1)",
                            "Call"
                        ],
                        [
                            "curr_split[channel]",
                            "Subscript"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "max_pool3d(curr, pool_size, pool_strides)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(curr, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "n_features_inp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "concat_327": {
                "variable": {
                    "value": "curr",
                    "possible_values": []
                },
                "values": {
                    "value": "curr_split",
                    "possible_values": [
                        [
                            "tf.split(curr, n_features_inp, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "reshape_370": {
                "variable": {
                    "value": "out",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inp",
                    "possible_values": [
                        [
                            "get_activation(input_activation)(inp)",
                            "Call"
                        ],
                        [
                            "apply_dropout(inp, dropout)",
                            "Call"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, out_dim]",
                    "possible_values": []
                }
            },
            "reshape_372": {
                "variable": {
                    "value": "out",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inp",
                    "possible_values": [
                        [
                            "get_activation(input_activation)(inp)",
                            "Call"
                        ],
                        [
                            "apply_dropout(inp, dropout)",
                            "Call"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "[tf.shape(inp)[0], -1]",
                    "possible_values": []
                }
            },
            "variable_scope_27": {
                "name_or_scope": {
                    "value": "name",
                    "possible_values": []
                }
            },
            "constant_initializer_29": {
                "variable": {
                    "value": "W_initializer",
                    "possible_values": []
                },
                "value": {
                    "value": "W_initializer",
                    "possible_values": [
                        [
                            "tf.constant_initializer(W_initializer)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_81": {
                "name_or_scope": {
                    "value": "name",
                    "possible_values": []
                }
            },
            "bias_add_91": {
                "variable": {
                    "value": "curr",
                    "possible_values": []
                },
                "value": {
                    "value": "curr",
                    "possible_values": [
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, W, dilation, padding=padding)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features_inp, batch_norm_decay, tower_setup, freeze_batchnorm_override=freeze_batchnorm_override)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, W, dilation, padding=padding)",
                            "Call"
                        ],
                        [
                            "curr + b",
                            "BinOp"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features, batch_norm_decay, tower_setup, freeze_batchnorm_override=freeze_batchnorm_override)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "max_pool(curr, pool_size, pool_strides)",
                            "Call"
                        ],
                        [
                            "conv2d_transpose(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(curr, b)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features, batch_norm_decay, tower_setup, freeze_batchnorm_override=freeze_batchnorm_override)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features_inp, batch_norm_decay, tower_setup, 'bn0')",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W1, strides[0])",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, W1, dilations[0])",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features[idx - 1], batch_norm_decay, tower_setup, 'bn' + str(idx + 1))",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, Wi, strides[idx])",
                            "Call"
                        ],
                        [
                            "conv2d_dilated(curr, Wi, dilations[idx])",
                            "Call"
                        ],
                        [
                            "tf.image.resize_nearest_neighbor(curr, tf.shape(concat_inp)[1:3])",
                            "Call"
                        ],
                        [
                            "tf.concat([curr, concat_inp], axis=3)",
                            "Call"
                        ],
                        [
                            "conv2d(curr, W) + b",
                            "BinOp"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(curr, axis=0)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features_inp, batch_norm_decay, tower_setup)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "apply_dropout(curr, dropout)",
                            "Call"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(curr, n_features, batch_norm_decay, tower_setup)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "max_pool3d(curr, pool_size, pool_strides)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(curr, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(curr, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat(curr_split, axis=-1)",
                            "Call"
                        ],
                        [
                            "curr_split[channel]",
                            "Subscript"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "conv3d(curr, W, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "get_activation(activation)(curr)",
                            "Call"
                        ],
                        [
                            "max_pool3d(curr, pool_size, pool_strides)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(curr, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "b",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "self.create_bias_variable('b', [n_features], tower_setup, initializer=b_initializer)",
                            "Call"
                        ],
                        [
                            "self.create_bias_variable('b', [n_features], tower_setup)",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "self.create_bias_variable('b', [n_features], tower_setup)",
                            "Call"
                        ],
                        [
                            "self.create_bias_variable('b', [n_features], tower_setup)",
                            "Call"
                        ],
                        [
                            "self.create_bias_variable('b', [n_features], tower_setup)",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "self.create_bias_variable('b', [n_features], tower_setup)",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "self.create_bias_variable('b', [n_features], tower_setup)",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "self.create_bias_variable('b', [n_features], tower_setup)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_113": {
                "name_or_scope": {
                    "value": "name",
                    "possible_values": []
                }
            },
            "variable_scope_145": {
                "name_or_scope": {
                    "value": "name",
                    "possible_values": []
                }
            },
            "variable_scope_196": {
                "name_or_scope": {
                    "value": "name",
                    "possible_values": []
                }
            },
            "variable_scope_226": {
                "name_or_scope": {
                    "value": "name",
                    "possible_values": []
                }
            },
            "variable_scope_300": {
                "name_or_scope": {
                    "value": "name",
                    "possible_values": []
                }
            },
            "constant_initializer_35": {
                "variable": {
                    "value": "b_initializer",
                    "possible_values": []
                },
                "value": {
                    "value": "b_initializer",
                    "possible_values": [
                        [
                            "tf.constant_initializer(b_initializer)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "shape_192": {
                "input": {
                    "value": "concat_inp",
                    "possible_values": []
                }
            },
            "variable_scope_314": {
                "name_or_scope": {
                    "value": "'channel_' + str(channel)",
                    "possible_values": []
                }
            },
            "shape_372": {
                "input": {
                    "value": "inp",
                    "possible_values": [
                        [
                            "get_activation(input_activation)(inp)",
                            "Call"
                        ],
                        [
                            "apply_dropout(inp, dropout)",
                            "Call"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "network/FasterRCNN.py": {
        "tensorflow": {
            "constant_505": {
                "variable": {
                    "value": "reid_loss",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "possible_values": []
                }
            },
            "constant_506": {
                "variable": {
                    "value": "normalization",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "equal_549": {
                "variable": {
                    "value": "id_mask_axis_0",
                    "possible_values": []
                },
                "x": {
                    "value": "target_ids_axis_0",
                    "possible_values": []
                },
                "y": {
                    "value": "id_",
                    "possible_values": []
                }
            },
            "equal_550": {
                "variable": {
                    "value": "id_mask_axis_1",
                    "possible_values": []
                },
                "x": {
                    "value": "target_ids_axis_1",
                    "possible_values": []
                },
                "y": {
                    "value": "id_",
                    "possible_values": []
                }
            },
            "boolean_mask_551": {
                "variable": {
                    "value": "sliced_matrix",
                    "possible_values": []
                },
                "tensor": {
                    "value": "computed_measure",
                    "possible_values": [
                        [
                            "compute_measure(all_reid_features, all_reid_features)",
                            "Call"
                        ],
                        [
                            "compute_measure(reid_features_t, reid_features_tp1)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "id_mask_axis_0",
                    "possible_values": [
                        [
                            "tf.equal(target_ids_axis_0, id_)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_557": {
                "variable": {
                    "value": "same",
                    "possible_values": []
                },
                "tensor": {
                    "value": "sliced_matrix",
                    "possible_values": [
                        [
                            "tf.boolean_mask(computed_measure, id_mask_axis_0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(sliced_matrix, class_mask_axis_1, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "id_mask_axis_1",
                    "possible_values": [
                        [
                            "tf.equal(target_ids_axis_1, id_)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(id_mask_axis_1, class_mask_axis_1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "boolean_mask_558": {
                "variable": {
                    "value": "different",
                    "possible_values": []
                },
                "tensor": {
                    "value": "sliced_matrix",
                    "possible_values": [
                        [
                            "tf.boolean_mask(computed_measure, id_mask_axis_0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(sliced_matrix, class_mask_axis_1, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "tf.logical_not(id_mask_axis_1)",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "shape_32": {
                "variable": {
                    "value": "shp",
                    "possible_values": []
                },
                "input": {
                    "value": "box_logits",
                    "possible_values": [
                        [
                            "Conv('box', [hidden], 4 * num_anchors, tower_setup, (1, 1), old_order=True, bias=True, activation='linear', W_initializer=tf.random_normal_initializer(stddev=0.01)).outputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(box_logits, tf.stack([shp[0], shp[1], shp[2], num_anchors, 4]))",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_33": {
                "variable": {
                    "value": "box_logits",
                    "possible_values": []
                },
                "tensor": {
                    "value": "box_logits",
                    "possible_values": [
                        [
                            "Conv('box', [hidden], 4 * num_anchors, tower_setup, (1, 1), old_order=True, bias=True, activation='linear', W_initializer=tf.random_normal_initializer(stddev=0.01)).outputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(box_logits, tf.stack([shp[0], shp[1], shp[2], num_anchors, 4]))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.stack([shp[0], shp[1], shp[2], num_anchors, 4])",
                    "possible_values": []
                }
            },
            "reduce_mean_41": {
                "variable": {
                    "value": "feature",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "feature",
                    "possible_values": [
                        [
                            "tf.reduce_mean(feature, [1, 2], name='gap/output')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "possible_values": []
                },
                "name": {
                    "value": "gap/output",
                    "possible_values": []
                }
            },
            "reshape_52": {
                "variable": {
                    "value": "box_regression",
                    "possible_values": []
                },
                "tensor": {
                    "value": "box_regression",
                    "possible_values": [
                        [
                            "FullyConnected('box', [feature], num_hidden_box * 4, tower_setup, activation='linear', W_initializer=tf.random_normal_initializer(stddev=0.001)).outputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(box_regression, (-1, num_hidden_box, 4))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1, num_hidden_box, 4)",
                    "possible_values": []
                }
            },
            "cond_336": {
                "variable": {
                    "value": "(feature_fastrcnn, fastrcnn_label_logits, fastrcnn_box_logits, *fastrcnn_reid_features)",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.size(boxes_on_featuremap) > 0",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "ff_true",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "ff_false",
                    "possible_values": []
                }
            },
            "slice_348": {
                "variable": {
                    "value": "anchor_labels",
                    "possible_values": []
                },
                "input_": {
                    "value": "featuremap_labels",
                    "possible_values": [
                        [
                            "self.network_input_dict[DataKeys.FEATUREMAP_LABELS]",
                            "Subscript"
                        ],
                        [
                            "featuremap_labels[batch_idx]",
                            "Subscript"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0]",
                    "possible_values": []
                },
                "size": {
                    "value": "tf.stack([fm_shape[0], fm_shape[1], -1])",
                    "possible_values": []
                },
                "name": {
                    "value": "sliced_anchor_labels",
                    "possible_values": []
                }
            },
            "slice_352": {
                "variable": {
                    "value": "anchor_boxes",
                    "possible_values": []
                },
                "input_": {
                    "value": "featuremap_boxes",
                    "possible_values": [
                        [
                            "self.network_input_dict[DataKeys.FEATUREMAP_BOXES]",
                            "Subscript"
                        ],
                        [
                            "featuremap_boxes[batch_idx]",
                            "Subscript"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, 0]",
                    "possible_values": []
                },
                "size": {
                    "value": "tf.stack([fm_shape[0], fm_shape[1], -1, -1])",
                    "possible_values": []
                },
                "name": {
                    "value": "sliced_anchor_boxes",
                    "possible_values": []
                }
            },
            "reshape_362": {
                "variable": {
                    "value": "fg_inds_wrt_sample",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.where(rcnn_labels > 0)",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "possible_values": []
                }
            },
            "gather_363": {
                "variable": {
                    "value": "fg_sampled_boxes",
                    "possible_values": []
                },
                "params": {
                    "value": "rcnn_sampled_boxes",
                    "possible_values": []
                },
                "indices": {
                    "value": "fg_inds_wrt_sample",
                    "possible_values": [
                        [
                            "tf.reshape(tf.where(rcnn_labels > 0), [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_364": {
                "variable": {
                    "value": "matched_gt_boxes",
                    "possible_values": []
                },
                "params": {
                    "value": "gt_boxes",
                    "possible_values": [
                        [
                            "self.network_input_dict[DataKeys.BBOXES_x0y0x1y1]",
                            "Subscript"
                        ],
                        [
                            "gt_boxes[batch_idx]",
                            "Subscript"
                        ],
                        [
                            "tf.boolean_mask(gt_boxes, valid_gts_mask)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "fg_inds_wrt_gt",
                    "possible_values": []
                }
            },
            "softmax_396": {
                "variable": {
                    "value": "label_probs",
                    "possible_values": []
                },
                "logits": {
                    "value": "fastrcnn_label_logits",
                    "possible_values": []
                },
                "name": {
                    "value": "fastrcnn_all_probs",
                    "possible_values": []
                }
            },
            "identity_417": {
                "variable": {
                    "value": "final_probs",
                    "possible_values": []
                },
                "input": {
                    "value": "final_probs",
                    "possible_values": [
                        [
                            "tf.ones((n_proposals,))",
                            "Call"
                        ],
                        [
                            "tf.identity(final_probs, 'final_probs')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "final_probs",
                    "possible_values": []
                }
            },
            "add_422": {
                "variable": {
                    "value": "final_labels",
                    "possible_values": []
                },
                "x": {
                    "value": "pred_indices[:, 1]",
                    "possible_values": []
                },
                "y": {
                    "value": "1",
                    "possible_values": []
                },
                "name": {
                    "value": "final_labels",
                    "possible_values": []
                }
            },
            "concat_529": {
                "variable": {
                    "value": "all_target_ids",
                    "possible_values": []
                },
                "values": {
                    "value": "[ids for (_, ids) in reid_features_and_target_ids_per_time]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "concat_530": {
                "variable": {
                    "value": "all_reid_features",
                    "possible_values": []
                },
                "values": {
                    "value": "[reid for (reid, _) in reid_features_and_target_ids_per_time]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "unique_536": {
                "variable": {
                    "value": "(unique_target_ids, _)",
                    "possible_values": []
                },
                "x": {
                    "value": "all_target_ids",
                    "possible_values": [
                        [
                            "tf.concat([ids for (_, ids) in reid_features_and_target_ids_per_time], axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "map_fn_537": {
                "variable": {
                    "value": "(reid_losses_per_id, normalization_per_id)",
                    "possible_values": []
                },
                "fn": {
                    "value": "reid_loss_per_id_fn",
                    "possible_values": [
                        [
                            "partial(id_fun, computed_measure=computed_measure, target_ids_axis_0=all_target_ids, target_ids_axis_1=all_target_ids)",
                            "Call"
                        ],
                        [
                            "partial(id_fun, computed_measure=computed_measure, target_ids_axis_0=target_ids_t, target_ids_axis_1=target_ids_tp1)",
                            "Call"
                        ]
                    ]
                },
                "elems": {
                    "value": "unique_target_ids",
                    "possible_values": []
                },
                "dtype": {
                    "value": "(tf.float32, tf.int32)",
                    "possible_values": []
                }
            },
            "reduce_sum_539": {
                "variable": {
                    "value": "reid_loss",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "reid_losses_per_id",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "reduce_sum_540": {
                "variable": {
                    "value": "normalization",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "normalization_per_id",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "equal_554": {
                "variable": {
                    "value": "class_mask_axis_1",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.floordiv(target_ids_axis_1, 1000)",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.floordiv(id_, 1000)",
                    "possible_values": []
                }
            },
            "boolean_mask_555": {
                "variable": {
                    "value": "sliced_matrix",
                    "possible_values": []
                },
                "tensor": {
                    "value": "sliced_matrix",
                    "possible_values": [
                        [
                            "tf.boolean_mask(computed_measure, id_mask_axis_0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(sliced_matrix, class_mask_axis_1, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "class_mask_axis_1",
                    "possible_values": [
                        [
                            "tf.equal(tf.floordiv(target_ids_axis_1, 1000), tf.floordiv(id_, 1000))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "boolean_mask_556": {
                "variable": {
                    "value": "id_mask_axis_1",
                    "possible_values": []
                },
                "tensor": {
                    "value": "id_mask_axis_1",
                    "possible_values": [
                        [
                            "tf.equal(target_ids_axis_1, id_)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(id_mask_axis_1, class_mask_axis_1)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "class_mask_axis_1",
                    "possible_values": [
                        [
                            "tf.equal(tf.floordiv(target_ids_axis_1, 1000), tf.floordiv(id_, 1000))",
                            "Call"
                        ]
                    ]
                }
            },
            "cond_583": {
                "variable": {
                    "value": "(loss, normalization)",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.logical_and(tf.size(same) > 0, tf.size(different) > 0)",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "contrastive",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (tf.constant(0.0), tf.constant(1, dtype=tf.int32))",
                    "possible_values": []
                }
            },
            "cond_586": {
                "variable": {
                    "value": "(loss, normalization)",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.logical_and(tf.size(same) > 0, tf.size(different) > 0)",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "triplet",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (tf.constant(0.0), tf.constant(1, dtype=tf.int32))",
                    "possible_values": []
                }
            },
            "variable_scope_24": {
                "name_or_scope": {
                    "value": "rpn",
                    "possible_values": []
                }
            },
            "variable_scope_38": {
                "name_or_scope": {
                    "value": "fastrcnn",
                    "possible_values": []
                }
            },
            "variable_scope_70": {
                "name_or_scope": {
                    "value": "maskrcnn",
                    "possible_values": []
                }
            },
            "constant_94": {
                "variable": {
                    "value": "all_anchors",
                    "possible_values": []
                },
                "value": {
                    "value": "ALL_ANCHORS",
                    "possible_values": []
                },
                "name": {
                    "value": "all_anchors",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "slice_95": {
                "variable": {
                    "value": "fm_anchors",
                    "possible_values": []
                },
                "input_": {
                    "value": "all_anchors",
                    "possible_values": [
                        [
                            "tf.constant(ALL_ANCHORS, name='all_anchors', dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, 0]",
                    "possible_values": []
                },
                "size": {
                    "value": "tf.stack([shape2d[0], shape2d[1], -1, -1])",
                    "possible_values": []
                },
                "name": {
                    "value": "fm_anchors",
                    "possible_values": []
                }
            },
            "trainable_variables_221": {
                "variable": {
                    "value": "vars_to_regularize",
                    "possible_values": []
                },
                "scope": {
                    "value": "frcnn/(?:rpn|group3|fastrcnn|maskrcnn)/.*W",
                    "possible_values": []
                }
            },
            "add_n_223": {
                "variable": {
                    "value": "regularization_loss",
                    "possible_values": []
                },
                "inputs": {
                    "value": "regularizers",
                    "possible_values": [
                        [
                            "[0.0001 * tf.nn.l2_loss(W) for W in vars_to_regularize]",
                            "ListComp"
                        ]
                    ]
                },
                "name": {
                    "value": "regularization_loss",
                    "possible_values": []
                }
            },
            "squeeze_246": {
                "variable": {
                    "value": "input_boxes",
                    "possible_values": []
                },
                "input": {
                    "value": "self.network_input_dict[DataKeys.BBOXES_TO_REFINE_x0y0x1y1]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "squeeze_249": {
                "variable": {
                    "value": "image_shape2d_before_resize",
                    "possible_values": []
                },
                "input": {
                    "value": "image_shape2d_before_resize",
                    "possible_values": [
                        [
                            "self.network_input_dict[DataKeys.RAW_IMAGE_SIZES]",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(image_shape2d_before_resize, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "stack_255": {
                "variable": {
                    "value": "scale",
                    "possible_values": []
                },
                "values": {
                    "value": "[width_scale, height_scale, width_scale, height_scale]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "cast_263": {
                "variable": {
                    "value": "gt_labels",
                    "possible_values": []
                },
                "x": {
                    "value": "gt_labels[batch_idx]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "possible_values": []
                }
            },
            "logical_and_275": {
                "variable": {
                    "value": "valid_gts_mask",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.greater(target_ids, 0)",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.equal(is_crowd, 0)",
                    "possible_values": []
                }
            },
            "boolean_mask_276": {
                "variable": {
                    "value": "gt_boxes",
                    "possible_values": []
                },
                "tensor": {
                    "value": "gt_boxes",
                    "possible_values": [
                        [
                            "self.network_input_dict[DataKeys.BBOXES_x0y0x1y1]",
                            "Subscript"
                        ],
                        [
                            "gt_boxes[batch_idx]",
                            "Subscript"
                        ],
                        [
                            "tf.boolean_mask(gt_boxes, valid_gts_mask)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "valid_gts_mask",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.greater(target_ids, 0), tf.equal(is_crowd, 0))",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_277": {
                "variable": {
                    "value": "gt_labels",
                    "possible_values": []
                },
                "tensor": {
                    "value": "gt_labels",
                    "possible_values": [
                        [
                            "self.network_input_dict[DataKeys.CLASSES]",
                            "Subscript"
                        ],
                        [
                            "tf.cast(gt_labels[batch_idx], dtype=tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(gt_labels, valid_gts_mask)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "valid_gts_mask",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.greater(target_ids, 0), tf.equal(is_crowd, 0))",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_278": {
                "variable": {
                    "value": "target_ids",
                    "possible_values": []
                },
                "tensor": {
                    "value": "target_ids",
                    "possible_values": [
                        [
                            "self.network_input_dict[DataKeys.IDS]",
                            "Subscript"
                        ],
                        [
                            "target_ids[batch_idx]",
                            "Subscript"
                        ],
                        [
                            "tf.boolean_mask(target_ids, valid_gts_mask)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "valid_gts_mask",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.greater(target_ids, 0), tf.equal(is_crowd, 0))",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_375": {
                "variable": {
                    "value": "fg_labels",
                    "possible_values": []
                },
                "params": {
                    "value": "rcnn_labels",
                    "possible_values": []
                },
                "indices": {
                    "value": "fg_inds_wrt_sample",
                    "possible_values": [
                        [
                            "tf.reshape(tf.where(rcnn_labels > 0), [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_376": {
                "variable": {
                    "value": "fg_feature",
                    "possible_values": []
                },
                "params": {
                    "value": "feature_fastrcnn",
                    "possible_values": []
                },
                "indices": {
                    "value": "fg_inds_wrt_sample",
                    "possible_values": [
                        [
                            "tf.reshape(tf.where(rcnn_labels > 0), [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_380": {
                "variable": {
                    "value": "gt_masks_for_fg",
                    "possible_values": []
                },
                "params": {
                    "value": "gt_masks",
                    "possible_values": [
                        [
                            "self.network_input_dict[DataKeys.SEGMENTATION_MASK]",
                            "Subscript"
                        ],
                        [
                            "gt_masks[batch_idx]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(gt_masks, [2, 0, 1])",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ]
                    ]
                },
                "indices": {
                    "value": "fg_inds_wrt_gt",
                    "possible_values": []
                }
            },
            "squeeze_385": {
                "variable": {
                    "value": "target_masks_for_fg",
                    "possible_values": []
                },
                "input": {
                    "value": "target_masks_for_fg",
                    "possible_values": [
                        [
                            "crop_and_resize(tf.expand_dims(gt_masks_for_fg, 3), fg_sampled_boxes, tf.range(tf.size(fg_inds_wrt_gt)), 14, pad_border=False)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(target_masks_for_fg, 3, 'sampled_fg_mask_targets')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "possible_values": []
                },
                "name": {
                    "value": "sampled_fg_mask_targets",
                    "possible_values": []
                }
            },
            "tile_398": {
                "variable": {
                    "value": "anchors",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(proposal_boxes, 1)",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, 1]",
                    "possible_values": []
                }
            },
            "tile_400": {
                "variable": {
                    "value": "anchors",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(proposal_boxes, 1)",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, self._num_classes - 1, 1]",
                    "possible_values": []
                }
            },
            "stack_408": {
                "variable": {
                    "value": "pred_indices",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.range(n_proposals), tf.zeros((n_proposals,), dtype=tf.int32)]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "ones_409": {
                "variable": {
                    "value": "final_probs",
                    "possible_values": []
                },
                "shape": {
                    "value": "(n_proposals,)",
                    "possible_values": []
                }
            },
            "gather_419": {
                "variable": {
                    "value": "final_boxes",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.squeeze(decoded_boxes, axis=1)",
                    "possible_values": []
                },
                "indices": {
                    "value": "pred_indices[:, 0]",
                    "possible_values": []
                },
                "name": {
                    "value": "final_boxes",
                    "possible_values": []
                }
            },
            "gather_nd_421": {
                "variable": {
                    "value": "final_boxes",
                    "possible_values": []
                },
                "params": {
                    "value": "decoded_boxes",
                    "possible_values": [
                        [
                            "decode_bbox_target(self.bbox_decode_clip, rpn_box_logits, fm_anchors)",
                            "Call"
                        ],
                        [
                            "decode_bbox_target(self.bbox_decode_clip, fastrcnn_box_logits / tf.constant(FASTRCNN_BBOX_REG_WEIGHTS), anchors)",
                            "Call"
                        ],
                        [
                            "clip_boxes(decoded_boxes, self._image_shape2d, name='fastrcnn_all_boxes')",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "pred_indices",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(n_proposals), tf.zeros((n_proposals,), dtype=tf.int32)], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "final_boxes",
                    "possible_values": []
                }
            },
            "cond_442": {
                "variable": {
                    "value": "final_masks",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.size(final_probs) > 0",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "f1",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.zeros([0, 14, 14])",
                    "possible_values": []
                }
            },
            "identity_443": {
                "variable": {
                    "value": "final_masks",
                    "possible_values": []
                },
                "input": {
                    "value": "final_masks",
                    "possible_values": [
                        [
                            "tf.cond(tf.size(final_probs) > 0, f1, lambda : tf.zeros([0, 14, 14]))",
                            "Call"
                        ],
                        [
                            "tf.identity(final_masks, name='final_masks')",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.py_func(self.fill_full_mask, [clipped_boxes, final_masks, orig_img_shape], tf.uint8, name='fill_full_mask')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "final_masks",
                    "possible_values": []
                }
            },
            "gather_449": {
                "variable": {
                    "value": "final_reid_features",
                    "possible_values": []
                },
                "params": {
                    "value": "reid_features",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "FullyConnected('reid', [feature], (num_classes - 1) * reid_dim, tower_setup, activation='linear').outputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(reid_features, (-1, num_classes - 1, reid_dim))",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(reid_features, feature_indices)",
                            "Call"
                        ],
                        [
                            "FullyConnected('reid', [feature], reid_dim, tower_setup, activation='linear').outputs[0]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "pred_indices[:, 0]",
                    "possible_values": []
                }
            },
            "cast_465": {
                "variable": {
                    "value": "orig_img_shape_f",
                    "possible_values": []
                },
                "x": {
                    "value": "orig_img_shape",
                    "possible_values": [
                        [
                            "self.network_input_dict[DataKeys.RAW_IMAGE_SIZES][batch_idx, ...]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "cast_466": {
                "variable": {
                    "value": "image_shape2d_f",
                    "possible_values": []
                },
                "x": {
                    "value": "self._image_shape2d",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "cond_523": {
                "variable": {
                    "value": "(reid_loss_t, normalization_t)",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.logical_and(tf.size(reid_features_t) > 0, tf.size(reid_features_tp1) > 0)",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "f",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (tf.constant(0.0), tf.constant(1, dtype=tf.int32))",
                    "possible_values": []
                }
            },
            "size_542": {
                "variable": {
                    "value": "normalization",
                    "possible_values": []
                },
                "input": {
                    "value": "all_target_ids",
                    "possible_values": [
                        [
                            "tf.concat([ids for (_, ids) in reid_features_and_target_ids_per_time], axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_543": {
                "x": {
                    "value": "normalization",
                    "possible_values": [
                        [
                            "tf.constant(0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(normalization_per_id, axis=0)",
                            "Call"
                        ],
                        [
                            "normalization + normalization_t",
                            "BinOp"
                        ],
                        [
                            "tf.size(all_target_ids)",
                            "Call"
                        ],
                        [
                            "tf.size(loss)",
                            "Call"
                        ],
                        [
                            "tf.size(loss)",
                            "Call"
                        ],
                        [
                            "tf.count_nonzero(loss, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.size(same) + tf.size(different)",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "logical_not_558": {
                "x": {
                    "value": "id_mask_axis_1",
                    "possible_values": [
                        [
                            "tf.equal(target_ids_axis_1, id_)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(id_mask_axis_1, class_mask_axis_1)",
                            "Call"
                        ]
                    ]
                }
            },
            "maximum_564": {
                "variable": {
                    "value": "loss",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.constant(margin) + all_combinations",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "reduce_max_570": {
                "variable": {
                    "value": "hard_pos",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "same",
                    "possible_values": [
                        [
                            "tf.boolean_mask(sliced_matrix, id_mask_axis_1, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "reduce_min_571": {
                "variable": {
                    "value": "hard_neg",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "different",
                    "possible_values": [
                        [
                            "tf.boolean_mask(sliced_matrix, tf.logical_not(id_mask_axis_1), axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "maximum_572": {
                "variable": {
                    "value": "loss",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.constant(margin) + hard_pos - hard_neg",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "size_573": {
                "variable": {
                    "value": "normalization",
                    "possible_values": []
                },
                "input": {
                    "value": "loss",
                    "possible_values": [
                        [
                            "tf.maximum(tf.constant(margin) + all_combinations, 0)",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.constant(margin) + hard_pos - hard_neg, 0)",
                            "Call"
                        ],
                        [
                            "tf.constant(0.5) * (tf.reduce_sum(tf.square(same)) + tf.reduce_sum(tf.square(tf.maximum(tf.constant(margin) - different, 0))))",
                            "BinOp"
                        ],
                        [
                            "tf.add_n(losses, 'total_cost') / batch_size",
                            "BinOp"
                        ],
                        [
                            "0.0",
                            "Constant"
                        ]
                    ]
                }
            },
            "expand_dims_604": {
                "input": {
                    "value": "b",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "name_scope_625": {
                "name": {
                    "value": "cdist",
                    "possible_values": []
                }
            },
            "stack_33": {
                "values": {
                    "value": "[shp[0], shp[1], shp[2], num_anchors, 4]",
                    "possible_values": []
                }
            },
            "reshape_58": {
                "variable": {
                    "value": "reid_features",
                    "possible_values": []
                },
                "tensor": {
                    "value": "reid_features",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "FullyConnected('reid', [feature], (num_classes - 1) * reid_dim, tower_setup, activation='linear').outputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(reid_features, (-1, num_classes - 1, reid_dim))",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(reid_features, feature_indices)",
                            "Call"
                        ],
                        [
                            "FullyConnected('reid', [feature], reid_dim, tower_setup, activation='linear').outputs[0]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1, num_classes - 1, reid_dim)",
                    "possible_values": []
                }
            },
            "cast_59": {
                "variable": {
                    "value": "best_class",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(classification, axis=-1) - 1",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "stack_60": {
                "variable": {
                    "value": "feature_indices",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.range(tf.shape(best_class)[0], dtype=tf.int32), best_class]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "gather_nd_61": {
                "variable": {
                    "value": "reid_features",
                    "possible_values": []
                },
                "params": {
                    "value": "reid_features",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "FullyConnected('reid', [feature], (num_classes - 1) * reid_dim, tower_setup, activation='linear').outputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(reid_features, (-1, num_classes - 1, reid_dim))",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(reid_features, feature_indices)",
                            "Call"
                        ],
                        [
                            "FullyConnected('reid', [feature], reid_dim, tower_setup, activation='linear').outputs[0]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "feature_indices",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(tf.shape(best_class)[0], dtype=tf.int32), best_class], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_93": {
                "name": {
                    "value": "anchors",
                    "possible_values": []
                }
            },
            "add_to_collection_140": {
                "name": {
                    "value": "checkpoints",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_141": {
                "input": {
                    "value": "network_input_dict[DataKeys.IMAGES]",
                    "possible_values": []
                }
            },
            "variable_scope_166": {
                "name_or_scope": {
                    "value": "name",
                    "possible_values": []
                }
            },
            "reshape_241": {
                "tensor": {
                    "value": "decoded_boxes",
                    "possible_values": [
                        [
                            "decode_bbox_target(self.bbox_decode_clip, rpn_box_logits, fm_anchors)",
                            "Call"
                        ],
                        [
                            "decode_bbox_target(self.bbox_decode_clip, fastrcnn_box_logits / tf.constant(FASTRCNN_BBOX_REG_WEIGHTS), anchors)",
                            "Call"
                        ],
                        [
                            "clip_boxes(decoded_boxes, self._image_shape2d, name='fastrcnn_all_boxes')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 4]",
                    "possible_values": []
                }
            },
            "reshape_242": {
                "tensor": {
                    "value": "rpn_label_logits",
                    "possible_values": [
                        [
                            "rpn_label_logits[batch_idx]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "possible_values": []
                }
            },
            "transpose_267": {
                "variable": {
                    "value": "gt_masks",
                    "possible_values": []
                },
                "a": {
                    "value": "gt_masks",
                    "possible_values": [
                        [
                            "self.network_input_dict[DataKeys.SEGMENTATION_MASK]",
                            "Subscript"
                        ],
                        [
                            "gt_masks[batch_idx]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(gt_masks, [2, 0, 1])",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ]
                    ]
                },
                "perm": {
                    "value": "[2, 0, 1]",
                    "possible_values": []
                }
            },
            "stack_350": {
                "values": {
                    "value": "[fm_shape[0], fm_shape[1], -1]",
                    "possible_values": []
                }
            },
            "stack_354": {
                "values": {
                    "value": "[fm_shape[0], fm_shape[1], -1, -1]",
                    "possible_values": []
                }
            },
            "where_362": {
                "condition": {
                    "value": "rcnn_labels > 0",
                    "possible_values": []
                }
            },
            "constant_367": {
                "value": {
                    "value": "FASTRCNN_BBOX_REG_WEIGHTS",
                    "possible_values": [
                        [
                            "np.array([10, 10, 5, 5], dtype='float32')",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_371": {
                "params": {
                    "value": "fastrcnn_box_logits",
                    "possible_values": []
                },
                "indices": {
                    "value": "fg_inds_wrt_sample",
                    "possible_values": [
                        [
                            "tf.reshape(tf.where(rcnn_labels > 0), [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_434": {
                "variable": {
                    "value": "mask_logits",
                    "possible_values": []
                },
                "a": {
                    "value": "mask_logits",
                    "possible_values": [
                        [
                            "maskrcnn_head(fg_feature, self._num_classes, self.tower_setup, class_agnostic_conv=self.class_agnostic_box_and_mask_heads)",
                            "Call"
                        ],
                        [
                            "maskrcnn_head(feature_maskrcnn, self._num_classes, self.tower_setup, class_agnostic_conv=self.class_agnostic_box_and_mask_heads)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask_logits, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(mask_logits, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(mask_logits, indices)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 3, 1, 2]",
                    "possible_values": []
                }
            },
            "shape_457": {
                "input": {
                    "value": "inp",
                    "possible_values": []
                }
            },
            "py_func_475": {
                "variable": {
                    "value": "final_masks",
                    "possible_values": []
                },
                "func": {
                    "value": "self.fill_full_mask",
                    "possible_values": []
                },
                "inp": {
                    "value": "[clipped_boxes, final_masks, orig_img_shape]",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.uint8",
                    "possible_values": []
                },
                "name": {
                    "value": "fill_full_mask",
                    "possible_values": []
                }
            },
            "unique_516": {
                "variable": {
                    "value": "(unique_target_ids_t, _)",
                    "possible_values": []
                },
                "x": {
                    "value": "target_ids_t",
                    "possible_values": []
                }
            },
            "map_fn_517": {
                "variable": {
                    "value": "(reid_losses_per_id, normalization_per_id)",
                    "possible_values": []
                },
                "fn": {
                    "value": "reid_loss_per_id_fn",
                    "possible_values": [
                        [
                            "partial(id_fun, computed_measure=computed_measure, target_ids_axis_0=all_target_ids, target_ids_axis_1=all_target_ids)",
                            "Call"
                        ],
                        [
                            "partial(id_fun, computed_measure=computed_measure, target_ids_axis_0=target_ids_t, target_ids_axis_1=target_ids_tp1)",
                            "Call"
                        ]
                    ]
                },
                "elems": {
                    "value": "unique_target_ids_t",
                    "possible_values": []
                },
                "dtype": {
                    "value": "(tf.float32, tf.int32)",
                    "possible_values": []
                }
            },
            "reduce_sum_519": {
                "variable": {
                    "value": "reid_loss_t",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "reid_losses_per_id",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "reduce_sum_520": {
                "variable": {
                    "value": "normalization_t",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "normalization_per_id",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "floordiv_554": {
                "x": {
                    "value": "id_",
                    "possible_values": []
                },
                "y": {
                    "value": "1000",
                    "possible_values": []
                }
            },
            "size_566": {
                "variable": {
                    "value": "normalization",
                    "possible_values": []
                },
                "input": {
                    "value": "loss",
                    "possible_values": [
                        [
                            "tf.maximum(tf.constant(margin) + all_combinations, 0)",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.constant(margin) + hard_pos - hard_neg, 0)",
                            "Call"
                        ],
                        [
                            "tf.constant(0.5) * (tf.reduce_sum(tf.square(same)) + tf.reduce_sum(tf.square(tf.maximum(tf.constant(margin) - different, 0))))",
                            "BinOp"
                        ],
                        [
                            "tf.add_n(losses, 'total_cost') / batch_size",
                            "BinOp"
                        ],
                        [
                            "0.0",
                            "Constant"
                        ]
                    ]
                }
            },
            "count_nonzero_568": {
                "variable": {
                    "value": "normalization",
                    "possible_values": []
                },
                "input": {
                    "value": "loss",
                    "possible_values": [
                        [
                            "tf.maximum(tf.constant(margin) + all_combinations, 0)",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.constant(margin) + hard_pos - hard_neg, 0)",
                            "Call"
                        ],
                        [
                            "tf.constant(0.5) * (tf.reduce_sum(tf.square(same)) + tf.reduce_sum(tf.square(tf.maximum(tf.constant(margin) - different, 0))))",
                            "BinOp"
                        ],
                        [
                            "tf.add_n(losses, 'total_cost') / batch_size",
                            "BinOp"
                        ],
                        [
                            "0.0",
                            "Constant"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "reduce_sum_574": {
                "input_tensor": {
                    "value": "loss",
                    "possible_values": [
                        [
                            "tf.maximum(tf.constant(margin) + all_combinations, 0)",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.constant(margin) + hard_pos - hard_neg, 0)",
                            "Call"
                        ],
                        [
                            "tf.constant(0.5) * (tf.reduce_sum(tf.square(same)) + tf.reduce_sum(tf.square(tf.maximum(tf.constant(margin) - different, 0))))",
                            "BinOp"
                        ],
                        [
                            "tf.add_n(losses, 'total_cost') / batch_size",
                            "BinOp"
                        ],
                        [
                            "0.0",
                            "Constant"
                        ]
                    ]
                }
            },
            "constant_577": {
                "value": {
                    "value": "0.5",
                    "possible_values": []
                }
            },
            "size_579": {
                "input": {
                    "value": "different",
                    "possible_values": [
                        [
                            "tf.boolean_mask(sliced_matrix, tf.logical_not(id_mask_axis_1), axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_and_583": {
                "x": {
                    "value": "tf.size(same) > 0",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.size(different) > 0",
                    "possible_values": []
                }
            },
            "logical_and_586": {
                "x": {
                    "value": "tf.size(same) > 0",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.size(different) > 0",
                    "possible_values": []
                }
            },
            "reduce_sum_628": {
                "input_tensor": {
                    "value": "tf.square(diffs)",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "stack_96": {
                "values": {
                    "value": "[shape2d[0], shape2d[1], -1, -1]",
                    "possible_values": []
                }
            },
            "shape_168": {
                "input": {
                    "value": "inputs",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "control_dependencies_180": {
                "control_inputs": {
                    "value": "final_boxes_list",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "add_n_226": {
                "inputs": {
                    "value": "losses",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "name": {
                    "value": "total_cost",
                    "possible_values": []
                }
            },
            "cast_256": {
                "x": {
                    "value": "scale",
                    "possible_values": [
                        [
                            "tf.stack([width_scale, height_scale, width_scale, height_scale], axis=0)",
                            "Call"
                        ],
                        [
                            "(image_shape2d_f[0] / orig_img_shape_f[0] + image_shape2d_f[1] / orig_img_shape_f[1]) / 2",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "greater_275": {
                "x": {
                    "value": "target_ids",
                    "possible_values": [
                        [
                            "self.network_input_dict[DataKeys.IDS]",
                            "Subscript"
                        ],
                        [
                            "target_ids[batch_idx]",
                            "Subscript"
                        ],
                        [
                            "tf.boolean_mask(target_ids, valid_gts_mask)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "equal_275": {
                "x": {
                    "value": "is_crowd",
                    "possible_values": [
                        [
                            "self.network_input_dict[DataKeys.IS_CROWD]",
                            "Subscript"
                        ],
                        [
                            "is_crowd[batch_idx]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "size_337": {
                "input": {
                    "value": "boxes_on_featuremap",
                    "possible_values": [
                        [
                            "proposal_boxes * (1.0 / ANCHOR_STRIDE)",
                            "BinOp"
                        ],
                        [
                            "rcnn_sampled_boxes * (1.0 / ANCHOR_STRIDE)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "expand_dims_382": {
                "input": {
                    "value": "gt_masks_for_fg",
                    "possible_values": [
                        [
                            "tf.gather(gt_masks, fg_inds_wrt_gt)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "possible_values": []
                }
            },
            "expand_dims_398": {
                "input": {
                    "value": "proposal_boxes",
                    "possible_values": [
                        [
                            "input_boxes * tf.cast(scale, tf.float32)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_400": {
                "input": {
                    "value": "proposal_boxes",
                    "possible_values": [
                        [
                            "input_boxes * tf.cast(scale, tf.float32)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "constant_404": {
                "value": {
                    "value": "FASTRCNN_BBOX_REG_WEIGHTS",
                    "possible_values": [
                        [
                            "np.array([10, 10, 5, 5], dtype='float32')",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_407": {
                "input": {
                    "value": "proposal_boxes",
                    "possible_values": [
                        [
                            "input_boxes * tf.cast(scale, tf.float32)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "squeeze_419": {
                "input": {
                    "value": "decoded_boxes",
                    "possible_values": [
                        [
                            "decode_bbox_target(self.bbox_decode_clip, rpn_box_logits, fm_anchors)",
                            "Call"
                        ],
                        [
                            "decode_bbox_target(self.bbox_decode_clip, fastrcnn_box_logits / tf.constant(FASTRCNN_BBOX_REG_WEIGHTS), anchors)",
                            "Call"
                        ],
                        [
                            "clip_boxes(decoded_boxes, self._image_shape2d, name='fastrcnn_all_boxes')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "squeeze_436": {
                "variable": {
                    "value": "mask_logits",
                    "possible_values": []
                },
                "input": {
                    "value": "mask_logits",
                    "possible_values": [
                        [
                            "maskrcnn_head(fg_feature, self._num_classes, self.tower_setup, class_agnostic_conv=self.class_agnostic_box_and_mask_heads)",
                            "Call"
                        ],
                        [
                            "maskrcnn_head(feature_maskrcnn, self._num_classes, self.tower_setup, class_agnostic_conv=self.class_agnostic_box_and_mask_heads)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask_logits, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(mask_logits, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(mask_logits, indices)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "stack_438": {
                "variable": {
                    "value": "indices",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.range(tf.size(final_labels)), tf.to_int32(final_labels) - 1]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "gather_nd_439": {
                "variable": {
                    "value": "mask_logits",
                    "possible_values": []
                },
                "params": {
                    "value": "mask_logits",
                    "possible_values": [
                        [
                            "maskrcnn_head(fg_feature, self._num_classes, self.tower_setup, class_agnostic_conv=self.class_agnostic_box_and_mask_heads)",
                            "Call"
                        ],
                        [
                            "maskrcnn_head(feature_maskrcnn, self._num_classes, self.tower_setup, class_agnostic_conv=self.class_agnostic_box_and_mask_heads)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask_logits, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(mask_logits, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(mask_logits, indices)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(tf.size(final_labels)), tf.to_int32(final_labels) - 1], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_440": {
                "x": {
                    "value": "mask_logits",
                    "possible_values": [
                        [
                            "maskrcnn_head(fg_feature, self._num_classes, self.tower_setup, class_agnostic_conv=self.class_agnostic_box_and_mask_heads)",
                            "Call"
                        ],
                        [
                            "maskrcnn_head(feature_maskrcnn, self._num_classes, self.tower_setup, class_agnostic_conv=self.class_agnostic_box_and_mask_heads)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask_logits, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(mask_logits, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(mask_logits, indices)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_460": {
                "x": {
                    "value": "n_examples",
                    "possible_values": [
                        [
                            "tf.shape(inp)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "l2_normalize_490": {
                "x": {
                    "value": "reid",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "matmul_495": {
                "a": {
                    "value": "a",
                    "possible_values": []
                },
                "b": {
                    "value": "b",
                    "possible_values": []
                },
                "transpose_b": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "logical_and_523": {
                "x": {
                    "value": "tf.size(reid_features_t) > 0",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.size(reid_features_tp1) > 0",
                    "possible_values": []
                }
            },
            "expand_dims_563": {
                "input": {
                    "value": "different",
                    "possible_values": [
                        [
                            "tf.boolean_mask(sliced_matrix, tf.logical_not(id_mask_axis_1), axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "reduce_sum_577": {
                "input_tensor": {
                    "value": "tf.square(same)",
                    "possible_values": []
                }
            },
            "reduce_sum_578": {
                "input_tensor": {
                    "value": "tf.square(tf.maximum(tf.constant(margin) - different, 0))",
                    "possible_values": []
                }
            },
            "square_628": {
                "x": {
                    "value": "diffs",
                    "possible_values": [
                        [
                            "all_diffs(a, b)",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_630": {
                "x": {
                    "value": "tf.reduce_sum(tf.square(diffs), axis=-1) + 1e-12",
                    "possible_values": []
                }
            },
            "variable_scope_181": {
                "name_or_scope": {
                    "value": "name",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True if batch_idx > 0 else None",
                    "possible_values": []
                }
            },
            "l2_loss_222": {
                "t": {
                    "value": "W",
                    "possible_values": []
                }
            },
            "zeros_331": {
                "shape": {
                    "value": "[0, ncls - 1, 4]",
                    "possible_values": []
                }
            },
            "zeros_332": {
                "shape": {
                    "value": "[0, self._reid_dimension]",
                    "possible_values": []
                }
            },
            "zeros_334": {
                "shape": {
                    "value": "[0, ncls - 1, 4]",
                    "possible_values": []
                }
            },
            "size_384": {
                "input": {
                    "value": "fg_inds_wrt_gt",
                    "possible_values": []
                }
            },
            "zeros_408": {
                "shape": {
                    "value": "(n_proposals,)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "variable_scope_429": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "size_442": {
                "input": {
                    "value": "final_probs",
                    "possible_values": [
                        [
                            "tf.ones((n_proposals,))",
                            "Call"
                        ],
                        [
                            "tf.identity(final_probs, 'final_probs')",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_442": {
                "shape": {
                    "value": "[0, 14, 14]",
                    "possible_values": []
                }
            },
            "constant_564": {
                "value": {
                    "value": "margin",
                    "possible_values": []
                }
            },
            "square_577": {
                "x": {
                    "value": "same",
                    "possible_values": [
                        [
                            "tf.boolean_mask(sliced_matrix, id_mask_axis_1, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "square_578": {
                "x": {
                    "value": "tf.maximum(tf.constant(margin) - different, 0)",
                    "possible_values": []
                }
            },
            "size_583": {
                "input": {
                    "value": "different",
                    "possible_values": [
                        [
                            "tf.boolean_mask(sliced_matrix, tf.logical_not(id_mask_axis_1), axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_584": {
                "value": {
                    "value": "1",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "size_586": {
                "input": {
                    "value": "different",
                    "possible_values": [
                        [
                            "tf.boolean_mask(sliced_matrix, tf.logical_not(id_mask_axis_1), axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_587": {
                "value": {
                    "value": "1",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "reduce_sum_632": {
                "input_tensor": {
                    "value": "tf.abs(diffs)",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "random_normal_initializer_26": {
                "stddev": {
                    "value": "0.01",
                    "possible_values": []
                }
            },
            "random_normal_initializer_29": {
                "stddev": {
                    "value": "0.01",
                    "possible_values": []
                }
            },
            "random_normal_initializer_31": {
                "stddev": {
                    "value": "0.01",
                    "possible_values": []
                }
            },
            "random_normal_initializer_44": {
                "stddev": {
                    "value": "0.01",
                    "possible_values": []
                }
            },
            "random_normal_initializer_51": {
                "stddev": {
                    "value": "0.001",
                    "possible_values": []
                }
            },
            "argmax_59": {
                "input": {
                    "value": "classification",
                    "possible_values": [
                        [
                            "FullyConnected('class', [feature], num_classes, tower_setup, activation='linear', W_initializer=tf.random_normal_initializer(stddev=0.01)).outputs[0]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "get_variable_scope_429": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "size_523": {
                "input": {
                    "value": "reid_features_t",
                    "possible_values": []
                }
            },
            "size_524": {
                "input": {
                    "value": "reid_features_tp1",
                    "possible_values": []
                }
            },
            "constant_525": {
                "value": {
                    "value": "1",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "constant_572": {
                "value": {
                    "value": "margin",
                    "possible_values": []
                }
            },
            "maximum_578": {
                "x": {
                    "value": "tf.constant(margin) - different",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "reduce_sum_630": {
                "input_tensor": {
                    "value": "tf.square(diffs)",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "abs_632": {
                "x": {
                    "value": "diffs",
                    "possible_values": [
                        [
                            "all_diffs(a, b)",
                            "Call"
                        ]
                    ]
                }
            },
            "range_438": {},
            "square_630": {
                "x": {
                    "value": "diffs",
                    "possible_values": [
                        [
                            "all_diffs(a, b)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_60": {
                "input": {
                    "value": "best_class",
                    "possible_values": [
                        [
                            "tf.cast(tf.argmax(classification, axis=-1) - 1, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "size_438": {
                "input": {
                    "value": "final_labels",
                    "possible_values": [
                        [
                            "tf.add(pred_indices[:, 1], 1, name='final_labels')",
                            "Call"
                        ]
                    ]
                }
            },
            "to_int32_438": {
                "x": {
                    "value": "final_labels",
                    "possible_values": [
                        [
                            "tf.add(pred_indices[:, 1], 1, name='final_labels')",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_578": {
                "value": {
                    "value": "margin",
                    "possible_values": []
                }
            }
        }
    },
    "network/FasterRCNN_utils.py": {
        "tensorflow": {
            "shape_29": {
                "variable": {
                    "value": "orig_shape",
                    "possible_values": []
                },
                "input": {
                    "value": "anchors",
                    "possible_values": []
                }
            },
            "reshape_30": {
                "variable": {
                    "value": "box_pred_txtytwth",
                    "possible_values": []
                },
                "tensor": {
                    "value": "box_predictions",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, 2, 2)",
                    "possible_values": []
                }
            },
            "split_31": {
                "variable": {
                    "value": "(box_pred_txty, box_pred_twth)",
                    "possible_values": []
                },
                "value": {
                    "value": "box_pred_txtytwth",
                    "possible_values": [
                        [
                            "tf.reshape(box_predictions, (-1, 2, 2))",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "reshape_33": {
                "variable": {
                    "value": "anchors_x1y1x2y2",
                    "possible_values": []
                },
                "tensor": {
                    "value": "anchors",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, 2, 2)",
                    "possible_values": []
                }
            },
            "split_34": {
                "variable": {
                    "value": "(anchors_x1y1, anchors_x2y2)",
                    "possible_values": []
                },
                "value": {
                    "value": "anchors_x1y1x2y2",
                    "possible_values": [
                        [
                            "tf.reshape(anchors, (-1, 2, 2))",
                            "Call"
                        ],
                        [
                            "tf.reshape(anchors, (-1, 2, 2))",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "concat_44": {
                "variable": {
                    "value": "out",
                    "possible_values": []
                },
                "values": {
                    "value": "[x1y1, x2y2]",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "possible_values": []
                }
            },
            "reshape_56": {
                "variable": {
                    "value": "anchors_x1y1x2y2",
                    "possible_values": []
                },
                "tensor": {
                    "value": "anchors",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, 2, 2)",
                    "possible_values": []
                }
            },
            "split_57": {
                "variable": {
                    "value": "(anchors_x1y1, anchors_x2y2)",
                    "possible_values": []
                },
                "value": {
                    "value": "anchors_x1y1x2y2",
                    "possible_values": [
                        [
                            "tf.reshape(anchors, (-1, 2, 2))",
                            "Call"
                        ],
                        [
                            "tf.reshape(anchors, (-1, 2, 2))",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "reshape_61": {
                "variable": {
                    "value": "boxes_x1y1x2y2",
                    "possible_values": []
                },
                "tensor": {
                    "value": "boxes",
                    "possible_values": [
                        [
                            "tf.maximum(boxes, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.minimum(boxes, tf.to_float(m), name=name)",
                            "Call"
                        ],
                        [
                            "tf.concat([boxes, gt_boxes], axis=0)",
                            "Call"
                        ],
                        [
                            "boxes + 1",
                            "BinOp"
                        ],
                        [
                            "transform_fpcoor_for_tf(boxes, image_shape, [crop_size, crop_size])",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(boxes)",
                            "Call"
                        ],
                        [
                            "tf.transpose(boxes, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.tile(boxes, [num_cat, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1, 2, 2)",
                    "possible_values": []
                }
            },
            "split_62": {
                "variable": {
                    "value": "(boxes_x1y1, boxes_x2y2)",
                    "possible_values": []
                },
                "value": {
                    "value": "boxes_x1y1x2y2",
                    "possible_values": [
                        [
                            "tf.reshape(boxes, (-1, 2, 2))",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "log_68": {
                "variable": {
                    "value": "twth",
                    "possible_values": []
                },
                "x": {
                    "value": "wbhb / waha",
                    "possible_values": []
                }
            },
            "concat_69": {
                "variable": {
                    "value": "encoded",
                    "possible_values": []
                },
                "values": {
                    "value": "[txty, twth]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "maximum_79": {
                "variable": {
                    "value": "boxes",
                    "possible_values": []
                },
                "x": {
                    "value": "boxes",
                    "possible_values": [
                        [
                            "tf.maximum(boxes, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.minimum(boxes, tf.to_float(m), name=name)",
                            "Call"
                        ],
                        [
                            "tf.concat([boxes, gt_boxes], axis=0)",
                            "Call"
                        ],
                        [
                            "boxes + 1",
                            "BinOp"
                        ],
                        [
                            "transform_fpcoor_for_tf(boxes, image_shape, [crop_size, crop_size])",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(boxes)",
                            "Call"
                        ],
                        [
                            "tf.transpose(boxes, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.tile(boxes, [num_cat, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0.0",
                    "possible_values": []
                }
            },
            "tile_80": {
                "variable": {
                    "value": "m",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reverse(window, [0])",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[2]",
                    "possible_values": []
                }
            },
            "minimum_81": {
                "variable": {
                    "value": "boxes",
                    "possible_values": []
                },
                "x": {
                    "value": "boxes",
                    "possible_values": [
                        [
                            "tf.maximum(boxes, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.minimum(boxes, tf.to_float(m), name=name)",
                            "Call"
                        ],
                        [
                            "tf.concat([boxes, gt_boxes], axis=0)",
                            "Call"
                        ],
                        [
                            "boxes + 1",
                            "BinOp"
                        ],
                        [
                            "transform_fpcoor_for_tf(boxes, image_shape, [crop_size, crop_size])",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(boxes)",
                            "Call"
                        ],
                        [
                            "tf.transpose(boxes, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.tile(boxes, [num_cat, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.to_float(m)",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "minimum_103": {
                "variable": {
                    "value": "topk",
                    "possible_values": []
                },
                "x": {
                    "value": "PRE_NMS_TOPK",
                    "possible_values": [
                        [
                            "TRAIN_PRE_NMS_TOPK",
                            "Name"
                        ],
                        [
                            "TEST_PRE_NMS_TOPK",
                            "Name"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.size(scores)",
                    "possible_values": []
                }
            },
            "top_k_104": {
                "variable": {
                    "value": "(topk_scores, topk_indices)",
                    "possible_values": []
                },
                "input": {
                    "value": "scores",
                    "possible_values": []
                },
                "k": {
                    "value": "topk",
                    "possible_values": [
                        [
                            "tf.minimum(PRE_NMS_TOPK, tf.size(scores))",
                            "Call"
                        ]
                    ]
                },
                "sorted": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "gather_105": {
                "variable": {
                    "value": "topk_boxes",
                    "possible_values": []
                },
                "params": {
                    "value": "boxes",
                    "possible_values": [
                        [
                            "tf.maximum(boxes, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.minimum(boxes, tf.to_float(m), name=name)",
                            "Call"
                        ],
                        [
                            "tf.concat([boxes, gt_boxes], axis=0)",
                            "Call"
                        ],
                        [
                            "boxes + 1",
                            "BinOp"
                        ],
                        [
                            "transform_fpcoor_for_tf(boxes, image_shape, [crop_size, crop_size])",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(boxes)",
                            "Call"
                        ],
                        [
                            "tf.transpose(boxes, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.tile(boxes, [num_cat, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "topk_indices",
                    "possible_values": []
                }
            },
            "reshape_108": {
                "variable": {
                    "value": "topk_boxes_x1y1x2y2",
                    "possible_values": []
                },
                "tensor": {
                    "value": "topk_boxes",
                    "possible_values": [
                        [
                            "tf.gather(boxes, topk_indices)",
                            "Call"
                        ],
                        [
                            "clip_boxes(topk_boxes, img_shape)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1, 2, 2)",
                    "possible_values": []
                }
            },
            "split_109": {
                "variable": {
                    "value": "(topk_boxes_x1y1, topk_boxes_x2y2)",
                    "possible_values": []
                },
                "value": {
                    "value": "topk_boxes_x1y1x2y2",
                    "possible_values": [
                        [
                            "tf.reshape(topk_boxes, (-1, 2, 2))",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "squeeze_111": {
                "variable": {
                    "value": "wbhb",
                    "possible_values": []
                },
                "input": {
                    "value": "topk_boxes_x2y2 - topk_boxes_x1y1",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "reduce_all_112": {
                "variable": {
                    "value": "valid",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "wbhb > RPN_MIN_SIZE",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "boolean_mask_113": {
                "variable": {
                    "value": "topk_valid_boxes_x1y1x2y2",
                    "possible_values": []
                },
                "tensor": {
                    "value": "topk_boxes_x1y1x2y2",
                    "possible_values": [
                        [
                            "tf.reshape(topk_boxes, (-1, 2, 2))",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "valid",
                    "possible_values": [
                        [
                            "tf.reduce_all(wbhb > RPN_MIN_SIZE, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_114": {
                "variable": {
                    "value": "topk_valid_scores",
                    "possible_values": []
                },
                "tensor": {
                    "value": "topk_scores",
                    "possible_values": []
                },
                "mask": {
                    "value": "valid",
                    "possible_values": [
                        [
                            "tf.reduce_all(wbhb > RPN_MIN_SIZE, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_116": {
                "variable": {
                    "value": "topk_valid_boxes_y1x1y2x2",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.reverse(topk_valid_boxes_x1y1x2y2, axis=[2])",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, 4)",
                    "possible_values": []
                },
                "name": {
                    "value": "nms_input_boxes",
                    "possible_values": []
                }
            },
            "non_max_suppression_122": {
                "variable": {
                    "value": "nms_indices",
                    "possible_values": []
                },
                "boxes": {
                    "value": "topk_valid_boxes_y1x1y2x2",
                    "possible_values": [
                        [
                            "tf.reshape(tf.reverse(topk_valid_boxes_x1y1x2y2, axis=[2]), (-1, 4), name='nms_input_boxes')",
                            "Call"
                        ]
                    ]
                },
                "scores": {
                    "value": "topk_valid_scores",
                    "possible_values": [
                        [
                            "tf.boolean_mask(topk_scores, valid)",
                            "Call"
                        ]
                    ]
                },
                "max_output_size": {
                    "value": "POST_NMS_TOPK",
                    "possible_values": [
                        [
                            "TRAIN_POST_NMS_TOPK",
                            "Name"
                        ],
                        [
                            "TEST_POST_NMS_TOPK",
                            "Name"
                        ]
                    ]
                },
                "iou_threshold": {
                    "value": "RPN_PROPOSAL_NMS_THRESH",
                    "possible_values": [
                        [
                            "0.7",
                            "Constant"
                        ]
                    ]
                }
            },
            "reshape_128": {
                "variable": {
                    "value": "topk_valid_boxes",
                    "possible_values": []
                },
                "tensor": {
                    "value": "topk_valid_boxes_x1y1x2y2",
                    "possible_values": [
                        [
                            "tf.boolean_mask(topk_boxes_x1y1x2y2, valid)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1, 4)",
                    "possible_values": []
                }
            },
            "gather_129": {
                "variable": {
                    "value": "final_boxes",
                    "possible_values": []
                },
                "params": {
                    "value": "topk_valid_boxes",
                    "possible_values": [
                        [
                            "tf.reshape(topk_valid_boxes_x1y1x2y2, (-1, 4))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "nms_indices",
                    "possible_values": [
                        [
                            "tf.image.non_max_suppression(topk_valid_boxes_y1x1y2x2, topk_valid_scores, max_output_size=POST_NMS_TOPK, iou_threshold=RPN_PROPOSAL_NMS_THRESH)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "boxes",
                    "possible_values": []
                }
            },
            "gather_132": {
                "variable": {
                    "value": "final_scores",
                    "possible_values": []
                },
                "params": {
                    "value": "topk_valid_scores",
                    "possible_values": [
                        [
                            "tf.boolean_mask(topk_scores, valid)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "nms_indices",
                    "possible_values": [
                        [
                            "tf.image.non_max_suppression(topk_valid_boxes_y1x1y2x2, topk_valid_scores, max_output_size=POST_NMS_TOPK, iou_threshold=RPN_PROPOSAL_NMS_THRESH)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "scores",
                    "possible_values": []
                }
            },
            "split_144": {
                "variable": {
                    "value": "(x_min, y_min, x_max, y_max)",
                    "possible_values": []
                },
                "value": {
                    "value": "boxes",
                    "possible_values": [
                        [
                            "tf.maximum(boxes, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.minimum(boxes, tf.to_float(m), name=name)",
                            "Call"
                        ],
                        [
                            "tf.concat([boxes, gt_boxes], axis=0)",
                            "Call"
                        ],
                        [
                            "boxes + 1",
                            "BinOp"
                        ],
                        [
                            "transform_fpcoor_for_tf(boxes, image_shape, [crop_size, crop_size])",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(boxes)",
                            "Call"
                        ],
                        [
                            "tf.transpose(boxes, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.tile(boxes, [num_cat, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "split_156": {
                "variable": {
                    "value": "(x_min1, y_min1, x_max1, y_max1)",
                    "possible_values": []
                },
                "value": {
                    "value": "boxlist1",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "4",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "split_157": {
                "variable": {
                    "value": "(x_min2, y_min2, x_max2, y_max2)",
                    "possible_values": []
                },
                "value": {
                    "value": "boxlist2",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "4",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "minimum_158": {
                "variable": {
                    "value": "all_pairs_min_ymax",
                    "possible_values": []
                },
                "x": {
                    "value": "y_max1",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.transpose(y_max2)",
                    "possible_values": []
                }
            },
            "maximum_159": {
                "variable": {
                    "value": "all_pairs_max_ymin",
                    "possible_values": []
                },
                "x": {
                    "value": "y_min1",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.transpose(y_min2)",
                    "possible_values": []
                }
            },
            "maximum_160": {
                "variable": {
                    "value": "intersect_heights",
                    "possible_values": []
                },
                "x": {
                    "value": "0.0",
                    "possible_values": []
                },
                "y": {
                    "value": "all_pairs_min_ymax - all_pairs_max_ymin",
                    "possible_values": []
                }
            },
            "minimum_161": {
                "variable": {
                    "value": "all_pairs_min_xmax",
                    "possible_values": []
                },
                "x": {
                    "value": "x_max1",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.transpose(x_max2)",
                    "possible_values": []
                }
            },
            "maximum_162": {
                "variable": {
                    "value": "all_pairs_max_xmin",
                    "possible_values": []
                },
                "x": {
                    "value": "x_min1",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.transpose(x_min2)",
                    "possible_values": []
                }
            },
            "maximum_163": {
                "variable": {
                    "value": "intersect_widths",
                    "possible_values": []
                },
                "x": {
                    "value": "0.0",
                    "possible_values": []
                },
                "y": {
                    "value": "all_pairs_min_xmax - all_pairs_max_xmin",
                    "possible_values": []
                }
            },
            "concat_202": {
                "variable": {
                    "value": "boxes",
                    "possible_values": []
                },
                "values": {
                    "value": "[boxes, gt_boxes]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "concat_203": {
                "variable": {
                    "value": "iou",
                    "possible_values": []
                },
                "values": {
                    "value": "[iou, tf.eye(tf.shape(gt_boxes)[0])]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "argmax_228": {
                "variable": {
                    "value": "best_iou_ind",
                    "possible_values": []
                },
                "input": {
                    "value": "iou",
                    "possible_values": [
                        [
                            "pairwise_iou(boxes, gt_boxes)",
                            "Call"
                        ],
                        [
                            "tf.concat([iou, tf.eye(tf.shape(gt_boxes)[0])], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "gather_229": {
                "variable": {
                    "value": "fg_inds_wrt_gt",
                    "possible_values": []
                },
                "params": {
                    "value": "best_iou_ind",
                    "possible_values": [
                        [
                            "tf.argmax(iou, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "fg_inds",
                    "possible_values": [
                        [
                            "tf.reshape(tf.where(fg_mask), [-1])",
                            "Call"
                        ],
                        [
                            "tf.random_shuffle(fg_inds)[:num_fg]",
                            "Subscript"
                        ],
                        [
                            "tf.where(labels > 0)[:, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "concat_231": {
                "variable": {
                    "value": "all_indices",
                    "possible_values": []
                },
                "values": {
                    "value": "[fg_inds, bg_inds]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "gather_232": {
                "variable": {
                    "value": "ret_boxes",
                    "possible_values": []
                },
                "params": {
                    "value": "boxes",
                    "possible_values": [
                        [
                            "tf.maximum(boxes, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.minimum(boxes, tf.to_float(m), name=name)",
                            "Call"
                        ],
                        [
                            "tf.concat([boxes, gt_boxes], axis=0)",
                            "Call"
                        ],
                        [
                            "boxes + 1",
                            "BinOp"
                        ],
                        [
                            "transform_fpcoor_for_tf(boxes, image_shape, [crop_size, crop_size])",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(boxes)",
                            "Call"
                        ],
                        [
                            "tf.transpose(boxes, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.tile(boxes, [num_cat, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "all_indices",
                    "possible_values": [
                        [
                            "tf.concat([fg_inds, bg_inds], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "sampled_proposal_boxes",
                    "possible_values": []
                }
            },
            "concat_234": {
                "variable": {
                    "value": "ret_labels",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.gather(gt_labels, fg_inds_wrt_gt), tf.zeros_like(bg_inds, dtype=tf.int64)]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                },
                "name": {
                    "value": "sampled_labels",
                    "possible_values": []
                }
            },
            "concat_238": {
                "variable": {
                    "value": "ret_target_ids",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.gather(target_ids, fg_inds_wrt_gt), tf.zeros_like(bg_inds, dtype=target_ids.dtype)]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                },
                "name": {
                    "value": "sampled_target_ids",
                    "possible_values": []
                }
            },
            "crop_and_resize_292": {
                "variable": {
                    "value": "ret",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "possible_values": [
                        [
                            "tf.pad(image, [[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ]
                    ]
                },
                "boxes": {
                    "value": "boxes",
                    "possible_values": [
                        [
                            "tf.maximum(boxes, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.minimum(boxes, tf.to_float(m), name=name)",
                            "Call"
                        ],
                        [
                            "tf.concat([boxes, gt_boxes], axis=0)",
                            "Call"
                        ],
                        [
                            "boxes + 1",
                            "BinOp"
                        ],
                        [
                            "transform_fpcoor_for_tf(boxes, image_shape, [crop_size, crop_size])",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(boxes)",
                            "Call"
                        ],
                        [
                            "tf.transpose(boxes, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.tile(boxes, [num_cat, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "box_indices": {
                    "value": "box_ind",
                    "possible_values": []
                },
                "crop_size": {
                    "value": "[crop_size, crop_size]",
                    "possible_values": []
                }
            },
            "stop_gradient_307": {
                "variable": {
                    "value": "boxes",
                    "possible_values": []
                },
                "input": {
                    "value": "boxes",
                    "possible_values": [
                        [
                            "tf.maximum(boxes, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.minimum(boxes, tf.to_float(m), name=name)",
                            "Call"
                        ],
                        [
                            "tf.concat([boxes, gt_boxes], axis=0)",
                            "Call"
                        ],
                        [
                            "boxes + 1",
                            "BinOp"
                        ],
                        [
                            "transform_fpcoor_for_tf(boxes, image_shape, [crop_size, crop_size])",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(boxes)",
                            "Call"
                        ],
                        [
                            "tf.transpose(boxes, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.tile(boxes, [num_cat, 1, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "avg_pool_313": {
                "variable": {
                    "value": "ret",
                    "possible_values": []
                },
                "input": {
                    "value": "ret",
                    "possible_values": [
                        [
                            "tf.image.crop_and_resize(image, boxes, box_ind, crop_size=[crop_size, crop_size])",
                            "Call"
                        ],
                        [
                            "crop_and_resize(featuremap, boxes, tf.zeros([tf.shape(boxes)[0]], dtype=tf.int32), output_shape * 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(ret, [1, 2, 2, 1], [1, 2, 2, 1], padding='SAME', data_format='NHWC')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 2, 2, 1]",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "possible_values": []
                },
                "data_format": {
                    "value": "NHWC",
                    "possible_values": []
                }
            },
            "boolean_mask_334": {
                "variable": {
                    "value": "valid_label_logits",
                    "possible_values": []
                },
                "tensor": {
                    "value": "label_logits",
                    "possible_values": []
                },
                "mask": {
                    "value": "valid_mask",
                    "possible_values": [
                        [
                            "tf.stop_gradient(tf.not_equal(anchor_labels, -1))",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_cross_entropy_with_logits_356": {
                "variable": {
                    "value": "label_loss",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.to_float(valid_anchor_labels)",
                    "possible_values": []
                },
                "logits": {
                    "value": "valid_label_logits",
                    "possible_values": [
                        [
                            "tf.boolean_mask(label_logits, valid_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_358": {
                "variable": {
                    "value": "label_loss",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "label_loss",
                    "possible_values": [
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=tf.to_float(valid_anchor_labels), logits=valid_label_logits)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(label_loss, name='label_loss')",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(labels=labels, logits=label_logits)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(label_loss, name='label_loss')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "label_loss",
                    "possible_values": []
                }
            },
            "boolean_mask_360": {
                "variable": {
                    "value": "pos_anchor_boxes",
                    "possible_values": []
                },
                "tensor": {
                    "value": "anchor_boxes",
                    "possible_values": []
                },
                "mask": {
                    "value": "pos_mask",
                    "possible_values": [
                        [
                            "tf.stop_gradient(tf.equal(anchor_labels, 1))",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_361": {
                "variable": {
                    "value": "pos_box_logits",
                    "possible_values": []
                },
                "tensor": {
                    "value": "box_logits",
                    "possible_values": []
                },
                "mask": {
                    "value": "pos_mask",
                    "possible_values": [
                        [
                            "tf.stop_gradient(tf.equal(anchor_labels, 1))",
                            "Call"
                        ]
                    ]
                }
            },
            "div_366": {
                "variable": {
                    "value": "box_loss",
                    "possible_values": []
                },
                "x": {
                    "value": "box_loss",
                    "possible_values": [
                        [
                            "tf.losses.huber_loss(pos_anchor_boxes, pos_box_logits, delta=delta, reduction=tf.losses.Reduction.SUM) / delta",
                            "BinOp"
                        ],
                        [
                            "tf.div(box_loss, tf.cast(nr_valid, tf.float32), name='box_loss')",
                            "Call"
                        ],
                        [
                            "tf.losses.huber_loss(fg_boxes, fg_box_logits, reduction=tf.losses.Reduction.SUM)",
                            "Call"
                        ],
                        [
                            "tf.truediv(box_loss, tf.to_float(tf.shape(labels)[0]), name='box_loss')",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.cast(nr_valid, tf.float32)",
                    "possible_values": []
                },
                "name": {
                    "value": "box_loss",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_382": {
                "variable": {
                    "value": "label_loss",
                    "possible_values": []
                },
                "labels": {
                    "value": "labels",
                    "possible_values": []
                },
                "logits": {
                    "value": "label_logits",
                    "possible_values": []
                }
            },
            "reduce_mean_384": {
                "variable": {
                    "value": "label_loss",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "label_loss",
                    "possible_values": [
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=tf.to_float(valid_anchor_labels), logits=valid_label_logits)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(label_loss, name='label_loss')",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(labels=labels, logits=label_logits)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(label_loss, name='label_loss')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "label_loss",
                    "possible_values": []
                }
            },
            "gather_387": {
                "variable": {
                    "value": "fg_labels",
                    "possible_values": []
                },
                "params": {
                    "value": "labels",
                    "possible_values": []
                },
                "indices": {
                    "value": "fg_inds",
                    "possible_values": [
                        [
                            "tf.reshape(tf.where(fg_mask), [-1])",
                            "Call"
                        ],
                        [
                            "tf.random_shuffle(fg_inds)[:num_fg]",
                            "Subscript"
                        ],
                        [
                            "tf.where(labels > 0)[:, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "size_388": {
                "variable": {
                    "value": "num_fg",
                    "possible_values": []
                },
                "input": {
                    "value": "fg_inds",
                    "possible_values": [
                        [
                            "tf.reshape(tf.where(fg_mask), [-1])",
                            "Call"
                        ],
                        [
                            "tf.random_shuffle(fg_inds)[:num_fg]",
                            "Subscript"
                        ],
                        [
                            "tf.where(labels > 0)[:, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "stack_389": {
                "variable": {
                    "value": "indices",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.range(num_fg), tf.to_int32(fg_labels) - 1]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "gather_nd_392": {
                "variable": {
                    "value": "fg_box_logits",
                    "possible_values": []
                },
                "params": {
                    "value": "fg_box_logits",
                    "possible_values": [
                        [
                            "tf.gather_nd(fg_box_logits, indices)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(num_fg), tf.to_int32(fg_labels) - 1], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([tf.range(num_fg), tf.to_int32(fg_labels) - 1], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "huber_loss_404": {
                "variable": {
                    "value": "box_loss",
                    "possible_values": []
                },
                "labels": {
                    "value": "fg_boxes",
                    "possible_values": []
                },
                "predictions": {
                    "value": "fg_box_logits",
                    "possible_values": [
                        [
                            "tf.gather_nd(fg_box_logits, indices)",
                            "Call"
                        ]
                    ]
                },
                "reduction": {
                    "value": "tf.losses.Reduction.SUM",
                    "possible_values": []
                }
            },
            "truediv_406": {
                "variable": {
                    "value": "box_loss",
                    "possible_values": []
                },
                "x": {
                    "value": "box_loss",
                    "possible_values": [
                        [
                            "tf.losses.huber_loss(pos_anchor_boxes, pos_box_logits, delta=delta, reduction=tf.losses.Reduction.SUM) / delta",
                            "BinOp"
                        ],
                        [
                            "tf.div(box_loss, tf.cast(nr_valid, tf.float32), name='box_loss')",
                            "Call"
                        ],
                        [
                            "tf.losses.huber_loss(fg_boxes, fg_box_logits, reduction=tf.losses.Reduction.SUM)",
                            "Call"
                        ],
                        [
                            "tf.truediv(box_loss, tf.to_float(tf.shape(labels)[0]), name='box_loss')",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.to_float(tf.shape(labels)[0])",
                    "possible_values": []
                },
                "name": {
                    "value": "box_loss",
                    "possible_values": []
                }
            },
            "transpose_425": {
                "variable": {
                    "value": "boxes",
                    "possible_values": []
                },
                "a": {
                    "value": "boxes",
                    "possible_values": [
                        [
                            "tf.maximum(boxes, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.minimum(boxes, tf.to_float(m), name=name)",
                            "Call"
                        ],
                        [
                            "tf.concat([boxes, gt_boxes], axis=0)",
                            "Call"
                        ],
                        [
                            "boxes + 1",
                            "BinOp"
                        ],
                        [
                            "transform_fpcoor_for_tf(boxes, image_shape, [crop_size, crop_size])",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(boxes)",
                            "Call"
                        ],
                        [
                            "tf.transpose(boxes, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.tile(boxes, [num_cat, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "possible_values": []
                }
            },
            "transpose_426": {
                "variable": {
                    "value": "probs",
                    "possible_values": []
                },
                "a": {
                    "value": "probs[:, 1:]",
                    "possible_values": []
                },
                "perm": {
                    "value": "[1, 0]",
                    "possible_values": []
                }
            },
            "map_fn_461": {
                "variable": {
                    "value": "masks",
                    "possible_values": []
                },
                "fn": {
                    "value": "f",
                    "possible_values": []
                },
                "elems": {
                    "value": "(probs, boxes)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "possible_values": []
                },
                "parallel_iterations": {
                    "value": "10",
                    "possible_values": []
                }
            },
            "where_463": {
                "variable": {
                    "value": "selected_indices",
                    "possible_values": []
                },
                "condition": {
                    "value": "masks",
                    "possible_values": [
                        [
                            "tf.map_fn(f, (probs, boxes), dtype=tf.bool, parallel_iterations=10)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_464": {
                "variable": {
                    "value": "probs",
                    "possible_values": []
                },
                "tensor": {
                    "value": "probs",
                    "possible_values": [
                        [
                            "tf.transpose(probs[:, 1:], [1, 0])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(probs, masks)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "masks",
                    "possible_values": [
                        [
                            "tf.map_fn(f, (probs, boxes), dtype=tf.bool, parallel_iterations=10)",
                            "Call"
                        ]
                    ]
                }
            },
            "top_k_467": {
                "variable": {
                    "value": "(topk_probs, topk_indices)",
                    "possible_values": []
                },
                "input": {
                    "value": "probs",
                    "possible_values": [
                        [
                            "tf.transpose(probs[:, 1:], [1, 0])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(probs, masks)",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "tf.minimum(RESULTS_PER_IM, tf.size(probs))",
                    "possible_values": []
                },
                "sorted": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "gather_471": {
                "variable": {
                    "value": "filtered_selection",
                    "possible_values": []
                },
                "params": {
                    "value": "selected_indices",
                    "possible_values": [
                        [
                            "tf.where(masks)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "topk_indices",
                    "possible_values": []
                }
            },
            "reverse_472": {
                "variable": {
                    "value": "filtered_selection",
                    "possible_values": []
                },
                "tensor": {
                    "value": "filtered_selection",
                    "possible_values": [
                        [
                            "tf.gather(selected_indices, topk_indices)",
                            "Call"
                        ],
                        [
                            "tf.reverse(filtered_selection, axis=[1], name='filtered_indices')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1]",
                    "possible_values": []
                },
                "name": {
                    "value": "filtered_indices",
                    "possible_values": []
                }
            },
            "size_486": {
                "variable": {
                    "value": "num_fg",
                    "possible_values": []
                },
                "input": {
                    "value": "fg_labels",
                    "possible_values": [
                        [
                            "tf.gather(labels, fg_inds)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.greater(fg_labels, 0), fg_labels.dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_487": {
                "variable": {
                    "value": "indices",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.range(num_fg), tf.to_int32(fg_labels) - 1]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "transpose_489": {
                "variable": {
                    "value": "mask_logits",
                    "possible_values": []
                },
                "a": {
                    "value": "mask_logits",
                    "possible_values": [
                        [
                            "tf.transpose(mask_logits, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(mask_logits, indices)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 3, 1, 2]",
                    "possible_values": []
                }
            },
            "gather_nd_490": {
                "variable": {
                    "value": "mask_logits",
                    "possible_values": []
                },
                "params": {
                    "value": "mask_logits",
                    "possible_values": [
                        [
                            "tf.transpose(mask_logits, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(mask_logits, indices)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(num_fg), tf.to_int32(fg_labels) - 1], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([tf.range(num_fg), tf.to_int32(fg_labels) - 1], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_491": {
                "variable": {
                    "value": "mask_probs",
                    "possible_values": []
                },
                "x": {
                    "value": "mask_logits",
                    "possible_values": [
                        [
                            "tf.transpose(mask_logits, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(mask_logits, indices)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_cross_entropy_with_logits_500": {
                "variable": {
                    "value": "loss",
                    "possible_values": []
                },
                "labels": {
                    "value": "fg_target_masks",
                    "possible_values": []
                },
                "logits": {
                    "value": "mask_logits",
                    "possible_values": [
                        [
                            "tf.transpose(mask_logits, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(mask_logits, indices)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_502": {
                "variable": {
                    "value": "loss",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "loss",
                    "possible_values": [
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=fg_target_masks, logits=mask_logits)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(loss, name='maskrcnn_loss')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "maskrcnn_loss",
                    "possible_values": []
                }
            },
            "reduce_mean_506": {
                "variable": {
                    "value": "accuracy",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.to_float(tf.equal(pred_label, truth_label))",
                    "possible_values": []
                },
                "name": {
                    "value": "accuracy",
                    "possible_values": []
                }
            },
            "logical_and_509": {
                "variable": {
                    "value": "pos_accuracy",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(pred_label, truth_label)",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.equal(truth_label, True)",
                    "possible_values": []
                }
            },
            "reduce_mean_512": {
                "variable": {
                    "value": "pos_accuracy",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.to_float(pos_accuracy)",
                    "possible_values": []
                },
                "name": {
                    "value": "pos_accuracy",
                    "possible_values": []
                }
            },
            "reduce_mean_513": {
                "variable": {
                    "value": "fg_pixel_ratio",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.to_float(truth_label)",
                    "possible_values": []
                },
                "name": {
                    "value": "fg_pixel_ratio",
                    "possible_values": []
                }
            },
            "reshape_45": {
                "tensor": {
                    "value": "out",
                    "possible_values": [
                        [
                            "tf.concat([x1y1, x2y2], axis=-2)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "orig_shape",
                    "possible_values": [
                        [
                            "tf.shape(anchors)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_70": {
                "tensor": {
                    "value": "encoded",
                    "possible_values": [
                        [
                            "tf.concat([txty, twth], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.shape(boxes)",
                    "possible_values": []
                }
            },
            "sigmoid_133": {
                "x": {
                    "value": "final_scores",
                    "possible_values": [
                        [
                            "tf.gather(topk_valid_scores, nms_indices, name='scores')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "probs",
                    "possible_values": []
                }
            },
            "squeeze_145": {
                "input": {
                    "value": "(y_max - y_min) * (x_max - x_min)",
                    "possible_values": []
                },
                "axis": {
                    "value": "[1]",
                    "possible_values": []
                }
            },
            "where_180": {
                "condition": {
                    "value": "tf.equal(intersections, 0.0)",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.zeros_like(intersections)",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.truediv(intersections, unions)",
                    "possible_values": []
                }
            },
            "reshape_210": {
                "variable": {
                    "value": "fg_inds",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.where(fg_mask)",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "possible_values": []
                }
            },
            "minimum_211": {
                "variable": {
                    "value": "num_fg",
                    "possible_values": []
                },
                "x": {
                    "value": "int(fastrcnn_batch_per_img * FASTRCNN_FG_RATIO)",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.size(fg_inds)",
                    "possible_values": []
                },
                "name": {
                    "value": "num_fg",
                    "possible_values": []
                }
            },
            "reshape_216": {
                "variable": {
                    "value": "bg_inds",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.where(tf.logical_not(fg_mask))",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "possible_values": []
                }
            },
            "minimum_217": {
                "variable": {
                    "value": "num_bg",
                    "possible_values": []
                },
                "x": {
                    "value": "fastrcnn_batch_per_img - num_fg",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.size(bg_inds)",
                    "possible_values": []
                },
                "name": {
                    "value": "num_bg",
                    "possible_values": []
                }
            },
            "pad_260": {
                "variable": {
                    "value": "image",
                    "possible_values": []
                },
                "tensor": {
                    "value": "image",
                    "possible_values": [
                        [
                            "tf.pad(image, [[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [1, 1], [1, 1], [0, 0]]",
                    "possible_values": []
                },
                "mode": {
                    "value": "SYMMETRIC",
                    "possible_values": []
                }
            },
            "split_277": {
                "variable": {
                    "value": "(x0, y0, x1, y1)",
                    "possible_values": []
                },
                "value": {
                    "value": "boxes",
                    "possible_values": [
                        [
                            "tf.maximum(boxes, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.minimum(boxes, tf.to_float(m), name=name)",
                            "Call"
                        ],
                        [
                            "tf.concat([boxes, gt_boxes], axis=0)",
                            "Call"
                        ],
                        [
                            "boxes + 1",
                            "BinOp"
                        ],
                        [
                            "transform_fpcoor_for_tf(boxes, image_shape, [crop_size, crop_size])",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(boxes)",
                            "Call"
                        ],
                        [
                            "tf.transpose(boxes, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.tile(boxes, [num_cat, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "stop_gradient_328": {
                "variable": {
                    "value": "valid_mask",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.not_equal(anchor_labels, -1)",
                    "possible_values": []
                }
            },
            "stop_gradient_329": {
                "variable": {
                    "value": "pos_mask",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.equal(anchor_labels, 1)",
                    "possible_values": []
                }
            },
            "stop_gradient_330": {
                "variable": {
                    "value": "nr_valid",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.count_nonzero(valid_mask, dtype=tf.int32)",
                    "possible_values": []
                },
                "name": {
                    "value": "num_valid_anchor",
                    "possible_values": []
                }
            },
            "count_nonzero_331": {
                "variable": {
                    "value": "nr_pos",
                    "possible_values": []
                },
                "input": {
                    "value": "pos_mask",
                    "possible_values": [
                        [
                            "tf.stop_gradient(tf.equal(anchor_labels, 1))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                },
                "name": {
                    "value": "num_pos_anchor",
                    "possible_values": []
                }
            },
            "boolean_mask_333": {
                "variable": {
                    "value": "valid_anchor_labels",
                    "possible_values": []
                },
                "tensor": {
                    "value": "anchor_labels",
                    "possible_values": []
                },
                "mask": {
                    "value": "valid_mask",
                    "possible_values": [
                        [
                            "tf.stop_gradient(tf.not_equal(anchor_labels, -1))",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_337": {
                "variable": {
                    "value": "valid_label_prob",
                    "possible_values": []
                },
                "x": {
                    "value": "valid_label_logits",
                    "possible_values": [
                        [
                            "tf.boolean_mask(label_logits, valid_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_430": {
                "variable": {
                    "value": "boxes",
                    "possible_values": []
                },
                "input": {
                    "value": "boxes",
                    "possible_values": [
                        [
                            "tf.maximum(boxes, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.minimum(boxes, tf.to_float(m), name=name)",
                            "Call"
                        ],
                        [
                            "tf.concat([boxes, gt_boxes], axis=0)",
                            "Call"
                        ],
                        [
                            "boxes + 1",
                            "BinOp"
                        ],
                        [
                            "transform_fpcoor_for_tf(boxes, image_shape, [crop_size, crop_size])",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(boxes)",
                            "Call"
                        ],
                        [
                            "tf.transpose(boxes, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.tile(boxes, [num_cat, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[num_cat, 1, 1]",
                    "possible_values": []
                }
            },
            "shape_439": {
                "variable": {
                    "value": "output_shape",
                    "possible_values": []
                },
                "input": {
                    "value": "prob",
                    "possible_values": [
                        [
                            "tf.gather(prob, ids)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_441": {
                "variable": {
                    "value": "ids",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.where(prob > result_score_thresh)",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "possible_values": []
                }
            },
            "gather_442": {
                "variable": {
                    "value": "prob",
                    "possible_values": []
                },
                "params": {
                    "value": "prob",
                    "possible_values": [
                        [
                            "tf.gather(prob, ids)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "ids",
                    "possible_values": [
                        [
                            "tf.reshape(tf.where(prob > result_score_thresh), [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_443": {
                "variable": {
                    "value": "box",
                    "possible_values": []
                },
                "params": {
                    "value": "box",
                    "possible_values": [
                        [
                            "tf.gather(box, ids)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "ids",
                    "possible_values": [
                        [
                            "tf.reshape(tf.where(prob > result_score_thresh), [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "non_max_suppression_448": {
                "variable": {
                    "value": "selection",
                    "possible_values": []
                },
                "boxes": {
                    "value": "box",
                    "possible_values": [
                        [
                            "tf.gather(box, ids)",
                            "Call"
                        ]
                    ]
                },
                "scores": {
                    "value": "prob",
                    "possible_values": [
                        [
                            "tf.gather(prob, ids)",
                            "Call"
                        ]
                    ]
                },
                "max_output_size": {
                    "value": "RESULTS_PER_IM",
                    "possible_values": [
                        [
                            "100",
                            "Constant"
                        ]
                    ]
                },
                "iou_threshold": {
                    "value": "FASTRCNN_NMS_THRESH",
                    "possible_values": [
                        [
                            "0.5",
                            "Constant"
                        ]
                    ]
                }
            },
            "to_int32_450": {
                "variable": {
                    "value": "selection",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.gather(ids, selection)",
                    "possible_values": []
                }
            },
            "sparse_to_dense_454": {
                "variable": {
                    "value": "mask",
                    "possible_values": []
                },
                "sparse_indices": {
                    "value": "sorted_selection",
                    "possible_values": [
                        [
                            "-tf.nn.top_k(-selection, k=tf.size(selection))[0]",
                            "UnaryOp"
                        ]
                    ]
                },
                "output_shape": {
                    "value": "output_shape",
                    "possible_values": [
                        [
                            "tf.shape(prob)",
                            "Call"
                        ]
                    ]
                },
                "sparse_values": {
                    "value": "True",
                    "possible_values": []
                },
                "default_value": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "cast_485": {
                "variable": {
                    "value": "fg_labels",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.greater(fg_labels, 0)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "fg_labels.dtype",
                    "possible_values": []
                }
            },
            "concat_495": {
                "variable": {
                    "value": "viz",
                    "possible_values": []
                },
                "values": {
                    "value": "[fg_target_masks, mask_probs]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_496": {
                "variable": {
                    "value": "viz",
                    "possible_values": []
                },
                "input": {
                    "value": "viz",
                    "possible_values": [
                        [
                            "tf.concat([fg_target_masks, mask_probs], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(viz, 3)",
                            "Call"
                        ],
                        [
                            "tf.cast(viz * 255, tf.uint8, name='viz')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "possible_values": []
                }
            },
            "cast_497": {
                "variable": {
                    "value": "viz",
                    "possible_values": []
                },
                "x": {
                    "value": "viz * 255",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.uint8",
                    "possible_values": []
                },
                "name": {
                    "value": "viz",
                    "possible_values": []
                }
            },
            "exp_39": {
                "x": {
                    "value": "tf.minimum(box_pred_twth, BBOX_DECODE_CLIP)",
                    "possible_values": []
                }
            },
            "shape_70": {
                "input": {
                    "value": "boxes",
                    "possible_values": [
                        [
                            "tf.maximum(boxes, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.minimum(boxes, tf.to_float(m), name=name)",
                            "Call"
                        ],
                        [
                            "tf.concat([boxes, gt_boxes], axis=0)",
                            "Call"
                        ],
                        [
                            "boxes + 1",
                            "BinOp"
                        ],
                        [
                            "transform_fpcoor_for_tf(boxes, image_shape, [crop_size, crop_size])",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(boxes)",
                            "Call"
                        ],
                        [
                            "tf.transpose(boxes, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.tile(boxes, [num_cat, 1, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reverse_80": {
                "tensor": {
                    "value": "window",
                    "possible_values": []
                },
                "axis": {
                    "value": "[0]",
                    "possible_values": []
                }
            },
            "to_float_81": {
                "x": {
                    "value": "m",
                    "possible_values": [
                        [
                            "tf.tile(tf.reverse(window, [0]), [2])",
                            "Call"
                        ]
                    ]
                }
            },
            "size_103": {
                "input": {
                    "value": "scores",
                    "possible_values": []
                }
            },
            "reverse_117": {
                "tensor": {
                    "value": "topk_valid_boxes_x1y1x2y2",
                    "possible_values": [
                        [
                            "tf.boolean_mask(topk_boxes_x1y1x2y2, valid)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2]",
                    "possible_values": []
                }
            },
            "transpose_158": {
                "a": {
                    "value": "y_max2",
                    "possible_values": []
                }
            },
            "transpose_159": {
                "a": {
                    "value": "y_min2",
                    "possible_values": []
                }
            },
            "transpose_161": {
                "a": {
                    "value": "x_max2",
                    "possible_values": []
                }
            },
            "transpose_162": {
                "a": {
                    "value": "x_min2",
                    "possible_values": []
                }
            },
            "equal_181": {
                "x": {
                    "value": "intersections",
                    "possible_values": [
                        [
                            "pairwise_intersection(boxlist1, boxlist2)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0.0",
                    "possible_values": []
                }
            },
            "zeros_like_182": {
                "input": {
                    "value": "intersections",
                    "possible_values": [
                        [
                            "pairwise_intersection(boxlist1, boxlist2)",
                            "Call"
                        ]
                    ]
                }
            },
            "truediv_182": {
                "x": {
                    "value": "intersections",
                    "possible_values": [
                        [
                            "pairwise_intersection(boxlist1, boxlist2)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "unions",
                    "possible_values": [
                        [
                            "tf.expand_dims(areas1, 1) + tf.expand_dims(areas2, 0) - intersections",
                            "BinOp"
                        ]
                    ]
                }
            },
            "stop_gradient_241": {
                "input": {
                    "value": "ret_target_ids",
                    "possible_values": [
                        [
                            "tf.concat([tf.gather(target_ids, fg_inds_wrt_gt), tf.zeros_like(bg_inds, dtype=target_ids.dtype)], axis=0, name='sampled_target_ids')",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_288": {
                "values": {
                    "value": "[ny0, nx0, ny0 + nh, nx0 + nw]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "shape_290": {
                "input": {
                    "value": "image",
                    "possible_values": [
                        [
                            "tf.pad(image, [[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_311": {
                "shape": {
                    "value": "[tf.shape(boxes)[0]]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "device_327": {
                "device_name": {
                    "value": "/cpu:0",
                    "possible_values": []
                }
            },
            "name_scope_336": {
                "name": {
                    "value": "label_metrics",
                    "possible_values": []
                }
            },
            "huber_loss_363": {
                "labels": {
                    "value": "pos_anchor_boxes",
                    "possible_values": [
                        [
                            "tf.boolean_mask(anchor_boxes, pos_mask)",
                            "Call"
                        ]
                    ]
                },
                "predictions": {
                    "value": "pos_box_logits",
                    "possible_values": [
                        [
                            "tf.boolean_mask(box_logits, pos_mask)",
                            "Call"
                        ]
                    ]
                },
                "delta": {
                    "value": "delta",
                    "possible_values": [
                        [
                            "1.0 / 9",
                            "BinOp"
                        ]
                    ]
                },
                "reduction": {
                    "value": "tf.losses.Reduction.SUM",
                    "possible_values": []
                }
            },
            "cast_368": {
                "x": {
                    "value": "nr_valid",
                    "possible_values": [
                        [
                            "tf.stop_gradient(tf.count_nonzero(valid_mask, dtype=tf.int32), name='num_valid_anchor')",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "where_386": {
                "condition": {
                    "value": "labels > 0",
                    "possible_values": []
                }
            },
            "to_float_407": {
                "x": {
                    "value": "tf.shape(labels)[0]",
                    "possible_values": []
                }
            },
            "minimum_469": {
                "x": {
                    "value": "RESULTS_PER_IM",
                    "possible_values": [
                        [
                            "100",
                            "Constant"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.size(probs)",
                    "possible_values": []
                }
            },
            "name_scope_494": {
                "name": {
                    "value": "mask_viz",
                    "possible_values": []
                }
            },
            "image_498": {
                "name": {
                    "value": "mask_truth|pred",
                    "possible_values": []
                },
                "data": {
                    "value": "viz",
                    "possible_values": [
                        [
                            "tf.concat([fg_target_masks, mask_probs], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(viz, 3)",
                            "Call"
                        ],
                        [
                            "tf.cast(viz * 255, tf.uint8, name='viz')",
                            "Call"
                        ]
                    ]
                },
                "max_outputs": {
                    "value": "10",
                    "possible_values": []
                }
            },
            "to_float_507": {
                "x": {
                    "value": "tf.equal(pred_label, truth_label)",
                    "possible_values": []
                }
            },
            "equal_510": {
                "x": {
                    "value": "pred_label",
                    "possible_values": [
                        [
                            "mask_probs > 0.5",
                            "Compare"
                        ]
                    ]
                },
                "y": {
                    "value": "truth_label",
                    "possible_values": [
                        [
                            "fg_target_masks > 0.5",
                            "Compare"
                        ]
                    ]
                }
            },
            "equal_511": {
                "x": {
                    "value": "truth_label",
                    "possible_values": [
                        [
                            "fg_target_masks > 0.5",
                            "Compare"
                        ]
                    ]
                },
                "y": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "to_float_512": {
                "x": {
                    "value": "pos_accuracy",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.equal(pred_label, truth_label), tf.equal(truth_label, True))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.to_float(pos_accuracy), name='pos_accuracy')",
                            "Call"
                        ]
                    ]
                }
            },
            "to_float_513": {
                "x": {
                    "value": "truth_label",
                    "possible_values": [
                        [
                            "fg_target_masks > 0.5",
                            "Compare"
                        ]
                    ]
                }
            },
            "minimum_39": {
                "x": {
                    "value": "box_pred_twth",
                    "possible_values": []
                },
                "y": {
                    "value": "BBOX_DECODE_CLIP",
                    "possible_values": []
                }
            },
            "expand_dims_179": {
                "input": {
                    "value": "areas2",
                    "possible_values": [
                        [
                            "area(boxlist2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "eye_203": {
                "num_rows": {
                    "value": "tf.shape(gt_boxes)[0]",
                    "possible_values": []
                }
            },
            "reduce_max_208": {
                "input_tensor": {
                    "value": "iou",
                    "possible_values": [
                        [
                            "pairwise_iou(boxes, gt_boxes)",
                            "Call"
                        ],
                        [
                            "tf.concat([iou, tf.eye(tf.shape(gt_boxes)[0])], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "where_210": {
                "condition": {
                    "value": "fg_mask",
                    "possible_values": [
                        [
                            "tf.reduce_max(iou, axis=1) >= FASTRCNN_FG_THRESH",
                            "Compare"
                        ]
                    ]
                }
            },
            "size_213": {
                "input": {
                    "value": "fg_inds",
                    "possible_values": [
                        [
                            "tf.reshape(tf.where(fg_mask), [-1])",
                            "Call"
                        ],
                        [
                            "tf.random_shuffle(fg_inds)[:num_fg]",
                            "Subscript"
                        ],
                        [
                            "tf.where(labels > 0)[:, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "where_216": {
                "condition": {
                    "value": "tf.logical_not(fg_mask)",
                    "possible_values": []
                }
            },
            "size_219": {
                "input": {
                    "value": "bg_inds",
                    "possible_values": [
                        [
                            "tf.reshape(tf.where(tf.logical_not(fg_mask)), [-1])",
                            "Call"
                        ],
                        [
                            "tf.random_shuffle(bg_inds)[:num_bg]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "gather_235": {
                "params": {
                    "value": "gt_labels",
                    "possible_values": []
                },
                "indices": {
                    "value": "fg_inds_wrt_gt",
                    "possible_values": [
                        [
                            "tf.gather(best_iou_ind, fg_inds)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_236": {
                "input": {
                    "value": "bg_inds",
                    "possible_values": [
                        [
                            "tf.reshape(tf.where(tf.logical_not(fg_mask)), [-1])",
                            "Call"
                        ],
                        [
                            "tf.random_shuffle(bg_inds)[:num_bg]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "possible_values": []
                }
            },
            "gather_238": {
                "params": {
                    "value": "target_ids",
                    "possible_values": []
                },
                "indices": {
                    "value": "fg_inds_wrt_gt",
                    "possible_values": [
                        [
                            "tf.gather(best_iou_ind, fg_inds)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_238": {
                "input": {
                    "value": "bg_inds",
                    "possible_values": [
                        [
                            "tf.reshape(tf.where(tf.logical_not(fg_mask)), [-1])",
                            "Call"
                        ],
                        [
                            "tf.random_shuffle(bg_inds)[:num_bg]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "target_ids.dtype",
                    "possible_values": []
                }
            },
            "to_float_279": {
                "x": {
                    "value": "crop_shape[1]",
                    "possible_values": []
                }
            },
            "to_float_280": {
                "x": {
                    "value": "crop_shape[0]",
                    "possible_values": []
                }
            },
            "to_float_282": {
                "x": {
                    "value": "image_shape[1] - 1",
                    "possible_values": []
                }
            },
            "to_float_283": {
                "x": {
                    "value": "image_shape[0] - 1",
                    "possible_values": []
                }
            },
            "to_float_285": {
                "x": {
                    "value": "crop_shape[1] - 1",
                    "possible_values": []
                }
            },
            "to_float_286": {
                "x": {
                    "value": "crop_shape[0] - 1",
                    "possible_values": []
                }
            },
            "not_equal_328": {
                "x": {
                    "value": "anchor_labels",
                    "possible_values": []
                },
                "y": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "equal_329": {
                "x": {
                    "value": "anchor_labels",
                    "possible_values": []
                },
                "y": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "count_nonzero_330": {
                "input": {
                    "value": "valid_mask",
                    "possible_values": [
                        [
                            "tf.stop_gradient(tf.not_equal(anchor_labels, -1))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "device_339": {
                "device_name": {
                    "value": "/cpu:0",
                    "possible_values": []
                }
            },
            "cast_341": {
                "variable": {
                    "value": "valid_prediction",
                    "possible_values": []
                },
                "x": {
                    "value": "valid_label_prob > th",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "reduce_sum_342": {
                "variable": {
                    "value": "nr_pos_prediction",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "valid_prediction",
                    "possible_values": [
                        [
                            "tf.cast(valid_label_prob > th, tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "num_pos_prediction",
                    "possible_values": []
                }
            },
            "count_nonzero_343": {
                "variable": {
                    "value": "pos_prediction_corr",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.logical_and(valid_label_prob > th, tf.equal(valid_prediction, valid_anchor_labels))",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "to_float_351": {
                "variable": {
                    "value": "precision",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.truediv(pos_prediction_corr, nr_pos_prediction)",
                    "possible_values": []
                }
            },
            "where_352": {
                "variable": {
                    "value": "precision",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.equal(nr_pos_prediction, 0)",
                    "possible_values": []
                },
                "x": {
                    "value": "0.0",
                    "possible_values": []
                },
                "y": {
                    "value": "precision",
                    "possible_values": [
                        [
                            "tf.to_float(tf.truediv(pos_prediction_corr, nr_pos_prediction))",
                            "Call"
                        ],
                        [
                            "tf.where(tf.equal(nr_pos_prediction, 0), 0.0, precision, name='precision_th{}'.format(th))",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "'precision_th{}'.format(th)",
                    "possible_values": []
                }
            },
            "to_float_357": {
                "x": {
                    "value": "valid_anchor_labels",
                    "possible_values": [
                        [
                            "tf.boolean_mask(anchor_labels, valid_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_429": {
                "input": {
                    "value": "probs",
                    "possible_values": [
                        [
                            "tf.transpose(probs[:, 1:], [1, 0])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(probs, masks)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_441": {
                "condition": {
                    "value": "prob > result_score_thresh",
                    "possible_values": []
                }
            },
            "gather_450": {
                "params": {
                    "value": "ids",
                    "possible_values": [
                        [
                            "tf.reshape(tf.where(prob > result_score_thresh), [-1])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "selection",
                    "possible_values": [
                        [
                            "tf.image.non_max_suppression(box, prob, RESULTS_PER_IM, FASTRCNN_NMS_THRESH)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(tf.gather(ids, selection))",
                            "Call"
                        ]
                    ]
                }
            },
            "size_469": {
                "input": {
                    "value": "probs",
                    "possible_values": [
                        [
                            "tf.transpose(probs[:, 1:], [1, 0])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(probs, masks)",
                            "Call"
                        ]
                    ]
                }
            },
            "greater_485": {
                "x": {
                    "value": "fg_labels",
                    "possible_values": [
                        [
                            "tf.gather(labels, fg_inds)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.greater(fg_labels, 0), fg_labels.dtype)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "equal_507": {
                "x": {
                    "value": "pred_label",
                    "possible_values": [
                        [
                            "mask_probs > 0.5",
                            "Compare"
                        ]
                    ]
                },
                "y": {
                    "value": "truth_label",
                    "possible_values": [
                        [
                            "fg_target_masks > 0.5",
                            "Compare"
                        ]
                    ]
                }
            },
            "logical_not_216": {
                "x": {
                    "value": "fg_mask",
                    "possible_values": [
                        [
                            "tf.reduce_max(iou, axis=1) >= FASTRCNN_FG_THRESH",
                            "Compare"
                        ]
                    ]
                }
            },
            "to_int32_391": {
                "x": {
                    "value": "fg_labels",
                    "possible_values": [
                        [
                            "tf.gather(labels, fg_inds)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.greater(fg_labels, 0), fg_labels.dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_407": {
                "input": {
                    "value": "labels",
                    "possible_values": []
                }
            },
            "top_k_453": {
                "input": {
                    "value": "-selection",
                    "possible_values": []
                },
                "k": {
                    "value": "tf.size(selection)",
                    "possible_values": []
                }
            },
            "to_int32_487": {
                "x": {
                    "value": "fg_labels",
                    "possible_values": [
                        [
                            "tf.gather(labels, fg_inds)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.greater(fg_labels, 0), fg_labels.dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_203": {
                "input": {
                    "value": "gt_boxes",
                    "possible_values": []
                }
            },
            "shape_311": {
                "input": {
                    "value": "boxes",
                    "possible_values": [
                        [
                            "tf.maximum(boxes, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.minimum(boxes, tf.to_float(m), name=name)",
                            "Call"
                        ],
                        [
                            "tf.concat([boxes, gt_boxes], axis=0)",
                            "Call"
                        ],
                        [
                            "boxes + 1",
                            "BinOp"
                        ],
                        [
                            "transform_fpcoor_for_tf(boxes, image_shape, [crop_size, crop_size])",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(boxes)",
                            "Call"
                        ],
                        [
                            "tf.transpose(boxes, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.tile(boxes, [num_cat, 1, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_and_344": {
                "x": {
                    "value": "valid_label_prob > th",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.equal(valid_prediction, valid_anchor_labels)",
                    "possible_values": []
                }
            },
            "truediv_348": {
                "x": {
                    "value": "pos_prediction_corr",
                    "possible_values": [
                        [
                            "tf.count_nonzero(tf.logical_and(valid_label_prob > th, tf.equal(valid_prediction, valid_anchor_labels)), dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "nr_pos",
                    "possible_values": [
                        [
                            "tf.count_nonzero(pos_mask, dtype=tf.int32, name='num_pos_anchor')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "'recall_th{}'.format(th)",
                    "possible_values": []
                }
            },
            "truediv_351": {
                "x": {
                    "value": "pos_prediction_corr",
                    "possible_values": [
                        [
                            "tf.count_nonzero(tf.logical_and(valid_label_prob > th, tf.equal(valid_prediction, valid_anchor_labels)), dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "nr_pos_prediction",
                    "possible_values": [
                        [
                            "tf.reduce_sum(valid_prediction, name='num_pos_prediction')",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_352": {
                "x": {
                    "value": "nr_pos_prediction",
                    "possible_values": [
                        [
                            "tf.reduce_sum(valid_prediction, name='num_pos_prediction')",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "equal_346": {
                "x": {
                    "value": "valid_prediction",
                    "possible_values": [
                        [
                            "tf.cast(valid_label_prob > th, tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "valid_anchor_labels",
                    "possible_values": [
                        [
                            "tf.boolean_mask(anchor_labels, valid_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "size_453": {
                "input": {
                    "value": "selection",
                    "possible_values": [
                        [
                            "tf.image.non_max_suppression(box, prob, RESULTS_PER_IM, FASTRCNN_NMS_THRESH)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(tf.gather(ids, selection))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "network/FullyConnected.py": {
        "tensorflow": {
            "variable_scope_14": {
                "name_or_scope": {
                    "value": "name",
                    "possible_values": []
                }
            },
            "expand_dims_17": {
                "variable": {
                    "value": "inp",
                    "possible_values": []
                },
                "input": {
                    "value": "inp",
                    "possible_values": [
                        [
                            "apply_dropout(inp, dropout)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(inp, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(inp, axis=0)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(inp, n_features_inp, batch_norm_decay, tower_setup)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(inp, axis=[0, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "expand_dims_18": {
                "variable": {
                    "value": "inp",
                    "possible_values": []
                },
                "input": {
                    "value": "inp",
                    "possible_values": [
                        [
                            "apply_dropout(inp, dropout)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(inp, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(inp, axis=0)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(inp, n_features_inp, batch_norm_decay, tower_setup)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(inp, axis=[0, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "squeeze_20": {
                "variable": {
                    "value": "inp",
                    "possible_values": []
                },
                "input": {
                    "value": "inp",
                    "possible_values": [
                        [
                            "apply_dropout(inp, dropout)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(inp, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(inp, axis=0)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(inp, n_features_inp, batch_norm_decay, tower_setup)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(inp, axis=[0, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[0, 1]",
                    "possible_values": []
                }
            },
            "matmul_23": {
                "a": {
                    "value": "inp",
                    "possible_values": [
                        [
                            "apply_dropout(inp, dropout)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(inp, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(inp, axis=0)",
                            "Call"
                        ],
                        [
                            "self.create_and_apply_batch_norm(inp, n_features_inp, batch_norm_decay, tower_setup)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(inp, axis=[0, 1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "W",
                    "possible_values": [
                        [
                            "self.create_weight_variable('W', [n_features_inp, n_features], l2, tower_setup, initializer=W_initializer)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "network/Layer.py": {
        "tensorflow": {
            "scalar_25": {
                "variable": {
                    "value": "summary",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "possible_values": []
                },
                "data": {
                    "value": "op",
                    "possible_values": []
                }
            },
            "image_29": {
                "variable": {
                    "value": "summary",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "possible_values": []
                },
                "data": {
                    "value": "im",
                    "possible_values": []
                }
            },
            "fused_batch_norm_39": {
                "variable": {
                    "value": "(xn, batch_mean, batch_var)",
                    "possible_values": []
                },
                "x": {
                    "value": "inp",
                    "possible_values": []
                },
                "scale": {
                    "value": "gamma",
                    "possible_values": []
                },
                "offset": {
                    "value": "beta",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "Layer.BATCH_NORM_EPSILON",
                    "possible_values": []
                },
                "is_training": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "fused_batch_norm_52": {
                "variable": {
                    "value": "(xn, _, _)",
                    "possible_values": []
                },
                "x": {
                    "value": "inp",
                    "possible_values": []
                },
                "scale": {
                    "value": "gamma",
                    "possible_values": []
                },
                "offset": {
                    "value": "beta",
                    "possible_values": []
                },
                "mean": {
                    "value": "moving_mean",
                    "possible_values": []
                },
                "variance": {
                    "value": "moving_var",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "Layer.BATCH_NORM_EPSILON",
                    "possible_values": []
                },
                "is_training": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "get_variable_78": {
                "variable": {
                    "value": "b",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tower_setup.dtype",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "possible_values": [
                        [
                            "tf.contrib.layers.variance_scaling_initializer(factor=2.0, mode='FAN_IN', uniform=False)",
                            "Call"
                        ],
                        [
                            "tf.constant_initializer(0.0, dtype=tower_setup.dtype)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "trainable": {
                    "value": "trainable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "device_56": {
                "device_name": {
                    "value": "tower_setup.variable_device",
                    "possible_values": []
                }
            },
            "get_variable_62": {
                "variable": {
                    "value": "W",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tower_setup.dtype",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "possible_values": [
                        [
                            "tf.contrib.layers.variance_scaling_initializer(factor=2.0, mode='FAN_IN', uniform=False)",
                            "Call"
                        ],
                        [
                            "tf.constant_initializer(0.0, dtype=tower_setup.dtype)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "trainable": {
                    "value": "trainable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "get_variable_64": {
                "variable": {
                    "value": "W",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tower_setup.dtype",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "possible_values": [
                        [
                            "tf.contrib.layers.variance_scaling_initializer(factor=2.0, mode='FAN_IN', uniform=False)",
                            "Call"
                        ],
                        [
                            "tf.constant_initializer(0.0, dtype=tower_setup.dtype)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "trainable": {
                    "value": "trainable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "histogram_68": {
                "variable": {
                    "value": "summ",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "possible_values": []
                },
                "data": {
                    "value": "W",
                    "possible_values": [
                        [
                            "tf.get_variable(name, dtype=tower_setup.dtype, initializer=initializer, trainable=trainable)",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name, shape, tower_setup.dtype, initializer, trainable=trainable)",
                            "Call"
                        ]
                    ]
                }
            },
            "device_74": {
                "device_name": {
                    "value": "tower_setup.variable_device",
                    "possible_values": []
                }
            },
            "constant_initializer_76": {
                "variable": {
                    "value": "initializer",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tower_setup.dtype",
                    "possible_values": []
                }
            },
            "histogram_80": {
                "variable": {
                    "value": "summ",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "possible_values": []
                },
                "data": {
                    "value": "b",
                    "possible_values": [
                        [
                            "tf.get_variable(name, shape, tower_setup.dtype, initializer, trainable=trainable)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_max_70": {
                "input_tensor": {
                    "value": "tf.abs(W)",
                    "possible_values": []
                }
            },
            "reduce_max_82": {
                "input_tensor": {
                    "value": "tf.abs(b)",
                    "possible_values": []
                }
            },
            "l2_loss_66": {
                "t": {
                    "value": "W",
                    "possible_values": [
                        [
                            "tf.get_variable(name, dtype=tower_setup.dtype, initializer=initializer, trainable=trainable)",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name, shape, tower_setup.dtype, initializer, trainable=trainable)",
                            "Call"
                        ]
                    ]
                }
            },
            "abs_70": {
                "x": {
                    "value": "W",
                    "possible_values": [
                        [
                            "tf.get_variable(name, dtype=tower_setup.dtype, initializer=initializer, trainable=trainable)",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name, shape, tower_setup.dtype, initializer, trainable=trainable)",
                            "Call"
                        ]
                    ]
                }
            },
            "abs_82": {
                "x": {
                    "value": "b",
                    "possible_values": [
                        [
                            "tf.get_variable(name, shape, tower_setup.dtype, initializer, trainable=trainable)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "network/Network.py": {
        "tensorflow": {
            "name_scope_43": {
                "name": {
                    "value": "self.name",
                    "possible_values": []
                }
            }
        }
    },
    "network/NetworkTower.py": {
        "tensorflow": {
            "constant_101": {
                "variable": {
                    "value": "loss",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "add_n_103": {
                "variable": {
                    "value": "loss",
                    "possible_values": []
                },
                "inputs": {
                    "value": "self.losses",
                    "possible_values": []
                }
            },
            "constant_105": {
                "variable": {
                    "value": "reg",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "add_n_107": {
                "variable": {
                    "value": "reg",
                    "possible_values": []
                },
                "inputs": {
                    "value": "self.regularizers",
                    "possible_values": []
                }
            },
            "variable_scope_62": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tower_setup.reuse_variables",
                    "possible_values": []
                }
            },
            "device_63": {
                "device_name": {
                    "value": "gpu_str",
                    "possible_values": [
                        [
                            "'/gpu:' + str(tower_setup.gpu_idx)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "name_scope_63": {
                "name": {
                    "value": "tower_name",
                    "possible_values": [
                        [
                            "'tower_gpu_' + str(tower_setup.gpu_idx)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "get_variable_scope_62": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            }
        }
    },
    "network/RecurrentLayers.py": {
        "tensorflow": {
            "reshape_36": {
                "variable": {
                    "value": "y",
                    "possible_values": []
                },
                "tensor": {
                    "value": "y",
                    "possible_values": [
                        [
                            "tf.reshape(y, shape[:-1] + [n_features])",
                            "Call"
                        ],
                        [
                            "tf.concat([y_fwd, y_bwd], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "shape[:-1] + [n_features]",
                    "possible_values": []
                }
            },
            "reverse_56": {
                "variable": {
                    "value": "inp_bwd",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inp",
                    "possible_values": [
                        [
                            "inp[:, tf.newaxis]",
                            "Subscript"
                        ],
                        [
                            "inp[:, tf.newaxis]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "[0]",
                    "possible_values": []
                }
            },
            "reverse_69": {
                "variable": {
                    "value": "y_bwd",
                    "possible_values": []
                },
                "tensor": {
                    "value": "y_bwd",
                    "possible_values": [
                        [
                            "tf.reverse(y_bwd, axis=[0])",
                            "Call"
                        ],
                        [
                            "tf.reshape(y_bwd, shape[:-1] + [n_features])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[0]",
                    "possible_values": []
                }
            },
            "reshape_70": {
                "variable": {
                    "value": "y_fwd",
                    "possible_values": []
                },
                "tensor": {
                    "value": "y_fwd",
                    "possible_values": [
                        [
                            "tf.reshape(y_fwd, shape[:-1] + [n_features])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "shape[:-1] + [n_features]",
                    "possible_values": []
                }
            },
            "reshape_71": {
                "variable": {
                    "value": "y_bwd",
                    "possible_values": []
                },
                "tensor": {
                    "value": "y_bwd",
                    "possible_values": [
                        [
                            "tf.reverse(y_bwd, axis=[0])",
                            "Call"
                        ],
                        [
                            "tf.reshape(y_bwd, shape[:-1] + [n_features])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "shape[:-1] + [n_features]",
                    "possible_values": []
                }
            },
            "concat_72": {
                "variable": {
                    "value": "y",
                    "possible_values": []
                },
                "values": {
                    "value": "[y_fwd, y_bwd]",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "variable_scope_22": {
                "name_or_scope": {
                    "value": "name",
                    "possible_values": []
                }
            },
            "placeholder_with_default_30": {
                "variable": {
                    "value": "c0",
                    "possible_values": []
                },
                "input": {
                    "value": "initial_state[0]",
                    "possible_values": []
                },
                "shape": {
                    "value": "initial_state[0].get_shape()",
                    "possible_values": []
                },
                "name": {
                    "value": "c0_placeholder",
                    "possible_values": []
                }
            },
            "placeholder_with_default_31": {
                "variable": {
                    "value": "h0",
                    "possible_values": []
                },
                "input": {
                    "value": "initial_state[1]",
                    "possible_values": []
                },
                "shape": {
                    "value": "initial_state[1].get_shape()",
                    "possible_values": []
                },
                "name": {
                    "value": "h0_placeholder",
                    "possible_values": []
                }
            },
            "variable_scope_54": {
                "name_or_scope": {
                    "value": "name",
                    "possible_values": []
                }
            }
        }
    },
    "network/Resnet.py": {
        "tensorflow": {
            "pad_52": {
                "variable": {
                    "value": "l",
                    "possible_values": []
                },
                "tensor": {
                    "value": "image",
                    "possible_values": []
                },
                "paddings": {
                    "value": "[[0, 0], [2, 3], [2, 3], [0, 0]]",
                    "possible_values": []
                }
            },
            "pad_55": {
                "variable": {
                    "value": "l",
                    "possible_values": []
                },
                "tensor": {
                    "value": "l",
                    "possible_values": [
                        [
                            "l[:, :-1, :-1, :]",
                            "Subscript"
                        ],
                        [
                            "Conv(name='conv1', inputs=[l], n_features=ch_out, tower_setup=tower_setup, filter_size=(1, 1), activation='relu', batch_norm=True, old_order=True).outputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(l, [[0, 0], [0, 1], [0, 1], [0, 0]])",
                            "Call"
                        ],
                        [
                            "Conv(name='conv2', inputs=[l], n_features=ch_out, tower_setup=tower_setup, filter_size=(3, 3), strides=(2, 2), activation='relu', padding='VALID', batch_norm=True, old_order=True).outputs[0]",
                            "Subscript"
                        ],
                        [
                            "Conv(name='conv2', inputs=[l], n_features=ch_out, tower_setup=tower_setup, filter_size=(3, 3), strides=(stride, stride), activation='relu', batch_norm=True, old_order=True).outputs[0]",
                            "Subscript"
                        ],
                        [
                            "Conv(name='conv3', inputs=[l], n_features=ch_out * 4, tower_setup=tower_setup, filter_size=(1, 1), activation='linear', batch_norm=True, old_order=True).outputs[0]",
                            "Subscript"
                        ],
                        [
                            "resnet_bottleneck(l, features, stride if i == 0 else 1, tower_setup)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(l)",
                            "Call"
                        ],
                        [
                            "tf.pad(image, [[0, 0], [2, 3], [2, 3], [0, 0]])",
                            "Call"
                        ],
                        [
                            "Conv(name='conv0', inputs=[l], n_features=64, tower_setup=tower_setup, filter_size=(7, 7), strides=(2, 2), activation='relu', padding='VALID', batch_norm=True, old_order=True).outputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(l, [[0, 0], [0, 1], [0, 1], [0, 0]])",
                            "Call"
                        ],
                        [
                            "max_pool(l, shape=[3, 3], strides=[2, 2], padding='VALID')",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [0, 1], [0, 1], [0, 0]]",
                    "possible_values": []
                }
            },
            "pad_29": {
                "variable": {
                    "value": "l",
                    "possible_values": []
                },
                "tensor": {
                    "value": "l",
                    "possible_values": [
                        [
                            "l[:, :-1, :-1, :]",
                            "Subscript"
                        ],
                        [
                            "Conv(name='conv1', inputs=[l], n_features=ch_out, tower_setup=tower_setup, filter_size=(1, 1), activation='relu', batch_norm=True, old_order=True).outputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(l, [[0, 0], [0, 1], [0, 1], [0, 0]])",
                            "Call"
                        ],
                        [
                            "Conv(name='conv2', inputs=[l], n_features=ch_out, tower_setup=tower_setup, filter_size=(3, 3), strides=(2, 2), activation='relu', padding='VALID', batch_norm=True, old_order=True).outputs[0]",
                            "Subscript"
                        ],
                        [
                            "Conv(name='conv2', inputs=[l], n_features=ch_out, tower_setup=tower_setup, filter_size=(3, 3), strides=(stride, stride), activation='relu', batch_norm=True, old_order=True).outputs[0]",
                            "Subscript"
                        ],
                        [
                            "Conv(name='conv3', inputs=[l], n_features=ch_out * 4, tower_setup=tower_setup, filter_size=(1, 1), activation='linear', batch_norm=True, old_order=True).outputs[0]",
                            "Subscript"
                        ],
                        [
                            "resnet_bottleneck(l, features, stride if i == 0 else 1, tower_setup)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(l)",
                            "Call"
                        ],
                        [
                            "tf.pad(image, [[0, 0], [2, 3], [2, 3], [0, 0]])",
                            "Call"
                        ],
                        [
                            "Conv(name='conv0', inputs=[l], n_features=64, tower_setup=tower_setup, filter_size=(7, 7), strides=(2, 2), activation='relu', padding='VALID', batch_norm=True, old_order=True).outputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(l, [[0, 0], [0, 1], [0, 1], [0, 0]])",
                            "Call"
                        ],
                        [
                            "max_pool(l, shape=[3, 3], strides=[2, 2], padding='VALID')",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [0, 1], [0, 1], [0, 0]]",
                    "possible_values": []
                }
            },
            "stop_gradient_59": {
                "variable": {
                    "value": "c2",
                    "possible_values": []
                },
                "input": {
                    "value": "c2",
                    "possible_values": [
                        [
                            "resnet_group(l, 'group0', 64, num_blocks[0], 1, tower_setup)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(c2)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_41": {
                "name_or_scope": {
                    "value": "name",
                    "possible_values": []
                }
            },
            "concat_87": {
                "variable": {
                    "value": "inp",
                    "possible_values": []
                },
                "values": {
                    "value": "[inp, inp, inp]",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "relu_46": {
                "variable": {
                    "value": "l",
                    "possible_values": []
                },
                "features": {
                    "value": "l",
                    "possible_values": [
                        [
                            "l[:, :-1, :-1, :]",
                            "Subscript"
                        ],
                        [
                            "Conv(name='conv1', inputs=[l], n_features=ch_out, tower_setup=tower_setup, filter_size=(1, 1), activation='relu', batch_norm=True, old_order=True).outputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(l, [[0, 0], [0, 1], [0, 1], [0, 0]])",
                            "Call"
                        ],
                        [
                            "Conv(name='conv2', inputs=[l], n_features=ch_out, tower_setup=tower_setup, filter_size=(3, 3), strides=(2, 2), activation='relu', padding='VALID', batch_norm=True, old_order=True).outputs[0]",
                            "Subscript"
                        ],
                        [
                            "Conv(name='conv2', inputs=[l], n_features=ch_out, tower_setup=tower_setup, filter_size=(3, 3), strides=(stride, stride), activation='relu', batch_norm=True, old_order=True).outputs[0]",
                            "Subscript"
                        ],
                        [
                            "Conv(name='conv3', inputs=[l], n_features=ch_out * 4, tower_setup=tower_setup, filter_size=(1, 1), activation='linear', batch_norm=True, old_order=True).outputs[0]",
                            "Subscript"
                        ],
                        [
                            "resnet_bottleneck(l, features, stride if i == 0 else 1, tower_setup)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(l)",
                            "Call"
                        ],
                        [
                            "tf.pad(image, [[0, 0], [2, 3], [2, 3], [0, 0]])",
                            "Call"
                        ],
                        [
                            "Conv(name='conv0', inputs=[l], n_features=64, tower_setup=tower_setup, filter_size=(7, 7), strides=(2, 2), activation='relu', padding='VALID', batch_norm=True, old_order=True).outputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(l, [[0, 0], [0, 1], [0, 1], [0, 0]])",
                            "Call"
                        ],
                        [
                            "max_pool(l, shape=[3, 3], strides=[2, 2], padding='VALID')",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_91": {
                "name_or_scope": {
                    "value": "name",
                    "possible_values": []
                }
            },
            "trainable_variables_104": {
                "variable": {
                    "value": "vars_to_regularize",
                    "possible_values": []
                },
                "scope": {
                    "value": "name + '/(?:group1|group2|group3)/.*W'",
                    "possible_values": []
                }
            },
            "add_n_106": {
                "variable": {
                    "value": "regularization_loss",
                    "possible_values": []
                },
                "inputs": {
                    "value": "regularizers",
                    "possible_values": [
                        [
                            "[0.0001 * tf.nn.l2_loss(W) for W in vars_to_regularize]",
                            "ListComp"
                        ]
                    ]
                },
                "name": {
                    "value": "regularization_loss",
                    "possible_values": []
                }
            },
            "variable_scope_43": {
                "name_or_scope": {
                    "value": "'block{}'.format(i)",
                    "possible_values": []
                }
            },
            "l2_loss_105": {
                "t": {
                    "value": "W",
                    "possible_values": []
                }
            }
        }
    },
    "network/Util.py": {
        "tensorflow": {
            "shape_20": {
                "variable": {
                    "value": "W_shape",
                    "possible_values": []
                },
                "input": {
                    "value": "W",
                    "possible_values": []
                }
            },
            "shape_21": {
                "variable": {
                    "value": "inputs_shape",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "possible_values": []
                }
            },
            "atrous_conv2d_32": {
                "variable": {
                    "value": "res",
                    "possible_values": []
                },
                "value": {
                    "value": "x",
                    "possible_values": []
                },
                "filters": {
                    "value": "W",
                    "possible_values": []
                },
                "rate": {
                    "value": "dilation",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "maximum_92": {
                "variable": {
                    "value": "ks",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.cast(tf.round(tf.cast(n_valid_pixels_per_im, tf.float32) * fraction), tf.int32)",
                    "possible_values": []
                },
                "y": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "map_fn_98": {
                "variable": {
                    "value": "loss_per_im",
                    "possible_values": []
                },
                "fn": {
                    "value": "bootstrapped_ce_for_one_img",
                    "possible_values": []
                },
                "elems": {
                    "value": "[raw_ce, ks]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "map_fn_116": {
                "variable": {
                    "value": "loss_per_im",
                    "possible_values": []
                },
                "fn": {
                    "value": "class_balanced_ce_for_one_img",
                    "possible_values": []
                },
                "elems": {
                    "value": "[raw_ce, targets]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "conv2d_8": {
                "input": {
                    "value": "x",
                    "possible_values": []
                },
                "filters": {
                    "value": "W",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1] + strides + [1]",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "conv3d_13": {
                "input": {
                    "value": "x",
                    "possible_values": []
                },
                "filters": {
                    "value": "W",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1] + strides + [1]",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "conv2d_transpose_28": {
                "input": {
                    "value": "x",
                    "possible_values": []
                },
                "filters": {
                    "value": "W",
                    "possible_values": []
                },
                "output_shape": {
                    "value": "tf.stack(output_shape)",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1] + strides + [1]",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "constant_initializer_41": {
                "variable": {
                    "value": "initializer_zero",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "get_variable_42": {
                "variable": {
                    "value": "beta",
                    "possible_values": []
                },
                "name": {
                    "value": "beta",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n_out]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer_zero",
                    "possible_values": [
                        [
                            "tf.constant_initializer(0.0, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_initializer_43": {
                "variable": {
                    "value": "initializer_gamma",
                    "possible_values": []
                },
                "value": {
                    "value": "1.0",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "get_variable_44": {
                "variable": {
                    "value": "gamma",
                    "possible_values": []
                },
                "name": {
                    "value": "gamma",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n_out]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer_gamma",
                    "possible_values": [
                        [
                            "tf.constant_initializer(1.0, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_45": {
                "variable": {
                    "value": "mean_ema",
                    "possible_values": []
                },
                "name": {
                    "value": "mean_ema",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n_out]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer_zero",
                    "possible_values": [
                        [
                            "tf.constant_initializer(0.0, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "trainable": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "get_variable_46": {
                "variable": {
                    "value": "var_ema",
                    "possible_values": []
                },
                "name": {
                    "value": "var_ema",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n_out]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer_zero",
                    "possible_values": [
                        [
                            "tf.constant_initializer(0.0, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "trainable": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "concat_65": {
                "variable": {
                    "value": "inp",
                    "possible_values": []
                },
                "values": {
                    "value": "inputs",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "possible_values": []
                }
            },
            "max_pool_80": {
                "input": {
                    "value": "x",
                    "possible_values": []
                },
                "ksize": {
                    "value": "[1] + shape + [1]",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1] + strides + [1]",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "max_pool3d_87": {
                "input": {
                    "value": "x",
                    "possible_values": []
                },
                "ksize": {
                    "value": "[1] + shape + [1]",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1] + strides + [1]",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reduce_mean_99": {
                "input_tensor": {
                    "value": "loss_per_im",
                    "possible_values": [
                        [
                            "tf.map_fn(bootstrapped_ce_for_one_img, [raw_ce, ks], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(class_balanced_ce_for_one_img, [raw_ce, targets], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_117": {
                "input_tensor": {
                    "value": "loss_per_im",
                    "possible_values": [
                        [
                            "tf.map_fn(bootstrapped_ce_for_one_img, [raw_ce, ks], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(class_balanced_ce_for_one_img, [raw_ce, targets], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_28": {
                "values": {
                    "value": "output_shape",
                    "possible_values": [
                        [
                            "(inputs_shape[0], out_height, out_width, W_shape[2])",
                            "Tuple"
                        ]
                    ]
                }
            },
            "device_40": {
                "device_name": {
                    "value": "tower_setup.variable_device",
                    "possible_values": []
                }
            },
            "variable_scope_40": {
                "name_or_scope": {
                    "value": "scope_name",
                    "possible_values": [
                        [
                            "'bn'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "dropout_74": {
                "x": {
                    "value": "inp",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.concat(inputs, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob",
                    "possible_values": [
                        [
                            "1.0 - dropout",
                            "BinOp"
                        ]
                    ]
                }
            },
            "cast_92": {
                "x": {
                    "value": "n_valid_pixels_per_im",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "reduce_mean_97": {
                "input_tensor": {
                    "value": "hardest",
                    "possible_values": [
                        [
                            "tf.nn.top_k(tf.reshape(one_ce, [-1]), k, sorted=False)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "equal_110": {
                "variable": {
                    "value": "cls_mask",
                    "possible_values": []
                },
                "x": {
                    "value": "target",
                    "possible_values": []
                },
                "y": {
                    "value": "cls",
                    "possible_values": [
                        [
                            "range(n_classes)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_111": {
                "variable": {
                    "value": "n_cls",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(cls_mask, tf.int32)",
                    "possible_values": []
                }
            },
            "round_92": {
                "x": {
                    "value": "tf.cast(n_valid_pixels_per_im, tf.float32) * fraction",
                    "possible_values": []
                }
            },
            "top_k_96": {
                "input": {
                    "value": "tf.reshape(one_ce, [-1])",
                    "possible_values": []
                },
                "k": {
                    "value": "k",
                    "possible_values": []
                },
                "sorted": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "add_n_114": {
                "inputs": {
                    "value": "cls_losses",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "reshape_96": {
                "tensor": {
                    "value": "one_ce",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "possible_values": []
                }
            },
            "cast_111": {
                "x": {
                    "value": "cls_mask",
                    "possible_values": [
                        [
                            "tf.equal(target, cls)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "reduce_sum_112": {
                "input_tensor": {
                    "value": "tf.boolean_mask(ce, cls_mask)",
                    "possible_values": []
                }
            },
            "cast_112": {
                "x": {
                    "value": "tf.maximum(n_cls, 1)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "boolean_mask_112": {
                "tensor": {
                    "value": "ce",
                    "possible_values": []
                },
                "mask": {
                    "value": "cls_mask",
                    "possible_values": [
                        [
                            "tf.equal(target, cls)",
                            "Call"
                        ]
                    ]
                }
            },
            "maximum_112": {
                "x": {
                    "value": "n_cls",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.cast(cls_mask, tf.int32))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1",
                    "possible_values": []
                }
            }
        }
    },
    "network/UtilLayers.py": {
        "tensorflow": {
            "constant_initializer_14": {
                "variable": {
                    "value": "initializer",
                    "possible_values": []
                },
                "value": {
                    "value": "initial_weights",
                    "possible_values": []
                }
            },
            "variable_scope_13": {
                "name_or_scope": {
                    "value": "name",
                    "possible_values": []
                }
            },
            "variable_scope_38": {
                "name_or_scope": {
                    "value": "name",
                    "possible_values": []
                }
            },
            "concat_53": {
                "values": {
                    "value": "inputs",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "shape_40": {
                "input": {
                    "value": "inp",
                    "possible_values": []
                }
            },
            "shape_41": {
                "input": {
                    "value": "inp",
                    "possible_values": []
                }
            },
            "identity_23": {
                "input": {
                    "value": "x",
                    "possible_values": []
                }
            }
        }
    },
    "network/layer_implementations/ConvLSTMCell.py": {
        "tensorflow": {
            "dynamic_rnn_19": {
                "variable": {
                    "value": "(h, final_state)",
                    "possible_values": []
                },
                "cell": {
                    "value": "cell",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "sequence_length",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "initial_state": {
                    "value": "initial_state",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "parallel_iterations": {
                    "value": "parallel_iterations",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "swap_memory": {
                    "value": "swap_memory",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                },
                "time_major": {
                    "value": "time_major",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                },
                "scope": {
                    "value": "scope",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reshape_21": {
                "variable": {
                    "value": "h",
                    "possible_values": []
                },
                "tensor": {
                    "value": "h",
                    "possible_values": [
                        [
                            "tf.reshape(h, tf.stack([input_shape[0], input_shape[1], input_shape[2], input_shape[3], num_units]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(h, [batch, self._height, self._width, self._num_units])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.stack([input_shape[0], input_shape[1], input_shape[2], input_shape[3], num_units])",
                    "possible_values": []
                }
            },
            "conv2d_10": {
                "input": {
                    "value": "x",
                    "possible_values": []
                },
                "filters": {
                    "value": "W",
                    "possible_values": [
                        [
                            "self._W",
                            "Attribute"
                        ],
                        [
                            "tf.get_variable('W', shape=self._filter_size + [n_input_features + self._num_units, 4 * self._num_units])",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1] + strides + [1]",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "possible_values": []
                }
            },
            "reshape_81": {
                "variable": {
                    "value": "h",
                    "possible_values": []
                },
                "tensor": {
                    "value": "h",
                    "possible_values": [
                        [
                            "tf.reshape(h, tf.stack([input_shape[0], input_shape[1], input_shape[2], input_shape[3], num_units]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(h, [batch, self._height, self._width, self._num_units])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch, self._height, self._width, self._num_units]",
                    "possible_values": []
                }
            },
            "concat_82": {
                "variable": {
                    "value": "inp",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs, h]",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "possible_values": []
                }
            },
            "stack_21": {
                "values": {
                    "value": "[input_shape[0], input_shape[1], input_shape[2], input_shape[3], num_units]",
                    "possible_values": []
                }
            },
            "split_61": {
                "variable": {
                    "value": "(i, j, f, o)",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "4",
                    "possible_values": []
                },
                "value": {
                    "value": "concat",
                    "possible_values": [
                        [
                            "self._conv(inputs, h)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_88": {
                "variable": {
                    "value": "W",
                    "possible_values": []
                },
                "name": {
                    "value": "W",
                    "possible_values": []
                },
                "shape": {
                    "value": "self._filter_size + [n_input_features + self._num_units, 4 * self._num_units]",
                    "possible_values": []
                }
            },
            "constant_initializer_92": {
                "variable": {
                    "value": "zero_initializer",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "possible_values": []
                }
            },
            "get_variable_93": {
                "variable": {
                    "value": "b",
                    "possible_values": []
                },
                "name": {
                    "value": "b",
                    "possible_values": []
                },
                "shape": {
                    "value": "4 * self._num_units",
                    "possible_values": []
                },
                "initializer": {
                    "value": "zero_initializer",
                    "possible_values": [
                        [
                            "tf.constant_initializer(0.0, dtype=inputs.dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_55": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "possible_values": []
                }
            },
            "reshape_65": {
                "tensor": {
                    "value": "x",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch, -1]",
                    "possible_values": []
                }
            },
            "sigmoid_69": {
                "x": {
                    "value": "o",
                    "possible_values": []
                }
            },
            "shape_77": {
                "input": {
                    "value": "inputs",
                    "possible_values": []
                }
            },
            "shape_64": {
                "input": {
                    "value": "inputs",
                    "possible_values": []
                }
            },
            "sigmoid_67": {
                "x": {
                    "value": "i",
                    "possible_values": []
                }
            }
        }
    }
}