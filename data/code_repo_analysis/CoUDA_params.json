{
    "src_office/models/mobilenet.py": {
        "tensorflow": {}
    },
    "src_office/nets/mobilenet/conv_blocks.py": {
        "tensorflow": {
            "pad_45": {
                "variable": {
                    "value": "padded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.split(input_tensor, input_splits, axis=3, name='split_' + scope)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [pad_beg[0], pad_end[0]], [pad_beg[1], pad_end[1]], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "split_354": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_fixed_padding(input_tensor, kernel_size, rate)",
                            "Call"
                        ],
                        [
                            "tf.identity(input_tensor, 'input')",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "input_splits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_split_divisible(b, num_ways, divisible_by=divisible_by)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "'split_' + scope",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "identity_252": {
                "variable": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_fixed_padding(input_tensor, kernel_size, rate)",
                            "Call"
                        ],
                        [
                            "tf.identity(input_tensor, 'input')",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_282": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.separable_conv2d(input_tensor, None, kernel_size, depth_multiplier=1, stride=stride, rate=rate, normalizer_fn=normalizer_fn, padding=padding, scope=dw_scope)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(net, num_outputs, [1, 1], stride=1, normalizer_fn=normalizer_fn, scope=pw_scope)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "_fixed_padding(net, kernel_size, rate)",
                            "Call"
                        ],
                        [
                            "depthwise_func(net, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "split_conv(net, inner_size, num_ways=split_expansion, scope='expand', stride=1, normalizer_fn=normalizer_fn)",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'expansion_output')",
                            "Call"
                        ],
                        [
                            "tf.identity(net, name='depthwise_output')",
                            "Call"
                        ],
                        [
                            "_fixed_padding(net, kernel_size, rate)",
                            "Call"
                        ],
                        [
                            "depthwise_func(net)",
                            "Call"
                        ],
                        [
                            "expansion_transform(expansion_tensor=net, input_tensor=input_tensor)",
                            "Call"
                        ],
                        [
                            "split_conv(net, num_outputs, num_ways=split_projection, stride=1, scope='project', normalizer_fn=normalizer_fn, activation_fn=project_activation_fn)",
                            "Call"
                        ],
                        [
                            "_fixed_padding(net, kernel_size, rate)",
                            "Call"
                        ],
                        [
                            "depthwise_func(net, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "residual(input_tensor=input_tensor, output_tensor=net)",
                            "Call"
                        ],
                        [
                            "net + input_tensor",
                            "BinOp"
                        ]
                    ]
                },
                "name": {
                    "value": "depthwise_output",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_359": {
                "variable": {
                    "value": "n",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "n",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.conv2d(input_tensor, out_size, [1, 1], scope=scope, **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(n, scope + '_output')",
                            "Call"
                        ],
                        [
                            "n",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "scope + '_output'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_361": {
                "values": {
                    "value": "outs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "scope + '_concat'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_229": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope + '_'",
                            "BinOp"
                        ],
                        [
                            "base + '_part_%d' % (i,)",
                            "BinOp"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                },
                "default_name": {
                    "value": "expanded_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_230": {
                "name": {
                    "value": "s.original_name_scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "identity_273": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.separable_conv2d(input_tensor, None, kernel_size, depth_multiplier=1, stride=stride, rate=rate, normalizer_fn=normalizer_fn, padding=padding, scope=dw_scope)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(net, num_outputs, [1, 1], stride=1, normalizer_fn=normalizer_fn, scope=pw_scope)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "_fixed_padding(net, kernel_size, rate)",
                            "Call"
                        ],
                        [
                            "depthwise_func(net, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "split_conv(net, inner_size, num_ways=split_expansion, scope='expand', stride=1, normalizer_fn=normalizer_fn)",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'expansion_output')",
                            "Call"
                        ],
                        [
                            "tf.identity(net, name='depthwise_output')",
                            "Call"
                        ],
                        [
                            "_fixed_padding(net, kernel_size, rate)",
                            "Call"
                        ],
                        [
                            "depthwise_func(net)",
                            "Call"
                        ],
                        [
                            "expansion_transform(expansion_tensor=net, input_tensor=input_tensor)",
                            "Call"
                        ],
                        [
                            "split_conv(net, num_outputs, num_ways=split_projection, stride=1, scope='project', normalizer_fn=normalizer_fn, activation_fn=project_activation_fn)",
                            "Call"
                        ],
                        [
                            "_fixed_padding(net, kernel_size, rate)",
                            "Call"
                        ],
                        [
                            "depthwise_func(net, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "residual(input_tensor=input_tensor, output_tensor=net)",
                            "Call"
                        ],
                        [
                            "net + input_tensor",
                            "BinOp"
                        ]
                    ]
                },
                "name": {
                    "value": "expansion_output",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_317": {
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.separable_conv2d(input_tensor, None, kernel_size, depth_multiplier=1, stride=stride, rate=rate, normalizer_fn=normalizer_fn, padding=padding, scope=dw_scope)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(net, num_outputs, [1, 1], stride=1, normalizer_fn=normalizer_fn, scope=pw_scope)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "_fixed_padding(net, kernel_size, rate)",
                            "Call"
                        ],
                        [
                            "depthwise_func(net, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "split_conv(net, inner_size, num_ways=split_expansion, scope='expand', stride=1, normalizer_fn=normalizer_fn)",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'expansion_output')",
                            "Call"
                        ],
                        [
                            "tf.identity(net, name='depthwise_output')",
                            "Call"
                        ],
                        [
                            "_fixed_padding(net, kernel_size, rate)",
                            "Call"
                        ],
                        [
                            "depthwise_func(net)",
                            "Call"
                        ],
                        [
                            "expansion_transform(expansion_tensor=net, input_tensor=input_tensor)",
                            "Call"
                        ],
                        [
                            "split_conv(net, num_outputs, num_ways=split_projection, stride=1, scope='project', normalizer_fn=normalizer_fn, activation_fn=project_activation_fn)",
                            "Call"
                        ],
                        [
                            "_fixed_padding(net, kernel_size, rate)",
                            "Call"
                        ],
                        [
                            "depthwise_func(net, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "residual(input_tensor=input_tensor, output_tensor=net)",
                            "Call"
                        ],
                        [
                            "net + input_tensor",
                            "BinOp"
                        ]
                    ]
                },
                "name": {
                    "value": "output",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_81": {
                "name_or_scope": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "default_name": {
                    "value": "separable",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_82": {
                "name": {
                    "value": "s.original_name_scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "crop_to_bounding_box_314": {
                "image": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_fixed_padding(input_tensor, kernel_size, rate)",
                            "Call"
                        ],
                        [
                            "tf.identity(input_tensor, 'input')",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "offset_height": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "offset_width": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "target_height": {
                    "value": "net.shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "target_width": {
                    "value": "net.shape[2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "src_office/nets/mobilenet/mobilenet.py": {
        "tensorflow": {
            "pad_57": {
                "variable": {
                    "value": "padded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(inputs, 'input')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [pad_beg[0], pad_end[0]], [pad_beg[1], pad_end[1]], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "identity_358": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(inputs, 'input')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_363": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "_fixed_padding(net, params['kernel_size'], layer_rate)",
                            "Call"
                        ],
                        [
                            "opdef.op(net, **params)",
                            "Call"
                        ],
                        [
                            "mobilenet_base(inputs, scope=scope, **mobilenet_args)",
                            "Call"
                        ],
                        [
                            "tf.identity(net, name='embedding')",
                            "Call"
                        ],
                        [
                            "global_pool(net)",
                            "Call"
                        ],
                        [
                            "slim.dropout(net, scope='Dropout', is_training=is_training)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "embedding",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_406": {
                "variable": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[1, tf.shape(input_tensor)[1], tf.shape(input_tensor)[2], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "truncated_normal_initializer_456": {
                "variable": {
                    "value": "weight_intitializer",
                    "type": "variable",
                    "possible_values": []
                },
                "stddev": {
                    "value": "stddev",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.09",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_299": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.dirname(t.name)",
                            "Call"
                        ],
                        [
                            "os.path.dirname(net.name)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "'Mobilenet'",
                            "Method Argument"
                        ]
                    ]
                },
                "default_name": {
                    "value": "default_scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "name_scope_300": {
                "name": {
                    "value": "s.original_name_scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_357": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.dirname(t.name)",
                            "Call"
                        ],
                        [
                            "os.path.dirname(net.name)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "'Mobilenet'",
                            "Method Argument"
                        ]
                    ]
                },
                "default_name": {
                    "value": "Mobilenet",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "identity_385": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.conv2d(net, num_classes, [1, 1], activation_fn=None, normalizer_fn=None, biases_initializer=tf.zeros_initializer(), scope='Conv2d_1c_1x1')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(logits, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(logits, name='output')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "output",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_365": {
                "name_or_scope": {
                    "value": "Logits",
                    "type": "str",
                    "possible_values": []
                }
            },
            "squeeze_383": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.conv2d(net, num_classes, [1, 1], activation_fn=None, normalizer_fn=None, biases_initializer=tf.zeros_initializer(), scope='Conv2d_1c_1x1')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(logits, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(logits, name='output')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_initializer_379": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "shape_407": {
                "input": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_tensor",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_408": {
                "input": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_tensor",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "src_office/nets/mobilenet/mobilenet_v2.py": {
        "tensorflow": {}
    },
    "src_office/nets/mobilenet/mobilenet_v2_test.py": {
        "tensorflow": {
            "get_default_graph_38": {
                "variable": {
                    "value": "gd",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_189": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reset_default_graph_45": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reset_default_graph_101": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reset_default_graph_113": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reset_default_graph_125": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reset_default_graph_139": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reset_default_graph_148": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reset_default_graph_156": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reset_default_graph_166": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_50": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(10, 224, 224, 16)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_66": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(10, 224, 224, 16)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reset_default_graph_73": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_86": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(10, 224, 224, 16)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_94": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(10, 224, 224, 16)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_103": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(10, 224, 224, 16)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_130": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(10, 224, 224, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_150": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(10, 224, 224, 16)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_158": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(10, 224, 224, 16)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_168": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(10, 224, 224, 16)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_75": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(10, input_size, input_size, 3)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_118": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(10, 224, 224, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_143": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(10, 224, 224, 16)",
                    "type": "Tuple",
                    "possible_values": []
                }
            }
        }
    },
    "src_office/network.py": {
        "tensorflow": {
            "relu_110": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "relu_117": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "relu_148": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "relu_160": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "relu_205": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "relu_211": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "relu_218": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "relu_257": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "relu_269": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "relu_275": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "batch_normalization_25": {
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1 if data_format == 'channels_first' else 3",
                    "type": "IfExp",
                    "possible_values": []
                },
                "momentum": {
                    "value": "_BATCH_NORM_DECAY",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.997",
                            "float"
                        ]
                    ]
                },
                "epsilon": {
                    "value": "_BATCH_NORM_EPSILON",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1e-05",
                            "float"
                        ]
                    ]
                },
                "center": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "scale": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "training": {
                    "value": "training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "training",
                            "Method Argument"
                        ],
                        [
                            "training",
                            "Method Argument"
                        ],
                        [
                            "training",
                            "Method Argument"
                        ],
                        [
                            "training",
                            "Method Argument"
                        ],
                        [
                            "training",
                            "Method Argument"
                        ],
                        [
                            "training",
                            "Method Argument"
                        ],
                        [
                            "training",
                            "Method Argument"
                        ],
                        [
                            "training",
                            "Method Argument"
                        ]
                    ]
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "pad_50": {
                "variable": {
                    "value": "padded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [0, 0], [pad_beg, pad_end], [pad_beg, pad_end]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "pad_53": {
                "variable": {
                    "value": "padded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [pad_beg, pad_end], [pad_beg, pad_end], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "conv2d_65": {
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "filters",
                    "type": "variable",
                    "possible_values": [
                        [
                            "filters",
                            "Method Argument"
                        ],
                        [
                            "filters",
                            "Method Argument"
                        ],
                        [
                            "filters",
                            "Method Argument"
                        ],
                        [
                            "filters",
                            "Method Argument"
                        ],
                        [
                            "filters",
                            "Method Argument"
                        ],
                        [
                            "filters",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kernel_size",
                            "Method Argument"
                        ],
                        [
                            "kernel_size",
                            "Method Argument"
                        ],
                        [
                            "kernel_size",
                            "Method Argument"
                        ]
                    ]
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": [
                        [
                            "strides",
                            "Method Argument"
                        ],
                        [
                            "strides",
                            "Method Argument"
                        ],
                        [
                            "strides",
                            "Method Argument"
                        ],
                        [
                            "strides",
                            "Method Argument"
                        ],
                        [
                            "strides",
                            "Method Argument"
                        ],
                        [
                            "strides",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "SAME if strides == 1 else VALID",
                    "type": "IfExp",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.variance_scaling_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_first' if tf.test.is_built_with_cuda() else 'channels_last'",
                            "IfExp"
                        ],
                        [
                            "data_format",
                            "Method Argument"
                        ],
                        [
                            "data_format",
                            "Method Argument"
                        ],
                        [
                            "data_format",
                            "Method Argument"
                        ],
                        [
                            "data_format",
                            "Method Argument"
                        ],
                        [
                            "data_format",
                            "Method Argument"
                        ],
                        [
                            "data_format",
                            "Method Argument"
                        ],
                        [
                            "data_format",
                            "Method Argument"
                        ],
                        [
                            "data_format",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "identity_321": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name",
                            "Method Argument"
                        ],
                        [
                            "name",
                            "Method Argument"
                        ],
                        [
                            "name",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_default_graph_596": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_433": {
                "name_or_scope": {
                    "value": "resnet_model",
                    "type": "str",
                    "possible_values": []
                },
                "custom_getter": {
                    "value": "self._custom_dtype_getter",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "identity_458": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "initial_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_495": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "axes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[2, 3] if self.data_format == 'channels_first' else [1, 2]",
                            "IfExp"
                        ]
                    ]
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "identity_496": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "final_reduce_mean",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_498": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, self.final_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dense_502": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "hidden_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ]
                    ]
                },
                "units": {
                    "value": "self.num_classes",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "identity_503": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "final_dense",
                    "type": "str",
                    "possible_values": []
                }
            },
            "RegisterGradient_592": {
                "op_type": {
                    "value": "grad_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'FlipGradient{:d}'.format(global_step_grl)",
                            "Call"
                        ]
                    ]
                }
            },
            "identity_598": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "dense_616": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "units": {
                    "value": "1024",
                    "type": "int",
                    "possible_values": []
                }
            },
            "relu_617": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "dropout_618": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "dense_619": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "units": {
                    "value": "1024",
                    "type": "int",
                    "possible_values": []
                }
            },
            "relu_620": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "dropout_621": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "dense_622": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "units": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_626": {
                "name_or_scope": {
                    "value": "adversarial_net",
                    "type": "str",
                    "possible_values": []
                },
                "custom_getter": {
                    "value": "self._custom_dtype_getter",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_423": {
                "x": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "getter(name, shape, tf.float32, *args, **kwargs)",
                            "Call"
                        ],
                        [
                            "getter(name, shape, tf.float32, *args, **kwargs)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "DEFAULT_DTYPE",
                            "Method Argument"
                        ],
                        [
                            "DEFAULT_DTYPE",
                            "Method Argument"
                        ],
                        [
                            "DEFAULT_DTYPE",
                            "Method Argument"
                        ],
                        [
                            "DEFAULT_DTYPE",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "name + '_cast'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "transpose_453": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 3, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_466": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "max_pooling2d_469": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "self.first_pool_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "strides": {
                    "value": "self.first_pool_stride",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "identity_473": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "initial_max_pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_487": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size, data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "inputs + shortcut",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.conv_stride, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=self.first_pool_size, strides=self.first_pool_stride, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=num_filters, bottleneck=self.bottleneck, block_fn=self.block_fn, blocks=num_blocks, strides=self.block_strides[i], training=training, name='block_layer{}'.format(i + 1), data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training, self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.final_size])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=hidden_features, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ],
                        [
                            "self.flip_gradient(inputs, self.l, self.global_step)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1024)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob=0.5)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_649": {
                "x": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "getter(name, shape, tf.float32, *args, **kwargs)",
                            "Call"
                        ],
                        [
                            "getter(name, shape, tf.float32, *args, **kwargs)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "DEFAULT_DTYPE",
                            "Method Argument"
                        ],
                        [
                            "DEFAULT_DTYPE",
                            "Method Argument"
                        ],
                        [
                            "DEFAULT_DTYPE",
                            "Method Argument"
                        ],
                        [
                            "DEFAULT_DTYPE",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "name + '_cast'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "is_built_with_cuda_368": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "negative_594": {
                "x": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grad",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "exp_615": {
                "x": {
                    "value": "-self.alpha * tf.maximum(math_ops.cast(self.global_step, tf.float32) - 1000.0, 0.0) / self.max_iter",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "maximum_615": {
                "x": {
                    "value": "math_ops.cast(self.global_step, tf.float32) - 1000.0",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "cast_615": {
                "x": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "src_office/predict_dual.py": {
        "tensorflow": {
            "read_file_52": {
                "variable": {
                    "value": "image_string",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "fname",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fname",
                            "Method Argument"
                        ],
                        [
                            "fname",
                            "Method Argument"
                        ],
                        [
                            "fname",
                            "Method Argument"
                        ],
                        [
                            "fname",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "decode_jpeg_53": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image_string",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.read_file(fname)",
                            "Call"
                        ],
                        [
                            "tf.read_file(fname)",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_image_dtype_54": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_string, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [256, 256])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, [224, 224, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image_string, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [256, 256])",
                            "Call"
                        ],
                        [
                            "tf.image.central_crop(image, 0.875)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "random_crop_56": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_string, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [256, 256])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, [224, 224, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image_string, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [256, 256])",
                            "Call"
                        ],
                        [
                            "tf.image.central_crop(image, 0.875)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "[224, 224, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "random_flip_left_right_57": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_string, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [256, 256])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, [224, 224, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image_string, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [256, 256])",
                            "Call"
                        ],
                        [
                            "tf.image.central_crop(image, 0.875)",
                            "Call"
                        ]
                    ]
                }
            },
            "read_file_62": {
                "variable": {
                    "value": "image_string",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "fname",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fname",
                            "Method Argument"
                        ],
                        [
                            "fname",
                            "Method Argument"
                        ],
                        [
                            "fname",
                            "Method Argument"
                        ],
                        [
                            "fname",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "decode_jpeg_63": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image_string",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.read_file(fname)",
                            "Call"
                        ],
                        [
                            "tf.read_file(fname)",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_image_dtype_64": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_string, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [256, 256])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, [224, 224, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image_string, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [256, 256])",
                            "Call"
                        ],
                        [
                            "tf.image.central_crop(image, 0.875)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "central_crop_66": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_string, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [256, 256])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, [224, 224, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image_string, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [256, 256])",
                            "Call"
                        ],
                        [
                            "tf.image.central_crop(image, 0.875)",
                            "Call"
                        ]
                    ]
                },
                "central_fraction": {
                    "value": "0.875",
                    "type": "float",
                    "possible_values": []
                }
            },
            "softmax_228": {
                "variable": {
                    "value": "source_prediction",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "original_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "original_logits",
                            "Method Argument"
                        ],
                        [
                            "original_logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_245": {
                "variable": {
                    "value": "source_prediction",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "original_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "original_logits",
                            "Method Argument"
                        ],
                        [
                            "original_logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_247": {
                "variable": {
                    "value": "Q_softmax",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "Q",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(tf.log(tf.ones([num_classes, num_classes]) * (0.1 / (num_classes - 1)) + tf.eye(num_classes) * (0.9 - 0.1 / (num_classes - 1))), name='refine_matrix')",
                            "Call"
                        ],
                        [
                            "Q",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_249": {
                "variable": {
                    "value": "source_new_prediction",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "source_prediction",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(original_logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(original_logits)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "Q_softmax",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(Q)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_collection_292": {
                "variable": {
                    "value": "vars",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.GLOBAL_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "batch_336": {
                "variable": {
                    "value": "test_element",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_341": {
                "variable": {
                    "value": "target_label",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "next_element[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "depth": {
                    "value": "CLASS_NUMBER",
                    "type": "variable",
                    "possible_values": [
                        [
                            "31",
                            "int"
                        ]
                    ]
                }
            },
            "concat_344": {
                "variable": {
                    "value": "all_data",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[source_data, target_data]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_345": {
                "variable": {
                    "value": "all_label",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[source_label, target_label]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_365": {
                "variable": {
                    "value": "original_logits_1",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tensors_1['output']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, num_classes)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_366": {
                "variable": {
                    "value": "original_logits_2",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tensors_2['output']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, num_classes)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Variable_367": {
                "variable": {
                    "value": "Q",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.log(tf.ones([num_classes, num_classes]) * (0.1 / (num_classes - 1)) + tf.eye(num_classes) * (0.9 - 0.1 / (num_classes - 1)))",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "refine_matrix",
                    "type": "str",
                    "possible_values": []
                }
            },
            "softmax_371": {
                "variable": {
                    "value": "logits_1",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "all_logits_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prediction_refine_k(original_logits_1, num_classes, Q)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_372": {
                "variable": {
                    "value": "logits_2",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "all_logits_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prediction_refine_k(original_logits_2, num_classes, Q)",
                            "Call"
                        ]
                    ]
                }
            },
            "Saver_377": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ConfigProto_380": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "concat_101": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "pyrimid",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "relu_104": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(pyrimid, 3)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(net, img_dim[2], 3, scope='conv_pmerge')",
                            "Call"
                        ],
                        [
                            "slim.batch_norm(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "slim.softmax(logits, scope='predictions')",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits, name='predictions')",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_80": {
                "name_or_scope": {
                    "value": "psp_net",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_94": {
                "variable": {
                    "value": "pyrimid[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "features": {
                    "value": "pyrimid[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "relu_139": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mobilenet_v2(images, 512, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.batch_norm(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(logits)",
                            "Call"
                        ],
                        [
                            "build_psp(logits)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(logits, num_classes, 1, scope='conv_seg', biases_initializer=tf.zeros_initializer(), padding=padding)",
                            "Call"
                        ],
                        [
                            "mobilenet_v2(images, num_classes, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ]
                    ]
                }
            },
            "placeholder_203": {
                "variable": {
                    "value": "imgs_node",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None] + list(img_size)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "image_input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_207": {
                "variable": {
                    "value": "labels_node",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, num_classes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_211": {
                "variable": {
                    "value": "is_training_node",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_231": {
                "name_or_scope": {
                    "value": "refine",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "log_367": {
                "x": {
                    "value": "tf.ones([num_classes, num_classes]) * (0.1 / (num_classes - 1)) + tf.eye(num_classes) * (0.9 - 0.1 / (num_classes - 1))",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Session_382": {
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ]
                    ]
                }
            },
            "global_variables_initializer_383": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_383": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sigmoid_155": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mobilenet_v2(images, 512, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.batch_norm(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(logits)",
                            "Call"
                        ],
                        [
                            "build_psp(logits)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(logits, num_classes, 1, scope='conv_seg', biases_initializer=tf.zeros_initializer(), padding=padding)",
                            "Call"
                        ],
                        [
                            "mobilenet_v2(images, num_classes, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "predictions",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_175": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "placeholder_179": {
                "variable": {
                    "value": "imgs_node",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None] + list(img_size)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "image_input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_183": {
                "variable": {
                    "value": "labels_node",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, num_classes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_187": {
                "variable": {
                    "value": "is_training_node",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_initializer_233": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_233": {
                "value": {
                    "value": "[0.9, 0.1, 0.1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_initializer_235": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_235": {
                "value": {
                    "value": "[0.1, 0.9, 0.1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_initializer_237": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_237": {
                "value": {
                    "value": "[0.1, 0.1, 0.9]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_239": {
                "input": {
                    "value": "source_prediction[:, 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_initializer_143": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ones_367": {
                "shape": {
                    "value": "[num_classes, num_classes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "eye_367": {
                "num_rows": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "CLASS_NUMBER",
                            "variable"
                        ],
                        [
                            "num_classes",
                            "Method Argument"
                        ],
                        [
                            "num_classes",
                            "Method Argument"
                        ],
                        [
                            "num_classes",
                            "Method Argument"
                        ],
                        [
                            "num_classes",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "src_office/train_dual.py": {
        "tensorflow": {
            "read_file_52": {
                "variable": {
                    "value": "image_string",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "fname",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fname",
                            "Method Argument"
                        ],
                        [
                            "fname",
                            "Method Argument"
                        ],
                        [
                            "fname",
                            "Method Argument"
                        ],
                        [
                            "fname",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "decode_jpeg_53": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image_string",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.read_file(fname)",
                            "Call"
                        ],
                        [
                            "tf.read_file(fname)",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_image_dtype_54": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_string, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [256, 256])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, [224, 224, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image_string, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [256, 256])",
                            "Call"
                        ],
                        [
                            "tf.image.central_crop(image, 0.875)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "random_crop_56": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_string, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [256, 256])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, [224, 224, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image_string, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [256, 256])",
                            "Call"
                        ],
                        [
                            "tf.image.central_crop(image, 0.875)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "[224, 224, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "random_flip_left_right_57": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_string, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [256, 256])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, [224, 224, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image_string, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [256, 256])",
                            "Call"
                        ],
                        [
                            "tf.image.central_crop(image, 0.875)",
                            "Call"
                        ]
                    ]
                }
            },
            "read_file_61": {
                "variable": {
                    "value": "image_string",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "fname",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fname",
                            "Method Argument"
                        ],
                        [
                            "fname",
                            "Method Argument"
                        ],
                        [
                            "fname",
                            "Method Argument"
                        ],
                        [
                            "fname",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "decode_jpeg_62": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image_string",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.read_file(fname)",
                            "Call"
                        ],
                        [
                            "tf.read_file(fname)",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_image_dtype_63": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_string, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [256, 256])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, [224, 224, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image_string, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [256, 256])",
                            "Call"
                        ],
                        [
                            "tf.image.central_crop(image, 0.875)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "central_crop_65": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_string, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [256, 256])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, [224, 224, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image_string, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [256, 256])",
                            "Call"
                        ],
                        [
                            "tf.image.central_crop(image, 0.875)",
                            "Call"
                        ]
                    ]
                },
                "central_fraction": {
                    "value": "0.875",
                    "type": "float",
                    "possible_values": []
                }
            },
            "NewCheckpointReader_229": {
                "variable": {
                    "value": "reader",
                    "type": "variable",
                    "possible_values": []
                },
                "filepattern": {
                    "value": "weight_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "weight_file",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_default_graph_231": {
                "variable": {
                    "value": "graph",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "softmax_284": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mobilenet_v2(images, 512, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.batch_norm(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(logits)",
                            "Call"
                        ],
                        [
                            "build_psp(logits)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(logits, num_classes, 1, scope='conv_seg', biases_initializer=tf.zeros_initializer(), padding=padding)",
                            "Call"
                        ],
                        [
                            "mobilenet_v2(images, num_classes, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_285": {
                "variable": {
                    "value": "size",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.shape(logits)[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_286": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.equal(size, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : 0.0",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.reduce_sum(-y_pred * tf.log(y_pred), axis=1)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "softmax_290": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mobilenet_v2(images, 512, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.batch_norm(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(logits)",
                            "Call"
                        ],
                        [
                            "build_psp(logits)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(logits, num_classes, 1, scope='conv_seg', biases_initializer=tf.zeros_initializer(), padding=padding)",
                            "Call"
                        ],
                        [
                            "mobilenet_v2(images, num_classes, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_292": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "L",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-labels * (1 - y_pred) ** gamma * tf.log(y_pred)",
                            "BinOp"
                        ],
                        [
                            "-source_label * (1 - y_pred) ** gamma * tf.log(y_pred)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_300": {
                "variable": {
                    "value": "size",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.shape(logits)[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "maximum_366": {
                "variable": {
                    "value": "loss_value",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "0.0001",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "loss_value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "maximum_mean_discrepancy(source_tensor, target_tensor, kernel=gaussian_kernel)",
                            "Call"
                        ],
                        [
                            "tf.maximum(0.0001, loss_value)",
                            "Call"
                        ]
                    ]
                }
            },
            "placeholder_374": {
                "variable": {
                    "value": "nodes[z_step]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_default_graph_381": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "NewCheckpointReader_495": {
                "variable": {
                    "value": "reader",
                    "type": "variable",
                    "possible_values": []
                },
                "filepattern": {
                    "value": "fine_tune_filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fine_tune_filename",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_504": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "source_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "source_logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_510": {
                "variable": {
                    "value": "source_prediction_1",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "source_logits_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(all_logits_1, source_mask)",
                            "Call"
                        ],
                        [
                            "source_logits_1",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_511": {
                "variable": {
                    "value": "source_prediction_2",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "source_logits_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(all_logits_2, source_mask)",
                            "Call"
                        ],
                        [
                            "source_logits_2",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_535": {
                "variable": {
                    "value": "L_1",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inner_focal_loss(source_new_prediction_1, source_label, gamma)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_536": {
                "variable": {
                    "value": "L_2",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inner_focal_loss(source_new_prediction_2, source_label, gamma)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_543": {
                "variable": {
                    "value": "source_prediction",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "original_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "original_logits",
                            "Method Argument"
                        ],
                        [
                            "original_logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_560": {
                "variable": {
                    "value": "source_prediction",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "original_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "original_logits",
                            "Method Argument"
                        ],
                        [
                            "original_logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_561": {
                "variable": {
                    "value": "Q_softmax",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "Q",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(tf.log(tf.ones([num_classes, num_classes]) * (0.2 / (num_classes - 1)) + tf.eye(num_classes) * (0.8 - 0.2 / (num_classes - 1))), name='refine_matrix')",
                            "Call"
                        ],
                        [
                            "Q",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_562": {
                "variable": {
                    "value": "source_new_prediction",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "source_prediction",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(original_logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(original_logits)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "Q_softmax",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(Q)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_collection_616": {
                "variable": {
                    "value": "vars",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.GLOBAL_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shuffle_699": {
                "variable": {
                    "value": "train_element",
                    "type": "variable",
                    "possible_values": []
                },
                "buffer_size": {
                    "value": "1000",
                    "type": "int",
                    "possible_values": []
                }
            },
            "batch_699": {
                "variable": {
                    "value": "train_element",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "32",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "batch_701": {
                "variable": {
                    "value": "test_element",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "test_batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "int"
                        ]
                    ]
                }
            },
            "one_hot_706": {
                "variable": {
                    "value": "source_label",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "next_element[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "depth": {
                    "value": "CLASS_NUMBER",
                    "type": "variable",
                    "possible_values": [
                        [
                            "31",
                            "int"
                        ]
                    ]
                }
            },
            "one_hot_708": {
                "variable": {
                    "value": "target_label",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "next_element[3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "depth": {
                    "value": "CLASS_NUMBER",
                    "type": "variable",
                    "possible_values": [
                        [
                            "31",
                            "int"
                        ]
                    ]
                }
            },
            "concat_709": {
                "variable": {
                    "value": "all_data",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[source_data, target_data]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_710": {
                "variable": {
                    "value": "all_label",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[source_label, target_label]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_732": {
                "variable": {
                    "value": "source_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.ones(tf.shape(source_data)[0]), tf.zeros(tf.shape(target_data)[0])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_733": {
                "variable": {
                    "value": "target_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.zeros(tf.shape(target_data)[0]), tf.ones(tf.shape(source_data)[0])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_737": {
                "variable": {
                    "value": "original_logits_1",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tensors_1['output']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, num_classes)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_738": {
                "variable": {
                    "value": "original_logits_2",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tensors_2['output']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, num_classes)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Variable_739": {
                "variable": {
                    "value": "Q",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.log(tf.ones([num_classes, num_classes]) * (0.2 / (num_classes - 1)) + tf.eye(num_classes) * (0.8 - 0.2 / (num_classes - 1)))",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "refine_matrix",
                    "type": "str",
                    "possible_values": []
                }
            },
            "softmax_744": {
                "variable": {
                    "value": "single_logits_1",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "tensors_1['predictions']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "softmax_745": {
                "variable": {
                    "value": "logits_1",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "all_logits_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prediction_refine_k(original_logits_1, num_classes, Q)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_746": {
                "variable": {
                    "value": "source_logits_1",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "all_logits_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prediction_refine_k(original_logits_1, num_classes, Q)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "source_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.ones(tf.shape(source_data)[0]), tf.zeros(tf.shape(target_data)[0])], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_747": {
                "variable": {
                    "value": "source_label_1",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "nodes_1['target']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "mask": {
                    "value": "source_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.ones(tf.shape(source_data)[0]), tf.zeros(tf.shape(target_data)[0])], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_748": {
                "variable": {
                    "value": "target_logits_1",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "all_logits_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prediction_refine_k(original_logits_1, num_classes, Q)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "target_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.zeros(tf.shape(target_data)[0]), tf.ones(tf.shape(source_data)[0])], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_749": {
                "variable": {
                    "value": "target_label_1",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "nodes_1['target']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "mask": {
                    "value": "target_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.zeros(tf.shape(target_data)[0]), tf.ones(tf.shape(source_data)[0])], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_750": {
                "variable": {
                    "value": "source_batch_size_1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.shape(source_logits_1)[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_751": {
                "variable": {
                    "value": "target_batch_size_1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.shape(target_logits_1)[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_757": {
                "variable": {
                    "value": "single_logits_2",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "tensors_2['predictions']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "softmax_758": {
                "variable": {
                    "value": "logits_2",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "all_logits_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prediction_refine_k(original_logits_2, num_classes, Q)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_759": {
                "variable": {
                    "value": "source_logits_2",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "all_logits_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prediction_refine_k(original_logits_2, num_classes, Q)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "source_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.ones(tf.shape(source_data)[0]), tf.zeros(tf.shape(target_data)[0])], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_760": {
                "variable": {
                    "value": "source_label_2",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "nodes_2['target']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "mask": {
                    "value": "source_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.ones(tf.shape(source_data)[0]), tf.zeros(tf.shape(target_data)[0])], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_761": {
                "variable": {
                    "value": "target_logits_2",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "all_logits_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prediction_refine_k(original_logits_2, num_classes, Q)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "target_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.zeros(tf.shape(target_data)[0]), tf.ones(tf.shape(source_data)[0])], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_762": {
                "variable": {
                    "value": "target_label_2",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "nodes_2['target']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "mask": {
                    "value": "target_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.zeros(tf.shape(target_data)[0]), tf.ones(tf.shape(source_data)[0])], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_763": {
                "variable": {
                    "value": "source_batch_size_2",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.shape(source_logits_2)[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_764": {
                "variable": {
                    "value": "target_batch_size_2",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.shape(target_logits_2)[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "transpose_777": {
                "variable": {
                    "value": "logit_1_temp",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.expand_dims(single_logits_1, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_778": {
                "variable": {
                    "value": "logit_2_temp",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.expand_dims(single_logits_2, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "divide_781": {
                "variable": {
                    "value": "weight",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "numerator",
                    "type": "variable",
                    "possible_values": [
                        [
                            "matmul(logit_1_temp, tf.expand_dims(single_logits_2, 2))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "denominator",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sqrt(matmul(logit_1_temp, tf.expand_dims(single_logits_1, 2))) * tf.sqrt(matmul(logit_2_temp, tf.expand_dims(single_logits_2, 2)))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "abs_782": {
                "variable": {
                    "value": "weight_abs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.divide(numerator, denominator)",
                            "Call"
                        ],
                        [
                            "weight",
                            "Method Argument"
                        ],
                        [
                            "weight",
                            "Method Argument"
                        ],
                        [
                            "weight",
                            "Method Argument"
                        ],
                        [
                            "weight",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "boolean_mask_783": {
                "variable": {
                    "value": "source_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "weight_abs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.abs(weight)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "source_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.ones(tf.shape(source_data)[0]), tf.zeros(tf.shape(target_data)[0])], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_784": {
                "variable": {
                    "value": "target_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "weight_abs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.abs(weight)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "target_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.zeros(tf.shape(target_data)[0]), tf.ones(tf.shape(source_data)[0])], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_798": {
                "variable": {
                    "value": "GAP_1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "GAP_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensors_1['global_pool']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(GAP_1, [1, 2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "boolean_mask_799": {
                "variable": {
                    "value": "source_tensors_1",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "GAP_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensors_1['global_pool']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(GAP_1, [1, 2])",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "source_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.ones(tf.shape(source_data)[0]), tf.zeros(tf.shape(target_data)[0])], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_800": {
                "variable": {
                    "value": "target_tensors_1",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "GAP_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensors_1['global_pool']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(GAP_1, [1, 2])",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "target_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.zeros(tf.shape(target_data)[0]), tf.ones(tf.shape(source_data)[0])], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_820": {
                "variable": {
                    "value": "GAP_2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "GAP_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensors_2['global_pool']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(GAP_2, [1, 2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "boolean_mask_821": {
                "variable": {
                    "value": "source_tensors_2",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "GAP_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensors_2['global_pool']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(GAP_2, [1, 2])",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "source_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.ones(tf.shape(source_data)[0]), tf.zeros(tf.shape(target_data)[0])], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_822": {
                "variable": {
                    "value": "target_tensors_2",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "GAP_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensors_2['global_pool']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(GAP_2, [1, 2])",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "target_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.zeros(tf.shape(target_data)[0]), tf.ones(tf.shape(source_data)[0])], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "exponential_decay_856": {
                "variable": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "init_lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0001",
                            "Method Argument"
                        ]
                    ]
                },
                "global_step": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "step + 1",
                            "BinOp"
                        ]
                    ]
                },
                "decay_steps": {
                    "value": "100000",
                    "type": "int",
                    "possible_values": []
                },
                "decay_rate": {
                    "value": "0.99",
                    "type": "float",
                    "possible_values": []
                },
                "staircase": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "merge_all_891": {
                "variable": {
                    "value": "merged_summary",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_893": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_897": {
                "variable": {
                    "value": "saver1",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "variables_network1_ckpt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[v for v in all_variables if v.name.split('/')[0] == 'network1' and 'Logits' not in v.name]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "Saver_898": {
                "variable": {
                    "value": "saver2",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "variables_network2_ckpt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[v for v in all_variables if v.name.split('/')[0] == 'network2' and 'Logits' not in v.name]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "ConfigProto_902": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "concat_101": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "pyrimid",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "relu_104": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(pyrimid, 3)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(net, img_dim[2], 3, scope='conv_pmerge')",
                            "Call"
                        ],
                        [
                            "slim.batch_norm(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "slim.softmax(logits, scope='predictions')",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits, name='predictions')",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Saver_247": {
                "variable": {
                    "value": "restorer",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "variables_to_restore",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "reduce_mean_276": {
                "variable": {
                    "value": "losses[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.losses.sigmoid_cross_entropy(labels, logits)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_279": {
                "variable": {
                    "value": "losses[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.losses.softmax_cross_entropy(labels, logits)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_287": {
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cond(tf.equal(size, 0), lambda : 0.0, lambda : tf.reduce_sum(-y_pred * tf.log(y_pred), axis=1))",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(L, axis=1)",
                            "Call"
                        ],
                        [
                            "loss_1 + loss_2",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_mean_302": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.losses.sigmoid_cross_entropy(labels, logits)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cond_305": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.equal(size, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.reduce_mean(tf.losses.softmax_cross_entropy(labels, logits))",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.reduce_mean(focal_loss(labels, logits, gamma))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "reduce_mean_334": {
                "variable": {
                    "value": "cost",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "kernel(x, x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_339": {
                "variable": {
                    "value": "cost",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "cost > 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "cost",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(kernel(x, x))",
                            "Call"
                        ],
                        [
                            "cost - 2 * tf.reduce_mean(kernel(x, y))",
                            "BinOp"
                        ],
                        [
                            "tf.where(cost > 0, cost, 0, name='value')",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "value",
                    "type": "str",
                    "possible_values": []
                }
            },
            "RegisterGradient_377": {
                "op_type": {
                    "value": "grad_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'FlipGradient%s' % tf.cast(nodes['z_step'], tf.string)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "identity_383": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_404": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "values": {
                    "value": "[source_tensor, target_tensor]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_407": {
                "variable": {
                    "value": "domain_selection_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.zeros((source_batch_size, 1)), tf.ones((target_batch_size, 1))]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_412": {
                "variable": {
                    "value": "grl",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.convert_to_tensor(grl)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, samples.get_shape().as_list()[1])",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "leaky_relu_415": {
                "variable": {
                    "value": "grl",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "grl",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flip_gradient(samples, nodes)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.convert_to_tensor(grl), (-1, samples.get_shape().as_list()[1]))",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc1')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc2')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ],
                        [
                            "flip_gradient(samples, nodes)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.convert_to_tensor(grl), (-1, samples.get_shape().as_list()[1]))",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc1')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc2')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ]
                    ]
                }
            },
            "leaky_relu_417": {
                "variable": {
                    "value": "grl",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "grl",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flip_gradient(samples, nodes)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.convert_to_tensor(grl), (-1, samples.get_shape().as_list()[1]))",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc1')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc2')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ],
                        [
                            "flip_gradient(samples, nodes)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.convert_to_tensor(grl), (-1, samples.get_shape().as_list()[1]))",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc1')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc2')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ]
                    ]
                }
            },
            "cond_435": {
                "variable": {
                    "value": "domain_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.equal(source_batch_size, 0) | tf.equal(target_batch_size, 0)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : cross_entropy(logits, domain_selection_mask)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : ls_distance(logits, source_batch_size, target_batch_size)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "concat_456": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "values": {
                    "value": "[source_tensor, target_tensor]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_459": {
                "variable": {
                    "value": "domain_selection_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.zeros((source_batch_size, 1)), tf.ones((target_batch_size, 1))]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_464": {
                "variable": {
                    "value": "grl",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.convert_to_tensor(grl)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, samples.get_shape().as_list()[1])",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "leaky_relu_467": {
                "variable": {
                    "value": "grl",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "grl",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flip_gradient(samples, nodes)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.convert_to_tensor(grl), (-1, samples.get_shape().as_list()[1]))",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc1')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc2')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ],
                        [
                            "flip_gradient(samples, nodes)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.convert_to_tensor(grl), (-1, samples.get_shape().as_list()[1]))",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc1')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc2')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ]
                    ]
                }
            },
            "leaky_relu_469": {
                "variable": {
                    "value": "grl",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "grl",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flip_gradient(samples, nodes)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.convert_to_tensor(grl), (-1, samples.get_shape().as_list()[1]))",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc1')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc2')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ],
                        [
                            "flip_gradient(samples, nodes)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.convert_to_tensor(grl), (-1, samples.get_shape().as_list()[1]))",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc1')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc2')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ]
                    ]
                }
            },
            "cond_487": {
                "variable": {
                    "value": "domain_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.equal(source_batch_size, 0) | tf.equal(target_batch_size, 0)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : cross_entropy(logits, domain_selection_mask, weight)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : ls_distance(logits, source_batch_size, target_batch_size, weight)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "trainable_variables_497": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "add_n_501": {
                "inputs": {
                    "value": "l2_losses_existing_layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "reduce_mean_576": {
                "input_tensor": {
                    "value": "classifier_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(logits_1 * tf.log(logits_1 / medium_dsitribution), axis=1) + tf.reduce_sum(logits_2 * tf.log(logits_2 / medium_dsitribution), axis=1)",
                            "BinOp"
                        ],
                        [
                            "-eta * build_classifier_loss(single_logits_1, single_logits_2)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "scalar_877": {
                "name": {
                    "value": "network1/acc/source_train_acc",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "source_acc_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100 / source_batch_size_1 * tf.reduce_sum(tf.cast(tf.equal(tf.argmax(source_logits_1, 1), tf.argmax(source_label_1, 1)), tf.float32))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "scalar_878": {
                "name": {
                    "value": "network1/acc/target_train_acc",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "target_acc_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100 / target_batch_size_1 * tf.reduce_sum(tf.cast(tf.equal(tf.argmax(target_logits_1, 1), tf.argmax(target_label_1, 1)), tf.float32))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "scalar_879": {
                "name": {
                    "value": "network1/loss/classification loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "classification_loss_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "build_focal_loss(source_logits_1, source_label_1)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_881": {
                "name": {
                    "value": "network1/loss/domain loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "domain_loss_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "build_weighted_dann_loss(source_tensors_1, target_tensors_1, nodes_1, 1 + domain_weight, variables_1, scope='network1-dann')",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_882": {
                "name": {
                    "value": "network1/loss/total loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "loss_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "classification_loss_1 + alpha * domain_loss_1 + regularization_loss_1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "scalar_883": {
                "name": {
                    "value": "network2/acc/source_train_acc",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "source_acc_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100 / source_batch_size_2 * tf.reduce_sum(tf.cast(tf.equal(tf.argmax(source_logits_2, 1), tf.argmax(source_label_2, 1)), tf.float32))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "scalar_884": {
                "name": {
                    "value": "network2/acc/target_train_acc",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "target_acc_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100 / target_batch_size_2 * tf.reduce_sum(tf.cast(tf.equal(tf.argmax(target_logits_2, 1), tf.argmax(target_label_2, 1)), tf.float32))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "scalar_885": {
                "name": {
                    "value": "network2/loss/classification loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "classification_loss_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "build_focal_loss(source_logits_2, source_label_2)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_887": {
                "name": {
                    "value": "network2/loss/domain loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "domain_loss_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "build_weighted_dann_loss(source_tensors_2, target_tensors_2, nodes_2, 1 + domain_weight, variables_2, scope='network2-dann')",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_888": {
                "name": {
                    "value": "network2/loss/total loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "loss_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "classification_loss_2 + alpha * domain_loss_2 + regularization_loss_2",
                            "BinOp"
                        ]
                    ]
                }
            },
            "scalar_889": {
                "name": {
                    "value": "loss/classifier loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "classifier_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(logits_1 * tf.log(logits_1 / medium_dsitribution), axis=1) + tf.reduce_sum(logits_2 * tf.log(logits_2 / medium_dsitribution), axis=1)",
                            "BinOp"
                        ],
                        [
                            "-eta * build_classifier_loss(single_logits_1, single_logits_2)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "scalar_890": {
                "name": {
                    "value": "loss/total loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "loss + classifier_loss",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "FileWriter_905": {
                "variable": {
                    "value": "train_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "output_folder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'./'",
                            "Method Argument"
                        ]
                    ]
                },
                "graph": {
                    "value": "sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_80": {
                "name_or_scope": {
                    "value": "psp_net",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_94": {
                "variable": {
                    "value": "pyrimid[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "features": {
                    "value": "pyrimid[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "relu_139": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mobilenet_v2(images, 512, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.batch_norm(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(logits)",
                            "Call"
                        ],
                        [
                            "build_psp(logits)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(logits, num_classes, 1, scope='conv_seg', biases_initializer=tf.zeros_initializer(), padding=padding)",
                            "Call"
                        ],
                        [
                            "mobilenet_v2(images, num_classes, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "placeholder_203": {
                "variable": {
                    "value": "imgs_node",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None] + list(img_size)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "image_input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_207": {
                "variable": {
                    "value": "labels_node",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, num_classes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_211": {
                "variable": {
                    "value": "is_training_node",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "equal_286": {
                "x": {
                    "value": "size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.shape(logits)[0], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.shape(logits)[0], tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_291": {
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(source_logits)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_333": {
                "name": {
                    "value": "MaximumMeanDiscrepancy",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_335": {
                "input_tensor": {
                    "value": "kernel(y, y)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_376": {
                "x": {
                    "value": "nodes['z_step']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_401": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sigmoid_422": {
                "variable": {
                    "value": "domain_predictions",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mobilenet_v2(images, 512, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.batch_norm(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(logits)",
                            "Call"
                        ],
                        [
                            "build_psp(logits)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(logits, num_classes, 1, scope='conv_seg', biases_initializer=tf.zeros_initializer(), padding=padding)",
                            "Call"
                        ],
                        [
                            "mobilenet_v2(images, num_classes, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "log_loss_423": {
                "variable": {
                    "value": "domain_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "domain_selection_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(axis=0, values=[tf.zeros((source_batch_size, 1)), tf.ones((target_batch_size, 1))])",
                            "Call"
                        ],
                        [
                            "tf.concat(axis=0, values=[tf.zeros((source_batch_size, 1)), tf.ones((target_batch_size, 1))])",
                            "Call"
                        ],
                        [
                            "domain_selection_mask",
                            "Method Argument"
                        ],
                        [
                            "domain_selection_mask",
                            "Method Argument"
                        ],
                        [
                            "domain_selection_mask",
                            "Method Argument"
                        ],
                        [
                            "domain_selection_mask",
                            "Method Argument"
                        ]
                    ]
                },
                "predictions": {
                    "value": "domain_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ]
                    ]
                }
            },
            "split_427": {
                "variable": {
                    "value": "(source_adversary_logits, target_adversary_logits)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mobilenet_v2(images, 512, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.batch_norm(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(logits)",
                            "Call"
                        ],
                        [
                            "build_psp(logits)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(logits, num_classes, 1, scope='conv_seg', biases_initializer=tf.zeros_initializer(), padding=padding)",
                            "Call"
                        ],
                        [
                            "mobilenet_v2(images, num_classes, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "[source_batch_size, target_batch_size]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_432": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mobilenet_v2(images, 512, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.batch_norm(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(logits)",
                            "Call"
                        ],
                        [
                            "build_psp(logits)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(logits, num_classes, 1, scope='conv_seg', biases_initializer=tf.zeros_initializer(), padding=padding)",
                            "Call"
                        ],
                        [
                            "mobilenet_v2(images, num_classes, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_433": {
                "variable": {
                    "value": "domain_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "-domain_selection_mask * ((1 - y_pred) * gamma) * tf.log(y_pred) - (1 - domain_selection_mask) * y_pred ** gamma * tf.log(1 - y_pred)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_453": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sigmoid_473": {
                "variable": {
                    "value": "domain_predictions",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mobilenet_v2(images, 512, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.batch_norm(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(logits)",
                            "Call"
                        ],
                        [
                            "build_psp(logits)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(logits, num_classes, 1, scope='conv_seg', biases_initializer=tf.zeros_initializer(), padding=padding)",
                            "Call"
                        ],
                        [
                            "mobilenet_v2(images, num_classes, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "log_loss_474": {
                "variable": {
                    "value": "domain_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "domain_selection_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(axis=0, values=[tf.zeros((source_batch_size, 1)), tf.ones((target_batch_size, 1))])",
                            "Call"
                        ],
                        [
                            "tf.concat(axis=0, values=[tf.zeros((source_batch_size, 1)), tf.ones((target_batch_size, 1))])",
                            "Call"
                        ],
                        [
                            "domain_selection_mask",
                            "Method Argument"
                        ],
                        [
                            "domain_selection_mask",
                            "Method Argument"
                        ],
                        [
                            "domain_selection_mask",
                            "Method Argument"
                        ],
                        [
                            "domain_selection_mask",
                            "Method Argument"
                        ]
                    ]
                },
                "predictions": {
                    "value": "domain_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ]
                    ]
                },
                "weights": {
                    "value": "weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.divide(numerator, denominator)",
                            "Call"
                        ],
                        [
                            "weight",
                            "Method Argument"
                        ],
                        [
                            "weight",
                            "Method Argument"
                        ],
                        [
                            "weight",
                            "Method Argument"
                        ],
                        [
                            "weight",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "split_478": {
                "variable": {
                    "value": "(source_adversary_logits, target_adversary_logits)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mobilenet_v2(images, 512, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.batch_norm(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(logits)",
                            "Call"
                        ],
                        [
                            "build_psp(logits)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(logits, num_classes, 1, scope='conv_seg', biases_initializer=tf.zeros_initializer(), padding=padding)",
                            "Call"
                        ],
                        [
                            "mobilenet_v2(images, num_classes, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "[source_batch_size, target_batch_size]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_479": {
                "variable": {
                    "value": "(source_weight, target_weight)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.divide(numerator, denominator)",
                            "Call"
                        ],
                        [
                            "weight",
                            "Method Argument"
                        ],
                        [
                            "weight",
                            "Method Argument"
                        ],
                        [
                            "weight",
                            "Method Argument"
                        ],
                        [
                            "weight",
                            "Method Argument"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "[source_batch_size, target_batch_size]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_484": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mobilenet_v2(images, 512, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.batch_norm(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(logits)",
                            "Call"
                        ],
                        [
                            "build_psp(logits)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(logits, num_classes, 1, scope='conv_seg', biases_initializer=tf.zeros_initializer(), padding=padding)",
                            "Call"
                        ],
                        [
                            "mobilenet_v2(images, num_classes, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_485": {
                "variable": {
                    "value": "domain_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "-domain_selection_mask * ((1 - y_pred) * gamma) * tf.log(y_pred) - (1 - domain_selection_mask) * y_pred ** gamma * tf.log(1 - y_pred)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_505": {
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(source_logits)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_514": {
                "name_or_scope": {
                    "value": "denoise1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_522": {
                "name_or_scope": {
                    "value": "denoise2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_546": {
                "name_or_scope": {
                    "value": "refine",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_574": {
                "input_tensor": {
                    "value": "logits_2 * tf.log(logits_2 / medium_dsitribution)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_739": {
                "x": {
                    "value": "tf.ones([num_classes, num_classes]) * (0.2 / (num_classes - 1)) + tf.eye(num_classes) * (0.8 - 0.2 / (num_classes - 1))",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_752": {
                "input_tensor": {
                    "value": "tf.cast(tf.equal(tf.argmax(source_logits_1, 1), tf.argmax(source_label_1, 1)), tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_753": {
                "input_tensor": {
                    "value": "tf.cast(tf.equal(tf.argmax(target_logits_1, 1), tf.argmax(target_label_1, 1)), tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_765": {
                "input_tensor": {
                    "value": "tf.cast(tf.equal(tf.argmax(source_logits_2, 1), tf.argmax(source_label_2, 1)), tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_766": {
                "input_tensor": {
                    "value": "tf.cast(tf.equal(tf.argmax(target_logits_2, 1), tf.argmax(target_label_2, 1)), tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "squeeze_775": {
                "input": {
                    "value": "tf.matmul(A, B)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_777": {
                "input": {
                    "value": "single_logits_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(tensors_1['predictions'])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_778": {
                "input": {
                    "value": "single_logits_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(tensors_2['predictions'])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_779": {
                "input": {
                    "value": "single_logits_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(tensors_2['predictions'])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sqrt_780": {
                "x": {
                    "value": "matmul(logit_2_temp, tf.expand_dims(single_logits_2, 2))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_785": {
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "values": {
                    "value": "[source_weight, target_weight]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_n_839": {
                "inputs": {
                    "value": "[tf.nn.l2_loss(tf.cast(v, tf.float32)) for v in variables_network1 if 'batch_normalization' not in v.name]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "add_n_842": {
                "inputs": {
                    "value": "[tf.nn.l2_loss(tf.cast(v, tf.float32)) for v in variables_network2 if 'batch_normalization' not in v.name]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "Session_904": {
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ]
                    ]
                }
            },
            "global_variables_initializer_907": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_907": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sigmoid_155": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mobilenet_v2(images, 512, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.batch_norm(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(logits)",
                            "Call"
                        ],
                        [
                            "build_psp(logits)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(logits, num_classes, 1, scope='conv_seg', biases_initializer=tf.zeros_initializer(), padding=padding)",
                            "Call"
                        ],
                        [
                            "mobilenet_v2(images, num_classes, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "predictions",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_175": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "placeholder_179": {
                "variable": {
                    "value": "imgs_node",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None] + list(img_size)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "image_input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_183": {
                "variable": {
                    "value": "labels_node",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, num_classes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_187": {
                "variable": {
                    "value": "is_training_node",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_276": {
                "multi_class_labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{'source_label': s_input_labels, 'target_label': t_input_labels}",
                            "Dict"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mobilenet_v2(images, 512, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.batch_norm(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(logits)",
                            "Call"
                        ],
                        [
                            "build_psp(logits)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(logits, num_classes, 1, scope='conv_seg', biases_initializer=tf.zeros_initializer(), padding=padding)",
                            "Call"
                        ],
                        [
                            "mobilenet_v2(images, num_classes, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_279": {
                "onehot_labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{'source_label': s_input_labels, 'target_label': t_input_labels}",
                            "Dict"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mobilenet_v2(images, 512, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.batch_norm(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(logits)",
                            "Call"
                        ],
                        [
                            "build_psp(logits)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(logits, num_classes, 1, scope='conv_seg', biases_initializer=tf.zeros_initializer(), padding=padding)",
                            "Call"
                        ],
                        [
                            "mobilenet_v2(images, num_classes, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_285": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mobilenet_v2(images, 512, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.batch_norm(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(logits)",
                            "Call"
                        ],
                        [
                            "build_psp(logits)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(logits, num_classes, 1, scope='conv_seg', biases_initializer=tf.zeros_initializer(), padding=padding)",
                            "Call"
                        ],
                        [
                            "mobilenet_v2(images, num_classes, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_286": {
                "input_tensor": {
                    "value": "-y_pred * tf.log(y_pred)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_300": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mobilenet_v2(images, 512, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.batch_norm(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(logits)",
                            "Call"
                        ],
                        [
                            "build_psp(logits)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(logits, num_classes, 1, scope='conv_seg', biases_initializer=tf.zeros_initializer(), padding=padding)",
                            "Call"
                        ],
                        [
                            "mobilenet_v2(images, num_classes, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sigmoid_cross_entropy_302": {
                "multi_class_labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{'source_label': s_input_labels, 'target_label': t_input_labels}",
                            "Dict"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mobilenet_v2(images, 512, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.batch_norm(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(logits)",
                            "Call"
                        ],
                        [
                            "build_psp(logits)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(logits, num_classes, 1, scope='conv_seg', biases_initializer=tf.zeros_initializer(), padding=padding)",
                            "Call"
                        ],
                        [
                            "mobilenet_v2(images, num_classes, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "equal_305": {
                "x": {
                    "value": "size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.shape(logits)[0], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.shape(logits)[0], tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_336": {
                "input_tensor": {
                    "value": "kernel(x, y)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_363": {
                "value": {
                    "value": "sigmas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1e-06, 1e-05, 0.0001, 0.001, 0.01, 0.1, 1, 5, 10, 15, 20, 25, 30, 35, 100, 1000.0, 10000.0, 100000.0, 1000000.0]",
                            "List"
                        ]
                    ]
                }
            },
            "shape_402": {
                "input": {
                    "value": "source_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "source_tensor",
                            "Method Argument"
                        ],
                        [
                            "source_tensor",
                            "Method Argument"
                        ],
                        [
                            "source_tensor",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_403": {
                "input": {
                    "value": "target_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "target_tensor",
                            "Method Argument"
                        ],
                        [
                            "target_tensor",
                            "Method Argument"
                        ],
                        [
                            "target_tensor",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_412": {
                "value": {
                    "value": "grl",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flip_gradient(samples, nodes)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.convert_to_tensor(grl), (-1, samples.get_shape().as_list()[1]))",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc1')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc2')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ],
                        [
                            "flip_gradient(samples, nodes)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.convert_to_tensor(grl), (-1, samples.get_shape().as_list()[1]))",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc1')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc2')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_454": {
                "input": {
                    "value": "source_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "source_tensor",
                            "Method Argument"
                        ],
                        [
                            "source_tensor",
                            "Method Argument"
                        ],
                        [
                            "source_tensor",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_455": {
                "input": {
                    "value": "target_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "target_tensor",
                            "Method Argument"
                        ],
                        [
                            "target_tensor",
                            "Method Argument"
                        ],
                        [
                            "target_tensor",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_464": {
                "value": {
                    "value": "grl",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flip_gradient(samples, nodes)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.convert_to_tensor(grl), (-1, samples.get_shape().as_list()[1]))",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc1')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc2')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ],
                        [
                            "flip_gradient(samples, nodes)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.convert_to_tensor(grl), (-1, samples.get_shape().as_list()[1]))",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc1')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1024, scope='fc2')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(grl)",
                            "Call"
                        ]
                    ]
                }
            },
            "l2_loss_500": {
                "t": {
                    "value": "v - pre_trained_weights",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_532": {
                "input": {
                    "value": "source_prediction_1[:, 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_533": {
                "input": {
                    "value": "source_prediction_2[:, 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_732": {
                "shape": {
                    "value": "tf.shape(source_data)[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "zeros_732": {
                "shape": {
                    "value": "tf.shape(target_data)[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "zeros_733": {
                "shape": {
                    "value": "tf.shape(target_data)[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ones_733": {
                "shape": {
                    "value": "tf.shape(source_data)[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_750": {
                "input": {
                    "value": "source_logits_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(all_logits_1, source_mask)",
                            "Call"
                        ],
                        [
                            "source_logits_1",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_751": {
                "input": {
                    "value": "target_logits_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(all_logits_1, target_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_752": {
                "x": {
                    "value": "tf.equal(tf.argmax(source_logits_1, 1), tf.argmax(source_label_1, 1))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_753": {
                "x": {
                    "value": "tf.equal(tf.argmax(target_logits_1, 1), tf.argmax(target_label_1, 1))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_763": {
                "input": {
                    "value": "source_logits_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(all_logits_2, source_mask)",
                            "Call"
                        ],
                        [
                            "source_logits_2",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_764": {
                "input": {
                    "value": "target_logits_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(all_logits_2, target_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_765": {
                "x": {
                    "value": "tf.equal(tf.argmax(source_logits_2, 1), tf.argmax(source_label_2, 1))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_766": {
                "x": {
                    "value": "tf.equal(tf.argmax(target_logits_2, 1), tf.argmax(target_label_2, 1))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_775": {
                "a": {
                    "value": "A",
                    "type": "variable",
                    "possible_values": [
                        [
                            "A",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "B",
                    "type": "variable",
                    "possible_values": [
                        [
                            "B",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_305": {
                "input_tensor": {
                    "value": "tf.losses.softmax_cross_entropy(labels, logits)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_306": {
                "input_tensor": {
                    "value": "focal_loss(labels, logits, gamma)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exp_375": {
                "x": {
                    "value": "-tf.cast(nodes['z_step'], tf.float32) * l",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "negative_379": {
                "x": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grad",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_428": {
                "input_tensor": {
                    "value": "target_adversary_logits ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "equal_435": {
                "x": {
                    "value": "target_batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(target_tensor)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(target_tensor)[0]",
                            "Subscript"
                        ],
                        [
                            "target_batch_size",
                            "Method Argument"
                        ],
                        [
                            "target_batch_size",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_480": {
                "input_tensor": {
                    "value": "tf.multiply(target_weight, target_adversary_logits ** 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_487": {
                "x": {
                    "value": "target_batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(target_tensor)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(target_tensor)[0]",
                            "Subscript"
                        ],
                        [
                            "target_batch_size",
                            "Method Argument"
                        ],
                        [
                            "target_batch_size",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_initializer_516": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_516": {
                "value": {
                    "value": "[0.9, 0.1, 0.1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_initializer_518": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_518": {
                "value": {
                    "value": "[0.1, 0.9, 0.1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_initializer_520": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_520": {
                "value": {
                    "value": "[0.1, 0.1, 0.9]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_initializer_524": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_524": {
                "value": {
                    "value": "[0.9, 0.1, 0.1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_initializer_526": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_526": {
                "value": {
                    "value": "[0.1, 0.9, 0.1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_initializer_528": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_528": {
                "value": {
                    "value": "[0.1, 0.1, 0.9]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_initializer_548": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_548": {
                "value": {
                    "value": "[0.9, 0.1, 0.1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_initializer_550": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_550": {
                "value": {
                    "value": "[0.1, 0.9, 0.1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_initializer_552": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_552": {
                "value": {
                    "value": "[0.1, 0.1, 0.9]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_554": {
                "input": {
                    "value": "source_prediction[:, 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_574": {
                "x": {
                    "value": "logits_2 / medium_dsitribution",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "equal_752": {
                "x": {
                    "value": "tf.argmax(source_logits_1, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.argmax(source_label_1, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_753": {
                "x": {
                    "value": "tf.argmax(target_logits_1, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.argmax(target_label_1, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_765": {
                "x": {
                    "value": "tf.argmax(source_logits_2, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.argmax(source_label_2, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_766": {
                "x": {
                    "value": "tf.argmax(target_logits_2, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.argmax(target_label_2, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_780": {
                "input": {
                    "value": "single_logits_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(tensors_2['predictions'])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_loss_840": {
                "t": {
                    "value": "tf.cast(v, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "l2_loss_843": {
                "t": {
                    "value": "tf.cast(v, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_initializer_143": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "log_286": {
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(source_logits)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_305": {
                "onehot_labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{'source_label': s_input_labels, 'target_label': t_input_labels}",
                            "Dict"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mobilenet_v2(images, 512, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.batch_norm(logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(logits)",
                            "Call"
                        ],
                        [
                            "build_psp(logits)",
                            "Call"
                        ],
                        [
                            "slim.conv2d(logits, num_classes, 1, scope='conv_seg', biases_initializer=tf.zeros_initializer(), padding=padding)",
                            "Call"
                        ],
                        [
                            "mobilenet_v2(images, num_classes, depth_multiplier, finegrain_classification_mode, padding, flag_global_pool)",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(grl, 1, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "zeros_408": {
                "shape": {
                    "value": "(source_batch_size, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "ones_408": {
                "shape": {
                    "value": "(target_batch_size, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "zeros_460": {
                "shape": {
                    "value": "(source_batch_size, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "ones_460": {
                "shape": {
                    "value": "(target_batch_size, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "multiply_480": {
                "x": {
                    "value": "target_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.split(weight, [source_batch_size, target_batch_size], 0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(weight_abs, target_mask)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "target_adversary_logits ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_732": {
                "input": {
                    "value": "target_data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "train_image_process(fname['target'])",
                            "Call"
                        ],
                        [
                            "next_element[2]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_733": {
                "input": {
                    "value": "source_data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "train_image_process(fname['source'])",
                            "Call"
                        ],
                        [
                            "next_element[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "ones_739": {
                "shape": {
                    "value": "[num_classes, num_classes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "eye_739": {
                "num_rows": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "CLASS_NUMBER",
                            "variable"
                        ],
                        [
                            "CLASS_NUMBER",
                            "variable"
                        ],
                        [
                            "CLASS_NUMBER",
                            "variable"
                        ],
                        [
                            "num_classes",
                            "Method Argument"
                        ],
                        [
                            "num_classes",
                            "Method Argument"
                        ],
                        [
                            "num_classes",
                            "Method Argument"
                        ],
                        [
                            "num_classes",
                            "Method Argument"
                        ],
                        [
                            "num_classes",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "argmax_752": {
                "input": {
                    "value": "source_label_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(nodes_1['target'], source_mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_753": {
                "input": {
                    "value": "target_label_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(nodes_1['target'], target_mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_765": {
                "input": {
                    "value": "source_label_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(nodes_2['target'], source_mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_766": {
                "input": {
                    "value": "target_label_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(nodes_2['target'], target_mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_840": {
                "x": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_843": {
                "x": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "log_433": {
                "x": {
                    "value": "1 - y_pred",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_485": {
                "x": {
                    "value": "1 - y_pred",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_375": {
                "x": {
                    "value": "nodes['z_step']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "src_office/utils.py": {
        "tensorflow": {
            "unstack_77": {
                "variable": {
                    "value": "conv_summary",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "features_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features_tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_78": {
                "variable": {
                    "value": "conv_one_row",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "values": {
                    "value": "conv_summary[0:num_filters_sqrt]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "tf.unstack(features_tensor, axis=3)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_122": {
                "variable": {
                    "value": "grid_centers",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "batch * [[height_half, width_half]]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_123": {
                "variable": {
                    "value": "crop_sizes",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "batch * [[input_height, input_width]]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "matmul_181": {
                "variable": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0 / (2.0 * tf.expand_dims(sigmas, 1))",
                            "BinOp"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.reshape(dist, (1, -1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_82": {
                "variable": {
                    "value": "conv_one_row",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "values": {
                    "value": "conv_summary[ind * num_filters_sqrt + 0:ind * num_filters_sqrt + num_filters_sqrt]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "tf.unstack(features_tensor, axis=3)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_85": {
                "variable": {
                    "value": "conv_final",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.squeeze(conv_final), tf.squeeze(conv_one_row)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_87": {
                "variable": {
                    "value": "conv_final",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv_final",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv_one_row",
                            "variable"
                        ],
                        [
                            "tf.concat(axis=1, values=[tf.squeeze(conv_final), tf.squeeze(conv_one_row)])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(conv_final, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_101": {
                "input_tensor": {
                    "value": "tf.cast(tf.equal(predictions, labels), tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "transpose_161": {
                "a": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "y",
                            "Method Argument"
                        ],
                        [
                            "y",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_183": {
                "tensor": {
                    "value": "tf.reduce_sum(tf.exp(-s), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.shape(dist)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_101": {
                "x": {
                    "value": "tf.equal(predictions, labels)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_float_127": {
                "x": {
                    "value": "crop_sizes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(batch * [[input_height, input_width]])",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_150": {
                "input_tensor": {
                    "value": "tf.square(x)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_181": {
                "tensor": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compute_pairwise_distances(x, y)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(1, -1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reduce_sum_183": {
                "input_tensor": {
                    "value": "tf.exp(-s)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_183": {
                "input": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compute_pairwise_distances(x, y)",
                            "Call"
                        ]
                    ]
                }
            },
            "image_45": {
                "name": {
                    "value": "'{}/{}'.format(prefix, name)",
                    "type": "Call",
                    "possible_values": []
                },
                "data": {
                    "value": "visualization_image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "end_points[layer_name]",
                            "Subscript"
                        ],
                        [
                            "reshape_feature_maps(end_points[layer_name])",
                            "Call"
                        ]
                    ]
                },
                "max_outputs": {
                    "value": "max_images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "expand_dims_50": {
                "variable": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "end_points[layer_name]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_101": {
                "x": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "predictions",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "square_150": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "expand_dims_177": {
                "input": {
                    "value": "sigmas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sigmas",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_183": {
                "x": {
                    "value": "-s",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "image_51": {
                "name": {
                    "value": "'{}/{}'.format(prefix, name)",
                    "type": "Call",
                    "possible_values": []
                },
                "data": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(end_points[layer_name], 3)",
                            "Call"
                        ]
                    ]
                },
                "max_outputs": {
                    "value": "max_images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "expand_dims_161": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "histogram_56": {
                "name": {
                    "value": "'{}/{}'.format(prefix, name)",
                    "type": "Call",
                    "possible_values": []
                },
                "data": {
                    "value": "end_points[layer_name]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "squeeze_86": {
                "input": {
                    "value": "conv_one_row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(axis=2, values=conv_summary[0:num_filters_sqrt])",
                            "Call"
                        ],
                        [
                            "tf.concat(axis=2, values=conv_summary[ind * num_filters_sqrt + 0:ind * num_filters_sqrt + num_filters_sqrt])",
                            "Call"
                        ]
                    ]
                }
            }
        }
    }
}