{
    "pinn/__init__.py": {
        "tensorflow": {}
    },
    "pinn/calculator.py": {
        "tensorflow": {}
    },
    "pinn/cli.py": {
        "tensorflow": {
            "RunConfig_113": {
                "variable": {
                    "value": "config",
                    "possible_values": []
                },
                "keep_checkpoint_max": {
                    "value": "max_ckpts",
                    "possible_values": []
                },
                "log_step_count_steps": {
                    "value": "log_every",
                    "possible_values": []
                },
                "save_summary_steps": {
                    "value": "log_every",
                    "possible_values": []
                },
                "save_checkpoints_steps": {
                    "value": "ckpt_every",
                    "possible_values": []
                }
            },
            "TrainSpec_126": {
                "variable": {
                    "value": "train_spec",
                    "possible_values": []
                },
                "input_fn": {
                    "value": "train_fn",
                    "possible_values": [
                        [
                            "lambda : _dataset_fn(train_ds).repeat().shuffle(shuffle_buffer)",
                            "Lambda"
                        ]
                    ]
                },
                "max_steps": {
                    "value": "train_steps",
                    "possible_values": []
                },
                "hooks": {
                    "value": "hooks",
                    "possible_values": [
                        [
                            "[tf.estimator.experimental.stop_if_no_decrease_hook(model, k, v) for (k, v) in stops.items()]",
                            "ListComp"
                        ],
                        [
                            "None",
                            "Constant"
                        ]
                    ]
                }
            },
            "EvalSpec_127": {
                "variable": {
                    "value": "eval_spec",
                    "possible_values": []
                },
                "input_fn": {
                    "value": "eval_fn",
                    "possible_values": [
                        [
                            "lambda : _dataset_fn(eval_ds)",
                            "Lambda"
                        ]
                    ]
                },
                "steps": {
                    "value": "eval_steps",
                    "possible_values": []
                }
            },
            "get_logger_79": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "train_and_evaluate_128": {
                "estimator": {
                    "value": "model",
                    "possible_values": [
                        [
                            "get_model(params, config=config)",
                            "Call"
                        ]
                    ]
                },
                "train_spec": {
                    "value": "train_spec",
                    "possible_values": [
                        [
                            "tf.estimator.TrainSpec(input_fn=train_fn, max_steps=train_steps, hooks=hooks)",
                            "Call"
                        ]
                    ]
                },
                "eval_spec": {
                    "value": "eval_spec",
                    "possible_values": [
                        [
                            "tf.estimator.EvalSpec(input_fn=eval_fn, steps=eval_steps)",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_if_no_decrease_hook_122": {
                "estimator": {
                    "value": "model",
                    "possible_values": [
                        [
                            "get_model(params, config=config)",
                            "Call"
                        ]
                    ]
                },
                "metric_name": {
                    "value": "k",
                    "possible_values": []
                },
                "max_steps_without_decrease": {
                    "value": "v",
                    "possible_values": [
                        [
                            "event.summary.value",
                            "Attribute"
                        ]
                    ]
                }
            },
            "name_scope_98": {
                "name": {
                    "value": "PRE",
                    "possible_values": []
                }
            }
        }
    },
    "pinn/io/ani.py": {
        "tensorflow": {
            "floatx_43": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "floatx_44": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            }
        }
    },
    "pinn/io/base.py": {
        "tensorflow": {
            "cast_19": {
                "variable": {
                    "value": "atom_ind",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(tensors['elems'])",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "gather_nd_23": {
                "variable": {
                    "value": "elems",
                    "possible_values": []
                },
                "params": {
                    "value": "tensors['elems']",
                    "possible_values": []
                },
                "indices": {
                    "value": "atom_ind",
                    "possible_values": [
                        [
                            "tf.cast(tf.where(tensors['elems']), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_24": {
                "variable": {
                    "value": "coord",
                    "possible_values": []
                },
                "params": {
                    "value": "tensors['coord']",
                    "possible_values": []
                },
                "indices": {
                    "value": "atom_ind",
                    "possible_values": [
                        [
                            "tf.cast(tf.where(tensors['elems']), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "floatx_88": {
                "variable": {
                    "value": "dtype",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "where_19": {
                "condition": {
                    "value": "tensors['elems']",
                    "possible_values": []
                }
            },
            "cumsum_21": {
                "x": {
                    "value": "tf.ones(tf.shape(ind_1), tf.int32)",
                    "possible_values": []
                }
            },
            "gather_nd_30": {
                "variable": {
                    "value": "tensors[name]",
                    "possible_values": []
                },
                "params": {
                    "value": "tensors[name]",
                    "possible_values": []
                },
                "indices": {
                    "value": "atom_ind",
                    "possible_values": [
                        [
                            "tf.cast(tf.where(tensors['elems']), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_21": {
                "shape": {
                    "value": "tf.shape(ind_1)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "shape_21": {
                "input": {
                    "value": "ind_1",
                    "possible_values": [
                        [
                            "atom_ind[:, :1]",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "pinn/io/numpy.py": {
        "tensorflow": {
            "floatx_29": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            }
        }
    },
    "pinn/io/qm9.py": {
        "tensorflow": {}
    },
    "pinn/io/tfr.py": {
        "tensorflow": {
            "TFRecordWriter_23": {
                "variable": {
                    "value": "writer",
                    "possible_values": []
                },
                "path": {
                    "value": "tfr",
                    "possible_values": [
                        [
                            "'.'.join(fname.split('.')[:-1] + ['tfr'])",
                            "Call"
                        ],
                        [
                            "'.'.join(dataset.split('.')[:-1] + ['tfr'])",
                            "Call"
                        ]
                    ]
                }
            },
            "TFRecordDataset_95": {
                "variable": {
                    "value": "dataset",
                    "possible_values": []
                },
                "filenames": {
                    "value": "tfr",
                    "possible_values": [
                        [
                            "'.'.join(fname.split('.')[:-1] + ['tfr'])",
                            "Call"
                        ],
                        [
                            "'.'.join(dataset.split('.')[:-1] + ['tfr'])",
                            "Call"
                        ]
                    ]
                }
            },
            "Example_39": {
                "variable": {
                    "value": "example",
                    "possible_values": []
                },
                "features": {
                    "value": "tf.train.Features(feature={key: _bytes_feature(val.numpy()) for (key, val) in tensors.items()})",
                    "possible_values": []
                }
            },
            "Feature_20": {
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[value])",
                    "possible_values": []
                }
            },
            "FixedLenFeature_85": {
                "shape": {
                    "value": "[]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "possible_values": []
                }
            },
            "parse_single_example_88": {
                "serialized": {
                    "value": "example",
                    "possible_values": [
                        [
                            "tf.train.Example(features=tf.train.Features(feature={key: _bytes_feature(val.numpy()) for (key, val) in tensors.items()}))",
                            "Call"
                        ]
                    ]
                },
                "features": {
                    "value": "feature_dict",
                    "possible_values": [
                        [
                            "{k: tf.io.FixedLenFeature([], tf.string) for k in dtypes}",
                            "DictComp"
                        ]
                    ]
                }
            },
            "serialize_tensor_33": {
                "tensor": {
                    "value": "v",
                    "possible_values": []
                }
            },
            "parse_tensor_90": {
                "serialized": {
                    "value": "v",
                    "possible_values": []
                },
                "out_type": {
                    "value": "dtypes[k]",
                    "possible_values": []
                }
            },
            "BytesList_20": {
                "value": {
                    "value": "[value]",
                    "possible_values": []
                }
            },
            "Features_40": {
                "feature": {
                    "value": "{key: _bytes_feature(val.numpy()) for (key, val) in tensors.items()}",
                    "possible_values": []
                }
            },
            "reduce_any_105": {
                "input_tensor": {
                    "value": "tf.equal(v, i)",
                    "possible_values": []
                }
            },
            "equal_105": {
                "x": {
                    "value": "v",
                    "possible_values": []
                },
                "y": {
                    "value": "i",
                    "possible_values": []
                }
            }
        }
    },
    "pinn/layers.py": {
        "tensorflow": {
            "CellListNL_52": {
                "base_class_0": {
                    "value": "tensorflow.keras.layers.Layer",
                    "possible_values": []
                },
                "self.rc": {
                    "value": "rc",
                    "possible_values": [
                        [
                            "5.0",
                            "MethodArgument"
                        ],
                        [
                            "5.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "CutoffFunc_146": {
                "base_class_0": {
                    "value": "tensorflow.keras.layers.Layer",
                    "possible_values": []
                },
                "self.cutoff_type": {
                    "value": "cutoff_type",
                    "possible_values": [
                        [
                            "'f1'",
                            "MethodArgument"
                        ]
                    ]
                },
                "self.rc": {
                    "value": "rc",
                    "possible_values": [
                        [
                            "5.0",
                            "MethodArgument"
                        ],
                        [
                            "5.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "GaussianBasis_170": {
                "base_class_0": {
                    "value": "tensorflow.keras.layers.Layer",
                    "possible_values": []
                }
            },
            "PolynomialBasis_192": {
                "base_class_0": {
                    "value": "tensorflow.keras.layers.Layer",
                    "possible_values": []
                },
                "self.n_basis": {
                    "value": "n_basis",
                    "possible_values": [
                        [
                            "[i + 1 for i in range(n_basis)]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "AtomicOnehot_210": {
                "base_class_0": {
                    "value": "tensorflow.keras.layers.Layer",
                    "possible_values": []
                },
                "self.atom_types": {
                    "value": "atom_types",
                    "possible_values": [
                        [
                            "[1",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "ANNOutput_224": {
                "base_class_0": {
                    "value": "tensorflow.keras.layers.Layer",
                    "possible_values": []
                },
                "self.out_pool": {
                    "value": "out_pool",
                    "possible_values": [
                        [
                            "{'sum': tf.math.unsorted_segment_sum, 'max': tf.math.unsorted_segment_max, 'min': tf.math.unsorted_segment_min, 'avg': tf.math.unsorted_segment_mean}[self.out_pool]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reduce_prod_11": {
                "variable": {
                    "value": "tot_repeat",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "n_repeat",
                    "possible_values": [
                        [
                            "max_repeat * 2 + 1",
                            "BinOp"
                        ],
                        [
                            "rc * tf.norm(tf.linalg.inv(cell), axis=1)",
                            "BinOp"
                        ],
                        [
                            "tf.cast(tf.math.ceil(n_repeat), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_15": {
                "variable": {
                    "value": "d",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.stack(d, axis=-1)",
                    "possible_values": []
                },
                "shape": {
                    "value": "[tot_repeat, 3]",
                    "possible_values": []
                }
            },
            "concat_16": {
                "variable": {
                    "value": "d",
                    "possible_values": []
                },
                "values": {
                    "value": "[d[:tot_repeat // 2], d[tot_repeat // 2 + 1:]]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "cast_23": {
                "variable": {
                    "value": "n_repeat",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.math.ceil(n_repeat)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "reduce_max_24": {
                "variable": {
                    "value": "max_repeat",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "n_repeat",
                    "possible_values": [
                        [
                            "max_repeat * 2 + 1",
                            "BinOp"
                        ],
                        [
                            "rc * tf.norm(tf.linalg.inv(cell), axis=1)",
                            "BinOp"
                        ],
                        [
                            "tf.cast(tf.math.ceil(n_repeat), tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "reduce_all_27": {
                "variable": {
                    "value": "repeat_mask",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.expand_dims(n_repeat, 1) >= tf.abs(disp_mat)",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "possible_values": []
                }
            },
            "gather_29": {
                "variable": {
                    "value": "atom_mask",
                    "possible_values": []
                },
                "params": {
                    "value": "repeat_mask",
                    "possible_values": [
                        [
                            "tf.reduce_all(tf.expand_dims(n_repeat, 1) >= tf.abs(disp_mat), axis=2)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "ind_1",
                    "possible_values": []
                }
            },
            "cast_30": {
                "variable": {
                    "value": "repeat_ar",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(atom_mask)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "gather_nd_33": {
                "variable": {
                    "value": "repeat_s",
                    "possible_values": []
                },
                "params": {
                    "value": "ind_1",
                    "possible_values": []
                },
                "indices": {
                    "value": "repeat_a",
                    "possible_values": [
                        [
                            "repeat_ar[:, :1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "gather_nd_44": {
                "variable": {
                    "value": "cell",
                    "possible_values": []
                },
                "params": {
                    "value": "tensors['cell']",
                    "possible_values": []
                },
                "indices": {
                    "value": "tensors['ind_1']",
                    "possible_values": []
                }
            },
            "expand_dims_45": {
                "variable": {
                    "value": "coord",
                    "possible_values": []
                },
                "input": {
                    "value": "tensors['coord']",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "solve_46": {
                "variable": {
                    "value": "frac_coord",
                    "possible_values": []
                },
                "matrix": {
                    "value": "tf.transpose(cell, perm=[0, 2, 1])",
                    "possible_values": []
                },
                "rhs": {
                    "value": "coord",
                    "possible_values": [
                        [
                            "tf.expand_dims(tensors['coord'], -1)",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.transpose(cell, perm=[0, 2, 1]), frac_coord)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_48": {
                "variable": {
                    "value": "coord",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.transpose(cell, perm=[0, 2, 1])",
                    "possible_values": []
                },
                "b": {
                    "value": "frac_coord",
                    "possible_values": [
                        [
                            "tf.linalg.solve(tf.transpose(cell, perm=[0, 2, 1]), coord)",
                            "Call"
                        ],
                        [
                            "frac_coord % 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "squeeze_49": {
                "input": {
                    "value": "coord",
                    "possible_values": [
                        [
                            "tf.expand_dims(tensors['coord'], -1)",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.transpose(cell, perm=[0, 2, 1]), frac_coord)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "cumsum_68": {
                "variable": {
                    "value": "atom_gind",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones_like(atom_sind)",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "concat_80": {
                "variable": {
                    "value": "atom_cpos",
                    "possible_values": []
                },
                "values": {
                    "value": "[atom_sind, tf.cast(atom_apos // self.rc, tf.int32)]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "concat_82": {
                "variable": {
                    "value": "cpos_shap",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.reduce_max(atom_cpos, axis=0) + 1, [1]]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "squeeze_83": {
                "variable": {
                    "value": "samp_ccnt",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.scatter_nd(atom_cpos, tf.ones_like(atom_sind, tf.int32), cpos_shap)",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "cast_85": {
                "variable": {
                    "value": "cell_cpos",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(samp_ccnt)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "cumsum_86": {
                "variable": {
                    "value": "cell_cind",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones(tf.shape(cell_cpos)[0], tf.int32)",
                    "possible_values": []
                }
            },
            "expand_dims_87": {
                "variable": {
                    "value": "cell_cind",
                    "possible_values": []
                },
                "input": {
                    "value": "cell_cind",
                    "possible_values": [
                        [
                            "tf.cumsum(tf.ones(tf.shape(cell_cpos)[0], tf.int32))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(cell_cind, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "squeeze_88": {
                "variable": {
                    "value": "samp_cind",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.scatter_nd(cell_cpos, cell_cind, cpos_shap)",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "argsort_93": {
                "variable": {
                    "value": "atom_cind_args",
                    "possible_values": []
                },
                "values": {
                    "value": "atom_cind",
                    "possible_values": [
                        [
                            "tf.gather_nd(samp_cind, atom_cpos) - 1",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "gather_94": {
                "variable": {
                    "value": "atom_cind_sort",
                    "possible_values": []
                },
                "params": {
                    "value": "atom_cind",
                    "possible_values": [
                        [
                            "tf.gather_nd(samp_cind, atom_cpos) - 1",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "atom_cind_args",
                    "possible_values": [
                        [
                            "tf.argsort(atom_cind, axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "cumsum_96": {
                "variable": {
                    "value": "atom_rind_sort",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones_like(atom_cind, tf.int32)",
                    "possible_values": []
                }
            },
            "segment_min_97": {
                "variable": {
                    "value": "cell_rind_min",
                    "possible_values": []
                },
                "data": {
                    "value": "atom_rind_sort",
                    "possible_values": [
                        [
                            "tf.cumsum(tf.ones_like(atom_cind, tf.int32))",
                            "Call"
                        ],
                        [
                            "atom_rind_sort - tf.gather(cell_rind_min, atom_cind_sort)",
                            "BinOp"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "atom_cind_sort",
                    "possible_values": [
                        [
                            "tf.gather(atom_cind, atom_cind_args)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_99": {
                "variable": {
                    "value": "atom_rpos_sort",
                    "possible_values": []
                },
                "values": {
                    "value": "[atom_cind_sort, atom_rind_sort]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "unsorted_segment_sum_100": {
                "variable": {
                    "value": "atom_rpos",
                    "possible_values": []
                },
                "data": {
                    "value": "atom_rpos_sort",
                    "possible_values": [
                        [
                            "tf.stack([atom_cind_sort, atom_rind_sort], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "atom_cind_args",
                    "possible_values": [
                        [
                            "tf.argsort(atom_cind, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "tf.shape(atom_gind)[0]",
                    "possible_values": []
                }
            },
            "squeeze_103": {
                "variable": {
                    "value": "cell_alst",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.scatter_nd(atom_rpos, atom_gind, cell_alst_shap)",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "reduce_all_112": {
                "variable": {
                    "value": "npos_mask",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "(cell_npos >= 0) & (cell_npos < cpos_shap[:-1])",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "possible_values": []
                }
            },
            "squeeze_114": {
                "variable": {
                    "value": "cell_nind",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.scatter_nd(tf.cast(tf.where(npos_mask), tf.int32), tf.expand_dims(tf.gather_nd(samp_cind, tf.boolean_mask(cell_npos, npos_mask)), 1), tf.concat([tf.shape(cell_npos)[:-1], [1]], 0))",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "gather_120": {
                "variable": {
                    "value": "coll_nind",
                    "possible_values": []
                },
                "params": {
                    "value": "cell_nind",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.scatter_nd(tf.cast(tf.where(npos_mask), tf.int32), tf.expand_dims(tf.gather_nd(samp_cind, tf.boolean_mask(cell_npos, npos_mask)), 1), tf.concat([tf.shape(cell_npos)[:-1], [1]], 0)), -1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.gather_nd(atom_cind, to_collect)",
                    "possible_values": []
                }
            },
            "cast_121": {
                "variable": {
                    "value": "pair_ic",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(coll_nind)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "gather_124": {
                "variable": {
                    "value": "pair_ic_alst",
                    "possible_values": []
                },
                "params": {
                    "value": "cell_alst",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.scatter_nd(atom_rpos, atom_gind, cell_alst_shap), axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "pair_ic_c",
                    "possible_values": [
                        [
                            "tf.gather_nd(coll_nind, pair_ic) - 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "cast_126": {
                "variable": {
                    "value": "pair_ij",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(pair_ic_alst)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "gather_127": {
                "variable": {
                    "value": "pair_ij_i",
                    "possible_values": []
                },
                "params": {
                    "value": "pair_ic_i",
                    "possible_values": [
                        [
                            "pair_ic[:, 0]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "pair_ij[:, 0]",
                    "possible_values": []
                }
            },
            "norm_131": {
                "variable": {
                    "value": "dist",
                    "possible_values": []
                },
                "tensor": {
                    "value": "diff",
                    "possible_values": [
                        [
                            "tf.gather(atom_apos, pair_ij_j) - tf.gather(atom_apos, pair_ij_i)",
                            "BinOp"
                        ],
                        [
                            "tf.gather_nd(diff, ind_rc)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "where_132": {
                "variable": {
                    "value": "ind_rc",
                    "possible_values": []
                },
                "condition": {
                    "value": "(dist < self.rc) & (dist > 0)",
                    "possible_values": []
                }
            },
            "gather_nd_133": {
                "variable": {
                    "value": "dist",
                    "possible_values": []
                },
                "params": {
                    "value": "dist",
                    "possible_values": [
                        [
                            "tf.norm(diff, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(dist, ind_rc)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "ind_rc",
                    "possible_values": [
                        [
                            "tf.where((dist < self.rc) & (dist > 0))",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_134": {
                "variable": {
                    "value": "diff",
                    "possible_values": []
                },
                "params": {
                    "value": "diff",
                    "possible_values": [
                        [
                            "tf.gather(atom_apos, pair_ij_j) - tf.gather(atom_apos, pair_ij_i)",
                            "BinOp"
                        ],
                        [
                            "tf.gather_nd(diff, ind_rc)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "ind_rc",
                    "possible_values": [
                        [
                            "tf.where((dist < self.rc) & (dist > 0))",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_135": {
                "variable": {
                    "value": "pair_i_aind",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.gather(atom_aind, pair_ij_i)",
                    "possible_values": []
                },
                "indices": {
                    "value": "ind_rc",
                    "possible_values": [
                        [
                            "tf.where((dist < self.rc) & (dist > 0))",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_136": {
                "variable": {
                    "value": "pair_j_aind",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.gather(atom_aind, pair_ij_j)",
                    "possible_values": []
                },
                "indices": {
                    "value": "ind_rc",
                    "possible_values": [
                        [
                            "tf.where((dist < self.rc) & (dist > 0))",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_186": {
                "variable": {
                    "value": "basis",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.exp(-gamma * (dist - center) ** 2) * fc for (center, gamma) in zip(self.center, self.gamma)]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "stack_206": {
                "variable": {
                    "value": "basis",
                    "possible_values": []
                },
                "values": {
                    "value": "[fc ** i for i in self.n_basis]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "equal_220": {
                "variable": {
                    "value": "output",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.expand_dims(elems, 1)",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.expand_dims(self.atom_types, 0)",
                    "possible_values": []
                }
            },
            "squeeze_244": {
                "variable": {
                    "value": "output",
                    "possible_values": []
                },
                "input": {
                    "value": "output",
                    "possible_values": [
                        [
                            "{'ind_2': tf.concat([pair_i_aind, pair_j_aind], 1), 'dist': dist, 'diff': diff}",
                            "Dict"
                        ],
                        [
                            "tf.equal(tf.expand_dims(elems, 1), tf.expand_dims(self.atom_types, 0))",
                            "Call"
                        ],
                        [
                            "out_pool(output, ind_1[:, 0], tf.reduce_max(ind_1) + 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "stack_15": {
                "values": {
                    "value": "d",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.reshape(tf.stack(d, axis=-1), [tot_repeat, 3])",
                            "Call"
                        ],
                        [
                            "tf.concat([d[:tot_repeat // 2], d[tot_repeat // 2 + 1:]], 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "norm_22": {
                "tensor": {
                    "value": "tf.linalg.inv(cell)",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "ceil_23": {
                "x": {
                    "value": "n_repeat",
                    "possible_values": [
                        [
                            "max_repeat * 2 + 1",
                            "BinOp"
                        ],
                        [
                            "rc * tf.norm(tf.linalg.inv(cell), axis=1)",
                            "BinOp"
                        ],
                        [
                            "tf.cast(tf.math.ceil(n_repeat), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_30": {
                "condition": {
                    "value": "atom_mask",
                    "possible_values": [
                        [
                            "tf.gather(repeat_mask, ind_1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_34": {
                "params": {
                    "value": "coord",
                    "possible_values": [
                        [
                            "tf.expand_dims(tensors['coord'], -1)",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.transpose(cell, perm=[0, 2, 1]), frac_coord)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "repeat_a",
                    "possible_values": [
                        [
                            "repeat_ar[:, :1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reduce_sum_35": {
                "input_tensor": {
                    "value": "tf.gather_nd(cell, repeat_s) * tf.gather(tf.cast(tf.expand_dims(disp_mat, 2), coord.dtype), repeat_r)",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "transpose_46": {
                "a": {
                    "value": "cell",
                    "possible_values": [
                        [
                            "tf.gather_nd(tensors['cell'], tensors['ind_1'])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "possible_values": []
                }
            },
            "transpose_48": {
                "a": {
                    "value": "cell",
                    "possible_values": [
                        [
                            "tf.gather_nd(tensors['cell'], tensors['ind_1'])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "possible_values": []
                }
            },
            "concat_75": {
                "variable": {
                    "value": "atom_sind",
                    "possible_values": []
                },
                "values": {
                    "value": "[atom_sind, rep_sind]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "concat_76": {
                "variable": {
                    "value": "atom_apos",
                    "possible_values": []
                },
                "values": {
                    "value": "[atom_apos, rep_apos]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "concat_77": {
                "variable": {
                    "value": "atom_aind",
                    "possible_values": []
                },
                "values": {
                    "value": "[atom_aind, rep_aind]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "cumsum_78": {
                "variable": {
                    "value": "atom_gind",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones_like(atom_sind)",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "inv_22": {
                "input": {
                    "value": "cell",
                    "possible_values": [
                        [
                            "tf.gather_nd(tensors['cell'], tensors['ind_1'])",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_28": {
                "input": {
                    "value": "n_repeat",
                    "possible_values": [
                        [
                            "max_repeat * 2 + 1",
                            "BinOp"
                        ],
                        [
                            "rc * tf.norm(tf.linalg.inv(cell), axis=1)",
                            "BinOp"
                        ],
                        [
                            "tf.cast(tf.math.ceil(n_repeat), tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "abs_28": {
                "x": {
                    "value": "disp_mat",
                    "possible_values": [
                        [
                            "_displace_matrix(max_repeat)",
                            "Call"
                        ],
                        [
                            "np.zeros([3, 3, 3, 4], np.int32)",
                            "Call"
                        ],
                        [
                            "np.reshape(disp_mat, (1, 27, 4))",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_68": {
                "input": {
                    "value": "atom_sind",
                    "possible_values": [
                        [
                            "tensors['ind_1']",
                            "Subscript"
                        ],
                        [
                            "tf.concat([atom_sind, rep_sind], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_min_79": {
                "input_tensor": {
                    "value": "atom_apos",
                    "possible_values": [
                        [
                            "tensors['coord']",
                            "Subscript"
                        ],
                        [
                            "_wrap_coord(tensors)",
                            "Call"
                        ],
                        [
                            "tf.concat([atom_apos, rep_apos], 0)",
                            "Call"
                        ],
                        [
                            "atom_apos - tf.reduce_min(atom_apos, axis=0)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "scatter_nd_83": {
                "indices": {
                    "value": "atom_cpos",
                    "possible_values": [
                        [
                            "tf.concat([atom_sind, tf.cast(atom_apos // self.rc, tf.int32)], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "tf.ones_like(atom_sind, tf.int32)",
                    "possible_values": []
                },
                "shape": {
                    "value": "cpos_shap",
                    "possible_values": [
                        [
                            "tf.concat([tf.reduce_max(atom_cpos, axis=0) + 1, [1]], axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_85": {
                "condition": {
                    "value": "samp_ccnt",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.scatter_nd(atom_cpos, tf.ones_like(atom_sind, tf.int32), cpos_shap), axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_86": {
                "shape": {
                    "value": "tf.shape(cell_cpos)[0]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "scatter_nd_88": {
                "indices": {
                    "value": "cell_cpos",
                    "possible_values": [
                        [
                            "tf.cast(tf.where(samp_ccnt), tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "cell_cind",
                    "possible_values": [
                        [
                            "tf.cumsum(tf.ones(tf.shape(cell_cpos)[0], tf.int32))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(cell_cind, 1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "cpos_shap",
                    "possible_values": [
                        [
                            "tf.concat([tf.reduce_max(atom_cpos, axis=0) + 1, [1]], axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_92": {
                "params": {
                    "value": "samp_cind",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.scatter_nd(cell_cpos, cell_cind, cpos_shap), axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "atom_cpos",
                    "possible_values": [
                        [
                            "tf.concat([atom_sind, tf.cast(atom_apos // self.rc, tf.int32)], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_96": {
                "input": {
                    "value": "atom_cind",
                    "possible_values": [
                        [
                            "tf.gather_nd(samp_cind, atom_cpos) - 1",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "gather_98": {
                "params": {
                    "value": "cell_rind_min",
                    "possible_values": [
                        [
                            "tf.math.segment_min(atom_rind_sort, atom_cind_sort)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "atom_cind_sort",
                    "possible_values": [
                        [
                            "tf.gather(atom_cind, atom_cind_args)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_max_102": {
                "input_tensor": {
                    "value": "samp_ccnt",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.scatter_nd(atom_cpos, tf.ones_like(atom_sind, tf.int32), cpos_shap), axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "scatter_nd_103": {
                "indices": {
                    "value": "atom_rpos",
                    "possible_values": [
                        [
                            "tf.math.unsorted_segment_sum(atom_rpos_sort, atom_cind_args, tf.shape(atom_gind)[0])",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "atom_gind",
                    "possible_values": [
                        [
                            "tf.cumsum(tf.ones_like(atom_sind), 0)",
                            "Call"
                        ],
                        [
                            "tf.cumsum(tf.ones_like(atom_sind), 0)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "cell_alst_shap",
                    "possible_values": [
                        [
                            "[tf.shape(cell_cind)[0], tf.reduce_max(samp_ccnt), 1]",
                            "List"
                        ]
                    ]
                }
            },
            "expand_dims_111": {
                "input": {
                    "value": "cell_cpos",
                    "possible_values": [
                        [
                            "tf.cast(tf.where(samp_ccnt), tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "scatter_nd_114": {
                "indices": {
                    "value": "tf.cast(tf.where(npos_mask), tf.int32)",
                    "possible_values": []
                },
                "updates": {
                    "value": "tf.expand_dims(tf.gather_nd(samp_cind, tf.boolean_mask(cell_npos, npos_mask)), 1)",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.concat([tf.shape(cell_npos)[:-1], [1]], 0)",
                    "possible_values": []
                }
            },
            "gather_nd_120": {
                "params": {
                    "value": "atom_cind",
                    "possible_values": [
                        [
                            "tf.gather_nd(samp_cind, atom_cpos) - 1",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "to_collect",
                    "possible_values": [
                        [
                            "atom_aind",
                            "Name"
                        ]
                    ]
                }
            },
            "where_121": {
                "condition": {
                    "value": "coll_nind",
                    "possible_values": [
                        [
                            "tf.gather(cell_nind, tf.gather_nd(atom_cind, to_collect))",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_123": {
                "params": {
                    "value": "coll_nind",
                    "possible_values": [
                        [
                            "tf.gather(cell_nind, tf.gather_nd(atom_cind, to_collect))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "pair_ic",
                    "possible_values": [
                        [
                            "tf.cast(tf.where(coll_nind), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_126": {
                "condition": {
                    "value": "pair_ic_alst",
                    "possible_values": [
                        [
                            "tf.gather(cell_alst, pair_ic_c)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_128": {
                "params": {
                    "value": "pair_ic_alst",
                    "possible_values": [
                        [
                            "tf.gather(cell_alst, pair_ic_c)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "pair_ij",
                    "possible_values": [
                        [
                            "tf.cast(tf.where(pair_ic_alst), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_130": {
                "params": {
                    "value": "atom_apos",
                    "possible_values": [
                        [
                            "tensors['coord']",
                            "Subscript"
                        ],
                        [
                            "_wrap_coord(tensors)",
                            "Call"
                        ],
                        [
                            "tf.concat([atom_apos, rep_apos], 0)",
                            "Call"
                        ],
                        [
                            "atom_apos - tf.reduce_min(atom_apos, axis=0)",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "pair_ij_i",
                    "possible_values": [
                        [
                            "tf.gather(pair_ic_i, pair_ij[:, 0])",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_135": {
                "params": {
                    "value": "atom_aind",
                    "possible_values": [
                        [
                            "atom_gind - 1",
                            "BinOp"
                        ],
                        [
                            "tf.concat([atom_aind, rep_aind], 0)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "pair_ij_i",
                    "possible_values": [
                        [
                            "tf.gather(pair_ic_i, pair_ij[:, 0])",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_136": {
                "params": {
                    "value": "atom_aind",
                    "possible_values": [
                        [
                            "atom_gind - 1",
                            "BinOp"
                        ],
                        [
                            "tf.concat([atom_aind, rep_aind], 0)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "pair_ij_j",
                    "possible_values": [
                        [
                            "tf.gather_nd(pair_ic_alst, pair_ij) - 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "concat_139": {
                "values": {
                    "value": "[pair_i_aind, pair_j_aind]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_220": {
                "input": {
                    "value": "elems",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_221": {
                "input": {
                    "value": "self.atom_types",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "gather_nd_36": {
                "params": {
                    "value": "cell",
                    "possible_values": [
                        [
                            "tf.gather_nd(tensors['cell'], tensors['ind_1'])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "repeat_s",
                    "possible_values": [
                        [
                            "tf.gather_nd(ind_1, repeat_a)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_37": {
                "params": {
                    "value": "tf.cast(tf.expand_dims(disp_mat, 2), coord.dtype)",
                    "possible_values": []
                },
                "indices": {
                    "value": "repeat_r",
                    "possible_values": [
                        [
                            "repeat_ar[:, 2]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "ones_like_78": {
                "input": {
                    "value": "atom_sind",
                    "possible_values": [
                        [
                            "tensors['ind_1']",
                            "Subscript"
                        ],
                        [
                            "tf.concat([atom_sind, rep_sind], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_81": {
                "x": {
                    "value": "atom_apos // self.rc",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "ones_like_84": {
                "input": {
                    "value": "atom_sind",
                    "possible_values": [
                        [
                            "tensors['ind_1']",
                            "Subscript"
                        ],
                        [
                            "tf.concat([atom_sind, rep_sind], 0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "shape_101": {
                "input": {
                    "value": "atom_gind",
                    "possible_values": [
                        [
                            "tf.cumsum(tf.ones_like(atom_sind), 0)",
                            "Call"
                        ],
                        [
                            "tf.cumsum(tf.ones_like(atom_sind), 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_102": {
                "input": {
                    "value": "cell_cind",
                    "possible_values": [
                        [
                            "tf.cumsum(tf.ones(tf.shape(cell_cpos)[0], tf.int32))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(cell_cind, 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_115": {
                "x": {
                    "value": "tf.where(npos_mask)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "expand_dims_116": {
                "input": {
                    "value": "tf.gather_nd(samp_cind, tf.boolean_mask(cell_npos, npos_mask))",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "concat_118": {
                "values": {
                    "value": "[tf.shape(cell_npos)[:-1], [1]]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "cos_163": {
                "x": {
                    "value": "np.pi * x / rc / 2",
                    "possible_values": []
                }
            },
            "cumsum_13": {
                "x": {
                    "value": "tf.ones(n_repeat, tf.int32)",
                    "possible_values": []
                },
                "axis": {
                    "value": "i",
                    "possible_values": [
                        [
                            [
                                0,
                                1,
                                2
                            ],
                            "Call"
                        ]
                    ]
                }
            },
            "cast_37": {
                "x": {
                    "value": "tf.expand_dims(disp_mat, 2)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "coord.dtype",
                    "possible_values": []
                }
            },
            "reduce_max_82": {
                "input_tensor": {
                    "value": "atom_cpos",
                    "possible_values": [
                        [
                            "tf.concat([atom_sind, tf.cast(atom_apos // self.rc, tf.int32)], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "shape_86": {
                "input": {
                    "value": "cell_cpos",
                    "possible_values": [
                        [
                            "tf.cast(tf.where(samp_ccnt), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_115": {
                "condition": {
                    "value": "npos_mask",
                    "possible_values": [
                        [
                            "tf.reduce_all((cell_npos >= 0) & (cell_npos < cpos_shap[:-1]), 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_116": {
                "params": {
                    "value": "samp_cind",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.scatter_nd(cell_cpos, cell_cind, cpos_shap), axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.boolean_mask(cell_npos, npos_mask)",
                    "possible_values": []
                }
            },
            "cos_161": {
                "x": {
                    "value": "np.pi * x / rc",
                    "possible_values": []
                }
            },
            "tanh_162": {
                "x": {
                    "value": "1 - x / rc",
                    "possible_values": []
                }
            },
            "exp_186": {
                "x": {
                    "value": "-gamma * (dist - center) ** 2",
                    "possible_values": []
                }
            },
            "reduce_max_243": {
                "input_tensor": {
                    "value": "ind_1",
                    "possible_values": []
                }
            },
            "ones_13": {
                "shape": {
                    "value": "n_repeat",
                    "possible_values": [
                        [
                            "max_repeat * 2 + 1",
                            "BinOp"
                        ],
                        [
                            "rc * tf.norm(tf.linalg.inv(cell), axis=1)",
                            "BinOp"
                        ],
                        [
                            "tf.cast(tf.math.ceil(n_repeat), tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "expand_dims_37": {
                "input": {
                    "value": "disp_mat",
                    "possible_values": [
                        [
                            "_displace_matrix(max_repeat)",
                            "Call"
                        ],
                        [
                            "np.zeros([3, 3, 3, 4], np.int32)",
                            "Call"
                        ],
                        [
                            "np.reshape(disp_mat, (1, 27, 4))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "possible_values": []
                }
            },
            "boolean_mask_117": {
                "tensor": {
                    "value": "cell_npos",
                    "possible_values": [
                        [
                            "tf.expand_dims(cell_cpos, 1) + disp_mat",
                            "BinOp"
                        ]
                    ]
                },
                "mask": {
                    "value": "npos_mask",
                    "possible_values": [
                        [
                            "tf.reduce_all((cell_npos >= 0) & (cell_npos < cpos_shap[:-1]), 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_118": {
                "input": {
                    "value": "cell_npos",
                    "possible_values": [
                        [
                            "tf.expand_dims(cell_cpos, 1) + disp_mat",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "pinn/models/__init__.py": {
        "tensorflow": {
            "exists_16": {
                "path": {
                    "value": "'{}/params.yml'.format(model_spec)",
                    "possible_values": []
                }
            },
            "exists_35": {
                "path": {
                    "value": "params_file",
                    "possible_values": [
                        [
                            "os.path.join(model_dir, 'params.yml')",
                            "Call"
                        ],
                        [
                            "os.path.join(model_spec, 'params.yml')",
                            "Call"
                        ],
                        [
                            "model_spec",
                            "Name"
                        ]
                    ]
                }
            },
            "write_40": {
                "tag": {
                    "value": "to_write",
                    "possible_values": [
                        [
                            "yaml.dump(model_spec)",
                            "Call"
                        ]
                    ]
                }
            },
            "exists_21": {
                "path": {
                    "value": "model_spec",
                    "possible_values": [
                        [
                            "dict(yaml.load(f, Loader=yaml.Loader), model_dir=model_spec)",
                            "Call"
                        ],
                        [
                            "yaml.load(f, Loader=yaml.Loader)",
                            "Call"
                        ]
                    ]
                }
            },
            "isdir_33": {
                "path": {
                    "value": "model_dir",
                    "possible_values": [
                        [
                            "model_spec['model_dir']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "makedirs_34": {
                "path": {
                    "value": "model_dir",
                    "possible_values": [
                        [
                            "model_spec['model_dir']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "rename_38": {
                "src": {
                    "value": "params_file",
                    "possible_values": [
                        [
                            "os.path.join(model_dir, 'params.yml')",
                            "Call"
                        ],
                        [
                            "os.path.join(model_spec, 'params.yml')",
                            "Call"
                        ],
                        [
                            "model_spec",
                            "Name"
                        ]
                    ]
                },
                "dst": {
                    "value": "params_file + '.' + datetime.now().strftime('%y%m%d%H%M')",
                    "possible_values": []
                }
            }
        }
    },
    "pinn/models/base.py": {
        "tensorflow": {
            "get_or_create_global_step_90": {
                "variable": {
                    "value": "optimizer.iterations",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "Estimator_15": {
                "variable": {
                    "value": "model",
                    "possible_values": []
                },
                "model_fn": {
                    "value": "model_fn",
                    "possible_values": []
                },
                "params": {
                    "value": "params",
                    "possible_values": [
                        [
                            "params_tmp",
                            "Name"
                        ]
                    ]
                },
                "model_dir": {
                    "value": "model_dir",
                    "possible_values": [
                        [
                            "params['model_dir']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "cast_45": {
                "variable": {
                    "value": "weight",
                    "possible_values": []
                },
                "x": {
                    "value": "weight",
                    "possible_values": [
                        [
                            "tf.cast(weight, data.dtype)",
                            "Call"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "data.dtype",
                    "possible_values": []
                }
            },
            "gradients_101": {
                "variable": {
                    "value": "grads",
                    "possible_values": []
                },
                "ys": {
                    "value": "loss",
                    "possible_values": [
                        [
                            "tf.stack(loss_list)[selection]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_sum(loss_list)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(error ** 2 * weight)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(error ** 2 * weight)",
                            "Call"
                        ]
                    ]
                },
                "xs": {
                    "value": "tvars",
                    "possible_values": []
                }
            },
            "uniform_97": {
                "variable": {
                    "value": "selection",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "possible_values": []
                },
                "maxval": {
                    "value": "len(loss_list)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "reduce_sum_100": {
                "variable": {
                    "value": "loss",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "loss_list",
                    "possible_values": [
                        [
                            "metrics.LOSS",
                            "Attribute"
                        ]
                    ]
                }
            },
            "concat_107": {
                "variable": {
                    "value": "error",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.reshape(e, [-1]) / tf.math.sqrt(tf.cast(tf.size(e), e.dtype)) for e in error_list]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "concat_111": {
                "variable": {
                    "value": "error",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.reshape(e, [-1]) for e in error_list]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "uniform_113": {
                "variable": {
                    "value": "selection",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "possible_values": []
                },
                "maxval": {
                    "value": "len(error_list)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "concat_114": {
                "variable": {
                    "value": "mask",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.fill([tf.size(e)], tf.equal(selection, i)) for (i, e) in enumerate(error_list)]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "boolean_mask_116": {
                "variable": {
                    "value": "error",
                    "possible_values": []
                },
                "tensor": {
                    "value": "error",
                    "possible_values": [
                        [
                            "tf.concat([tf.reshape(e, [-1]) / tf.math.sqrt(tf.cast(tf.size(e), e.dtype)) for e in error_list], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.reshape(e, [-1]) for e in error_list], 0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(error, mask)",
                            "Call"
                        ],
                        [
                            "data - pred",
                            "BinOp"
                        ],
                        [
                            "tf.boolean_mask(error, mask)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(error, mask)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "possible_values": [
                        [
                            "tf.concat([tf.fill([tf.size(e)], tf.equal(selection, i)) for (i, e) in enumerate(error_list)], 0)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reduce_mean_52": {
                "variable": {
                    "value": "mae",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.abs(error)",
                    "possible_values": []
                }
            },
            "sqrt_53": {
                "variable": {
                    "value": "rmse",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_mean(error ** 2)",
                    "possible_values": []
                }
            },
            "boolean_mask_57": {
                "variable": {
                    "value": "error",
                    "possible_values": []
                },
                "tensor": {
                    "value": "error",
                    "possible_values": [
                        [
                            "tf.concat([tf.reshape(e, [-1]) / tf.math.sqrt(tf.cast(tf.size(e), e.dtype)) for e in error_list], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.reshape(e, [-1]) for e in error_list], 0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(error, mask)",
                            "Call"
                        ],
                        [
                            "data - pred",
                            "BinOp"
                        ],
                        [
                            "tf.boolean_mask(error, mask)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(error, mask)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "possible_values": [
                        [
                            "tf.concat([tf.fill([tf.size(e)], tf.equal(selection, i)) for (i, e) in enumerate(error_list)], 0)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reduce_mean_59": {
                "variable": {
                    "value": "loss",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "error ** 2 * weight",
                    "possible_values": []
                }
            },
            "mean_absolute_error_65": {
                "variable": {
                    "value": "self.METRICS[fMETRICS/{tag}_MAE]",
                    "possible_values": []
                },
                "y_true": {
                    "value": "data",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "pred",
                    "possible_values": []
                }
            },
            "root_mean_squared_error_66": {
                "variable": {
                    "value": "self.METRICS[fMETRICS/{tag}_RMSE]",
                    "possible_values": []
                },
                "labels": {
                    "value": "data",
                    "possible_values": []
                },
                "predictions": {
                    "value": "pred",
                    "possible_values": []
                }
            },
            "boolean_mask_68": {
                "variable": {
                    "value": "error",
                    "possible_values": []
                },
                "tensor": {
                    "value": "error",
                    "possible_values": [
                        [
                            "tf.concat([tf.reshape(e, [-1]) / tf.math.sqrt(tf.cast(tf.size(e), e.dtype)) for e in error_list], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.reshape(e, [-1]) for e in error_list], 0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(error, mask)",
                            "Call"
                        ],
                        [
                            "data - pred",
                            "BinOp"
                        ],
                        [
                            "tf.boolean_mask(error, mask)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(error, mask)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "possible_values": [
                        [
                            "tf.concat([tf.fill([tf.size(e)], tf.equal(selection, i)) for (i, e) in enumerate(error_list)], 0)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reduce_mean_70": {
                "variable": {
                    "value": "loss",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "error ** 2 * weight",
                    "possible_values": []
                }
            },
            "mean_71": {
                "variable": {
                    "value": "self.METRICS[fMETRICS/{tag}_LOSS]",
                    "possible_values": []
                },
                "a": {
                    "value": "loss",
                    "possible_values": [
                        [
                            "tf.stack(loss_list)[selection]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_sum(loss_list)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(error ** 2 * weight)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(error ** 2 * weight)",
                            "Call"
                        ]
                    ]
                }
            },
            "histogram_48": {
                "name": {
                    "value": "f'{tag}_DATA'",
                    "possible_values": []
                },
                "data": {
                    "value": "data",
                    "possible_values": []
                }
            },
            "histogram_49": {
                "name": {
                    "value": "f'{tag}_PRED'",
                    "possible_values": []
                },
                "data": {
                    "value": "pred",
                    "possible_values": []
                }
            },
            "histogram_50": {
                "name": {
                    "value": "f'{tag}_ERROR'",
                    "possible_values": []
                },
                "data": {
                    "value": "error",
                    "possible_values": [
                        [
                            "tf.concat([tf.reshape(e, [-1]) / tf.math.sqrt(tf.cast(tf.size(e), e.dtype)) for e in error_list], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.reshape(e, [-1]) for e in error_list], 0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(error, mask)",
                            "Call"
                        ],
                        [
                            "data - pred",
                            "BinOp"
                        ],
                        [
                            "tf.boolean_mask(error, mask)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(error, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_54": {
                "name": {
                    "value": "f'{tag}_MAE'",
                    "possible_values": []
                },
                "data": {
                    "value": "mae",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.abs(error))",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_55": {
                "name": {
                    "value": "f'{tag}_RMSE'",
                    "possible_values": []
                },
                "data": {
                    "value": "rmse",
                    "possible_values": [
                        [
                            "tf.sqrt(tf.reduce_mean(error ** 2))",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_60": {
                "name": {
                    "value": "f'{tag}_LOSS'",
                    "possible_values": []
                },
                "data": {
                    "value": "loss",
                    "possible_values": [
                        [
                            "tf.stack(loss_list)[selection]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_sum(loss_list)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(error ** 2 * weight)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(error ** 2 * weight)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_98": {
                "values": {
                    "value": "loss_list",
                    "possible_values": [
                        [
                            "metrics.LOSS",
                            "Attribute"
                        ]
                    ]
                }
            },
            "abs_52": {
                "x": {
                    "value": "error",
                    "possible_values": [
                        [
                            "tf.concat([tf.reshape(e, [-1]) / tf.math.sqrt(tf.cast(tf.size(e), e.dtype)) for e in error_list], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.reshape(e, [-1]) for e in error_list], 0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(error, mask)",
                            "Call"
                        ],
                        [
                            "data - pred",
                            "BinOp"
                        ],
                        [
                            "tf.boolean_mask(error, mask)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(error, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_53": {
                "input_tensor": {
                    "value": "error ** 2",
                    "possible_values": []
                }
            },
            "reshape_111": {
                "tensor": {
                    "value": "e",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "possible_values": []
                }
            },
            "fill_114": {
                "dims": {
                    "value": "[tf.size(e)]",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.equal(selection, i)",
                    "possible_values": []
                }
            },
            "sqrt_61": {
                "x": {
                    "value": "weight",
                    "possible_values": [
                        [
                            "tf.cast(weight, data.dtype)",
                            "Call"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reshape_107": {
                "tensor": {
                    "value": "e",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "possible_values": []
                }
            },
            "sqrt_107": {
                "x": {
                    "value": "tf.cast(tf.size(e), e.dtype)",
                    "possible_values": []
                }
            },
            "equal_114": {
                "x": {
                    "value": "selection",
                    "possible_values": [
                        [
                            "tf.random.uniform([], maxval=len(loss_list), dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.random.uniform([], maxval=len(error_list), dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "i",
                    "possible_values": []
                }
            },
            "cast_107": {
                "x": {
                    "value": "tf.size(e)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "e.dtype",
                    "possible_values": []
                }
            },
            "size_114": {
                "input": {
                    "value": "e",
                    "possible_values": []
                }
            },
            "size_107": {
                "input": {
                    "value": "e",
                    "possible_values": []
                }
            }
        }
    },
    "pinn/models/dipole.py": {
        "tensorflow": {
            "expand_dims_41": {
                "variable": {
                    "value": "pred",
                    "possible_values": []
                },
                "input": {
                    "value": "pred",
                    "possible_values": [
                        [
                            "network(features)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pred, axis=1)",
                            "Call"
                        ],
                        [
                            "pred / model_params['d_scale']",
                            "BinOp"
                        ],
                        [
                            "pred * model_params['d_unit']",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "unsorted_segment_sum_45": {
                "variable": {
                    "value": "charge",
                    "possible_values": []
                },
                "data": {
                    "value": "pred",
                    "possible_values": [
                        [
                            "network(features)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pred, axis=1)",
                            "Call"
                        ],
                        [
                            "pred / model_params['d_scale']",
                            "BinOp"
                        ],
                        [
                            "pred * model_params['d_unit']",
                            "BinOp"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "ind[:, 0]",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "nbatch",
                    "possible_values": [
                        [
                            "tf.reduce_max(ind) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "unsorted_segment_sum_47": {
                "variable": {
                    "value": "dipole",
                    "possible_values": []
                },
                "data": {
                    "value": "dipole",
                    "possible_values": [
                        [
                            "pred * features['coord']",
                            "BinOp"
                        ],
                        [
                            "tf.math.unsorted_segment_sum(dipole, ind[:, 0], nbatch)",
                            "Call"
                        ],
                        [
                            "tf.sqrt(tf.reduce_sum(dipole ** 2, axis=1) + 1e-06)",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "ind[:, 0]",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "nbatch",
                    "possible_values": [
                        [
                            "tf.reduce_max(ind) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "sqrt_48": {
                "variable": {
                    "value": "dipole",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(dipole ** 2, axis=1) + 1e-06",
                    "possible_values": []
                }
            },
            "zeros_like_79": {
                "variable": {
                    "value": "q_data",
                    "possible_values": []
                },
                "input": {
                    "value": "q_pred",
                    "possible_values": []
                }
            },
            "trainable_variables_96": {
                "variable": {
                    "value": "tvars",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "add_n_97": {
                "variable": {
                    "value": "l2_loss",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[tf.nn.l2_loss(v) for v in tvars if 'bias' not in v.name and 'noact' not in v.name]",
                    "possible_values": []
                }
            },
            "reduce_max_44": {
                "input_tensor": {
                    "value": "ind",
                    "possible_values": [
                        [
                            "features['ind_1']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "EstimatorSpec_54": {
                "mode": {
                    "value": "mode",
                    "possible_values": []
                },
                "loss": {
                    "value": "tf.reduce_sum(metrics.LOSS)",
                    "possible_values": []
                },
                "train_op": {
                    "value": "train_op",
                    "possible_values": [
                        [
                            "get_train_op(params['optimizer'], metrics, tvars)",
                            "Call"
                        ]
                    ]
                }
            },
            "EstimatorSpec_59": {
                "mode": {
                    "value": "mode",
                    "possible_values": []
                },
                "loss": {
                    "value": "tf.reduce_sum(metrics.LOSS)",
                    "possible_values": []
                },
                "eval_metric_ops": {
                    "value": "metrics.METRICS",
                    "possible_values": []
                }
            },
            "EstimatorSpec_70": {
                "mode": {
                    "value": "mode",
                    "possible_values": []
                },
                "predictions": {
                    "value": "predictions",
                    "possible_values": [
                        [
                            "{'dipole': dipole, 'charges': tf.expand_dims(pred, 0)}",
                            "Dict"
                        ]
                    ]
                }
            },
            "reduce_sum_48": {
                "input_tensor": {
                    "value": "dipole ** 2",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_68": {
                "input": {
                    "value": "pred",
                    "possible_values": [
                        [
                            "network(features)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pred, axis=1)",
                            "Call"
                        ],
                        [
                            "pred / model_params['d_scale']",
                            "BinOp"
                        ],
                        [
                            "pred * model_params['d_unit']",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "abs_81": {
                "x": {
                    "value": "d_data",
                    "possible_values": [
                        [
                            "features['d_data']",
                            "Subscript"
                        ],
                        [
                            "d_data * model_params['d_scale']",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_54": {
                "input_tensor": {
                    "value": "metrics.LOSS",
                    "possible_values": []
                }
            },
            "reduce_sum_59": {
                "input_tensor": {
                    "value": "metrics.LOSS",
                    "possible_values": []
                }
            },
            "l2_loss_98": {
                "t": {
                    "value": "v",
                    "possible_values": []
                }
            }
        }
    },
    "pinn/models/potential.py": {
        "tensorflow": {
            "unsorted_segment_sum_62": {
                "variable": {
                    "value": "pred",
                    "possible_values": []
                },
                "data": {
                    "value": "pred",
                    "possible_values": [
                        [
                            "network(features)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_sum(pred, ind[:, 0], nbatch)",
                            "Call"
                        ],
                        [
                            "pred / model_params['e_scale']",
                            "BinOp"
                        ],
                        [
                            "pred * model_params['e_unit']",
                            "BinOp"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "ind[:, 0]",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "nbatch",
                    "possible_values": [
                        [
                            "tf.reduce_max(ind) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_151": {
                "variable": {
                    "value": "s_pred",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.expand_dims(f_ij, 1) * tf.expand_dims(tensors['diff'], 2)",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "expand_dims_83": {
                "variable": {
                    "value": "forces",
                    "possible_values": []
                },
                "input": {
                    "value": "forces",
                    "possible_values": [
                        [
                            "-_get_dense_grad(pred, features['coord'])",
                            "UnaryOp"
                        ],
                        [
                            "tf.expand_dims(forces, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "fill_118": {
                "variable": {
                    "value": "f_mask",
                    "possible_values": []
                },
                "dims": {
                    "value": "tf.shape(f_pred)",
                    "possible_values": []
                },
                "value": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "trainable_variables_139": {
                "variable": {
                    "value": "tvars",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "concat_140": {
                "variable": {
                    "value": "l2_vars",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.reshape(v, [-1]) for v in tvars if 'bias' not in v.name and 'noact' not in v.name]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "det_155": {
                "input": {
                    "value": "tensors['cell']",
                    "possible_values": []
                }
            },
            "scatter_nd_167": {
                "variable": {
                    "value": "grad",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.expand_dims(grad.indices, 1)",
                    "possible_values": []
                },
                "updates": {
                    "value": "grad.values",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.cast(grad.dense_shape, tf.int32)",
                    "possible_values": []
                }
            },
            "reduce_max_61": {
                "input_tensor": {
                    "value": "ind",
                    "possible_values": [
                        [
                            "features['ind_1']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "EstimatorSpec_69": {
                "mode": {
                    "value": "mode",
                    "possible_values": []
                },
                "loss": {
                    "value": "tf.reduce_sum(metrics.LOSS)",
                    "possible_values": []
                },
                "train_op": {
                    "value": "train_op",
                    "possible_values": [
                        [
                            "get_train_op(params['optimizer'], metrics, tvars, separate_errors=model_params['separate_errors'])",
                            "Call"
                        ]
                    ]
                }
            },
            "EstimatorSpec_74": {
                "mode": {
                    "value": "mode",
                    "possible_values": []
                },
                "loss": {
                    "value": "tf.reduce_sum(metrics.LOSS)",
                    "possible_values": []
                },
                "eval_metric_ops": {
                    "value": "metrics.METRICS",
                    "possible_values": []
                }
            },
            "EstimatorSpec_88": {
                "mode": {
                    "value": "mode",
                    "possible_values": []
                },
                "predictions": {
                    "value": "predictions",
                    "possible_values": [
                        [
                            "{'energy': pred, 'forces': forces}",
                            "Dict"
                        ]
                    ]
                }
            },
            "boolean_mask_122": {
                "variable": {
                    "value": "f_pred",
                    "possible_values": []
                },
                "tensor": {
                    "value": "f_pred",
                    "possible_values": [
                        [
                            "-_get_dense_grad(pred, features['coord'])",
                            "UnaryOp"
                        ],
                        [
                            "tf.boolean_mask(f_pred, use_ind)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "use_ind",
                    "possible_values": [
                        [
                            "tf.cast(tf.random.shuffle(tf.where(f_mask))[:params['no_force_comp']], tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_123": {
                "variable": {
                    "value": "f_data",
                    "possible_values": []
                },
                "tensor": {
                    "value": "f_data",
                    "possible_values": [
                        [
                            "features['f_data'] * params['e_scale']",
                            "BinOp"
                        ],
                        [
                            "tf.boolean_mask(f_data, use_ind)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "use_ind",
                    "possible_values": [
                        [
                            "tf.cast(tf.random.shuffle(tf.where(f_mask))[:params['no_force_comp']], tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_126": {
                "variable": {
                    "value": "use_ind",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.random.shuffle(tf.where(f_mask))[:params['no_force_comp']]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "scatter_nd_127": {
                "variable": {
                    "value": "f_mask",
                    "possible_values": []
                },
                "indices": {
                    "value": "use_ind",
                    "possible_values": [
                        [
                            "tf.cast(tf.random.shuffle(tf.where(f_mask))[:params['no_force_comp']], tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "tf.fill(tf.shape(use_ind)[:1], True)",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.shape(f_mask)",
                    "possible_values": []
                }
            },
            "abs_103": {
                "x": {
                    "value": "e_data",
                    "possible_values": [
                        [
                            "features['e_data']",
                            "Subscript"
                        ],
                        [
                            "e_data * params['e_scale']",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_118": {
                "input": {
                    "value": "f_pred",
                    "possible_values": [
                        [
                            "-_get_dense_grad(pred, features['coord'])",
                            "UnaryOp"
                        ],
                        [
                            "tf.boolean_mask(f_pred, use_ind)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_152": {
                "input": {
                    "value": "f_ij",
                    "possible_values": [
                        [
                            "_get_dense_grad(pred, tensors['diff'])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_153": {
                "input": {
                    "value": "tensors['diff']",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "possible_values": []
                }
            },
            "gradients_165": {
                "ys": {
                    "value": "energy",
                    "possible_values": []
                },
                "xs": {
                    "value": "coord",
                    "possible_values": []
                }
            },
            "expand_dims_167": {
                "input": {
                    "value": "grad.indices",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "cast_168": {
                "x": {
                    "value": "grad.dense_shape",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "reduce_sum_69": {
                "input_tensor": {
                    "value": "metrics.LOSS",
                    "possible_values": []
                }
            },
            "reduce_sum_74": {
                "input_tensor": {
                    "value": "metrics.LOSS",
                    "possible_values": []
                }
            },
            "abs_121": {
                "x": {
                    "value": "f_data",
                    "possible_values": [
                        [
                            "features['f_data'] * params['e_scale']",
                            "BinOp"
                        ],
                        [
                            "tf.boolean_mask(f_data, use_ind)",
                            "Call"
                        ]
                    ]
                }
            },
            "fill_127": {
                "dims": {
                    "value": "tf.shape(use_ind)[:1]",
                    "possible_values": []
                },
                "value": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "shape_127": {
                "input": {
                    "value": "use_ind",
                    "possible_values": [
                        [
                            "tf.cast(tf.random.shuffle(tf.where(f_mask))[:params['no_force_comp']], tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_141": {
                "tensor": {
                    "value": "v",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "possible_values": []
                }
            },
            "shuffle_126": {
                "value": {
                    "value": "tf.where(f_mask)",
                    "possible_values": []
                }
            },
            "where_126": {
                "condition": {
                    "value": "f_mask",
                    "possible_values": [
                        [
                            "tf.fill(tf.shape(f_pred), True)",
                            "Call"
                        ],
                        [
                            "tf.abs(f_data) < params['max_force']",
                            "Compare"
                        ],
                        [
                            "tf.scatter_nd(use_ind, tf.fill(tf.shape(use_ind)[:1], True), tf.shape(f_mask))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "pinn/networks/__init__.py": {
        "tensorflow": {}
    },
    "pinn/networks/bpnn.py": {
        "tensorflow": {
            "BPSymmFunc_268": {
                "base_class_0": {
                    "value": "tensorflow.keras.layers.Layer",
                    "possible_values": []
                },
                "self.use_jacobian": {
                    "value": "use_jacobian",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "BPFingerprint_335": {
                "base_class_0": {
                    "value": "tensorflow.keras.layers.Layer",
                    "possible_values": []
                },
                "self.sf_spec": {
                    "value": "sf_spec",
                    "possible_values": []
                },
                "self.nn_spec": {
                    "value": "nn_spec",
                    "possible_values": []
                },
                "self.fp_range": {
                    "value": "fp_range",
                    "possible_values": [
                        [
                            "[]",
                            "MethodArgument"
                        ]
                    ]
                },
                "self.fp_scale": {
                    "value": "fp_scale",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                },
                "self.use_jacobian": {
                    "value": "use_jacobian",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "BPFeedForward_376": {
                "base_class_0": {
                    "value": "tensorflow.keras.layers.Layer",
                    "possible_values": []
                },
                "self.out_units": {
                    "value": "out_units",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "PreprocessLayer_407": {
                "base_class_0": {
                    "value": "tensorflow.keras.layers.Layer",
                    "possible_values": []
                }
            },
            "BPNN_424": {
                "base_class_0": {
                    "value": "tensorflow.keras.Model",
                    "possible_values": []
                }
            },
            "cast_27": {
                "variable": {
                    "value": "Rs",
                    "possible_values": []
                },
                "x": {
                    "value": "Rs",
                    "possible_values": [
                        [
                            "tf.cast(Rs, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(Rs, 0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.keras.backend.floatx()",
                    "possible_values": []
                }
            },
            "cast_28": {
                "variable": {
                    "value": "eta",
                    "possible_values": []
                },
                "x": {
                    "value": "eta",
                    "possible_values": [
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.keras.backend.floatx()",
                    "possible_values": []
                }
            },
            "expand_dims_55": {
                "variable": {
                    "value": "R",
                    "possible_values": []
                },
                "input": {
                    "value": "R",
                    "possible_values": [
                        [
                            "tensors['dist']",
                            "Subscript"
                        ],
                        [
                            "tf.gather(R, p_ind)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(R, 1)",
                            "Call"
                        ],
                        [
                            "tensors['dist']",
                            "Subscript"
                        ],
                        [
                            "tensors['dist']",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_56": {
                "variable": {
                    "value": "fc",
                    "possible_values": []
                },
                "input": {
                    "value": "fc",
                    "possible_values": [
                        [
                            "tensors['fc']",
                            "Subscript"
                        ],
                        [
                            "tf.gather(fc, p_ind)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(fc, 1)",
                            "Call"
                        ],
                        [
                            "tensors['fc']",
                            "Subscript"
                        ],
                        [
                            "tensors['fc']",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_57": {
                "variable": {
                    "value": "Rs",
                    "possible_values": []
                },
                "input": {
                    "value": "Rs",
                    "possible_values": [
                        [
                            "tf.cast(Rs, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(Rs, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "expand_dims_58": {
                "variable": {
                    "value": "eta",
                    "possible_values": []
                },
                "input": {
                    "value": "eta",
                    "possible_values": [
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "scatter_nd_61": {
                "variable": {
                    "value": "fp",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.expand_dims(i_rind, 1)",
                    "possible_values": []
                },
                "updates": {
                    "value": "sf",
                    "possible_values": [
                        [
                            "tf.exp(-eta * (R - Rs) ** 2) * fc",
                            "BinOp"
                        ],
                        [
                            "2 ** (1 - zeta) * (1 + lambd * tf.reduce_sum(diff_ij * diff_ik, axis=-1) / R_ij / R_ik) ** zeta * tf.exp(-eta * (R_ij ** 2 + R_ik ** 2 + R_jk ** 2)) * fc_ij * fc_ik * fc_jk",
                            "BinOp"
                        ],
                        [
                            "2 ** (1 - zeta) * (1 + lambd * tf.reduce_sum(diff_ij * diff_ik, axis=-1) / R_ij / R_ik) ** zeta * tf.exp(-eta * (R_ij ** 2 + R_ik ** 2)) * fc_ij * fc_ik",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[tf.reduce_max(a_rind) + 1, n_sf]",
                    "possible_values": []
                }
            },
            "stack_63": {
                "variable": {
                    "value": "jacob_ind",
                    "possible_values": []
                },
                "values": {
                    "value": "[p_ind, i_rind]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "cast_95": {
                "variable": {
                    "value": "lambd",
                    "possible_values": []
                },
                "x": {
                    "value": "lambd",
                    "possible_values": [
                        [
                            "tf.cast(lambd, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(lambd, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(lambd, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(lambd, 0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.keras.backend.floatx()",
                    "possible_values": []
                }
            },
            "cast_96": {
                "variable": {
                    "value": "zeta",
                    "possible_values": []
                },
                "x": {
                    "value": "zeta",
                    "possible_values": [
                        [
                            "tf.cast(zeta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(zeta, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(zeta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(zeta, 0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.keras.backend.floatx()",
                    "possible_values": []
                }
            },
            "cast_97": {
                "variable": {
                    "value": "eta",
                    "possible_values": []
                },
                "x": {
                    "value": "eta",
                    "possible_values": [
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.keras.backend.floatx()",
                    "possible_values": []
                }
            },
            "gather_104": {
                "variable": {
                    "value": "i_rind",
                    "possible_values": []
                },
                "params": {
                    "value": "tensors['ind_2'][:, 0]",
                    "possible_values": []
                },
                "indices": {
                    "value": "ind_ij",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_128": {
                "variable": {
                    "value": "diff_ij",
                    "possible_values": []
                },
                "params": {
                    "value": "diff",
                    "possible_values": [
                        [
                            "tensors['diff']",
                            "Subscript"
                        ],
                        [
                            "tensors['diff']",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.expand_dims(ind_ij, 1)",
                    "possible_values": []
                }
            },
            "gather_nd_129": {
                "variable": {
                    "value": "diff_ik",
                    "possible_values": []
                },
                "params": {
                    "value": "diff",
                    "possible_values": [
                        [
                            "tensors['diff']",
                            "Subscript"
                        ],
                        [
                            "tensors['diff']",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.expand_dims(ind_ik, 1)",
                    "possible_values": []
                }
            },
            "norm_131": {
                "variable": {
                    "value": "R_jk",
                    "possible_values": []
                },
                "tensor": {
                    "value": "diff_jk",
                    "possible_values": [
                        [
                            "diff_ik - diff_ij",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "gather_133": {
                "variable": {
                    "value": "R_jk",
                    "possible_values": []
                },
                "params": {
                    "value": "R_jk",
                    "possible_values": [
                        [
                            "tf.norm(diff_jk, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.gather(R_jk, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(R_jk, 1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "t_ind",
                    "possible_values": [
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(R_jk < rc)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather_nd(tf.stack([t_ijind, t_ikind], axis=1), tf.where(tf.not_equal(t_ijind, t_ikind)))",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_135": {
                "variable": {
                    "value": "ind_ij",
                    "possible_values": []
                },
                "params": {
                    "value": "ind_ij",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "t_ind",
                    "possible_values": [
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(R_jk < rc)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather_nd(tf.stack([t_ijind, t_ikind], axis=1), tf.where(tf.not_equal(t_ijind, t_ikind)))",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_136": {
                "variable": {
                    "value": "ind_ik",
                    "possible_values": []
                },
                "params": {
                    "value": "ind_ik",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "t_ind",
                    "possible_values": [
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(R_jk < rc)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather_nd(tf.stack([t_ijind, t_ikind], axis=1), tf.where(tf.not_equal(t_ijind, t_ikind)))",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_137": {
                "variable": {
                    "value": "i_rind",
                    "possible_values": []
                },
                "params": {
                    "value": "i_rind",
                    "possible_values": [
                        [
                            "tensors['ind_2'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, p_ind))",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['ind_2'][:, 0], ind_ij)",
                            "Call"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, t_ind))",
                            "Call"
                        ],
                        [
                            "tf.gather(i_rind, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_max(tf.concat([i_rind, i_rind], axis=0), p_uniq_idx, tf.shape(p_ind)[0])",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['ind_2'][:, 0], ind_ij)",
                            "Call"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, t_ind))",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_max(tf.concat([i_rind, i_rind], axis=0), p_uniq_idx, tf.shape(p_ind)[0])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "t_ind",
                    "possible_values": [
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(R_jk < rc)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather_nd(tf.stack([t_ijind, t_ikind], axis=1), tf.where(tf.not_equal(t_ijind, t_ikind)))",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_138": {
                "variable": {
                    "value": "diff_ij",
                    "possible_values": []
                },
                "params": {
                    "value": "diff_ij",
                    "possible_values": [
                        [
                            "tf.gather_nd(diff, tf.expand_dims(ind_ij, 1))",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(diff_ij, tf.expand_dims(t_ind, 1))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(diff_ij, 1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.gather_nd(diff, tf.expand_dims(ind_ij, 1)), 1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.expand_dims(t_ind, 1)",
                    "possible_values": []
                }
            },
            "gather_nd_139": {
                "variable": {
                    "value": "diff_ik",
                    "possible_values": []
                },
                "params": {
                    "value": "diff_ik",
                    "possible_values": [
                        [
                            "tf.gather_nd(diff, tf.expand_dims(ind_ik, 1))",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(diff_ik, tf.expand_dims(t_ind, 1))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(diff_ik, 1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.gather_nd(diff, tf.expand_dims(ind_ik, 1)), 1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.expand_dims(t_ind, 1)",
                    "possible_values": []
                }
            },
            "expand_dims_141": {
                "variable": {
                    "value": "R_ij",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.gather(R, ind_ij)",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_142": {
                "variable": {
                    "value": "R_ik",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.gather(R, ind_ik)",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_143": {
                "variable": {
                    "value": "R_jk",
                    "possible_values": []
                },
                "input": {
                    "value": "R_jk",
                    "possible_values": [
                        [
                            "tf.norm(diff_jk, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.gather(R_jk, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(R_jk, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_144": {
                "variable": {
                    "value": "fc_ij",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.gather(fc, ind_ij)",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_145": {
                "variable": {
                    "value": "fc_ik",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.gather(fc, ind_ik)",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_146": {
                "variable": {
                    "value": "fc_jk",
                    "possible_values": []
                },
                "input": {
                    "value": "fc_jk",
                    "possible_values": [
                        [
                            "CutoffFunc(cutoff_type=cutoff_type, rc=rc)(R_jk)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(fc_jk, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_147": {
                "variable": {
                    "value": "diff_ij",
                    "possible_values": []
                },
                "input": {
                    "value": "diff_ij",
                    "possible_values": [
                        [
                            "tf.gather_nd(diff, tf.expand_dims(ind_ij, 1))",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(diff_ij, tf.expand_dims(t_ind, 1))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(diff_ij, 1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.gather_nd(diff, tf.expand_dims(ind_ij, 1)), 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_148": {
                "variable": {
                    "value": "diff_ik",
                    "possible_values": []
                },
                "input": {
                    "value": "diff_ik",
                    "possible_values": [
                        [
                            "tf.gather_nd(diff, tf.expand_dims(ind_ik, 1))",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(diff_ik, tf.expand_dims(t_ind, 1))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(diff_ik, 1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.gather_nd(diff, tf.expand_dims(ind_ik, 1)), 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_149": {
                "variable": {
                    "value": "eta",
                    "possible_values": []
                },
                "input": {
                    "value": "eta",
                    "possible_values": [
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "expand_dims_150": {
                "variable": {
                    "value": "zeta",
                    "possible_values": []
                },
                "input": {
                    "value": "zeta",
                    "possible_values": [
                        [
                            "tf.cast(zeta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(zeta, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(zeta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(zeta, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "expand_dims_151": {
                "variable": {
                    "value": "lambd",
                    "possible_values": []
                },
                "input": {
                    "value": "lambd",
                    "possible_values": [
                        [
                            "tf.cast(lambd, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(lambd, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(lambd, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(lambd, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "scatter_nd_156": {
                "variable": {
                    "value": "fp",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.expand_dims(i_rind, 1)",
                    "possible_values": []
                },
                "updates": {
                    "value": "sf",
                    "possible_values": [
                        [
                            "tf.exp(-eta * (R - Rs) ** 2) * fc",
                            "BinOp"
                        ],
                        [
                            "2 ** (1 - zeta) * (1 + lambd * tf.reduce_sum(diff_ij * diff_ik, axis=-1) / R_ij / R_ik) ** zeta * tf.exp(-eta * (R_ij ** 2 + R_ik ** 2 + R_jk ** 2)) * fc_ij * fc_ik * fc_jk",
                            "BinOp"
                        ],
                        [
                            "2 ** (1 - zeta) * (1 + lambd * tf.reduce_sum(diff_ij * diff_ik, axis=-1) / R_ij / R_ik) ** zeta * tf.exp(-eta * (R_ij ** 2 + R_ik ** 2)) * fc_ij * fc_ik",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[tf.reduce_max(a_rind) + 1, tf.shape(eta)[1]]",
                    "possible_values": []
                }
            },
            "unique_160": {
                "variable": {
                    "value": "(p_ind, p_uniq_idx)",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.concat([ind_ij, ind_ik], axis=0)",
                    "possible_values": []
                }
            },
            "unsorted_segment_max_161": {
                "variable": {
                    "value": "i_rind",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.concat([i_rind, i_rind], axis=0)",
                    "possible_values": []
                },
                "segment_ids": {
                    "value": "p_uniq_idx",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "tf.shape(p_ind)[0]",
                    "possible_values": []
                }
            },
            "stack_163": {
                "variable": {
                    "value": "jacob_ind",
                    "possible_values": []
                },
                "values": {
                    "value": "[p_ind, i_rind]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "cast_188": {
                "variable": {
                    "value": "lambd",
                    "possible_values": []
                },
                "x": {
                    "value": "lambd",
                    "possible_values": [
                        [
                            "tf.cast(lambd, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(lambd, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(lambd, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(lambd, 0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.keras.backend.floatx()",
                    "possible_values": []
                }
            },
            "cast_189": {
                "variable": {
                    "value": "zeta",
                    "possible_values": []
                },
                "x": {
                    "value": "zeta",
                    "possible_values": [
                        [
                            "tf.cast(zeta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(zeta, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(zeta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(zeta, 0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.keras.backend.floatx()",
                    "possible_values": []
                }
            },
            "cast_190": {
                "variable": {
                    "value": "eta",
                    "possible_values": []
                },
                "x": {
                    "value": "eta",
                    "possible_values": [
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.keras.backend.floatx()",
                    "possible_values": []
                }
            },
            "gather_197": {
                "variable": {
                    "value": "i_rind",
                    "possible_values": []
                },
                "params": {
                    "value": "tensors['ind_2'][:, 0]",
                    "possible_values": []
                },
                "indices": {
                    "value": "ind_ij",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_221": {
                "variable": {
                    "value": "R_ij",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.gather(R, ind_ij)",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_222": {
                "variable": {
                    "value": "R_ik",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.gather(R, ind_ik)",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_223": {
                "variable": {
                    "value": "fc_ij",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.gather(fc, ind_ij)",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_224": {
                "variable": {
                    "value": "fc_ik",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.gather(fc, ind_ik)",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_225": {
                "input": {
                    "value": "ind_ij",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_226": {
                "input": {
                    "value": "ind_ik",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_227": {
                "variable": {
                    "value": "eta",
                    "possible_values": []
                },
                "input": {
                    "value": "eta",
                    "possible_values": [
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "expand_dims_228": {
                "variable": {
                    "value": "zeta",
                    "possible_values": []
                },
                "input": {
                    "value": "zeta",
                    "possible_values": [
                        [
                            "tf.cast(zeta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(zeta, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(zeta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(zeta, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "expand_dims_229": {
                "variable": {
                    "value": "lambd",
                    "possible_values": []
                },
                "input": {
                    "value": "lambd",
                    "possible_values": [
                        [
                            "tf.cast(lambd, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(lambd, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(lambd, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(lambd, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "scatter_nd_233": {
                "variable": {
                    "value": "fp",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.expand_dims(i_rind, 1)",
                    "possible_values": []
                },
                "updates": {
                    "value": "sf",
                    "possible_values": [
                        [
                            "tf.exp(-eta * (R - Rs) ** 2) * fc",
                            "BinOp"
                        ],
                        [
                            "2 ** (1 - zeta) * (1 + lambd * tf.reduce_sum(diff_ij * diff_ik, axis=-1) / R_ij / R_ik) ** zeta * tf.exp(-eta * (R_ij ** 2 + R_ik ** 2 + R_jk ** 2)) * fc_ij * fc_ik * fc_jk",
                            "BinOp"
                        ],
                        [
                            "2 ** (1 - zeta) * (1 + lambd * tf.reduce_sum(diff_ij * diff_ik, axis=-1) / R_ij / R_ik) ** zeta * tf.exp(-eta * (R_ij ** 2 + R_ik ** 2)) * fc_ij * fc_ik",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[tf.reduce_max(a_rind) + 1, tf.shape(eta)[1]]",
                    "possible_values": []
                }
            },
            "unique_241": {
                "variable": {
                    "value": "(p_ind, p_uniq_idx)",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.concat([ind_ij, ind_ik], axis=0)",
                    "possible_values": []
                }
            },
            "unsorted_segment_max_242": {
                "variable": {
                    "value": "i_rind",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.concat([i_rind, i_rind], axis=0)",
                    "possible_values": []
                },
                "segment_ids": {
                    "value": "p_uniq_idx",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "tf.shape(p_ind)[0]",
                    "possible_values": []
                }
            },
            "stack_244": {
                "variable": {
                    "value": "jacob_ind",
                    "possible_values": []
                },
                "values": {
                    "value": "[p_ind, i_rind]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "cumsum_254": {
                "variable": {
                    "value": "p_aind",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones(n_pairs, tf.int32)",
                    "possible_values": []
                }
            },
            "scatter_nd_256": {
                "variable": {
                    "value": "t_dense",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.stack([p_iind, p_rind], axis=1)",
                    "possible_values": []
                },
                "updates": {
                    "value": "p_aind",
                    "possible_values": [
                        [
                            "tf.cumsum(tf.ones(n_pairs, tf.int32))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[n_atoms, tf.reduce_max(p_rind) + 1]",
                    "possible_values": []
                }
            },
            "gather_258": {
                "variable": {
                    "value": "t_dense",
                    "possible_values": []
                },
                "params": {
                    "value": "t_dense",
                    "possible_values": [
                        [
                            "tf.scatter_nd(tf.stack([p_iind, p_rind], axis=1), p_aind, [n_atoms, tf.reduce_max(p_rind) + 1])",
                            "Call"
                        ],
                        [
                            "tf.gather(t_dense, p_iind)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "p_iind",
                    "possible_values": [
                        [
                            "tensors['ind_2'][:, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "cast_259": {
                "variable": {
                    "value": "t_index",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(t_dense)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "gather_nd_262": {
                "variable": {
                    "value": "t_ind",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.stack([t_ijind, t_ikind], axis=1)",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.where(tf.not_equal(t_ijind, t_ikind))",
                    "possible_values": []
                }
            },
            "gather_38": {
                "variable": {
                    "value": "i_elem",
                    "possible_values": []
                },
                "params": {
                    "value": "tensors['elems']",
                    "possible_values": []
                },
                "indices": {
                    "value": "i_rind",
                    "possible_values": [
                        [
                            "tensors['ind_2'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, p_ind))",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['ind_2'][:, 0], ind_ij)",
                            "Call"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, t_ind))",
                            "Call"
                        ],
                        [
                            "tf.gather(i_rind, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_max(tf.concat([i_rind, i_rind], axis=0), p_uniq_idx, tf.shape(p_ind)[0])",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['ind_2'][:, 0], ind_ij)",
                            "Call"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, t_ind))",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_max(tf.concat([i_rind, i_rind], axis=0), p_uniq_idx, tf.shape(p_ind)[0])",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_39": {
                "variable": {
                    "value": "p_filter",
                    "possible_values": []
                },
                "x": {
                    "value": "i_elem",
                    "possible_values": [
                        [
                            "tf.gather(tensors['elems'], i_rind)",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['elems'], tf.gather(ind2[:, 0], ind_ij))",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['elems'], tf.gather(ind2[:, 0], ind_ij))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "i",
                    "possible_values": [
                        [
                            "'All'",
                            "MethodArgument"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "gather_42": {
                "variable": {
                    "value": "j_elem",
                    "possible_values": []
                },
                "params": {
                    "value": "tensors['elems']",
                    "possible_values": []
                },
                "indices": {
                    "value": "tensors['ind_2'][:, 1]",
                    "possible_values": []
                }
            },
            "equal_43": {
                "variable": {
                    "value": "j_filter",
                    "possible_values": []
                },
                "x": {
                    "value": "j_elem",
                    "possible_values": [
                        [
                            "tf.gather(tensors['elems'], tensors['ind_2'][:, 1])",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['elems'], tf.gather(ind2[:, 1], ind_ij))",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['elems'], tf.gather(ind2[:, 1], ind_ij))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "j",
                    "possible_values": [
                        [
                            "'ALL'",
                            "MethodArgument"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "cast_48": {
                "variable": {
                    "value": "p_ind",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(p_filter)[:, 0]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "gather_49": {
                "variable": {
                    "value": "R",
                    "possible_values": []
                },
                "params": {
                    "value": "R",
                    "possible_values": [
                        [
                            "tensors['dist']",
                            "Subscript"
                        ],
                        [
                            "tf.gather(R, p_ind)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(R, 1)",
                            "Call"
                        ],
                        [
                            "tensors['dist']",
                            "Subscript"
                        ],
                        [
                            "tensors['dist']",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "p_ind",
                    "possible_values": [
                        [
                            "tf.cast(tf.where(p_filter)[:, 0], tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.cumsum(tf.ones_like(i_rind)) - 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "gather_50": {
                "variable": {
                    "value": "fc",
                    "possible_values": []
                },
                "params": {
                    "value": "fc",
                    "possible_values": [
                        [
                            "tensors['fc']",
                            "Subscript"
                        ],
                        [
                            "tf.gather(fc, p_ind)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(fc, 1)",
                            "Call"
                        ],
                        [
                            "tensors['fc']",
                            "Subscript"
                        ],
                        [
                            "tensors['fc']",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "p_ind",
                    "possible_values": [
                        [
                            "tf.cast(tf.where(p_filter)[:, 0], tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.cumsum(tf.ones_like(i_rind)) - 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "gather_51": {
                "params": {
                    "value": "i_rind",
                    "possible_values": [
                        [
                            "tensors['ind_2'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, p_ind))",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['ind_2'][:, 0], ind_ij)",
                            "Call"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, t_ind))",
                            "Call"
                        ],
                        [
                            "tf.gather(i_rind, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_max(tf.concat([i_rind, i_rind], axis=0), p_uniq_idx, tf.shape(p_ind)[0])",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['ind_2'][:, 0], ind_ij)",
                            "Call"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, t_ind))",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_max(tf.concat([i_rind, i_rind], axis=0), p_uniq_idx, tf.shape(p_ind)[0])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "p_ind",
                    "possible_values": [
                        [
                            "tf.cast(tf.where(p_filter)[:, 0], tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.cumsum(tf.ones_like(i_rind)) - 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "gather_109": {
                "params": {
                    "value": "ind2[:, 0]",
                    "possible_values": []
                },
                "indices": {
                    "value": "ind_ij",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_110": {
                "variable": {
                    "value": "t_filter",
                    "possible_values": []
                },
                "x": {
                    "value": "i_elem",
                    "possible_values": [
                        [
                            "tf.gather(tensors['elems'], i_rind)",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['elems'], tf.gather(ind2[:, 0], ind_ij))",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['elems'], tf.gather(ind2[:, 0], ind_ij))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "i",
                    "possible_values": [
                        [
                            "'All'",
                            "MethodArgument"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "gather_113": {
                "params": {
                    "value": "ind2[:, 1]",
                    "possible_values": []
                },
                "indices": {
                    "value": "ind_ij",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_114": {
                "variable": {
                    "value": "j_filter",
                    "possible_values": []
                },
                "x": {
                    "value": "j_elem",
                    "possible_values": [
                        [
                            "tf.gather(tensors['elems'], tensors['ind_2'][:, 1])",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['elems'], tf.gather(ind2[:, 1], ind_ij))",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['elems'], tf.gather(ind2[:, 1], ind_ij))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "j",
                    "possible_values": [
                        [
                            "'ALL'",
                            "MethodArgument"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "gather_118": {
                "params": {
                    "value": "ind2[:, 1]",
                    "possible_values": []
                },
                "indices": {
                    "value": "ind_ik",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_119": {
                "variable": {
                    "value": "k_filter",
                    "possible_values": []
                },
                "x": {
                    "value": "k_elem",
                    "possible_values": [
                        [
                            "tf.gather(tensors['elems'], tf.gather(ind2[:, 1], ind_ik))",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['elems'], tf.gather(ind2[:, 1], ind_ik))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "k",
                    "possible_values": [
                        [
                            "['elems', 'dist']",
                            "List"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "gather_124": {
                "variable": {
                    "value": "ind_ij",
                    "possible_values": []
                },
                "params": {
                    "value": "ind_ij",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "t_ind",
                    "possible_values": [
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(R_jk < rc)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather_nd(tf.stack([t_ijind, t_ikind], axis=1), tf.where(tf.not_equal(t_ijind, t_ikind)))",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_125": {
                "variable": {
                    "value": "ind_ik",
                    "possible_values": []
                },
                "params": {
                    "value": "ind_ik",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "t_ind",
                    "possible_values": [
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(R_jk < rc)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather_nd(tf.stack([t_ijind, t_ikind], axis=1), tf.where(tf.not_equal(t_ijind, t_ikind)))",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_126": {
                "params": {
                    "value": "i_rind",
                    "possible_values": [
                        [
                            "tensors['ind_2'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, p_ind))",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['ind_2'][:, 0], ind_ij)",
                            "Call"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, t_ind))",
                            "Call"
                        ],
                        [
                            "tf.gather(i_rind, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_max(tf.concat([i_rind, i_rind], axis=0), p_uniq_idx, tf.shape(p_ind)[0])",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['ind_2'][:, 0], ind_ij)",
                            "Call"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, t_ind))",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_max(tf.concat([i_rind, i_rind], axis=0), p_uniq_idx, tf.shape(p_ind)[0])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "t_ind",
                    "possible_values": [
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(R_jk < rc)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather_nd(tf.stack([t_ijind, t_ikind], axis=1), tf.where(tf.not_equal(t_ijind, t_ikind)))",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_202": {
                "params": {
                    "value": "ind2[:, 0]",
                    "possible_values": []
                },
                "indices": {
                    "value": "ind_ij",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_203": {
                "variable": {
                    "value": "t_filter",
                    "possible_values": []
                },
                "x": {
                    "value": "i_elem",
                    "possible_values": [
                        [
                            "tf.gather(tensors['elems'], i_rind)",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['elems'], tf.gather(ind2[:, 0], ind_ij))",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['elems'], tf.gather(ind2[:, 0], ind_ij))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "i",
                    "possible_values": [
                        [
                            "'All'",
                            "MethodArgument"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "gather_206": {
                "params": {
                    "value": "ind2[:, 1]",
                    "possible_values": []
                },
                "indices": {
                    "value": "ind_ij",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_207": {
                "variable": {
                    "value": "j_filter",
                    "possible_values": []
                },
                "x": {
                    "value": "j_elem",
                    "possible_values": [
                        [
                            "tf.gather(tensors['elems'], tensors['ind_2'][:, 1])",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['elems'], tf.gather(ind2[:, 1], ind_ij))",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['elems'], tf.gather(ind2[:, 1], ind_ij))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "j",
                    "possible_values": [
                        [
                            "'ALL'",
                            "MethodArgument"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "gather_211": {
                "params": {
                    "value": "ind2[:, 1]",
                    "possible_values": []
                },
                "indices": {
                    "value": "ind_ik",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_212": {
                "variable": {
                    "value": "k_filter",
                    "possible_values": []
                },
                "x": {
                    "value": "k_elem",
                    "possible_values": [
                        [
                            "tf.gather(tensors['elems'], tf.gather(ind2[:, 1], ind_ik))",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['elems'], tf.gather(ind2[:, 1], ind_ik))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "k",
                    "possible_values": [
                        [
                            "['elems', 'dist']",
                            "List"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "gather_217": {
                "variable": {
                    "value": "ind_ij",
                    "possible_values": []
                },
                "params": {
                    "value": "ind_ij",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "t_ind",
                    "possible_values": [
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(R_jk < rc)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather_nd(tf.stack([t_ijind, t_ikind], axis=1), tf.where(tf.not_equal(t_ijind, t_ikind)))",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_218": {
                "variable": {
                    "value": "ind_ik",
                    "possible_values": []
                },
                "params": {
                    "value": "ind_ik",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "t_ind",
                    "possible_values": [
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(R_jk < rc)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather_nd(tf.stack([t_ijind, t_ikind], axis=1), tf.where(tf.not_equal(t_ijind, t_ikind)))",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_219": {
                "params": {
                    "value": "i_rind",
                    "possible_values": [
                        [
                            "tensors['ind_2'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, p_ind))",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['ind_2'][:, 0], ind_ij)",
                            "Call"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, t_ind))",
                            "Call"
                        ],
                        [
                            "tf.gather(i_rind, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_max(tf.concat([i_rind, i_rind], axis=0), p_uniq_idx, tf.shape(p_ind)[0])",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['ind_2'][:, 0], ind_ij)",
                            "Call"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, t_ind))",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_max(tf.concat([i_rind, i_rind], axis=0), p_uniq_idx, tf.shape(p_ind)[0])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "t_ind",
                    "possible_values": [
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(R_jk < rc)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather_nd(tf.stack([t_ijind, t_ikind], axis=1), tf.where(tf.not_equal(t_ijind, t_ikind)))",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_328": {
                "variable": {
                    "value": "dfp",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.gather_nd(dfp, jacob_ind[:, 1:])",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "reduce_sum_329": {
                "variable": {
                    "value": "ddiff",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "jacob * dfp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "possible_values": []
                }
            },
            "IndexedSlices_330": {
                "variable": {
                    "value": "ddiff",
                    "possible_values": []
                },
                "values": {
                    "value": "ddiff",
                    "possible_values": [
                        [
                            "tf.reduce_sum(jacob * dfp, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.IndexedSlices(ddiff, jacob_ind[:, 0], [n_pairs, 3])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "jacob_ind[:, 0]",
                    "possible_values": []
                },
                "dense_shape": {
                    "value": "[n_pairs, 3]",
                    "possible_values": []
                }
            },
            "unsorted_segment_sum_400": {
                "variable": {
                    "value": "output",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.concat(output, axis=0)",
                    "possible_values": []
                },
                "segment_ids": {
                    "value": "tf.concat(indices, axis=0)",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "tf.shape(tensors['ind_1'])[0]",
                    "possible_values": []
                }
            },
            "floatx_27": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "floatx_28": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "cumsum_36": {
                "x": {
                    "value": "tf.ones_like(tensors['elems'], tf.int32)",
                    "possible_values": []
                }
            },
            "exp_59": {
                "x": {
                    "value": "-eta * (R - Rs) ** 2",
                    "possible_values": []
                }
            },
            "expand_dims_61": {
                "input": {
                    "value": "i_rind",
                    "possible_values": [
                        [
                            "tensors['ind_2'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, p_ind))",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['ind_2'][:, 0], ind_ij)",
                            "Call"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, t_ind))",
                            "Call"
                        ],
                        [
                            "tf.gather(i_rind, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_max(tf.concat([i_rind, i_rind], axis=0), p_uniq_idx, tf.shape(p_ind)[0])",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['ind_2'][:, 0], ind_ij)",
                            "Call"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, t_ind))",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_max(tf.concat([i_rind, i_rind], axis=0), p_uniq_idx, tf.shape(p_ind)[0])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "floatx_95": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "floatx_96": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "floatx_97": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "cumsum_107": {
                "x": {
                    "value": "tf.ones_like(tensors['elems'], tf.int32)",
                    "possible_values": []
                }
            },
            "expand_dims_128": {
                "input": {
                    "value": "ind_ij",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_129": {
                "input": {
                    "value": "ind_ik",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "where_132": {
                "condition": {
                    "value": "R_jk < rc",
                    "possible_values": []
                }
            },
            "expand_dims_138": {
                "input": {
                    "value": "t_ind",
                    "possible_values": [
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(R_jk < rc)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather_nd(tf.stack([t_ijind, t_ikind], axis=1), tf.where(tf.not_equal(t_ijind, t_ikind)))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_139": {
                "input": {
                    "value": "t_ind",
                    "possible_values": [
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(R_jk < rc)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.where(t_filter)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather_nd(tf.stack([t_ijind, t_ikind], axis=1), tf.where(tf.not_equal(t_ijind, t_ikind)))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "gather_141": {
                "params": {
                    "value": "R",
                    "possible_values": [
                        [
                            "tensors['dist']",
                            "Subscript"
                        ],
                        [
                            "tf.gather(R, p_ind)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(R, 1)",
                            "Call"
                        ],
                        [
                            "tensors['dist']",
                            "Subscript"
                        ],
                        [
                            "tensors['dist']",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "ind_ij",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_142": {
                "params": {
                    "value": "R",
                    "possible_values": [
                        [
                            "tensors['dist']",
                            "Subscript"
                        ],
                        [
                            "tf.gather(R, p_ind)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(R, 1)",
                            "Call"
                        ],
                        [
                            "tensors['dist']",
                            "Subscript"
                        ],
                        [
                            "tensors['dist']",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "ind_ik",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_144": {
                "params": {
                    "value": "fc",
                    "possible_values": [
                        [
                            "tensors['fc']",
                            "Subscript"
                        ],
                        [
                            "tf.gather(fc, p_ind)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(fc, 1)",
                            "Call"
                        ],
                        [
                            "tensors['fc']",
                            "Subscript"
                        ],
                        [
                            "tensors['fc']",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "ind_ij",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_145": {
                "params": {
                    "value": "fc",
                    "possible_values": [
                        [
                            "tensors['fc']",
                            "Subscript"
                        ],
                        [
                            "tf.gather(fc, p_ind)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(fc, 1)",
                            "Call"
                        ],
                        [
                            "tensors['fc']",
                            "Subscript"
                        ],
                        [
                            "tensors['fc']",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "ind_ik",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_156": {
                "input": {
                    "value": "i_rind",
                    "possible_values": [
                        [
                            "tensors['ind_2'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, p_ind))",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['ind_2'][:, 0], ind_ij)",
                            "Call"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, t_ind))",
                            "Call"
                        ],
                        [
                            "tf.gather(i_rind, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_max(tf.concat([i_rind, i_rind], axis=0), p_uniq_idx, tf.shape(p_ind)[0])",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['ind_2'][:, 0], ind_ij)",
                            "Call"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, t_ind))",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_max(tf.concat([i_rind, i_rind], axis=0), p_uniq_idx, tf.shape(p_ind)[0])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "concat_160": {
                "values": {
                    "value": "[ind_ij, ind_ik]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "concat_162": {
                "values": {
                    "value": "[i_rind, i_rind]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "floatx_188": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "floatx_189": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "floatx_190": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "cumsum_200": {
                "x": {
                    "value": "tf.ones_like(tensors['elems'], tf.int32)",
                    "possible_values": []
                }
            },
            "gather_221": {
                "params": {
                    "value": "R",
                    "possible_values": [
                        [
                            "tensors['dist']",
                            "Subscript"
                        ],
                        [
                            "tf.gather(R, p_ind)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(R, 1)",
                            "Call"
                        ],
                        [
                            "tensors['dist']",
                            "Subscript"
                        ],
                        [
                            "tensors['dist']",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "ind_ij",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_222": {
                "params": {
                    "value": "R",
                    "possible_values": [
                        [
                            "tensors['dist']",
                            "Subscript"
                        ],
                        [
                            "tf.gather(R, p_ind)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(R, 1)",
                            "Call"
                        ],
                        [
                            "tensors['dist']",
                            "Subscript"
                        ],
                        [
                            "tensors['dist']",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "ind_ik",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_223": {
                "params": {
                    "value": "fc",
                    "possible_values": [
                        [
                            "tensors['fc']",
                            "Subscript"
                        ],
                        [
                            "tf.gather(fc, p_ind)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(fc, 1)",
                            "Call"
                        ],
                        [
                            "tensors['fc']",
                            "Subscript"
                        ],
                        [
                            "tensors['fc']",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "ind_ij",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ij, t_ind)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_224": {
                "params": {
                    "value": "fc",
                    "possible_values": [
                        [
                            "tensors['fc']",
                            "Subscript"
                        ],
                        [
                            "tf.gather(fc, p_ind)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(fc, 1)",
                            "Call"
                        ],
                        [
                            "tensors['fc']",
                            "Subscript"
                        ],
                        [
                            "tensors['fc']",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "ind_ik",
                    "possible_values": [
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ],
                        [
                            "tensors['ind_3'][:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(ind_ik, t_ind)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_225": {
                "params": {
                    "value": "diff",
                    "possible_values": [
                        [
                            "tensors['diff']",
                            "Subscript"
                        ],
                        [
                            "tensors['diff']",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.expand_dims(ind_ij, 1)",
                    "possible_values": []
                }
            },
            "gather_nd_226": {
                "params": {
                    "value": "diff",
                    "possible_values": [
                        [
                            "tensors['diff']",
                            "Subscript"
                        ],
                        [
                            "tensors['diff']",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.expand_dims(ind_ik, 1)",
                    "possible_values": []
                }
            },
            "expand_dims_233": {
                "input": {
                    "value": "i_rind",
                    "possible_values": [
                        [
                            "tensors['ind_2'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, p_ind))",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['ind_2'][:, 0], ind_ij)",
                            "Call"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, t_ind))",
                            "Call"
                        ],
                        [
                            "tf.gather(i_rind, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_max(tf.concat([i_rind, i_rind], axis=0), p_uniq_idx, tf.shape(p_ind)[0])",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['ind_2'][:, 0], ind_ij)",
                            "Call"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, t_ind))",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_max(tf.concat([i_rind, i_rind], axis=0), p_uniq_idx, tf.shape(p_ind)[0])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "concat_241": {
                "values": {
                    "value": "[ind_ij, ind_ik]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "concat_243": {
                "values": {
                    "value": "[i_rind, i_rind]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "shape_252": {
                "input": {
                    "value": "tensors['ind_1']",
                    "possible_values": []
                }
            },
            "shape_253": {
                "input": {
                    "value": "tensors['ind_2']",
                    "possible_values": []
                }
            },
            "ones_254": {
                "shape": {
                    "value": "n_pairs",
                    "possible_values": [
                        [
                            "tf.shape(tensors['ind_2'])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(tensors['diff'])[0]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "gather_255": {
                "params": {
                    "value": "tf.math.segment_min(p_aind, p_iind)",
                    "possible_values": []
                },
                "indices": {
                    "value": "p_iind",
                    "possible_values": [
                        [
                            "tensors['ind_2'][:, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "stack_256": {
                "values": {
                    "value": "[p_iind, p_rind]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "where_259": {
                "condition": {
                    "value": "t_dense",
                    "possible_values": [
                        [
                            "tf.scatter_nd(tf.stack([p_iind, p_rind], axis=1), p_aind, [n_atoms, tf.reduce_max(p_rind) + 1])",
                            "Call"
                        ],
                        [
                            "tf.gather(t_dense, p_iind)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_261": {
                "params": {
                    "value": "t_dense",
                    "possible_values": [
                        [
                            "tf.scatter_nd(tf.stack([p_iind, p_rind], axis=1), p_aind, [n_atoms, tf.reduce_max(p_rind) + 1])",
                            "Call"
                        ],
                        [
                            "tf.gather(t_dense, p_iind)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "t_index",
                    "possible_values": [
                        [
                            "tf.cast(tf.where(t_dense), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_262": {
                "values": {
                    "value": "[t_ijind, t_ikind]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "where_263": {
                "condition": {
                    "value": "tf.not_equal(t_ijind, t_ikind)",
                    "possible_values": []
                }
            },
            "identity_332": {
                "input": {
                    "value": "fp",
                    "possible_values": [
                        [
                            "tf.scatter_nd(tf.expand_dims(i_rind, 1), sf, [tf.reduce_max(a_rind) + 1, n_sf])",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(tf.expand_dims(i_rind, 1), sf, [tf.reduce_max(a_rind) + 1, tf.shape(eta)[1]])",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(tf.expand_dims(i_rind, 1), sf, [tf.reduce_max(a_rind) + 1, tf.shape(eta)[1]])",
                            "Call"
                        ],
                        [
                            "tensors['fp_{}'.format(i)]",
                            "Subscript"
                        ],
                        [
                            "_fake_fp(tensors['diff'], fp, tensors['jacob_{}'.format(i)], tensors['jacob_ind_{}'.format(i)], n_pairs)",
                            "Call"
                        ],
                        [
                            "(fp - fp_min) / tf.maximum(fp_max - fp_min, 1e-06) * 2 - 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "concat_366": {
                "variable": {
                    "value": "fps_all",
                    "possible_values": []
                },
                "values": {
                    "value": "fps_all",
                    "possible_values": [
                        [
                            "fps.pop('ALL')",
                            "Call"
                        ],
                        [
                            "tf.concat(fps_all, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "ones_like_36": {
                "input": {
                    "value": "tensors['elems']",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "cumsum_40": {
                "x": {
                    "value": "tf.cast(tf.equal(tensors['elems'], i), tf.int32)",
                    "possible_values": []
                }
            },
            "reduce_all_44": {
                "input_tensor": {
                    "value": "[p_filter, j_filter]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "cumsum_53": {
                "x": {
                    "value": "tf.ones_like(i_rind)",
                    "possible_values": []
                }
            },
            "ones_like_107": {
                "input": {
                    "value": "tensors['elems']",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "cumsum_111": {
                "x": {
                    "value": "tf.cast(tf.equal(tensors['elems'], i), tf.int32)",
                    "possible_values": []
                }
            },
            "reduce_all_115": {
                "input_tensor": {
                    "value": "[t_filter, j_filter]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "reduce_all_120": {
                "input_tensor": {
                    "value": "[t_filter, k_filter]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "where_123": {
                "condition": {
                    "value": "t_filter",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.equal(i_elem, i)",
                            "Call"
                        ],
                        [
                            "tf.reduce_all([t_filter, j_filter], axis=0) if t_filter is not None else j_filter",
                            "IfExp"
                        ],
                        [
                            "tf.reduce_all([t_filter, k_filter], axis=0) if t_filter is not None else k_filter",
                            "IfExp"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.equal(i_elem, i)",
                            "Call"
                        ],
                        [
                            "tf.reduce_all([t_filter, j_filter], axis=0) if t_filter is not None else j_filter",
                            "IfExp"
                        ],
                        [
                            "tf.reduce_all([t_filter, k_filter], axis=0) if t_filter is not None else k_filter",
                            "IfExp"
                        ]
                    ]
                }
            },
            "shape_162": {
                "input": {
                    "value": "p_ind",
                    "possible_values": [
                        [
                            "tf.cast(tf.where(p_filter)[:, 0], tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.cumsum(tf.ones_like(i_rind)) - 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "ones_like_200": {
                "input": {
                    "value": "tensors['elems']",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "cumsum_204": {
                "x": {
                    "value": "tf.cast(tf.equal(tensors['elems'], i), tf.int32)",
                    "possible_values": []
                }
            },
            "reduce_all_208": {
                "input_tensor": {
                    "value": "[t_filter, j_filter]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "reduce_all_213": {
                "input_tensor": {
                    "value": "[t_filter, k_filter]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "where_216": {
                "condition": {
                    "value": "t_filter",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.equal(i_elem, i)",
                            "Call"
                        ],
                        [
                            "tf.reduce_all([t_filter, j_filter], axis=0) if t_filter is not None else j_filter",
                            "IfExp"
                        ],
                        [
                            "tf.reduce_all([t_filter, k_filter], axis=0) if t_filter is not None else k_filter",
                            "IfExp"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.equal(i_elem, i)",
                            "Call"
                        ],
                        [
                            "tf.reduce_all([t_filter, j_filter], axis=0) if t_filter is not None else j_filter",
                            "IfExp"
                        ],
                        [
                            "tf.reduce_all([t_filter, k_filter], axis=0) if t_filter is not None else k_filter",
                            "IfExp"
                        ]
                    ]
                }
            },
            "shape_243": {
                "input": {
                    "value": "p_ind",
                    "possible_values": [
                        [
                            "tf.cast(tf.where(p_filter)[:, 0], tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.cumsum(tf.ones_like(i_rind)) - 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "segment_min_255": {
                "data": {
                    "value": "p_aind",
                    "possible_values": [
                        [
                            "tf.cumsum(tf.ones(n_pairs, tf.int32))",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "p_iind",
                    "possible_values": [
                        [
                            "tensors['ind_2'][:, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "not_equal_263": {
                "x": {
                    "value": "t_ijind",
                    "possible_values": [
                        [
                            "t_index[:, 0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "t_ikind",
                    "possible_values": [
                        [
                            "tf.gather_nd(t_dense, t_index) - 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "gather_nd_328": {
                "params": {
                    "value": "dfp",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.gather_nd(dfp, jacob_ind[:, 1:]), axis=1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "jacob_ind[:, 1:]",
                    "possible_values": []
                }
            },
            "shape_349": {
                "input": {
                    "value": "tensors['diff']",
                    "possible_values": []
                }
            },
            "expand_dims_359": {
                "variable": {
                    "value": "fp_min",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.cast(fp_range[i][0], fp.dtype)",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "expand_dims_360": {
                "variable": {
                    "value": "fp_max",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.cast(fp_range[i][1], fp.dtype)",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "where_368": {
                "variable": {
                    "value": "ind",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.equal(tensors['elems'], e)",
                    "possible_values": []
                }
            },
            "concat_371": {
                "values": {
                    "value": "v",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "concat_401": {
                "values": {
                    "value": "output",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.math.unsorted_segment_sum(tf.concat(output, axis=0), tf.concat(indices, axis=0), tf.shape(tensors['ind_1'])[0])",
                            "Call"
                        ],
                        [
                            "self.feed_forward(tensors)",
                            "Call"
                        ],
                        [
                            "self.ann_output([tensors['ind_1'], output])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "concat_402": {
                "values": {
                    "value": "indices",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "reshape_417": {
                "variable": {
                    "value": "tensors[k]",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tensors[k]",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.shape(tensors[k])[:1]",
                    "possible_values": []
                }
            },
            "cast_40": {
                "x": {
                    "value": "tf.equal(tensors['elems'], i)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "where_48": {
                "condition": {
                    "value": "p_filter",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.equal(i_elem, i)",
                            "Call"
                        ],
                        [
                            "tf.reduce_all([p_filter, j_filter], axis=0) if p_filter is not None else j_filter",
                            "IfExp"
                        ]
                    ]
                }
            },
            "ones_like_53": {
                "input": {
                    "value": "i_rind",
                    "possible_values": [
                        [
                            "tensors['ind_2'][:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, p_ind))",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['ind_2'][:, 0], ind_ij)",
                            "Call"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, t_ind))",
                            "Call"
                        ],
                        [
                            "tf.gather(i_rind, t_ind)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_max(tf.concat([i_rind, i_rind], axis=0), p_uniq_idx, tf.shape(p_ind)[0])",
                            "Call"
                        ],
                        [
                            "tf.gather(tensors['ind_2'][:, 0], ind_ij)",
                            "Call"
                        ],
                        [
                            "tf.gather(a_rind, tf.gather(i_rind, t_ind))",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_max(tf.concat([i_rind, i_rind], axis=0), p_uniq_idx, tf.shape(p_ind)[0])",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_max_62": {
                "input_tensor": {
                    "value": "a_rind",
                    "possible_values": [
                        [
                            "tf.cumsum(tf.ones_like(tensors['elems'], tf.int32)) - 1",
                            "BinOp"
                        ],
                        [
                            "tf.cumsum(tf.cast(tf.equal(tensors['elems'], i), tf.int32)) - 1",
                            "BinOp"
                        ],
                        [
                            "tf.cumsum(tf.ones_like(tensors['elems'], tf.int32)) - 1",
                            "BinOp"
                        ],
                        [
                            "tf.cumsum(tf.cast(tf.equal(tensors['elems'], i), tf.int32)) - 1",
                            "BinOp"
                        ],
                        [
                            "tf.cumsum(tf.ones_like(tensors['elems'], tf.int32)) - 1",
                            "BinOp"
                        ],
                        [
                            "tf.cumsum(tf.cast(tf.equal(tensors['elems'], i), tf.int32)) - 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "cast_111": {
                "x": {
                    "value": "tf.equal(tensors['elems'], i)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "reduce_max_157": {
                "input_tensor": {
                    "value": "a_rind",
                    "possible_values": [
                        [
                            "tf.cumsum(tf.ones_like(tensors['elems'], tf.int32)) - 1",
                            "BinOp"
                        ],
                        [
                            "tf.cumsum(tf.cast(tf.equal(tensors['elems'], i), tf.int32)) - 1",
                            "BinOp"
                        ],
                        [
                            "tf.cumsum(tf.ones_like(tensors['elems'], tf.int32)) - 1",
                            "BinOp"
                        ],
                        [
                            "tf.cumsum(tf.cast(tf.equal(tensors['elems'], i), tf.int32)) - 1",
                            "BinOp"
                        ],
                        [
                            "tf.cumsum(tf.ones_like(tensors['elems'], tf.int32)) - 1",
                            "BinOp"
                        ],
                        [
                            "tf.cumsum(tf.cast(tf.equal(tensors['elems'], i), tf.int32)) - 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_157": {
                "input": {
                    "value": "eta",
                    "possible_values": [
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_204": {
                "x": {
                    "value": "tf.equal(tensors['elems'], i)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "exp_232": {
                "x": {
                    "value": "-eta * (R_ij ** 2 + R_ik ** 2)",
                    "possible_values": []
                }
            },
            "reduce_max_234": {
                "input_tensor": {
                    "value": "a_rind",
                    "possible_values": [
                        [
                            "tf.cumsum(tf.ones_like(tensors['elems'], tf.int32)) - 1",
                            "BinOp"
                        ],
                        [
                            "tf.cumsum(tf.cast(tf.equal(tensors['elems'], i), tf.int32)) - 1",
                            "BinOp"
                        ],
                        [
                            "tf.cumsum(tf.ones_like(tensors['elems'], tf.int32)) - 1",
                            "BinOp"
                        ],
                        [
                            "tf.cumsum(tf.cast(tf.equal(tensors['elems'], i), tf.int32)) - 1",
                            "BinOp"
                        ],
                        [
                            "tf.cumsum(tf.ones_like(tensors['elems'], tf.int32)) - 1",
                            "BinOp"
                        ],
                        [
                            "tf.cumsum(tf.cast(tf.equal(tensors['elems'], i), tf.int32)) - 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_234": {
                "input": {
                    "value": "eta",
                    "possible_values": [
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(eta, tf.keras.backend.floatx())",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(eta, 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_max_257": {
                "input_tensor": {
                    "value": "p_rind",
                    "possible_values": [
                        [
                            "p_aind - tf.gather(tf.math.segment_min(p_aind, p_iind), p_iind)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "GradientTape_294": {
                "persistent": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "Dense_384": {
                "units": {
                    "value": "units",
                    "possible_values": []
                },
                "activation": {
                    "value": "act",
                    "possible_values": [
                        [
                            "'tanh'",
                            "MethodArgument"
                        ]
                    ]
                },
                "name": {
                    "value": "f'dense_{k}'",
                    "possible_values": []
                }
            },
            "Dense_387": {
                "units": {
                    "value": "out_units",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                },
                "activation": {
                    "value": "None",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "possible_values": []
                },
                "name": {
                    "value": "noact",
                    "possible_values": []
                }
            },
            "shape_403": {
                "input": {
                    "value": "tensors['ind_1']",
                    "possible_values": []
                }
            },
            "equal_40": {
                "x": {
                    "value": "tensors['elems']",
                    "possible_values": []
                },
                "y": {
                    "value": "i",
                    "possible_values": [
                        [
                            "'All'",
                            "MethodArgument"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "equal_111": {
                "x": {
                    "value": "tensors['elems']",
                    "possible_values": []
                },
                "y": {
                    "value": "i",
                    "possible_values": [
                        [
                            "'All'",
                            "MethodArgument"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "exp_155": {
                "x": {
                    "value": "-eta * (R_ij ** 2 + R_ik ** 2 + R_jk ** 2)",
                    "possible_values": []
                }
            },
            "equal_204": {
                "x": {
                    "value": "tensors['elems']",
                    "possible_values": []
                },
                "y": {
                    "value": "i",
                    "possible_values": [
                        [
                            "'All'",
                            "MethodArgument"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "stack_304": {
                "variable": {
                    "value": "jacob",
                    "possible_values": []
                },
                "values": {
                    "value": "[gtape.gradient(fp_slice, tensors['diff']) for fp_slice in fp_slices]",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "possible_values": []
                }
            },
            "gather_nd_308": {
                "variable": {
                    "value": "jacob",
                    "possible_values": []
                },
                "params": {
                    "value": "jacob",
                    "possible_values": [
                        [
                            "tf.stack([gtape.gradient(fp_slice, tensors['diff']) for fp_slice in fp_slices], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(jacob, jacob_ind[:, :1])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "jacob_ind[:, :1]",
                    "possible_values": []
                }
            },
            "cast_359": {
                "x": {
                    "value": "fp_range[i][0]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "fp.dtype",
                    "possible_values": []
                }
            },
            "cast_360": {
                "x": {
                    "value": "fp_range[i][1]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "fp.dtype",
                    "possible_values": []
                }
            },
            "equal_368": {
                "x": {
                    "value": "tensors['elems']",
                    "possible_values": []
                },
                "y": {
                    "value": "e",
                    "possible_values": [
                        [
                            "nn_spec.keys()",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_369": {
                "params": {
                    "value": "fps_all",
                    "possible_values": [
                        [
                            "fps.pop('ALL')",
                            "Call"
                        ],
                        [
                            "tf.concat(fps_all, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "ind",
                    "possible_values": [
                        [
                            "tf.where(tf.equal(tensors['elems'], e))",
                            "Call"
                        ]
                    ]
                }
            },
            "where_398": {
                "condition": {
                    "value": "tf.equal(tensors['elems'], k)",
                    "possible_values": []
                }
            },
            "equal_398": {
                "x": {
                    "value": "tensors['elems']",
                    "possible_values": []
                },
                "y": {
                    "value": "k",
                    "possible_values": [
                        [
                            "['elems', 'dist']",
                            "List"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ],
                        [
                            "'ALL'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "shape_417": {
                "input": {
                    "value": "tensors[k]",
                    "possible_values": []
                }
            },
            "maximum_361": {
                "x": {
                    "value": "fp_max - fp_min",
                    "possible_values": []
                },
                "y": {
                    "value": "1e-06",
                    "possible_values": []
                }
            },
            "reduce_sum_231": {
                "input_tensor": {
                    "value": "diff_ij * diff_ik",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "reduce_sum_154": {
                "input_tensor": {
                    "value": "diff_ij * diff_ik",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            }
        }
    },
    "pinn/networks/lj.py": {
        "tensorflow": {
            "LJ_6": {
                "base_class_0": {
                    "value": "tensorflow.keras.Model",
                    "possible_values": []
                },
                "self.rc": {
                    "value": "rc",
                    "possible_values": [
                        [
                            "3.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "self.sigma": {
                    "value": "sigma",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "self.epsilon": {
                    "value": "epsilon",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "unsorted_segment_sum_38": {
                "variable": {
                    "value": "en",
                    "possible_values": []
                },
                "data": {
                    "value": "en",
                    "possible_values": [
                        [
                            "4 * epsilon * (c12 - c6) - e0",
                            "BinOp"
                        ],
                        [
                            "tf.math.unsorted_segment_sum(en, tensors['ind_2'][:, 0], natom)",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "tensors['ind_2'][:, 0]",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "natom",
                    "possible_values": [
                        [
                            "tf.shape(tensors['ind_1'])[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_36": {
                "input": {
                    "value": "tensors['ind_1']",
                    "possible_values": []
                }
            },
            "reduce_max_37": {
                "input_tensor": {
                    "value": "tensors['ind_1']",
                    "possible_values": []
                }
            }
        }
    },
    "pinn/networks/pinet.py": {
        "tensorflow": {
            "FFLayer_7": {
                "base_class_0": {
                    "value": "tensorflow.keras.layers.Layer",
                    "possible_values": []
                }
            },
            "PILayer_28": {
                "base_class_0": {
                    "value": "tensorflow.keras.layers.Layer",
                    "possible_values": []
                },
                "self.n_nodes": {
                    "value": "n_nodes",
                    "possible_values": [
                        [
                            "[64",
                            "MethodArgument"
                        ],
                        [
                            "[64]",
                            "MethodArgument"
                        ]
                    ]
                },
                "self.kwargs": {
                    "value": "kwargs",
                    "possible_values": []
                }
            },
            "IPLayer_65": {
                "base_class_0": {
                    "value": "tensorflow.keras.layers.Layer",
                    "possible_values": []
                }
            },
            "OutLayer_78": {
                "base_class_0": {
                    "value": "tensorflow.keras.layers.Layer",
                    "possible_values": []
                },
                "self.out_units": {
                    "value": "out_units",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                },
                "Dense_87": {
                    "variable": {
                        "value": "self.out_units",
                        "possible_values": []
                    },
                    "units": {
                        "value": "out_units",
                        "possible_values": [
                            [
                                "1",
                                "MethodArgument"
                            ]
                        ]
                    },
                    "activation": {
                        "value": "None",
                        "possible_values": []
                    },
                    "use_bias": {
                        "value": "False",
                        "possible_values": []
                    },
                    "name": {
                        "value": "noact",
                        "possible_values": []
                    }
                }
            },
            "GCBlock_96": {
                "base_class_0": {
                    "value": "tensorflow.keras.layers.Layer",
                    "possible_values": []
                }
            },
            "ResUpdate_114": {
                "base_class_0": {
                    "value": "tensorflow.keras.layers.Layer",
                    "possible_values": []
                }
            },
            "PreprocessLayer_130": {
                "base_class_0": {
                    "value": "tensorflow.keras.layers.Layer",
                    "possible_values": []
                }
            },
            "PiNet_147": {
                "base_class_0": {
                    "value": "tensorflow.keras.Model",
                    "possible_values": []
                },
                "self.depth": {
                    "value": "depth",
                    "possible_values": [
                        [
                            "4",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "gather_54": {
                "variable": {
                    "value": "prop_i",
                    "possible_values": []
                },
                "params": {
                    "value": "prop",
                    "possible_values": [
                        [
                            "self.ff_layer(prop)",
                            "Call"
                        ],
                        [
                            "self.pp_layer(prop)",
                            "Call"
                        ],
                        [
                            "self.ip_layer([ind_2, inter])",
                            "Call"
                        ],
                        [
                            "self.gc_blocks[i]([tensors['ind_2'], tensors['prop'], basis])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "ind_i",
                    "possible_values": [
                        [
                            "ind_2[:, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "gather_55": {
                "variable": {
                    "value": "prop_j",
                    "possible_values": []
                },
                "params": {
                    "value": "prop",
                    "possible_values": [
                        [
                            "self.ff_layer(prop)",
                            "Call"
                        ],
                        [
                            "self.pp_layer(prop)",
                            "Call"
                        ],
                        [
                            "self.ip_layer([ind_2, inter])",
                            "Call"
                        ],
                        [
                            "self.gc_blocks[i]([tensors['ind_2'], tensors['prop'], basis])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "ind_j",
                    "possible_values": [
                        [
                            "ind_2[:, 1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "concat_57": {
                "variable": {
                    "value": "inter",
                    "possible_values": []
                },
                "values": {
                    "value": "[prop_i, prop_j]",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "reshape_59": {
                "variable": {
                    "value": "inter",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inter",
                    "possible_values": [
                        [
                            "tf.concat([prop_i, prop_j], axis=-1)",
                            "Call"
                        ],
                        [
                            "self.ff_layer(inter)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inter, tf.concat([tf.shape(inter)[:-1], [self.n_nodes[-1], self.n_basis]], 0))",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(inter * basis, axis=-1)",
                            "Call"
                        ],
                        [
                            "self.pi_layer([ind_2, prop, basis])",
                            "Call"
                        ],
                        [
                            "self.ii_layer(inter)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.concat([tf.shape(inter)[:-1], [self.n_nodes[-1], self.n_basis]], 0)",
                    "possible_values": []
                }
            },
            "reduce_sum_61": {
                "variable": {
                    "value": "inter",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inter * basis",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "unsorted_segment_sum_75": {
                "data": {
                    "value": "inter",
                    "possible_values": [
                        [
                            "tf.concat([prop_i, prop_j], axis=-1)",
                            "Call"
                        ],
                        [
                            "self.ff_layer(inter)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inter, tf.concat([tf.shape(inter)[:-1], [self.n_nodes[-1], self.n_basis]], 0))",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(inter * basis, axis=-1)",
                            "Call"
                        ],
                        [
                            "self.pi_layer([ind_2, prop, basis])",
                            "Call"
                        ],
                        [
                            "self.ii_layer(inter)",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "ind_2[:, 0]",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "n_atoms",
                    "possible_values": [
                        [
                            "tf.reduce_max(ind_2) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "Dense_123": {
                "variable": {
                    "value": "self.transform",
                    "possible_values": []
                },
                "units": {
                    "value": "shapes[1][-1]",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "possible_values": []
                }
            },
            "cast_143": {
                "variable": {
                    "value": "tensors[prop]",
                    "possible_values": []
                },
                "x": {
                    "value": "self.embed(tensors['elems'])",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tensors['coord'].dtype",
                    "possible_values": []
                }
            },
            "Dense_20": {
                "units": {
                    "value": "n_node",
                    "possible_values": []
                }
            },
            "concat_59": {
                "values": {
                    "value": "[tf.shape(inter)[:-1], [self.n_nodes[-1], self.n_basis]]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "reduce_max_74": {
                "input_tensor": {
                    "value": "ind_2",
                    "possible_values": []
                }
            },
            "reshape_140": {
                "variable": {
                    "value": "tensors[k]",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tensors[k]",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.shape(tensors[k])[:1]",
                    "possible_values": []
                }
            },
            "shape_60": {
                "input": {
                    "value": "inter",
                    "possible_values": [
                        [
                            "tf.concat([prop_i, prop_j], axis=-1)",
                            "Call"
                        ],
                        [
                            "self.ff_layer(inter)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inter, tf.concat([tf.shape(inter)[:-1], [self.n_nodes[-1], self.n_basis]], 0))",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(inter * basis, axis=-1)",
                            "Call"
                        ],
                        [
                            "self.pi_layer([ind_2, prop, basis])",
                            "Call"
                        ],
                        [
                            "self.ii_layer(inter)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_140": {
                "input": {
                    "value": "tensors[k]",
                    "possible_values": []
                }
            }
        }
    },
    "pinn/optimizers/__init__.py": {
        "tensorflow": {
            "get_24": {
                "identifier": {
                    "value": "optimizer",
                    "possible_values": []
                }
            }
        }
    },
    "pinn/optimizers/ekf.py": {
        "tensorflow": {
            "as_dtype_32": {
                "variable": {
                    "value": "self.inv_dtype",
                    "possible_values": []
                },
                "type_value": {
                    "value": "inv_dtype",
                    "possible_values": [
                        [
                            "'float64'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "concat_38": {
                "variable": {
                    "value": "HT",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.reshape(j, [tf.shape(j)[0], -1]) for j in jacob]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "transpose_39": {
                "variable": {
                    "value": "H",
                    "possible_values": []
                },
                "a": {
                    "value": "HT",
                    "possible_values": [
                        [
                            "tf.concat([tf.reshape(j, [tf.shape(j)[0], -1]) for j in jacob], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_41": {
                "variable": {
                    "value": "n",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "[tf.reduce_prod(var.shape) for var in tvars]",
                    "possible_values": []
                }
            },
            "Variable_45": {
                "variable": {
                    "value": "P",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.eye(n, dtype=H.dtype) / self.epsilon",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "cast_46": {
                "variable": {
                    "value": "t",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.compat.v1.train.get_global_step()",
                    "possible_values": []
                },
                "dtype": {
                    "value": "H.dtype",
                    "possible_values": []
                }
            },
            "minimum_51": {
                "variable": {
                    "value": "lr",
                    "possible_values": []
                },
                "x": {
                    "value": "lr",
                    "possible_values": [
                        [
                            "deserialize(self.learning_rate)(t)",
                            "Call"
                        ],
                        [
                            "tf.cast(self.learning_rate, H.dtype)",
                            "Call"
                        ],
                        [
                            "tf.math.minimum(lr, self.max_learning_rate)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.max_learning_rate",
                    "possible_values": []
                }
            },
            "tensordot_53": {
                "variable": {
                    "value": "PH",
                    "possible_values": []
                },
                "a": {
                    "value": "P",
                    "possible_values": [
                        [
                            "tf.Variable(tf.eye(n, dtype=H.dtype) / self.epsilon, trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "H",
                    "possible_values": [
                        [
                            "tf.transpose(HT)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "lstsq_55": {
                "variable": {
                    "value": "K",
                    "possible_values": []
                },
                "matrix": {
                    "value": "tf.cast(A_inv, self.inv_dtype)",
                    "possible_values": []
                },
                "rhs": {
                    "value": "tf.cast(tf.transpose(PH), self.inv_dtype)",
                    "possible_values": []
                },
                "fast": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "transpose_58": {
                "variable": {
                    "value": "K",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.cast(K, H.dtype)",
                    "possible_values": []
                }
            },
            "tensordot_59": {
                "variable": {
                    "value": "grads",
                    "possible_values": []
                },
                "a": {
                    "value": "K",
                    "possible_values": [
                        [
                            "tf.linalg.lstsq(tf.cast(A_inv, self.inv_dtype), tf.cast(tf.transpose(PH), self.inv_dtype), fast=False)",
                            "Call"
                        ],
                        [
                            "tf.transpose(tf.cast(K, H.dtype))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "error",
                    "possible_values": []
                },
                "axes": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "cumsum_61": {
                "variable": {
                    "value": "idx",
                    "possible_values": []
                },
                "x": {
                    "value": "[0] + lengths",
                    "possible_values": []
                }
            },
            "group_71": {
                "variable": {
                    "value": "train_op",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "ops",
                    "possible_values": [
                        [
                            "[self.iterations.assign_add(1, read_value=False)]",
                            "List"
                        ],
                        [
                            "ops + [var.assign_add(-grad, read_value=False) for (grad, var) in grads_and_vars]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "scalar_43": {
                "name": {
                    "value": "f'KalmanFilter/m'",
                    "possible_values": []
                },
                "data": {
                    "value": "m",
                    "possible_values": [
                        [
                            "tf.shape(H)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scalar_44": {
                "name": {
                    "value": "f'KalmanFilter/n'",
                    "possible_values": []
                },
                "data": {
                    "value": "n",
                    "possible_values": [
                        [
                            "tf.reduce_sum([tf.reduce_prod(var.shape) for var in tvars])",
                            "Call"
                        ]
                    ]
                }
            },
            "histogram_69": {
                "name": {
                    "value": "f'KalmanFilter/P_diag'",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.linalg.diag_part(P)",
                    "possible_values": []
                }
            },
            "histogram_70": {
                "name": {
                    "value": "f'KalmanFilter/P'",
                    "possible_values": []
                },
                "data": {
                    "value": "P",
                    "possible_values": [
                        [
                            "tf.Variable(tf.eye(n, dtype=H.dtype) / self.epsilon, trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_40": {
                "input": {
                    "value": "H",
                    "possible_values": [
                        [
                            "tf.transpose(HT)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_global_step_46": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "cast_50": {
                "variable": {
                    "value": "lr",
                    "possible_values": []
                },
                "x": {
                    "value": "self.learning_rate",
                    "possible_values": []
                },
                "dtype": {
                    "value": "H.dtype",
                    "possible_values": []
                }
            },
            "tensordot_54": {
                "a": {
                    "value": "HT",
                    "possible_values": [
                        [
                            "tf.concat([tf.reshape(j, [tf.shape(j)[0], -1]) for j in jacob], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "PH",
                    "possible_values": [
                        [
                            "tf.tensordot(P, H, 1)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "cast_55": {
                "x": {
                    "value": "A_inv",
                    "possible_values": [
                        [
                            "tf.eye(m, dtype=H.dtype) / lr + tf.tensordot(HT, PH, 1)",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.inv_dtype",
                    "possible_values": []
                }
            },
            "cast_56": {
                "x": {
                    "value": "tf.transpose(PH)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.inv_dtype",
                    "possible_values": []
                }
            },
            "cast_58": {
                "x": {
                    "value": "K",
                    "possible_values": [
                        [
                            "tf.linalg.lstsq(tf.cast(A_inv, self.inv_dtype), tf.cast(tf.transpose(PH), self.inv_dtype), fast=False)",
                            "Call"
                        ],
                        [
                            "tf.transpose(tf.cast(K, H.dtype))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "H.dtype",
                    "possible_values": []
                }
            },
            "reduce_prod_60": {
                "input_tensor": {
                    "value": "var.shape",
                    "possible_values": []
                }
            },
            "eye_62": {
                "num_rows": {
                    "value": "n",
                    "possible_values": [
                        [
                            "tf.reduce_sum([tf.reduce_prod(var.shape) for var in tvars])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "H.dtype",
                    "possible_values": []
                }
            },
            "maximum_62": {
                "x": {
                    "value": "tf.exp(-t / self.q_tau) * self.q_0",
                    "possible_values": []
                },
                "y": {
                    "value": "self.q_min",
                    "possible_values": []
                }
            },
            "reshape_63": {
                "tensor": {
                    "value": "grads[idx[i]:idx[i + 1]]",
                    "possible_values": []
                },
                "shape": {
                    "value": "var.shape",
                    "possible_values": []
                }
            },
            "diag_part_69": {
                "input": {
                    "value": "P",
                    "possible_values": [
                        [
                            "tf.Variable(tf.eye(n, dtype=H.dtype) / self.epsilon, trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_38": {
                "tensor": {
                    "value": "j",
                    "possible_values": []
                },
                "shape": {
                    "value": "[tf.shape(j)[0], -1]",
                    "possible_values": []
                }
            },
            "reduce_prod_42": {
                "input_tensor": {
                    "value": "var.shape",
                    "possible_values": []
                }
            },
            "eye_45": {
                "num_rows": {
                    "value": "n",
                    "possible_values": [
                        [
                            "tf.reduce_sum([tf.reduce_prod(var.shape) for var in tvars])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "H.dtype",
                    "possible_values": []
                }
            },
            "deserialize_48": {
                "name": {
                    "value": "self.learning_rate",
                    "possible_values": []
                }
            },
            "eye_54": {
                "num_rows": {
                    "value": "m",
                    "possible_values": [
                        [
                            "tf.shape(H)[1]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "H.dtype",
                    "possible_values": []
                }
            },
            "transpose_56": {
                "a": {
                    "value": "PH",
                    "possible_values": [
                        [
                            "tf.tensordot(P, H, 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_62": {
                "x": {
                    "value": "-t / self.q_tau",
                    "possible_values": []
                }
            },
            "tensordot_67": {
                "a": {
                    "value": "K",
                    "possible_values": [
                        [
                            "tf.linalg.lstsq(tf.cast(A_inv, self.inv_dtype), tf.cast(tf.transpose(PH), self.inv_dtype), fast=False)",
                            "Call"
                        ],
                        [
                            "tf.transpose(tf.cast(K, H.dtype))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.transpose(PH)",
                    "possible_values": []
                },
                "axes": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "transpose_67": {
                "a": {
                    "value": "PH",
                    "possible_values": [
                        [
                            "tf.tensordot(P, H, 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_38": {
                "input": {
                    "value": "j",
                    "possible_values": []
                }
            }
        }
    },
    "pinn/optimizers/gekf.py": {
        "tensorflow": {
            "as_dtype_27": {
                "variable": {
                    "value": "self.inv_dtype",
                    "possible_values": []
                },
                "type_value": {
                    "value": "inv_dtype",
                    "possible_values": [
                        [
                            "'float64'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reduce_mean_32": {
                "variable": {
                    "value": "l1",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.abs(error)",
                    "possible_values": []
                }
            },
            "reduce_mean_33": {
                "variable": {
                    "value": "l2",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "error ** 2",
                    "possible_values": []
                }
            },
            "gradients_34": {
                "variable": {
                    "value": "g1",
                    "possible_values": []
                },
                "ys": {
                    "value": "l1",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.abs(error))",
                            "Call"
                        ]
                    ]
                },
                "xs": {
                    "value": "tvars",
                    "possible_values": []
                }
            },
            "gradients_35": {
                "variable": {
                    "value": "g2",
                    "possible_values": []
                },
                "ys": {
                    "value": "l2",
                    "possible_values": [
                        [
                            "tf.reduce_mean(error ** 2)",
                            "Call"
                        ]
                    ]
                },
                "xs": {
                    "value": "tvars",
                    "possible_values": []
                }
            },
            "concat_36": {
                "variable": {
                    "value": "g1",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.reshape(g, [-1]) for g in g1]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "concat_37": {
                "variable": {
                    "value": "g2",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.reshape(g, [-1]) for g in g2]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "Variable_39": {
                "variable": {
                    "value": "P",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.eye(n, dtype=g1.dtype) / self.epsilon",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "cast_40": {
                "variable": {
                    "value": "t",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.compat.v1.train.get_global_step()",
                    "possible_values": []
                },
                "dtype": {
                    "value": "g1.dtype",
                    "possible_values": []
                }
            },
            "minimum_45": {
                "variable": {
                    "value": "lr",
                    "possible_values": []
                },
                "x": {
                    "value": "lr",
                    "possible_values": [
                        [
                            "deserialize(self.learning_rate)(t)",
                            "Call"
                        ],
                        [
                            "tf.cast(self.learning_rate, g1.dtype)",
                            "Call"
                        ],
                        [
                            "tf.math.minimum(lr, self.max_learning_rate)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.max_learning_rate",
                    "possible_values": []
                }
            },
            "cumsum_47": {
                "variable": {
                    "value": "idx",
                    "possible_values": []
                },
                "x": {
                    "value": "[0] + lengths",
                    "possible_values": []
                }
            },
            "einsum_48": {
                "variable": {
                    "value": "Pg1",
                    "possible_values": []
                },
                "equation": {
                    "value": "ij,i->j",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "P",
                    "possible_values": [
                        [
                            "tf.Variable(tf.eye(n, dtype=g1.dtype) / self.epsilon, trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "g1",
                    "possible_values": [
                        [
                            "tf.gradients(l1, tvars)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.reshape(g, [-1]) for g in g1], axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "einsum_49": {
                "variable": {
                    "value": "Pg2",
                    "possible_values": []
                },
                "equation": {
                    "value": "ij,i->j",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "P",
                    "possible_values": [
                        [
                            "tf.Variable(tf.eye(n, dtype=g1.dtype) / self.epsilon, trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "g2",
                    "possible_values": [
                        [
                            "tf.gradients(l2, tvars)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.reshape(g, [-1]) for g in g2], axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "einsum_50": {
                "variable": {
                    "value": "g1Pg1",
                    "possible_values": []
                },
                "equation": {
                    "value": "i,i->",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "g1",
                    "possible_values": [
                        [
                            "tf.gradients(l1, tvars)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.reshape(g, [-1]) for g in g1], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "Pg1",
                    "possible_values": [
                        [
                            "tf.einsum('ij,i->j', P, g1)",
                            "Call"
                        ]
                    ]
                }
            },
            "einsum_51": {
                "variable": {
                    "value": "g1Pg2",
                    "possible_values": []
                },
                "equation": {
                    "value": "i,i->",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "g1",
                    "possible_values": [
                        [
                            "tf.gradients(l1, tvars)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.reshape(g, [-1]) for g in g1], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "Pg2",
                    "possible_values": [
                        [
                            "tf.einsum('ij,i->j', P, g2)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_53": {
                "variable": {
                    "value": "k",
                    "possible_values": []
                },
                "x": {
                    "value": "k",
                    "possible_values": [
                        [
                            "tf.cast(Pg1, self.inv_dtype) / tf.cast(1.0 / lr + g1Pg1, self.inv_dtype)",
                            "BinOp"
                        ],
                        [
                            "tf.cast(k, g2.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "g2.dtype",
                    "possible_values": []
                }
            },
            "group_63": {
                "variable": {
                    "value": "train_op",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "ops",
                    "possible_values": [
                        [
                            "[self.iterations.assign_add(1, read_value=False)]",
                            "List"
                        ],
                        [
                            "ops + [var.assign_sub(grad, read_value=False) for (grad, var) in grads_and_vars]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "histogram_61": {
                "name": {
                    "value": "KalmanFilter/P_diag",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.linalg.diag_part(P)",
                    "possible_values": []
                }
            },
            "histogram_62": {
                "name": {
                    "value": "KalmanFilter/P",
                    "possible_values": []
                },
                "data": {
                    "value": "P",
                    "possible_values": [
                        [
                            "tf.Variable(tf.eye(n, dtype=g1.dtype) / self.epsilon, trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "abs_32": {
                "x": {
                    "value": "error",
                    "possible_values": []
                }
            },
            "get_global_step_40": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "cast_44": {
                "variable": {
                    "value": "lr",
                    "possible_values": []
                },
                "x": {
                    "value": "self.learning_rate",
                    "possible_values": []
                },
                "dtype": {
                    "value": "g1.dtype",
                    "possible_values": []
                }
            },
            "reduce_prod_46": {
                "input_tensor": {
                    "value": "var.shape",
                    "possible_values": []
                }
            },
            "cast_52": {
                "x": {
                    "value": "1.0 / lr + g1Pg1",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.inv_dtype",
                    "possible_values": []
                }
            },
            "eye_55": {
                "num_rows": {
                    "value": "n",
                    "possible_values": [
                        [
                            "g1.shape[0]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "g1.dtype",
                    "possible_values": []
                }
            },
            "maximum_55": {
                "x": {
                    "value": "tf.exp(-t / self.q_tau) * self.q_0",
                    "possible_values": []
                },
                "y": {
                    "value": "self.q_min",
                    "possible_values": []
                }
            },
            "reshape_56": {
                "tensor": {
                    "value": "grads[idx[i]:idx[i + 1]]",
                    "possible_values": []
                },
                "shape": {
                    "value": "var.shape",
                    "possible_values": []
                }
            },
            "diag_part_61": {
                "input": {
                    "value": "P",
                    "possible_values": [
                        [
                            "tf.Variable(tf.eye(n, dtype=g1.dtype) / self.epsilon, trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_36": {
                "tensor": {
                    "value": "g",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "possible_values": []
                }
            },
            "reshape_37": {
                "tensor": {
                    "value": "g",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "possible_values": []
                }
            },
            "eye_39": {
                "num_rows": {
                    "value": "n",
                    "possible_values": [
                        [
                            "g1.shape[0]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "g1.dtype",
                    "possible_values": []
                }
            },
            "deserialize_42": {
                "name": {
                    "value": "self.learning_rate",
                    "possible_values": []
                }
            },
            "exp_55": {
                "x": {
                    "value": "-t / self.q_tau",
                    "possible_values": []
                }
            },
            "einsum_59": {
                "equation": {
                    "value": "i,j->ij",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "k",
                    "possible_values": [
                        [
                            "tf.cast(Pg1, self.inv_dtype) / tf.cast(1.0 / lr + g1Pg1, self.inv_dtype)",
                            "BinOp"
                        ],
                        [
                            "tf.cast(k, g2.dtype)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "Pg1",
                    "possible_values": [
                        [
                            "tf.einsum('ij,i->j', P, g1)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "pinn/utils.py": {
        "tensorflow": {
            "zeros_like_79": {
                "variable": {
                    "value": "e_dress",
                    "possible_values": []
                },
                "input": {
                    "value": "elem",
                    "possible_values": [
                        [
                            "tensors['elems']",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "possible_values": [
                        [
                            "tf.float32",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "unsorted_segment_sum_84": {
                "variable": {
                    "value": "e_dress",
                    "possible_values": []
                },
                "data": {
                    "value": "e_dress",
                    "possible_values": [
                        [
                            "tf.zeros_like(elem, dtype)",
                            "Call"
                        ],
                        [
                            "e_dress + indices * tf.cast(val, dtype)",
                            "BinOp"
                        ],
                        [
                            "tf.math.unsorted_segment_sum(e_dress, tensors['ind_1'][:, 0], n_batch)",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "tensors['ind_1'][:, 0]",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "n_batch",
                    "possible_values": [
                        [
                            "tf.reduce_max(tensors['ind_1']) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "_tuneStoper_160": {
                "base_class_0": {
                    "value": "tensorflow.estimator.CheckpointSaverListener",
                    "possible_values": []
                }
            },
            "stack_243": {
                "variable": {
                    "value": "jacob",
                    "possible_values": []
                },
                "values": {
                    "value": "jacob",
                    "possible_values": [
                        [
                            "[tf.gradients(basis[:, i], diff)[0] for i in range(basis.shape[1])]",
                            "ListComp"
                        ],
                        [
                            "tf.stack(jacob, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "possible_values": []
                }
            },
            "cast_81": {
                "variable": {
                    "value": "indices",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(elem, k)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "possible_values": [
                        [
                            "tf.float32",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "unsorted_segment_sum_90": {
                "data": {
                    "value": "tf.ones_like(ind_1, dtype)",
                    "possible_values": []
                },
                "segment_ids": {
                    "value": "ind_1",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "tf.reduce_max(ind_1) + 1",
                    "possible_values": []
                }
            },
            "equal_110": {
                "variable": {
                    "value": "count",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.expand_dims(tensors['elems'], 1)",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.expand_dims(elems, 0)",
                    "possible_values": []
                }
            },
            "cast_112": {
                "variable": {
                    "value": "count",
                    "possible_values": []
                },
                "x": {
                    "value": "count",
                    "possible_values": [
                        [
                            "tf.equal(tf.expand_dims(tensors['elems'], 1), tf.expand_dims(elems, 0))",
                            "Call"
                        ],
                        [
                            "tf.cast(count, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.math.segment_sum(count, tensors['ind_1'][:, 0])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "segment_sum_113": {
                "variable": {
                    "value": "count",
                    "possible_values": []
                },
                "data": {
                    "value": "count",
                    "possible_values": [
                        [
                            "tf.equal(tf.expand_dims(tensors['elems'], 1), tf.expand_dims(elems, 0))",
                            "Call"
                        ],
                        [
                            "tf.cast(count, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.math.segment_sum(count, tensors['ind_1'][:, 0])",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "tensors['ind_1'][:, 0]",
                    "possible_values": []
                }
            },
            "unsorted_segment_sum_225": {
                "variable": {
                    "value": "dcoord",
                    "possible_values": []
                },
                "data": {
                    "value": "ddiff",
                    "possible_values": [
                        [
                            "ddiff.values",
                            "Attribute"
                        ],
                        [
                            "jacob * tf.expand_dims(dbasis, 1)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(ddiff, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "ind[:, 1]",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "natoms",
                    "possible_values": [
                        [
                            "tf.shape(coord)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reduce_sum_256": {
                "variable": {
                    "value": "ddiff",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "ddiff",
                    "possible_values": [
                        [
                            "ddiff.values",
                            "Attribute"
                        ],
                        [
                            "jacob * tf.expand_dims(dbasis, 1)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(ddiff, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "possible_values": []
                }
            },
            "reduce_max_83": {
                "input_tensor": {
                    "value": "tensors['ind_1']",
                    "possible_values": []
                }
            },
            "ones_like_91": {
                "input": {
                    "value": "ind_1",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "possible_values": [
                        [
                            "tf.float32",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "gather_nd_223": {
                "variable": {
                    "value": "ind",
                    "possible_values": []
                },
                "params": {
                    "value": "ind",
                    "possible_values": [
                        [
                            "tf.gather_nd(ind, tf.expand_dims(ddiff.indices, 1))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.expand_dims(ddiff.indices, 1)",
                    "possible_values": []
                }
            },
            "unsorted_segment_sum_226": {
                "data": {
                    "value": "ddiff",
                    "possible_values": [
                        [
                            "ddiff.values",
                            "Attribute"
                        ],
                        [
                            "jacob * tf.expand_dims(dbasis, 1)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(ddiff, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "ind[:, 0]",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "natoms",
                    "possible_values": [
                        [
                            "tf.shape(coord)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "identity_228": {
                "input": {
                    "value": "diff",
                    "possible_values": []
                }
            },
            "identity_236": {
                "input": {
                    "value": "dist",
                    "possible_values": []
                }
            },
            "identity_258": {
                "input": {
                    "value": "basis",
                    "possible_values": []
                }
            },
            "equal_81": {
                "x": {
                    "value": "elem",
                    "possible_values": [
                        [
                            "tensors['elems']",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "k",
                    "possible_values": []
                }
            },
            "cast_82": {
                "x": {
                    "value": "val",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "possible_values": [
                        [
                            "tf.float32",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reduce_max_91": {
                "input_tensor": {
                    "value": "ind_1",
                    "possible_values": []
                }
            },
            "expand_dims_110": {
                "input": {
                    "value": "tensors['elems']",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_111": {
                "input": {
                    "value": "elems",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "list(params['model']['params']['e_dress'].keys())",
                            "Call"
                        ],
                        [
                            "[int(e) for e in elems]",
                            "ListComp"
                        ],
                        [
                            "np.unique(np.concatenate([elems, e]))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "set_verbosity_166": {
                "level": {
                    "value": "tf.logging.ERROR",
                    "possible_values": []
                }
            },
            "shape_220": {
                "input": {
                    "value": "coord",
                    "possible_values": []
                }
            },
            "gradients_241": {
                "ys": {
                    "value": "basis[:, i]",
                    "possible_values": []
                },
                "xs": {
                    "value": "diff",
                    "possible_values": []
                }
            },
            "expand_dims_255": {
                "input": {
                    "value": "dbasis",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "name_scope_135": {
                "name": {
                    "value": "name",
                    "possible_values": [
                        [
                            "default_name",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "expand_dims_223": {
                "input": {
                    "value": "ddiff.indices",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "expand_dims_235": {
                "input": {
                    "value": "ddist / dist",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            }
        }
    },
    "tests/test_bpnn.py": {
        "tensorflow": {
            "constant_99": {
                "value": {
                    "value": "water.positions",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "zeros_like_100": {
                "input": {
                    "value": "water.numbers[:, np.newaxis]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "constant_101": {
                "value": {
                    "value": "water.numbers",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "constant_102": {
                "value": {
                    "value": "water.cell[np.newaxis, :, :]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "GradientTape_106": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "set_seed_108": {
                "seed": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "constant_113": {
                "value": {
                    "value": "water.positions",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "zeros_like_114": {
                "input": {
                    "value": "water.numbers[:, np.newaxis]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "constant_115": {
                "value": {
                    "value": "water.numbers",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "constant_116": {
                "value": {
                    "value": "water.cell[np.newaxis, :, :]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "GradientTape_120": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "set_seed_122": {
                "seed": {
                    "value": "0",
                    "possible_values": []
                }
            }
        }
    },
    "tests/test_io.py": {
        "tensorflow": {}
    },
    "tests/test_misc.py": {
        "tensorflow": {
            "TrainSpec_73": {
                "variable": {
                    "value": "train_spec",
                    "possible_values": []
                },
                "input_fn": {
                    "value": "train",
                    "possible_values": [
                        [
                            "lambda : dataset()['train'].shuffle(100).repeat().apply(sparse_batch(100))",
                            "Lambda"
                        ]
                    ]
                },
                "max_steps": {
                    "value": "200",
                    "possible_values": []
                }
            },
            "EvalSpec_74": {
                "variable": {
                    "value": "eval_spec",
                    "possible_values": []
                },
                "input_fn": {
                    "value": "test",
                    "possible_values": [
                        [
                            "lambda : dataset()['test'].repeat().apply(sparse_batch(100))",
                            "Lambda"
                        ]
                    ]
                },
                "steps": {
                    "value": "10",
                    "possible_values": []
                }
            },
            "train_and_evaluate_75": {
                "estimator": {
                    "value": "model",
                    "possible_values": [
                        [
                            "pinn.get_model(params)",
                            "Call"
                        ]
                    ]
                },
                "train_spec": {
                    "value": "train_spec",
                    "possible_values": [
                        [
                            "tf.estimator.TrainSpec(input_fn=train, max_steps=200)",
                            "Call"
                        ]
                    ]
                },
                "eval_spec": {
                    "value": "eval_spec",
                    "possible_values": [
                        [
                            "tf.estimator.EvalSpec(input_fn=test, steps=10)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_134": {
                "value": {
                    "value": "np.concatenate(ind, axis=0)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "constant_135": {
                "value": {
                    "value": "np.concatenate(coord, axis=0)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "constant_136": {
                "value": {
                    "value": "np.stack(cell, axis=0)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            }
        }
    },
    "tests/test_potential.py": {
        "tensorflow": {
            "TrainSpec_149": {
                "variable": {
                    "value": "train_spec",
                    "possible_values": []
                },
                "input_fn": {
                    "value": "train",
                    "possible_values": []
                },
                "max_steps": {
                    "value": "1000.0",
                    "possible_values": []
                }
            },
            "EvalSpec_150": {
                "variable": {
                    "value": "eval_spec",
                    "possible_values": []
                },
                "input_fn": {
                    "value": "test",
                    "possible_values": []
                },
                "steps": {
                    "value": "100",
                    "possible_values": []
                }
            },
            "train_and_evaluate_153": {
                "variable": {
                    "value": "(results, _)",
                    "possible_values": []
                },
                "estimator": {
                    "value": "model",
                    "possible_values": [
                        [
                            "pinn.get_model(params)",
                            "Call"
                        ]
                    ]
                },
                "train_spec": {
                    "value": "train_spec",
                    "possible_values": [
                        [
                            "tf.estimator.TrainSpec(input_fn=train, max_steps=1000.0)",
                            "Call"
                        ]
                    ]
                },
                "eval_spec": {
                    "value": "eval_spec",
                    "possible_values": [
                        [
                            "tf.estimator.EvalSpec(input_fn=test, steps=100)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    }
}