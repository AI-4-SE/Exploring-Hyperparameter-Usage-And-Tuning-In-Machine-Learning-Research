{
    "data/preprocess/build_dataset.py": {
        "sklearn": {
            "StandardScaler_61": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "data/preprocess/utils.py": {
        "sklearn": {
            "StandardScaler_148": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "StandardScaler_194": {
                "variable": {
                    "value": "static_scaler",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "data/loader.py": {
        "tensorflow": {}
    },
    "data/utils.py": {
        "tensorflow": {}
    },
    "eval/architectures/classifiers.py": {
        "tensorflow": {
            "Input_39": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "embedding_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gin.REQUIRED",
                            "MethodArgument"
                        ],
                        [
                            "gin.REQUIRED",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Input_84": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "embedding_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gin.REQUIRED",
                            "MethodArgument"
                        ],
                        [
                            "gin.REQUIRED",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Constant_62": {
                "variable": {
                    "value": "output_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "bias_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Model_65": {
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Input(embedding_shape)",
                            "Call"
                        ],
                        [
                            "Input(embedding_shape)",
                            "Call"
                        ]
                    ]
                },
                "outputs": {
                    "value": "o",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Dense(nb_class, activation='softmax')(f)",
                            "Call"
                        ],
                        [
                            "Dense(nb_class, activation='softmax', bias_initializer=output_bias)(f)",
                            "Call"
                        ],
                        [
                            "Dense(nb_class, activation='softmax')(x)",
                            "Call"
                        ],
                        [
                            "Dense(nb_class, activation='softmax', bias_initializer=output_bias)(x)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'MLP_classifier'",
                            "MethodArgument"
                        ],
                        [
                            "'Linear_classifier'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Constant_88": {
                "variable": {
                    "value": "output_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "bias_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Model_90": {
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Input(embedding_shape)",
                            "Call"
                        ],
                        [
                            "Input(embedding_shape)",
                            "Call"
                        ]
                    ]
                },
                "outputs": {
                    "value": "o",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Dense(nb_class, activation='softmax')(f)",
                            "Call"
                        ],
                        [
                            "Dense(nb_class, activation='softmax', bias_initializer=output_bias)(f)",
                            "Call"
                        ],
                        [
                            "Dense(nb_class, activation='softmax')(x)",
                            "Call"
                        ],
                        [
                            "Dense(nb_class, activation='softmax', bias_initializer=output_bias)(x)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'MLP_classifier'",
                            "MethodArgument"
                        ],
                        [
                            "'Linear_classifier'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "LayerNormalization_44": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Activation_45": {
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Dense_41": {
                "units": {
                    "value": "inner_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Dense_43": {
                "units": {
                    "value": "embedding_shape[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "Dropout_47": {
                "rate": {
                    "value": "do",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "LayerNormalization_55": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Activation_56": {
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Dense_60": {
                "units": {
                    "value": "nb_class",
                    "type": "variable",
                    "possible_values": [
                        [
                            "10",
                            "MethodArgument"
                        ],
                        [
                            "10",
                            "MethodArgument"
                        ]
                    ]
                },
                "activation": {
                    "value": "softmax",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Dense_63": {
                "units": {
                    "value": "nb_class",
                    "type": "variable",
                    "possible_values": [
                        [
                            "10",
                            "MethodArgument"
                        ],
                        [
                            "10",
                            "MethodArgument"
                        ]
                    ]
                },
                "activation": {
                    "value": "softmax",
                    "type": "str",
                    "possible_values": []
                },
                "bias_initializer": {
                    "value": "output_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.initializers.Constant(bias_init)",
                            "Call"
                        ],
                        [
                            "tf.keras.initializers.Constant(bias_init)",
                            "Call"
                        ]
                    ]
                }
            },
            "Dense_86": {
                "units": {
                    "value": "nb_class",
                    "type": "variable",
                    "possible_values": [
                        [
                            "10",
                            "MethodArgument"
                        ],
                        [
                            "10",
                            "MethodArgument"
                        ]
                    ]
                },
                "activation": {
                    "value": "softmax",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Dense_89": {
                "units": {
                    "value": "nb_class",
                    "type": "variable",
                    "possible_values": [
                        [
                            "10",
                            "MethodArgument"
                        ],
                        [
                            "10",
                            "MethodArgument"
                        ]
                    ]
                },
                "activation": {
                    "value": "softmax",
                    "type": "str",
                    "possible_values": []
                },
                "bias_initializer": {
                    "value": "output_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.initializers.Constant(bias_init)",
                            "Call"
                        ],
                        [
                            "tf.keras.initializers.Constant(bias_init)",
                            "Call"
                        ]
                    ]
                }
            },
            "Dense_52": {
                "units": {
                    "value": "inner_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Dense_54": {
                "units": {
                    "value": "embedding_shape[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "Dropout_58": {
                "rate": {
                    "value": "do",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "MethodArgument"
                        ]
                    ]
                }
            }
        }
    },
    "eval/architectures/losses.py": {
        "tensorflow": {}
    },
    "eval/architectures/utils.py": {
        "tensorflow": {
            "Checkpoint_56": {
                "variable": {
                    "value": "checkpoint_model",
                    "type": "variable",
                    "possible_values": []
                },
                "model": {
                    "value": "ft_model",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gin.query_parameter('eval_task.task').scoped_configurable_fn()",
                            "Call"
                        ]
                    ]
                }
            },
            "CheckpointManager_57": {
                "variable": {
                    "value": "manager",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint": {
                    "value": "checkpoint_model",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.Checkpoint(model=unsupervised_model)",
                            "Call"
                        ],
                        [
                            "tf.train.Checkpoint(model=ft_model)",
                            "Call"
                        ]
                    ]
                },
                "directory": {
                    "value": "checkpoint_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(model_dir, 'tf_checkpoints')",
                            "Call"
                        ],
                        [
                            "os.path.join(model_dir, 'tf_checkpoints')",
                            "Call"
                        ]
                    ]
                },
                "max_to_keep": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Checkpoint_24": {
                "variable": {
                    "value": "checkpoint_model",
                    "type": "variable",
                    "possible_values": []
                },
                "model": {
                    "value": "unsupervised_model",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gin.query_parameter('model.model').scoped_configurable_fn()",
                            "Call"
                        ]
                    ]
                }
            },
            "CheckpointManager_25": {
                "variable": {
                    "value": "manager",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint": {
                    "value": "checkpoint_model",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.Checkpoint(model=unsupervised_model)",
                            "Call"
                        ],
                        [
                            "tf.train.Checkpoint(model=ft_model)",
                            "Call"
                        ]
                    ]
                },
                "directory": {
                    "value": "checkpoint_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(model_dir, 'tf_checkpoints')",
                            "Call"
                        ],
                        [
                            "os.path.join(model_dir, 'tf_checkpoints')",
                            "Call"
                        ]
                    ]
                },
                "max_to_keep": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_88": {
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "eval/down_stream_tasks/add_on_classification.py": {
        "tensorflow": {
            "SparseCategoricalAccuracy_36": {
                "variable": {
                    "value": "self.accuracy",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "AUC_37": {
                "variable": {
                    "value": "self.auc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_thresholds": {
                    "value": "1000",
                    "type": "int",
                    "possible_values": []
                }
            },
            "AUC_38": {
                "variable": {
                    "value": "self.auprc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "curve": {
                    "value": "PR",
                    "type": "str",
                    "possible_values": []
                },
                "num_thresholds": {
                    "value": "1000",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_160": {
                "variable": {
                    "value": "best_val_metric",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "-np.inf",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "SparseCategoricalAccuracy_301": {
                "variable": {
                    "value": "self.accuracy",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "expand_dims_330": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs[-1]",
                            "Subscript"
                        ],
                        [
                            "batch[-1]",
                            "Subscript"
                        ],
                        [
                            "inputs[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ],
                        [
                            "batch[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Bucketize_331": {
                "variable": {
                    "value": "binned_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs[-1]",
                            "Subscript"
                        ],
                        [
                            "batch[-1]",
                            "Subscript"
                        ],
                        [
                            "inputs[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ],
                        [
                            "batch[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "boundaries": {
                    "value": "self.bins",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_359": {
                "variable": {
                    "value": "binned_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.classifier(embeddings, training=training)",
                            "Call"
                        ],
                        [
                            "self.classifier(embeddings, training=training)",
                            "Call"
                        ],
                        [
                            "self.predict(data)",
                            "Call"
                        ],
                        [
                            "self.classifier(embeddings, training=False)",
                            "Call"
                        ],
                        [
                            "self.classifier(embeddings, training=training)",
                            "Call"
                        ],
                        [
                            "self.classifier(embeddings, training=training)",
                            "Call"
                        ],
                        [
                            "self.predict(data)",
                            "Call"
                        ],
                        [
                            "self.classifier(embeddings, training=False)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_416": {
                "variable": {
                    "value": "best_val_metric",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "-np.inf",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_493": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs[-1]",
                            "Subscript"
                        ],
                        [
                            "batch[-1]",
                            "Subscript"
                        ],
                        [
                            "inputs[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ],
                        [
                            "batch[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_495": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs[-1]",
                            "Subscript"
                        ],
                        [
                            "batch[-1]",
                            "Subscript"
                        ],
                        [
                            "inputs[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ],
                        [
                            "batch[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Bucketize_496": {
                "variable": {
                    "value": "binned_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs[-1]",
                            "Subscript"
                        ],
                        [
                            "batch[-1]",
                            "Subscript"
                        ],
                        [
                            "inputs[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ],
                        [
                            "batch[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "boundaries": {
                    "value": "self.bins",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_497": {
                "variable": {
                    "value": "binned_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.classifier(embeddings, training=training)",
                            "Call"
                        ],
                        [
                            "self.classifier(embeddings, training=training)",
                            "Call"
                        ],
                        [
                            "self.predict(data)",
                            "Call"
                        ],
                        [
                            "self.classifier(embeddings, training=False)",
                            "Call"
                        ],
                        [
                            "self.classifier(embeddings, training=training)",
                            "Call"
                        ],
                        [
                            "self.classifier(embeddings, training=training)",
                            "Call"
                        ],
                        [
                            "self.predict(data)",
                            "Call"
                        ],
                        [
                            "self.classifier(embeddings, training=False)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "clip_by_global_norm_87": {
                "variable": {
                    "value": "(grads, global_norm)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "t_list": {
                    "value": "grads",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tape_supervised.gradient(loss_supervised, variables)",
                            "Call"
                        ],
                        [
                            "tape_supervised.gradient(loss_supervised, variables)",
                            "Call"
                        ]
                    ]
                },
                "clip_norm": {
                    "value": "self.grad_clip",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "clip_by_global_norm_350": {
                "variable": {
                    "value": "(grads, global_norm)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "t_list": {
                    "value": "grads",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tape_supervised.gradient(loss_supervised, variables)",
                            "Call"
                        ],
                        [
                            "tape_supervised.gradient(loss_supervised, variables)",
                            "Call"
                        ]
                    ]
                },
                "clip_norm": {
                    "value": "self.grad_clip",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_61": {
                "x": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs[-1]",
                            "Subscript"
                        ],
                        [
                            "batch[-1]",
                            "Subscript"
                        ],
                        [
                            "inputs[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ],
                        [
                            "batch[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GradientTape_69": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "start_167": {
                "logdir": {
                    "value": "ts_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'/'.join(checkpoint_manager.directory.split('/')[:-1] + ['tensorboard'])",
                            "Call"
                        ],
                        [
                            "'/'.join(checkpoint_manager.directory.split('/')[:-1] + ['tensorboard'])",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_209": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_225": {
                "name": {
                    "value": "val_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "-metrics['loss']",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_226": {
                "name": {
                    "value": "val_auc",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "metrics['auroc']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_227": {
                "name": {
                    "value": "val_auprc",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "metrics['auprc']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_228": {
                "name": {
                    "value": "val_accuracy",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "metrics['acc']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GradientTape_337": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_mean_357": {
                "input_tensor": {
                    "value": "self.loss(binned_labels, predictions)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "start_423": {
                "logdir": {
                    "value": "ts_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'/'.join(checkpoint_manager.directory.split('/')[:-1] + ['tensorboard'])",
                            "Call"
                        ],
                        [
                            "'/'.join(checkpoint_manager.directory.split('/')[:-1] + ['tensorboard'])",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_458": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_475": {
                "name": {
                    "value": "val_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "-metrics['loss']",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_62": {
                "x": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs[-1]",
                            "Subscript"
                        ],
                        [
                            "batch[-1]",
                            "Subscript"
                        ],
                        [
                            "inputs[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ],
                        [
                            "batch[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_99": {
                "input_tensor": {
                    "value": "self.loss(tf.expand_dims(labels, axis=-1), predictions[:, 1:], sample_weight=sample_weight)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_103": {
                "input_tensor": {
                    "value": "self.loss(labels, predictions, sample_weight=sample_weight)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_218": {
                "x": {
                    "value": "loss_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[0.5",
                            "MethodArgument"
                        ],
                        [
                            "(0.5",
                            "MethodArgument"
                        ],
                        [
                            "(0.5",
                            "MethodArgument"
                        ],
                        [
                            "(0.5",
                            "MethodArgument"
                        ],
                        [
                            "(0.5",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_340": {
                "input_tensor": {
                    "value": "self.loss(binned_labels, predictions)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_73": {
                "input_tensor": {
                    "value": "self.loss(tf.expand_dims(labels, axis=-1), predictions[:, 1:], sample_weight=sample_weight)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_77": {
                "input_tensor": {
                    "value": "self.loss(labels, predictions, sample_weight=sample_weight)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_175": {
                "x": {
                    "value": "loss_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[0.5",
                            "MethodArgument"
                        ],
                        [
                            "(0.5",
                            "MethodArgument"
                        ],
                        [
                            "(0.5",
                            "MethodArgument"
                        ],
                        [
                            "(0.5",
                            "MethodArgument"
                        ],
                        [
                            "(0.5",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_181": {
                "name": {
                    "value": "train_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "train_loss / validation_frequency",
                    "type": "BinOp",
                    "possible_values": []
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_183": {
                "name": {
                    "value": "train_auc",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "self.auc.result()",
                    "type": "Call",
                    "possible_values": []
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_184": {
                "name": {
                    "value": "train_auprc",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "self.auprc.result()",
                    "type": "Call",
                    "possible_values": []
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_185": {
                "name": {
                    "value": "train_accuracy",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "self.accuracy.result()",
                    "type": "Call",
                    "possible_values": []
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_434": {
                "name": {
                    "value": "train_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "train_loss / validation_frequency",
                    "type": "BinOp",
                    "possible_values": []
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_479": {
                "name": {
                    "value": "'val_' + name",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "metric",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_100": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs[-1]",
                            "Subscript"
                        ],
                        [
                            "batch[-1]",
                            "Subscript"
                        ],
                        [
                            "inputs[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ],
                        [
                            "batch[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "scalar_437": {
                "name": {
                    "value": "'train_' + name",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "metric.result()",
                    "type": "Call",
                    "possible_values": []
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_74": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs[-1]",
                            "Subscript"
                        ],
                        [
                            "batch[-1]",
                            "Subscript"
                        ],
                        [
                            "inputs[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ],
                        [
                            "batch[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "eval/evaluate.py": {
        "tensorflow": {
            "create_file_writer_108": {
                "variable": {
                    "value": "writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "os.path.join(task_dir, 'tensorboard')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Checkpoint_109": {
                "variable": {
                    "value": "checkpoint_model",
                    "type": "variable",
                    "possible_values": []
                },
                "model": {
                    "value": "task",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gin.REQUIRED",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "CheckpointManager_110": {
                "variable": {
                    "value": "manager",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint": {
                    "value": "checkpoint_model",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.Checkpoint(model=task)",
                            "Call"
                        ]
                    ]
                },
                "directory": {
                    "value": "os.path.join(task_dir, 'tf_checkpoints')",
                    "type": "Call",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "set_seed_38": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1234",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "MirroredStrategy_50": {
                "variable": {
                    "value": "strategy",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "isdir_101": {
                "path": {
                    "value": "task_dir",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "rmtree_103": {
                "path": {
                    "value": "task_dir",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cast_163": {
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_189": {
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "main.py": {
        "tensorflow": {
            "experimental_run_functions_eagerly_125": {
                "run_eagerly": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "model/architectures/critics.py": {
        "tensorflow": {
            "set_floatx_6": {
                "value": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Input_20": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(embedding_size,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Model_25": {
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Input((embedding_size,))",
                            "Call"
                        ]
                    ]
                },
                "outputs": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Dense(projection_size, activation='linear')(o)",
                            "Call"
                        ]
                    ]
                }
            },
            "Dense_21": {
                "units": {
                    "value": "projection_size",
                    "type": "variable",
                    "possible_values": []
                },
                "activation": {
                    "value": "linear",
                    "type": "str",
                    "possible_values": []
                }
            },
            "LayerNormalization_22": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Activation_23": {
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Dense_24": {
                "units": {
                    "value": "projection_size",
                    "type": "variable",
                    "possible_values": []
                },
                "activation": {
                    "value": "linear",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "model/architectures/decoders.py": {
        "tensorflow": {
            "Dense_156": {
                "variable": {
                    "value": "self.fs_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "n_filter + n_static",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "split_179": {
                "variable": {
                    "value": "(static, o)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "f",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.fs_layer(x, training=training)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "(self.n_static, self.n_filter)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "name_scope_70": {
                "name": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "name_scope_76": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'deconv1D_{}'.format(k)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_84": {
                "name": {
                    "value": "'norm_{}'.format(k)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Activation_90": {
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "SpatialDropout1D_91": {
                "rate": {
                    "value": "self.dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv1DTranspose_77": {
                "filters": {
                    "value": "self.nb_filters",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "self.kernel_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dilation_rate": {
                    "value": "self.dilation_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding": {
                    "value": "self.padding",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'deconv1D_{}'.format(k)",
                            "Call"
                        ]
                    ]
                },
                "kernel_initializer": {
                    "value": "self.kernel_initializer",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "BatchNormalization_86": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "LayerNormalization_88": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "model/architectures/encoders.py": {
        "tensorflow": {
            "Dropout_42": {
                "variable": {
                    "value": "self.static_DO",
                    "type": "Attribute",
                    "possible_values": []
                },
                "rate": {
                    "value": "static_do",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Dropout_43": {
                "variable": {
                    "value": "self.DO_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "rate": {
                    "value": "do",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "LayerNormalization_44": {
                "variable": {
                    "value": "self.LN",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Dense_49": {
                "variable": {
                    "value": "self.FC_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "self.embedding_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_69": {
                "variable": {
                    "value": "(static, v)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[self.n_static, x.shape[-1] - self.n_static]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_73": {
                "variable": {
                    "value": "o",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[static_doed, o]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_78": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.LN(o, training=training)",
                            "Call"
                        ],
                        [
                            "tf.math.l2_normalize(y, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "model/architectures/losses.py": {
        "tensorflow": {
            "matmul_15": {
                "variable": {
                    "value": "l_pos",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.reshape(q, [N, 1, C])",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "tf.reshape(k, [N, C, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_16": {
                "variable": {
                    "value": "l_pos",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "l_pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.reshape(q, [N, 1, C]), tf.reshape(k, [N, C, 1]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(l_pos, [N, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[N, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_19": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "q",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "tf.transpose(queue)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "range_20": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_logsumexp_22": {
                "variable": {
                    "value": "expectations_marginal_per_sample",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "logits / temperature",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_29": {
                "variable": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.argmax(tf.squeeze(logits), axis=1, output_type=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_60": {
                "variable": {
                    "value": "local_pos",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.reshape(q, [N, 1, C])",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "tf.reshape(k, [N, C, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "range_62": {
                "variable": {
                    "value": "local_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_63": {
                "variable": {
                    "value": "joint_expectation",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "local_pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.reshape(q, [N, 1, C]), tf.reshape(k, [N, C, 1]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(local_pos, [N, 1]) / temperature",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_logsumexp_67": {
                "variable": {
                    "value": "expectations_marginal_per_sample",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(q, tf.transpose(queue))",
                            "Call"
                        ],
                        [
                            "tf.matmul(q, tf.transpose(queue)) / temperature",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_72": {
                "variable": {
                    "value": "number_neigh",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "neighbors_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "neigh_func(n_l, n_labels_queues)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_74": {
                "variable": {
                    "value": "aggregation_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "expectations_marginal_per_sample - neighbors_expectation",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_77": {
                "variable": {
                    "value": "expectations_neighborhood_per_sample",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(tf.math.exp(logits) * neighbors_mask, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_80": {
                "variable": {
                    "value": "disc_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "n_X_ent_per_sample",
                    "type": "variable",
                    "possible_values": [
                        [
                            "expectations_neighborhood_per_sample - joint_expectation",
                            "BinOp"
                        ]
                    ]
                }
            },
            "transpose_85": {
                "variable": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.argmax(tf.squeeze(logits), axis=1, output_type=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_87": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(tf.expand_dims(correct_preds, axis=0), tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "split_108": {
                "variable": {
                    "value": "(a_n, a_t)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.tile(tf.reshape(samples, (N, 1, -1)), (1, K, 1))",
                    "type": "Call",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "split_109": {
                "variable": {
                    "value": "(b_n, b_t)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.tile(tf.reshape(queue, (1, K, -1)), (N, 1, 1))",
                    "type": "Call",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "abs_111": {
                "variable": {
                    "value": "t_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "a_t - b_t",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "logical_and_112": {
                "variable": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "t_n == 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "t_t <= threshold",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "tile_129": {
                "variable": {
                    "value": "a_n",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(samples, (N, 1, -1))",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "(1, K, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "tile_130": {
                "variable": {
                    "value": "b_n",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(queue, (1, K, -1))",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "(N, 1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "split_149": {
                "variable": {
                    "value": "(samples_dt, samples_patient)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "split_150": {
                "variable": {
                    "value": "(queue_dt, queue_patient)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "queue",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_113": {
                "x": {
                    "value": "c[:, :, 0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_133": {
                "x": {
                    "value": "c >= 1",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_10": {
                "input": {
                    "value": "q",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_11": {
                "input": {
                    "value": "queue",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reshape_15": {
                "tensor": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": [
                        [
                            "queue[:N]",
                            "Subscript"
                        ],
                        [
                            "queue[:N]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "[N, C, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_19": {
                "a": {
                    "value": "queue",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_sum_23": {
                "input_tensor": {
                    "value": "l_pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.reshape(q, [N, 1, C]), tf.reshape(k, [N, C, 1]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(l_pos, [N, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_26": {
                "input_tensor": {
                    "value": "X_ent_per_sample",
                    "type": "variable",
                    "possible_values": [
                        [
                            "joint_expectation - expectations_marginal_per_sample",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_29": {
                "input": {
                    "value": "tf.squeeze(logits)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_31": {
                "input_tensor": {
                    "value": "tf.cast(tf.expand_dims(correct_preds, axis=0), tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_54": {
                "input": {
                    "value": "q",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_55": {
                "input": {
                    "value": "queue",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reshape_60": {
                "tensor": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": [
                        [
                            "queue[:N]",
                            "Subscript"
                        ],
                        [
                            "queue[:N]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "[N, C, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_61": {
                "tensor": {
                    "value": "local_pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.reshape(q, [N, 1, C]), tf.reshape(k, [N, C, 1]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(local_pos, [N, 1]) / temperature",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[N, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_66": {
                "a": {
                    "value": "q",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "tf.transpose(queue)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_73": {
                "input_tensor": {
                    "value": "logits * neighbors_mask",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_78": {
                "input_tensor": {
                    "value": "tf.math.exp(logits) * neighbors_mask",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_85": {
                "input": {
                    "value": "tf.squeeze(logits)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_87": {
                "x": {
                    "value": "tf.expand_dims(correct_preds, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_108": {
                "input": {
                    "value": "tf.reshape(samples, (N, 1, -1))",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "(1, K, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "tile_109": {
                "input": {
                    "value": "tf.reshape(queue, (1, K, -1))",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "(N, 1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_129": {
                "tensor": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(N, 1, -1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_130": {
                "tensor": {
                    "value": "queue",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, K, -1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "diag_132": {
                "diagonal": {
                    "value": "tf.ones(N)",
                    "type": "Call",
                    "possible_values": []
                },
                "num_rows": {
                    "value": "N",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(q)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(q)[0]",
                            "Subscript"
                        ],
                        [
                            "samples.shape[0]",
                            "Subscript"
                        ],
                        [
                            "samples.shape[0]",
                            "Subscript"
                        ]
                    ]
                },
                "num_cols": {
                    "value": "K",
                    "type": "variable",
                    "possible_values": [
                        [
                            "queue.shape[0]",
                            "Subscript"
                        ],
                        [
                            "queue.shape[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "squeeze_29": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(q, tf.transpose(queue))",
                            "Call"
                        ],
                        [
                            "tf.matmul(q, tf.transpose(queue)) / temperature",
                            "BinOp"
                        ]
                    ]
                }
            },
            "cast_31": {
                "x": {
                    "value": "tf.expand_dims(correct_preds, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "transpose_66": {
                "a": {
                    "value": "queue",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "squeeze_85": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(q, tf.transpose(queue))",
                            "Call"
                        ],
                        [
                            "tf.matmul(q, tf.transpose(queue)) / temperature",
                            "BinOp"
                        ]
                    ]
                }
            },
            "expand_dims_87": {
                "input": {
                    "value": "correct_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "preds == labels",
                            "Compare"
                        ],
                        [
                            "preds == local_labels",
                            "Compare"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_108": {
                "tensor": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(N, 1, -1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_109": {
                "tensor": {
                    "value": "queue",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, K, -1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "cast_132": {
                "x": {
                    "value": "t_n == 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_132": {
                "shape": {
                    "value": "N",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(q)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(q)[0]",
                            "Subscript"
                        ],
                        [
                            "samples.shape[0]",
                            "Subscript"
                        ],
                        [
                            "samples.shape[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "cast_156": {
                "x": {
                    "value": "neigh_patient + neigh_dt >= 1",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_31": {
                "input": {
                    "value": "correct_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "preds == labels",
                            "Compare"
                        ],
                        [
                            "preds == local_labels",
                            "Compare"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_78": {
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(q, tf.transpose(queue))",
                            "Call"
                        ],
                        [
                            "tf.matmul(q, tf.transpose(queue)) / temperature",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "model/architectures/optimizers.py": {
        "tensorflow": {
            "CosineDecay_31": {
                "variable": {
                    "value": "self.cosine_decay",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_learning_rate": {
                    "value": "self.warm_learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "decay_steps": {
                    "value": "self.decay_steps",
                    "type": "Attribute",
                    "possible_values": []
                },
                "alpha": {
                    "value": "self.alpha",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "function_33": {
                "experimental_relax_shapes": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "name_scope_35": {
                "name": {
                    "value": "self.name or 'LinearWarmupCosineDecay'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "convert_to_tensor_37": {
                "variable": {
                    "value": "initial_learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self.initial_learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "initial_learning_rate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_40": {
                "variable": {
                    "value": "rate",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "initial_learning_rate.dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "cast_42": {
                "variable": {
                    "value": "global_step_recomp",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "initial_learning_rate.dtype",
                            "Attribute"
                        ]
                    ]
                }
            }
        }
    },
    "model/architectures/tests/losses_test.py": {
        "tensorflow": {
            "eye_11": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "num_rows": {
                    "value": "100",
                    "type": "int",
                    "possible_values": []
                }
            },
            "uniform_12": {
                "variable": {
                    "value": "neigh_queue",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(500, 2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "1000.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "concat_13": {
                "variable": {
                    "value": "queue",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[samples, tf.zeros((400, 100))]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "main_42": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "concat_27": {
                "values": {
                    "value": "[samples, queue]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_28": {
                "values": {
                    "value": "[samples, samples]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "eye_29": {
                "num_rows": {
                    "value": "100",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_30": {
                "input_tensor": {
                    "value": "neigh_mat_double",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_neighbors_mask_temporal(samples, tf.concat([samples, samples], axis=0), threshold)",
                            "Call"
                        ],
                        [
                            "get_neighbors_dt_label_multiclass(samples, tf.concat([samples, samples], axis=0))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_24": {
                "values": {
                    "value": "[tf.range(100) + 1, -tf.range(100) - 1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_25": {
                "values": {
                    "value": "[-tf.range(400) - 1, tf.range(400) + 1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_35": {
                "values": {
                    "value": "[samples, queue]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_36": {
                "values": {
                    "value": "[samples, samples]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "eye_37": {
                "num_rows": {
                    "value": "100",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_38": {
                "input_tensor": {
                    "value": "neigh_mat_double",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_neighbors_mask_temporal(samples, tf.concat([samples, samples], axis=0), threshold)",
                            "Call"
                        ],
                        [
                            "get_neighbors_dt_label_multiclass(samples, tf.concat([samples, samples], axis=0))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "uniform_33": {
                "shape": {
                    "value": "(400, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "minval": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "1000.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "zeros_13": {
                "shape": {
                    "value": "(400, 100)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "ones_30": {
                "shape": {
                    "value": "(100,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "ones_38": {
                "shape": {
                    "value": "(100,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            }
        }
    },
    "model/architectures/tests/transformations_test.py": {
        "tensorflow": {
            "ones_18": {
                "variable": {
                    "value": "batch",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(2, 48, 41)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "ones_34": {
                "variable": {
                    "value": "batch",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, 1000, 40)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "ones_48": {
                "variable": {
                    "value": "batch",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, 48, 41)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "zeros_52": {
                "variable": {
                    "value": "batch_zeros",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(50, 48, 41)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "ones_60": {
                "variable": {
                    "value": "batch",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, 1000, 10)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "ones_66": {
                "variable": {
                    "value": "batch",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(2, 48, 41)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "main_74": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_sum_62": {
                "input_tensor": {
                    "value": "cutout_seq",
                    "type": "variable",
                    "possible_values": [
                        [
                            "history_cutout(batch, tf_generator, size)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_25": {
                "input_tensor": {
                    "value": "dropped_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "spatial_dropout(batch, tf_generator, rate)",
                            "Call"
                        ],
                        [
                            "spatial_dropout(batch, tf_generator, rate)",
                            "Call"
                        ]
                    ]
                }
            },
            "is_nan_12": {
                "x": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_sum_21": {
                "input_tensor": {
                    "value": "dropped_out[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "model/architectures/transformations.py": {
        "tensorflow": {
            "cast_18": {
                "variable": {
                    "value": "noise_1d_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf_random_generator.uniform(noise_shape) > rate",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_19": {
                "variable": {
                    "value": "noise_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "noise_1d_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf_random_generator.uniform(noise_shape) > rate, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "(1, temporal_sequence.shape[1], 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "cast_36": {
                "variable": {
                    "value": "padding_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "temporal_sequence != 0.0",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_37": {
                "variable": {
                    "value": "bias_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[temporal_sequence.shape[:-2], [1], [temporal_sequence.shape[-1]]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "where_58": {
                "variable": {
                    "value": "tmp_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "padding_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(temporal_sequence != 0.0, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(temporal_sequence, axis=-1) != padding_value",
                            "Compare"
                        ]
                    ]
                }
            },
            "cast_59": {
                "variable": {
                    "value": "padding_size",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.math.segment_min(tmp_indices[:, 1], tmp_indices[:, 0]) / SEQ_LENGTH",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_60": {
                "variable": {
                    "value": "padding_size",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "padding_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.math.segment_min(tmp_indices[:, 1], tmp_indices[:, 0]) / SEQ_LENGTH, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(padding_size, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_65": {
                "variable": {
                    "value": "boxes_start",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "(boxes_start * (1 - padding_size) * (1 - min_history) + padding_size) * SEQ_LENGTH",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_66": {
                "variable": {
                    "value": "boxes_start",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "boxes_start",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_random_generator.uniform(shape=(NUM_SEQ, 1))",
                            "Call"
                        ],
                        [
                            "tf.cast((boxes_start * (1 - padding_size) * (1 - min_history) + padding_size) * SEQ_LENGTH, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(boxes_start, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf_random_generator.uniform(shape=(NUM_SEQ, 1), minval=0, maxval=1 - relative_size - 1 / SEQ_LENGTH)",
                            "Call"
                        ],
                        [
                            "tf.cast(boxes_start * SEQ_LENGTH, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(boxes_start, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_72": {
                "variable": {
                    "value": "random_selection",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.cast(tf_random_generator.uniform(shape=(NUM_SEQ,)) < p, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, 1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "cast_91": {
                "variable": {
                    "value": "size",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(size, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "4",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_93": {
                "variable": {
                    "value": "relative_size",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "size / SEQ_LENGTH",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_97": {
                "variable": {
                    "value": "boxes_start",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "boxes_start * SEQ_LENGTH",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_98": {
                "variable": {
                    "value": "boxes_start",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "boxes_start",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_random_generator.uniform(shape=(NUM_SEQ, 1))",
                            "Call"
                        ],
                        [
                            "tf.cast((boxes_start * (1 - padding_size) * (1 - min_history) + padding_size) * SEQ_LENGTH, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(boxes_start, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf_random_generator.uniform(shape=(NUM_SEQ, 1), minval=0, maxval=1 - relative_size - 1 / SEQ_LENGTH)",
                            "Call"
                        ],
                        [
                            "tf.cast(boxes_start * SEQ_LENGTH, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(boxes_start, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_100": {
                "variable": {
                    "value": "cropping_mask_pre",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.tile(tf.reshape(tf.range(SEQ_LENGTH, dtype=tf.int32), (1, SEQ_LENGTH, 1)), (NUM_SEQ, 1, 1)) < boxes_start",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_102": {
                "variable": {
                    "value": "cropping_mask_post",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.tile(tf.reshape(tf.range(SEQ_LENGTH, dtype=tf.int32), (1, SEQ_LENGTH, 1)), (NUM_SEQ, 1, 1)) >= boxes_start + size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_106": {
                "variable": {
                    "value": "random_selection",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.cast(tf_random_generator.uniform(shape=(NUM_SEQ,)) < p, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, 1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reduce_mean_57": {
                "input_tensor": {
                    "value": "temporal_sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_69": {
                "input": {
                    "value": "tf.reshape(tf.range(SEQ_LENGTH, dtype=tf.int32), (1, SEQ_LENGTH, 1))",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "(NUM_SEQ, 1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "cast_72": {
                "x": {
                    "value": "tf_random_generator.uniform(shape=(NUM_SEQ,)) < p",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_106": {
                "x": {
                    "value": "tf_random_generator.uniform(shape=(NUM_SEQ,)) < p",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "segment_min_59": {
                "data": {
                    "value": "tmp_indices[:, 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "segment_ids": {
                    "value": "tmp_indices[:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reshape_69": {
                "tensor": {
                    "value": "tf.range(SEQ_LENGTH, dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, SEQ_LENGTH, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "tile_100": {
                "input": {
                    "value": "tf.reshape(tf.range(SEQ_LENGTH, dtype=tf.int32), (1, SEQ_LENGTH, 1))",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "(NUM_SEQ, 1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "tile_102": {
                "input": {
                    "value": "tf.reshape(tf.range(SEQ_LENGTH, dtype=tf.int32), (1, SEQ_LENGTH, 1))",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "(NUM_SEQ, 1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "range_69": {
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_74": {
                "x": {
                    "value": "cropping_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(tf.range(SEQ_LENGTH, dtype=tf.int32), (1, SEQ_LENGTH, 1)), (NUM_SEQ, 1, 1)) >= boxes_start",
                            "Compare"
                        ],
                        [
                            "cropping_mask_pre + cropping_mask_post",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_100": {
                "tensor": {
                    "value": "tf.range(SEQ_LENGTH, dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, SEQ_LENGTH, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_102": {
                "tensor": {
                    "value": "tf.range(SEQ_LENGTH, dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, SEQ_LENGTH, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "cast_108": {
                "x": {
                    "value": "cropping_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(tf.range(SEQ_LENGTH, dtype=tf.int32), (1, SEQ_LENGTH, 1)), (NUM_SEQ, 1, 1)) >= boxes_start",
                            "Compare"
                        ],
                        [
                            "cropping_mask_pre + cropping_mask_post",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "range_100": {
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "range_102": {
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "model/methods/self_supervised.py": {
        "tensorflow": {
            "MeanSquaredError_22": {
                "variable": {
                    "value": "self.loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "split_68": {
                "variable": {
                    "value": "(true_static_reconstructions, true_variable_reconstructions)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "true_reconstrutions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "(self.decoder.n_static, true_reconstrutions.shape[-1] - self.decoder.n_static)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "scalar_156": {
                "name": {
                    "value": "Negative Loss Val",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "-tot_loss",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_63": {
                "variable": {
                    "value": "(seq, true_reconstrutions)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data_iterator.next()",
                            "Call"
                        ],
                        [
                            "data_iterator.next()",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "[seq_length - self.forcast_horizon, self.forcast_horizon]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_79": {
                "variable": {
                    "value": "embeddings",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.encoder(x_1, training=training)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(embeddings, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "GradientTape_77": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_133": {
                "name": {
                    "value": "Negative Loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "-loss",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "model/methods/semi_supervised.py": {
        "tensorflow": {
            "l2_normalize_36": {
                "variable": {
                    "value": "self.embedding_queue",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.random.uniform((self.queue_size, self.projection_size), -1, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_39": {
                "variable": {
                    "value": "self.labels_queue",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.random.uniform((self.queue_size, label_size), 0, 100, dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_42": {
                "variable": {
                    "value": "self.labels_queue",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.random.uniform((self.queue_size,), 50, 100, dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "l2_normalize_93": {
                "variable": {
                    "value": "new_keys_2",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.momentum_projector(mum_features_2, training=training)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "l2_normalize_95": {
                "variable": {
                    "value": "new_keys_1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.momentum_projector(mum_features_1, training=training)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_99": {
                "variable": {
                    "value": "concat_1",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[new_keys_1, queue]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_100": {
                "variable": {
                    "value": "concat_2",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[new_keys_2, queue]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_102": {
                "variable": {
                    "value": "labels_concat",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[n_labels, n_queue]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "scalar_276": {
                "name": {
                    "value": "Negative Loss Val",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "-tot_loss",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_277": {
                "name": {
                    "value": "Negative Aggregation Loss Val",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "-tot_aggregation_term",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_279": {
                "name": {
                    "value": "Negative Local Loss Val",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "-tot_local_term",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_281": {
                "name": {
                    "value": "Contrastive Accuracy Val",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tot_local_acc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tot_local_acc + local_acc",
                            "BinOp"
                        ]
                    ]
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "uniform_36": {
                "shape": {
                    "value": "(self.queue_size, self.projection_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "minval": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_108": {
                "variable": {
                    "value": "projections_1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.projector(embeddings_1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "l2_normalize_109": {
                "variable": {
                    "value": "projections_2",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.projector(embeddings_2)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_151": {
                "variable": {
                    "value": "new_keys",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "sub_new_keys.values",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_152": {
                "variable": {
                    "value": "new_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "n_labels.values",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_221": {
                "variable": {
                    "value": "new_queue",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[new_keys, self.embedding_queue]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_226": {
                "variable": {
                    "value": "new_labels_queue",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[new_n_labels, self.labels_queue]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "uniform_39": {
                "shape": {
                    "value": "(self.queue_size, label_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "100",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "uniform_42": {
                "shape": {
                    "value": "(self.queue_size,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "minval": {
                    "value": "50",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "100",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GradientTape_105": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_213": {
                "name": {
                    "value": "Negative Loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "-loss",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_214": {
                "name": {
                    "value": "Negative Aggregation Loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "-aggregation_term",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_216": {
                "name": {
                    "value": "Negative Local Loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "-local_term",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_218": {
                "name": {
                    "value": "Contrastive Accuracy",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "local_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "self.optimizer.iterations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_247": {
                "variable": {
                    "value": "binned_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(tf.cast(tf.raw_ops.Bucketize(input=binned_labels[:, :1], boundaries=self.labels_bin), dtype=tf.float32), binned_labels[:, 1:])",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_251": {
                "variable": {
                    "value": "binned_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.raw_ops.Bucketize(input=binned_labels, boundaries=self.labels_bin)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_199": {
                "variable": {
                    "value": "binned_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(tf.cast(tf.raw_ops.Bucketize(input=binned_labels[:, :1], boundaries=self.labels_bin), dtype=tf.float32), binned_labels[:, 1:])",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_203": {
                "variable": {
                    "value": "binned_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.raw_ops.Bucketize(input=binned_labels, boundaries=self.labels_bin)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Bucketize_251": {
                "input": {
                    "value": "binned_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs[1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat((tf.cast(tf.raw_ops.Bucketize(input=binned_labels[:, :1], boundaries=self.labels_bin), dtype=tf.float32), binned_labels[:, 1:]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.raw_ops.Bucketize(input=binned_labels, boundaries=self.labels_bin), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "inputs[1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat((tf.cast(tf.raw_ops.Bucketize(input=binned_labels[:, :1], boundaries=self.labels_bin), dtype=tf.float32), binned_labels[:, 1:]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.raw_ops.Bucketize(input=binned_labels, boundaries=self.labels_bin), dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "boundaries": {
                    "value": "self.labels_bin",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Bucketize_203": {
                "input": {
                    "value": "binned_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs[1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat((tf.cast(tf.raw_ops.Bucketize(input=binned_labels[:, :1], boundaries=self.labels_bin), dtype=tf.float32), binned_labels[:, 1:]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.raw_ops.Bucketize(input=binned_labels, boundaries=self.labels_bin), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "inputs[1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat((tf.cast(tf.raw_ops.Bucketize(input=binned_labels[:, :1], boundaries=self.labels_bin), dtype=tf.float32), binned_labels[:, 1:]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.raw_ops.Bucketize(input=binned_labels, boundaries=self.labels_bin), dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "boundaries": {
                    "value": "self.labels_bin",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_247": {
                "x": {
                    "value": "tf.raw_ops.Bucketize(input=binned_labels[:, :1], boundaries=self.labels_bin)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_199": {
                "x": {
                    "value": "tf.raw_ops.Bucketize(input=binned_labels[:, :1], boundaries=self.labels_bin)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Bucketize_248": {
                "input": {
                    "value": "binned_labels[:, :1]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "inputs[1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat((tf.cast(tf.raw_ops.Bucketize(input=binned_labels[:, :1], boundaries=self.labels_bin), dtype=tf.float32), binned_labels[:, 1:]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.raw_ops.Bucketize(input=binned_labels, boundaries=self.labels_bin), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "inputs[1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat((tf.cast(tf.raw_ops.Bucketize(input=binned_labels[:, :1], boundaries=self.labels_bin), dtype=tf.float32), binned_labels[:, 1:]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.raw_ops.Bucketize(input=binned_labels, boundaries=self.labels_bin), dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "boundaries": {
                    "value": "self.labels_bin",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Bucketize_200": {
                "input": {
                    "value": "binned_labels[:, :1]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "inputs[1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat((tf.cast(tf.raw_ops.Bucketize(input=binned_labels[:, :1], boundaries=self.labels_bin), dtype=tf.float32), binned_labels[:, 1:]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.raw_ops.Bucketize(input=binned_labels, boundaries=self.labels_bin), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "inputs[1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat((tf.cast(tf.raw_ops.Bucketize(input=binned_labels[:, :1], boundaries=self.labels_bin), dtype=tf.float32), binned_labels[:, 1:]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.raw_ops.Bucketize(input=binned_labels, boundaries=self.labels_bin), dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "boundaries": {
                    "value": "self.labels_bin",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "model/train.py": {
        "tensorflow": {
            "create_file_writer_100": {
                "variable": {
                    "value": "writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "os.path.join(model_dir, 'tensorboard')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Checkpoint_101": {
                "variable": {
                    "value": "checkpoint_model",
                    "type": "variable",
                    "possible_values": []
                },
                "model": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gin.REQUIRED",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "CheckpointManager_102": {
                "variable": {
                    "value": "manager",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint": {
                    "value": "checkpoint_model",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.Checkpoint(model=model)",
                            "Call"
                        ]
                    ]
                },
                "directory": {
                    "value": "os.path.join(model_dir, 'tf_checkpoints')",
                    "type": "Call",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "set_seed_37": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1234",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "MirroredStrategy_47": {
                "variable": {
                    "value": "strategy",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "isdir_91": {
                "path": {
                    "value": "model_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "rmtree_93": {
                "path": {
                    "value": "model_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            }
        }
    }
}