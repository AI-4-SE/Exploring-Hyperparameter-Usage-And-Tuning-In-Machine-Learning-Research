{
    "example_selection/modules/LFI.py": {
        "sklearn": {},
        "tensorflow": {
            "load_model_168": {
                "variable": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": []
                },
                "filepath": {
                    "value": "'{}'.format(NN_dir) + '/model{}_NN.json'.format(i)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "load_model_142": {
                "variable": {
                    "value": "globals()[model_%s % i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "filepath": {
                    "value": "'{}'.format(NN_dir) + '/model{}_NN.json'.format(i)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "RandomNormal_330": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                },
                "seed": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            }
        }
    },
    "example_selection/modules/NN.py": {
        "sklearn": {},
        "tensorflow": {
            "he_normal_172": {
                "variable": {
                    "value": "he_ini",
                    "type": "variable",
                    "possible_values": []
                },
                "seed": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "Sequential_149": {
                "variable": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": []
                },
                "layers": {
                    "value": "[tf.keras.Input(shape=(train_X.shape[1],)), tf.keras.layers.Dense(128, kernel_initializer=he_ini), tf.keras.layers.LeakyReLU(alpha=0.1), tf.keras.layers.Dense(128, kernel_initializer=he_ini), tf.keras.layers.LeakyReLU(alpha=0.1), tf.keras.layers.Dense(train_Y.shape[1])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Sequential_160": {
                "variable": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": []
                },
                "layers": {
                    "value": "[tf.keras.Input(shape=(train_X.shape[1],)), tf.keras.layers.Dense(128, kernel_initializer=he_ini, kernel_regularizer=tf.keras.regularizers.l1(l1)), tf.keras.layers.LeakyReLU(alpha=0.1), tf.keras.layers.Dense(128, kernel_initializer=he_ini, kernel_regularizer=tf.keras.regularizers.l1(l1)), tf.keras.layers.LeakyReLU(alpha=0.1), tf.keras.layers.Dense(train_Y.shape[1])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "EarlyStopping_184": {
                "patience": {
                    "value": "50",
                    "type": "int",
                    "possible_values": []
                },
                "verbose": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "restore_best_weights": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Adam_180": {
                "learning_rate": {
                    "value": "learning_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lr",
                            "Name"
                        ]
                    ]
                }
            },
            "Input_150": {
                "shape": {
                    "value": "(train_X.shape[1],)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Dense_151": {
                "units": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "he_ini",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.initializers.he_normal(seed=None)",
                            "Call"
                        ]
                    ]
                }
            },
            "LeakyReLU_152": {
                "alpha": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dense_153": {
                "units": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "he_ini",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.initializers.he_normal(seed=None)",
                            "Call"
                        ]
                    ]
                }
            },
            "LeakyReLU_154": {
                "alpha": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dense_155": {
                "units": {
                    "value": "train_Y.shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "Input_161": {
                "shape": {
                    "value": "(train_X.shape[1],)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Dense_162": {
                "units": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "he_ini",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.initializers.he_normal(seed=None)",
                            "Call"
                        ]
                    ]
                },
                "kernel_regularizer": {
                    "value": "tf.keras.regularizers.l1(l1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "LeakyReLU_163": {
                "alpha": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dense_164": {
                "units": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "he_ini",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.initializers.he_normal(seed=None)",
                            "Call"
                        ]
                    ]
                },
                "kernel_regularizer": {
                    "value": "tf.keras.regularizers.l1(l1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "LeakyReLU_165": {
                "alpha": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dense_166": {
                "units": {
                    "value": "train_Y.shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "example_selection/modules/simulator.py": {
        "sklearn": {}
    },
    "modules/LFI.py": {
        "sklearn": {},
        "tensorflow": {
            "load_model_168": {
                "variable": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": []
                },
                "filepath": {
                    "value": "'{}'.format(NN_dir) + '/model{}_NN.json'.format(i)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "load_model_142": {
                "variable": {
                    "value": "globals()[model_%s % i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "filepath": {
                    "value": "'{}'.format(NN_dir) + '/model{}_NN.json'.format(i)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "RandomNormal_330": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                },
                "seed": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            }
        }
    },
    "modules/NN.py": {
        "sklearn": {},
        "tensorflow": {
            "he_normal_172": {
                "variable": {
                    "value": "he_ini",
                    "type": "variable",
                    "possible_values": []
                },
                "seed": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "Sequential_149": {
                "variable": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": []
                },
                "layers": {
                    "value": "[tf.keras.Input(shape=(train_X.shape[1],)), tf.keras.layers.Dense(128, kernel_initializer=he_ini), tf.keras.layers.LeakyReLU(alpha=0.1), tf.keras.layers.Dense(128, kernel_initializer=he_ini), tf.keras.layers.LeakyReLU(alpha=0.1), tf.keras.layers.Dense(train_Y.shape[1])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Sequential_160": {
                "variable": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": []
                },
                "layers": {
                    "value": "[tf.keras.Input(shape=(train_X.shape[1],)), tf.keras.layers.Dense(128, kernel_initializer=he_ini, kernel_regularizer=tf.keras.regularizers.l1(l1)), tf.keras.layers.LeakyReLU(alpha=0.1), tf.keras.layers.Dense(128, kernel_initializer=he_ini, kernel_regularizer=tf.keras.regularizers.l1(l1)), tf.keras.layers.LeakyReLU(alpha=0.1), tf.keras.layers.Dense(train_Y.shape[1])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "EarlyStopping_184": {
                "patience": {
                    "value": "50",
                    "type": "int",
                    "possible_values": []
                },
                "verbose": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "restore_best_weights": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Adam_180": {
                "learning_rate": {
                    "value": "learning_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lr",
                            "Name"
                        ]
                    ]
                }
            },
            "Input_150": {
                "shape": {
                    "value": "(train_X.shape[1],)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Dense_151": {
                "units": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "he_ini",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.initializers.he_normal(seed=None)",
                            "Call"
                        ]
                    ]
                }
            },
            "LeakyReLU_152": {
                "alpha": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dense_153": {
                "units": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "he_ini",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.initializers.he_normal(seed=None)",
                            "Call"
                        ]
                    ]
                }
            },
            "LeakyReLU_154": {
                "alpha": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dense_155": {
                "units": {
                    "value": "train_Y.shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "Input_161": {
                "shape": {
                    "value": "(train_X.shape[1],)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Dense_162": {
                "units": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "he_ini",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.initializers.he_normal(seed=None)",
                            "Call"
                        ]
                    ]
                },
                "kernel_regularizer": {
                    "value": "tf.keras.regularizers.l1(l1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "LeakyReLU_163": {
                "alpha": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dense_164": {
                "units": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "he_ini",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.initializers.he_normal(seed=None)",
                            "Call"
                        ]
                    ]
                },
                "kernel_regularizer": {
                    "value": "tf.keras.regularizers.l1(l1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "LeakyReLU_165": {
                "alpha": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dense_166": {
                "units": {
                    "value": "train_Y.shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "modules/simulator.py": {
        "sklearn": {}
    },
    "example_selection/modules/STAN.py": {
        "tensorflow": {}
    },
    "example_selection/modules/pydelfi_t1/delfi.py": {
        "tensorflow": {
            "Session_68": {
                "variable": {
                    "value": "self.sess",
                    "type": "Attribute",
                    "possible_values": []
                },
                "config": {
                    "value": "tf.ConfigProto()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "placeholder_111": {
                "variable": {
                    "value": "self.x_train",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, self.npar)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_112": {
                "variable": {
                    "value": "self.y_train",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, self.D)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Saver_170": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_69": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ConfigProto_68": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "example_selection/modules/pydelfi_t1/ndes.py": {
        "tensorflow": {
            "add_52": {
                "variable": {
                    "value": "self.m",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.matmul(h, Mmp * Wm)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "bm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('bm', [1, self.n_data], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('bm', [self.n_data, n_comps], initializer=tf.random_normal_initializer())",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "m",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_55": {
                "variable": {
                    "value": "self.logp",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.matmul(h, Mmp * Wp)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "bp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('bp', [1, self.n_data], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('bp', [self.n_data, n_comps], initializer=tf.random_normal_initializer())",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "logp",
                    "type": "str",
                    "possible_values": []
                }
            },
            "multiply_61": {
                "variable": {
                    "value": "self.L",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "-0.5",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "y": {
                    "value": "self.n_data * np.log(2 * np.pi) + tf.reduce_sum(self.u ** 2 - self.logp, axis=1, keepdims=True)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "L",
                    "type": "str",
                    "possible_values": []
                }
            },
            "mean_squared_error_66": {
                "variable": {
                    "value": "self.reg_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y_true": {
                    "value": "self.L",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "self.logpdf",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_131": {
                "variable": {
                    "value": "Mmp",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "Mmp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "degrees[-1][:, np.newaxis] < degrees[0]",
                            "Compare"
                        ],
                        [
                            "tf.constant(Mmp, dtype=dtype, name='Mmp')",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "name": {
                    "value": "Mmp",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_147": {
                "variable": {
                    "value": "Wx",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Wx",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.n_parameters, self.n_hiddens[0]]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(0.0, np.sqrt(1.0 / (self.n_parameters + 1)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_248": {
                "variable": {
                    "value": "self.L",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "-0.5 * n_data * np.log(2 * np.pi) - 0.5 * tf.reduce_sum(self.u ** 2, axis=1, keepdims=True)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "self.logdet_dudy",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "L",
                    "type": "str",
                    "possible_values": []
                }
            },
            "mean_squared_error_252": {
                "variable": {
                    "value": "self.reg_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y_true": {
                    "value": "self.L",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "self.logpdf",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_318": {
                "variable": {
                    "value": "(self.mu, self.sigma, self.alpha)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "self.layers[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[self.M * self.n_data, self.M * self.n_data * (self.n_data + 1) // 2, self.M]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_319": {
                "variable": {
                    "value": "self.mu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.mu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, self.M, self.n_data)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_320": {
                "variable": {
                    "value": "self.sigma",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.sigma",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, self.M, self.n_data * (self.n_data + 1) // 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "softmax_321": {
                "variable": {
                    "value": "self.alpha",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.alpha",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_prod_324": {
                "variable": {
                    "value": "self.det",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.linalg.diag_part(self.Sigma)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "identity_326": {
                "variable": {
                    "value": "self.mu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.mu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "mu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_327": {
                "variable": {
                    "value": "self.Sigma",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.Sigma",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "Sigma",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_328": {
                "variable": {
                    "value": "self.alpha",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.alpha",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "alpha",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_329": {
                "variable": {
                    "value": "self.det",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.det",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "det",
                    "type": "str",
                    "possible_values": []
                }
            },
            "log_332": {
                "x": {
                    "value": "self.alpha",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "mean_squared_error_336": {
                "variable": {
                    "value": "self.reg_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y_true": {
                    "value": "self.L",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "self.logpdf",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_127": {
                "variable": {
                    "value": "M",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "M",
                    "type": "variable",
                    "possible_values": [
                        [
                            "d0[:, np.newaxis] <= d1",
                            "Compare"
                        ],
                        [
                            "tf.constant(M, dtype=dtype, name='M' + str(l + 1))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "name": {
                    "value": "'M' + str(l + 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "get_variable_151": {
                "variable": {
                    "value": "W",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "'W' + str(l)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[N0, N1]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(0.0, np.sqrt(1.0 / (1 + N0)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_152": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "'b' + str(l)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, N1]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_158": {
                "variable": {
                    "value": "Wm",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Wm",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n_units[-1], self.n_data]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(0.0, np.sqrt(1.0 / (n_units[-1] + 1)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_159": {
                "variable": {
                    "value": "Wp",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Wp",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n_units[-1], self.n_data]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(0.0, np.sqrt(1.0 / (n_units[-1] + 1)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_160": {
                "variable": {
                    "value": "bm",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bm",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, self.n_data]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_161": {
                "variable": {
                    "value": "bp",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bp",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, self.n_data]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_167": {
                "variable": {
                    "value": "Wm",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Wm",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n_units[-1], self.n_data, n_comps]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(0.0, np.sqrt(1.0 / (n_units[-1] + 1)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_168": {
                "variable": {
                    "value": "Wp",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Wp",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n_units[-1], self.n_data, n_comps]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(0.0, np.sqrt(1.0 / (n_units[-1] + 1)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_169": {
                "variable": {
                    "value": "Wa",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Wa",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n_units[-1], self.n_data, n_comps]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(0.0, np.sqrt(1.0 / (n_units[-1] + 1)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_170": {
                "variable": {
                    "value": "bm",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bm",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.n_data, n_comps]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_171": {
                "variable": {
                    "value": "bp",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bp",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.n_data, n_comps]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_172": {
                "variable": {
                    "value": "ba",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "ba",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.n_data, n_comps]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "placeholder_42": {
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[None, n_parameters]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "parameters",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_43": {
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[None, n_data]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "data",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_44": {
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[None, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "logpdf",
                    "type": "str",
                    "possible_values": []
                }
            },
            "matmul_52": {
                "a": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "f(tf.matmul(self.parameters, Wx) + tf.matmul(self.data, Ms[0] * Ws[0]) + bs[0], name='h1')",
                            "Call"
                        ],
                        [
                            "f(tf.matmul(h, M * W) + b, name='h' + str(l + 2))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "Mmp * Wm",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "matmul_55": {
                "a": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "f(tf.matmul(self.parameters, Wx) + tf.matmul(self.data, Ms[0] * Ws[0]) + bs[0], name='h1')",
                            "Call"
                        ],
                        [
                            "f(tf.matmul(h, M * W) + b, name='h' + str(l + 2))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "Mmp * Wp",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_58": {
                "x": {
                    "value": "0.5 * self.logp",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_65": {
                "input_tensor": {
                    "value": "self.L",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "trn_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_220": {
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[None, n_parameters]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "parameters",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_221": {
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[None, n_data]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "data",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_222": {
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[None, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "logpdf",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_251": {
                "input_tensor": {
                    "value": "self.L",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "trn_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_293": {
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[None, self.n_parameters]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "parameters",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_294": {
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[None, self.n_data]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "data",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_295": {
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[None, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "logpdf",
                    "type": "str",
                    "possible_values": []
                }
            },
            "diag_323": {
                "diagonal": {
                    "value": "tf.linalg.diag_part(self.Sigma)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "diag_part_324": {
                "input": {
                    "value": "self.Sigma",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_335": {
                "input_tensor": {
                    "value": "self.L",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "trn_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_62": {
                "input_tensor": {
                    "value": "self.u ** 2 - self.logp",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "random_normal_initializer_147": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(1.0 / (self.n_parameters + 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_234": {
                "name_or_scope": {
                    "value": "'nde_' + str(index) + '_made_' + str(i + 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_243": {
                "input_tensor": {
                    "value": "made.logp",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_302": {
                "name_or_scope": {
                    "value": "'nde_' + str(index) + '_layer_' + str(i + 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_323": {
                "x": {
                    "value": "tf.linalg.diag_part(self.Sigma)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_332": {
                "input_tensor": {
                    "value": "tf.square(tf.einsum('ijlk,ijk->ijl', self.Sigma, tf.subtract(tf.expand_dims(self.data, 1), self.mu)))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_47": {
                "a": {
                    "value": "self.data",
                    "type": "Attribute",
                    "possible_values": []
                },
                "b": {
                    "value": "Ms[0] * Ws[0]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "matmul_49": {
                "a": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "f(tf.matmul(self.parameters, Wx) + tf.matmul(self.data, Ms[0] * Ws[0]) + bs[0], name='h1')",
                            "Call"
                        ],
                        [
                            "f(tf.matmul(h, M * W) + b, name='h' + str(l + 2))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "M * W",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "random_normal_initializer_151": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(1.0 / (1 + N0))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_initializer_152": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "random_normal_initializer_158": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(1.0 / (n_units[-1] + 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "random_normal_initializer_159": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(1.0 / (n_units[-1] + 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_initializer_160": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_161": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "random_normal_initializer_167": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(1.0 / (n_units[-1] + 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "random_normal_initializer_168": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(1.0 / (n_units[-1] + 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "random_normal_initializer_169": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(1.0 / (n_units[-1] + 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "random_normal_initializer_170": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "random_normal_initializer_171": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "random_normal_initializer_172": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_sum_248": {
                "input_tensor": {
                    "value": "self.u ** 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "add_315": {
                "x": {
                    "value": "tf.matmul(self.layers[-1], self.weights[-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.biases[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "diag_part_323": {
                "input": {
                    "value": "self.Sigma",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "exp_332": {
                "x": {
                    "value": "-0.5 * tf.reduce_sum(tf.square(tf.einsum('ijlk,ijk->ijl', self.Sigma, tf.subtract(tf.expand_dims(self.data, 1), self.mu))), 2) + tf.log(self.alpha) + tf.log(self.det) - self.n_data * np.log(2.0 * np.pi) / 2.0",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "get_variable_304": {
                "name": {
                    "value": "weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.n_parameters, self.n_hidden[i]]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(0.0, np.sqrt(2.0 / self.n_parameters))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_305": {
                "name": {
                    "value": "biases",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.n_hidden[i]]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_313": {
                "x": {
                    "value": "tf.matmul(self.layers[-1], self.weights[-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.biases[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "matmul_315": {
                "a": {
                    "value": "self.layers[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "self.weights[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "get_variable_307": {
                "name": {
                    "value": "weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.n_hidden[i], self.N]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(0.0, np.sqrt(2.0 / self.n_hidden[i]))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_308": {
                "name": {
                    "value": "biases",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.N]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_310": {
                "name": {
                    "value": "weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.n_hidden[i], self.n_hidden[i + 1]]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(0.0, np.sqrt(2 / self.n_hidden[i]))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_311": {
                "name": {
                    "value": "biases",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.n_hidden[i + 1]]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_313": {
                "a": {
                    "value": "self.layers[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "self.weights[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "random_normal_initializer_304": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(2.0 / self.n_parameters)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_initializer_305": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "random_normal_initializer_307": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(2.0 / self.n_hidden[i])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_initializer_308": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "random_normal_initializer_310": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(2 / self.n_hidden[i])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_initializer_311": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "square_332": {
                "x": {
                    "value": "tf.einsum('ijlk,ijk->ijl', self.Sigma, tf.subtract(tf.expand_dims(self.data, 1), self.mu))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "einsum_332": {
                "equation": {
                    "value": "ijlk,ijk->ijl",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "self.Sigma",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "tf.subtract(tf.expand_dims(self.data, 1), self.mu)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "subtract_332": {
                "x": {
                    "value": "tf.expand_dims(self.data, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.mu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_332": {
                "input": {
                    "value": "self.data",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "example_selection/modules/pydelfi_t1/train.py": {
        "tensorflow": {
            "Saver_61": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "example_selection/modules/pydelfi_t2/delfi.py": {
        "tensorflow": {
            "cholesky_73": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.Finv",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multiply_210": {
                "x": {
                    "value": "self.NDEs.weighted_log_posterior(theta)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.sqrt(P_variance)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_210": {
                "x": {
                    "value": "P_variance",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cholesky_382": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "(9.0 * self.Finv).astype(np.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_55": {
                "variable": {
                    "value": "self.prior.low",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "low",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros((self.npar,), dtype=np.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_56": {
                "variable": {
                    "value": "self.prior.high",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "high",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros((self.npar,), dtype=np.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_61": {
                "variable": {
                    "value": "self.prior.low",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "param_limits[0].astype(np.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_62": {
                "variable": {
                    "value": "self.prior.high",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "param_limits[1].astype(np.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_65": {
                "variable": {
                    "value": "self.prior.low",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "np.ones(self.npar) * np.finfo(np.float32).min",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_66": {
                "variable": {
                    "value": "self.prior.high",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "np.ones(self.npar) * np.finfo(np.float32).max",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cholesky_549": {
                "input": {
                    "value": "9 * self.Finv",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "example_selection/modules/pydelfi_t2/ndes.py": {
        "tensorflow": {
            "ones_37": {
                "variable": {
                    "value": "self.weighting",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(self.n_stack,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "weighting",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_49": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(stack_size,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "zeros_68": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(stack_size,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "convert_to_tensor_96": {
                "variable": {
                    "value": "data_X",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "data_X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(data_X, dtype=self.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_97": {
                "variable": {
                    "value": "data_Y",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "data_Y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(data_Y, dtype=self.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shuffle_104": {
                "variable": {
                    "value": "is_train",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[True] * n_train + [False] * n_val",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_110": {
                "variable": {
                    "value": "n_train_batches",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "n_train_batches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "n_train // n_batch",
                            "BinOp"
                        ],
                        [
                            "1",
                            "Constant"
                        ],
                        [
                            "tf.cast(n_train_batches, dtype=self.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_115": {
                "variable": {
                    "value": "n_val_batches",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "n_val_batches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "int(n_val / n_batch)",
                            "Call"
                        ],
                        [
                            "1",
                            "Constant"
                        ],
                        [
                            "tf.cast(n_val_batches, dtype=self.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_128": {
                "variable": {
                    "value": "es_count",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(self.n_stack,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_129": {
                "variable": {
                    "value": "temp_train_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(self.n_stack,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "divide_130": {
                "variable": {
                    "value": "temp_val_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones(self.n_stack, dtype=self.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.convert_to_tensor(0, dtype=self.dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_215": {
                "variable": {
                    "value": "self.weighting",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "-temp_train_loss - tf.math.reduce_max(-temp_train_loss)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_350": {
                "variable": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(data, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "tf.cast(data, dtype=self.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_351": {
                "variable": {
                    "value": "conditional",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "conditional",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(conditional, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "tf.cast(conditional, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_359": {
                "variable": {
                    "value": "half",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_360": {
                "variable": {
                    "value": "two",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_361": {
                "variable": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(data, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "tf.cast(data, dtype=self.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_362": {
                "variable": {
                    "value": "conditional",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "conditional",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(conditional, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "tf.cast(conditional, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_369": {
                "variable": {
                    "value": "weighted_sum",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.weighting",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "divide_370": {
                "variable": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.einsum('i...,i->...', x, self.weighting)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "weighted_sum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(self.weighting)",
                            "Call"
                        ]
                    ]
                }
            },
            "divide_375": {
                "variable": {
                    "value": "variance",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(tf.square(tf.subtract(x, tf.expand_dims(mean, 0))), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "weighted_sum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(self.weighting)",
                            "Call"
                        ]
                    ]
                }
            },
            "LeakyReLU_399": {
                "alpha": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "RandomNormal_400": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                },
                "seed": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "Sequential_484": {
                "variable": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": []
                },
                "layers": {
                    "value": "[tf.keras.layers.Dense(self.architecture[layer + 1], input_shape=(size,), activation=self.activation, kernel_initializer=kernel_initializer) for (layer, size) in enumerate(self.architecture[:-1])]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "reduce_any_589": {
                "variable": {
                    "value": "rejected",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.logical_or(too_low, too_high)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_any_804": {
                "variable": {
                    "value": "rejected",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.logical_or(too_low, too_high)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Adam_20": {
                "lr": {
                    "value": "0.0001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "add_63": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((stack_size,))",
                            "Call"
                        ],
                        [
                            "tf.add(loss, neg_log_prob)",
                            "Call"
                        ],
                        [
                            "tf.zeros((stack_size,))",
                            "Call"
                        ],
                        [
                            "tf.add(loss, neg_log_prob)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "neg_log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_mean(self.log_prob(y_batch_train, conditional=x_batch_train, stack=stack), -1)",
                            "UnaryOp"
                        ],
                        [
                            "-tf.reduce_mean(self.log_prob(y_batch_train, conditional=x_batch_train, stack=stack), -1)",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "divide_64": {
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((stack_size,))",
                            "Call"
                        ],
                        [
                            "tf.add(loss, neg_log_prob)",
                            "Call"
                        ],
                        [
                            "tf.zeros((stack_size,))",
                            "Call"
                        ],
                        [
                            "tf.add(loss, neg_log_prob)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "n_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "add_74": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((stack_size,))",
                            "Call"
                        ],
                        [
                            "tf.add(loss, neg_log_prob)",
                            "Call"
                        ],
                        [
                            "tf.zeros((stack_size,))",
                            "Call"
                        ],
                        [
                            "tf.add(loss, neg_log_prob)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "neg_log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_mean(self.log_prob(y_batch_train, conditional=x_batch_train, stack=stack), -1)",
                            "UnaryOp"
                        ],
                        [
                            "-tf.reduce_mean(self.log_prob(y_batch_train, conditional=x_batch_train, stack=stack), -1)",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "divide_75": {
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((stack_size,))",
                            "Call"
                        ],
                        [
                            "tf.add(loss, neg_log_prob)",
                            "Call"
                        ],
                        [
                            "tf.zeros((stack_size,))",
                            "Call"
                        ],
                        [
                            "tf.add(loss, neg_log_prob)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "n_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "where_155": {
                "variable": {
                    "value": "improving",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "this_val_loss < tf.gather(temp_val_loss, stack)",
                            "Compare"
                        ]
                    ]
                }
            },
            "squeeze_156": {
                "variable": {
                    "value": "es_count",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.tensor_scatter_nd_update(tf.expand_dims(es_count, 1), improving, tf.zeros((tf.reduce_sum(tf.cast(state, dtype=tf.int64)), 1), dtype=tf.int64))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_166": {
                "variable": {
                    "value": "improving",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "improving",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(state)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(improving, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_167": {
                "variable": {
                    "value": "improving_stack",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "stack",
                    "type": "variable",
                    "possible_values": [
                        [
                            "list(range(self.n_stack))",
                            "Call"
                        ],
                        [
                            "self.remove_from_stack(stack, model_indices, epoch=epoch)",
                            "Call"
                        ],
                        [
                            "list(range(self.n_stack))",
                            "Call"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "indices": {
                    "value": "improving",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(state)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(improving, 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "tensor_scatter_nd_update_169": {
                "variable": {
                    "value": "temp_train_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "temp_train_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((self.n_stack,), dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(temp_train_loss, tf.expand_dims(improving_stack, 1), tf.gather(this_train_loss, improving))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.expand_dims(improving_stack, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "updates": {
                    "value": "tf.gather(this_train_loss, improving)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tensor_scatter_nd_update_173": {
                "variable": {
                    "value": "temp_val_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "temp_val_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.divide(tf.ones(self.n_stack, dtype=self.dtype), tf.convert_to_tensor(0, dtype=self.dtype))",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(temp_val_loss, tf.expand_dims(improving_stack, 1), tf.gather(this_val_loss, improving))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.expand_dims(improving_stack, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "updates": {
                    "value": "tf.gather(this_val_loss, improving)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_178": {
                "variable": {
                    "value": "not_improving",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "~state",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "squeeze_179": {
                "variable": {
                    "value": "es_count",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.tensor_scatter_nd_add(tf.expand_dims(es_count, 1), not_improving, tf.ones((tf.reduce_sum(tf.cast(~state, dtype=tf.int64)), 1), dtype=tf.int64))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_283": {
                "values": {
                    "value": "[self.model[element].conditional_log_prob(data, conditional=conditional) for element in stack]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_291": {
                "x": {
                    "value": "self.weighted_prob(data, conditional=conditional, stack=stack)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stack_302": {
                "values": {
                    "value": "[self.model[element].conditional_prob(data, conditional=conditional) for element in stack]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_310": {
                "input_tensor": {
                    "value": "tf.multiply(self.weighting, self.prob(data, conditional=conditional, stack=stack))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stack_320": {
                "values": {
                    "value": "[self.model[element].sample(n, conditional=conditional) for element in stack]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_342": {
                "x": {
                    "value": "self.log_prob(data, conditional=conditional, stack=stack)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(self.prior.log_prob(conditional), dtype=self.dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_352": {
                "x": {
                    "value": "self.weighted_log_prob(data, conditional=conditional, stack=stack)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(self.prior.log_prob(conditional), dtype=self.dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "multiply_363": {
                "x": {
                    "value": "half",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(0.5, dtype=self.dtype)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.add(self.weighted_log_prob(data, conditional=conditional, stack=stack), tf.multiply(two, self.prior.log_prob(conditional)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "LeakyReLU_448": {
                "alpha": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "RandomNormal_448": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                },
                "seed": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "squeeze_511": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._network(kwargs['conditional']).log_prob(x)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(log_prob, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_524": {
                "variable": {
                    "value": "prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._network(kwargs['conditional']).prob(x)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(prob, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_535": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample(n, conditional=None, stack=stack)",
                            "Call"
                        ],
                        [
                            "self._network(kwargs['conditional']).sample(n)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(samples, 1)",
                            "Call"
                        ],
                        [
                            "self.mvn.sample(n, seed=seed, **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(samples, tf.where(rejected), new_samples)",
                            "Call"
                        ],
                        [
                            "self.mvn.sample(n, seed=seed, **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(samples, tf.where(rejected), new_samples)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multiply_579": {
                "x": {
                    "value": "self.mvn.prob(x, **kwargs)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.u.prob(x, **kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_583": {
                "x": {
                    "value": "self.prob(x, **kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_any_590": {
                "input_tensor": {
                    "value": "rejected",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_591": {
                "variable": {
                    "value": "new_n",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(rejected, dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tensor_scatter_nd_update_593": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample(n, conditional=None, stack=stack)",
                            "Call"
                        ],
                        [
                            "self._network(kwargs['conditional']).sample(n)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(samples, 1)",
                            "Call"
                        ],
                        [
                            "self.mvn.sample(n, seed=seed, **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(samples, tf.where(rejected), new_samples)",
                            "Call"
                        ],
                        [
                            "self.mvn.sample(n, seed=seed, **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(samples, tf.where(rejected), new_samples)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.where(rejected)",
                    "type": "Call",
                    "possible_values": []
                },
                "updates": {
                    "value": "new_samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.mvn.sample(new_n, seed=seed, **kwargs)",
                            "Call"
                        ],
                        [
                            "self.mvn.sample(new_n, seed=seed, **kwargs)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_any_597": {
                "variable": {
                    "value": "rejected",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.logical_or(too_low, too_high)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "LinearOperatorLowerTriangular_776": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "tril": {
                    "value": "scale_tril",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor_util.convert_nonref_to_tensor(scale_tril, name='scale_tril', dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "is_non_singular": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "is_self_adjoint": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "is_positive_definite": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "log_794": {
                "x": {
                    "value": "self._log_prob(x, **kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "multiply_797": {
                "x": {
                    "value": "self.mvn.prob(x, **kwargs)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.u.prob(x, **kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_any_805": {
                "input_tensor": {
                    "value": "rejected",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_806": {
                "variable": {
                    "value": "new_n",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(rejected, dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tensor_scatter_nd_update_808": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample(n, conditional=None, stack=stack)",
                            "Call"
                        ],
                        [
                            "self._network(kwargs['conditional']).sample(n)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(samples, 1)",
                            "Call"
                        ],
                        [
                            "self.mvn.sample(n, seed=seed, **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(samples, tf.where(rejected), new_samples)",
                            "Call"
                        ],
                        [
                            "self.mvn.sample(n, seed=seed, **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(samples, tf.where(rejected), new_samples)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.where(rejected)",
                    "type": "Call",
                    "possible_values": []
                },
                "updates": {
                    "value": "new_samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.mvn.sample(new_n, seed=seed, **kwargs)",
                            "Call"
                        ],
                        [
                            "self.mvn.sample(new_n, seed=seed, **kwargs)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_any_812": {
                "variable": {
                    "value": "rejected",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.logical_or(too_low, too_high)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_58": {
                "variable": {
                    "value": "neg_total_log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "neg_log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_mean(self.log_prob(y_batch_train, conditional=x_batch_train, stack=stack), -1)",
                            "UnaryOp"
                        ],
                        [
                            "-tf.reduce_mean(self.log_prob(y_batch_train, conditional=x_batch_train, stack=stack), -1)",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "ones_130": {
                "shape": {
                    "value": "self.n_stack",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_130": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_any_191": {
                "input_tensor": {
                    "value": "ended",
                    "type": "variable",
                    "possible_values": [
                        [
                            "es_count >= patience",
                            "Compare"
                        ]
                    ]
                }
            },
            "gather_192": {
                "variable": {
                    "value": "model_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "stack",
                    "type": "variable",
                    "possible_values": [
                        [
                            "list(range(self.n_stack))",
                            "Call"
                        ],
                        [
                            "self.remove_from_stack(stack, model_indices, epoch=epoch)",
                            "Call"
                        ],
                        [
                            "list(range(self.n_stack))",
                            "Call"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.squeeze(tf.where(ended), 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "squeeze_193": {
                "variable": {
                    "value": "remaining_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.where(~ended)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_194": {
                "variable": {
                    "value": "es_count",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "es_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((self.n_stack,), dtype=tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tf.tensor_scatter_nd_update(tf.expand_dims(es_count, 1), improving, tf.zeros((tf.reduce_sum(tf.cast(state, dtype=tf.int64)), 1), dtype=tf.int64)), 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tf.tensor_scatter_nd_add(tf.expand_dims(es_count, 1), not_improving, tf.ones((tf.reduce_sum(tf.cast(~state, dtype=tf.int64)), 1), dtype=tf.int64)), 1)",
                            "Call"
                        ],
                        [
                            "tf.gather(es_count, remaining_indices)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "remaining_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.where(~ended), 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_217": {
                "values": {
                    "value": "train_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "multiply_311": {
                "x": {
                    "value": "self.weighting",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.prob(data, conditional=conditional, stack=stack)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_344": {
                "x": {
                    "value": "self.prior.log_prob(conditional)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_353": {
                "x": {
                    "value": "self.prior.log_prob(conditional)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_364": {
                "x": {
                    "value": "self.weighted_log_prob(data, conditional=conditional, stack=stack)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.multiply(two, self.prior.log_prob(conditional))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "einsum_371": {
                "equation": {
                    "value": "i...,i->...",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x[tf.newaxis, ...]",
                            "Subscript"
                        ],
                        [
                            "x[tf.newaxis, ...]",
                            "Subscript"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "self.weighting",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_376": {
                "input_tensor": {
                    "value": "tf.square(tf.subtract(x, tf.expand_dims(mean, 0)))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Dense_492": {
                "units": {
                    "value": "tfp.layers.MixtureSameFamily.params_size(self.n_components, component_params_size=tfp.layers.MultivariateNormalTriL.params_size(self.n_data))",
                    "type": "Call",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "kernel_initializer",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "name_scope_556": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'truncatedMultivariateNormalTriL'",
                            "MethodArgument"
                        ],
                        [
                            "'truncatedMultivariateNormalTriL'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "logical_or_589": {
                "x": {
                    "value": "too_low",
                    "type": "variable",
                    "possible_values": [
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ]
                    ]
                },
                "y": {
                    "value": "too_high",
                    "type": "variable",
                    "possible_values": [
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ]
                    ]
                }
            },
            "name_scope_766": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'truncatedMultivariateNormalTriL'",
                            "MethodArgument"
                        ],
                        [
                            "'truncatedMultivariateNormalTriL'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "logical_or_804": {
                "x": {
                    "value": "too_low",
                    "type": "variable",
                    "possible_values": [
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ]
                    ]
                },
                "y": {
                    "value": "too_high",
                    "type": "variable",
                    "possible_values": [
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ]
                    ]
                }
            },
            "GradientTape_55": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_mean_73": {
                "input_tensor": {
                    "value": "self.log_prob(y_batch_train, conditional=x_batch_train, stack=stack)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_153": {
                "params": {
                    "value": "temp_val_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.divide(tf.ones(self.n_stack, dtype=self.dtype), tf.convert_to_tensor(0, dtype=self.dtype))",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(temp_val_loss, tf.expand_dims(improving_stack, 1), tf.gather(this_val_loss, improving))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "stack",
                    "type": "variable",
                    "possible_values": [
                        [
                            "list(range(self.n_stack))",
                            "Call"
                        ],
                        [
                            "self.remove_from_stack(stack, model_indices, epoch=epoch)",
                            "Call"
                        ],
                        [
                            "list(range(self.n_stack))",
                            "Call"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "tensor_scatter_nd_update_157": {
                "tensor": {
                    "value": "tf.expand_dims(es_count, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "improving",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(state)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(improving, 1)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "tf.zeros((tf.reduce_sum(tf.cast(state, dtype=tf.int64)), 1), dtype=tf.int64)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_171": {
                "input": {
                    "value": "improving_stack",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(stack, improving)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_172": {
                "params": {
                    "value": "this_train_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.single_train_epoch(train_dataset, stack, variables_list, stack_size, n_train_batches)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "improving",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(state)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(improving, 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_175": {
                "input": {
                    "value": "improving_stack",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(stack, improving)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_176": {
                "params": {
                    "value": "this_val_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.single_validate_epoch(val_dataset, stack, stack_size, 1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "improving",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(state)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(improving, 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "tensor_scatter_nd_add_180": {
                "tensor": {
                    "value": "tf.expand_dims(es_count, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "not_improving",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(~state)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "tf.ones((tf.reduce_sum(tf.cast(~state, dtype=tf.int64)), 1), dtype=tf.int64)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_max_215": {
                "input_tensor": {
                    "value": "-temp_train_loss",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "multiply_365": {
                "x": {
                    "value": "two",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(2.0, dtype=self.dtype)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.prior.log_prob(conditional)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "square_377": {
                "x": {
                    "value": "tf.subtract(x, tf.expand_dims(mean, 0))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Dense_485": {
                "units": {
                    "value": "self.architecture[layer + 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input_shape": {
                    "value": "(size,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "self.activation",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "kernel_initializer",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cast_591": {
                "x": {
                    "value": "rejected",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_593": {
                "condition": {
                    "value": "rejected",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_or_597": {
                "x": {
                    "value": "too_low",
                    "type": "variable",
                    "possible_values": [
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ]
                    ]
                },
                "y": {
                    "value": "too_high",
                    "type": "variable",
                    "possible_values": [
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ]
                    ]
                }
            },
            "cast_806": {
                "x": {
                    "value": "rejected",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_808": {
                "condition": {
                    "value": "rejected",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_or_812": {
                "x": {
                    "value": "too_low",
                    "type": "variable",
                    "possible_values": [
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ]
                    ]
                },
                "y": {
                    "value": "too_high",
                    "type": "variable",
                    "possible_values": [
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ]
                    ]
                }
            },
            "reduce_mean_57": {
                "input_tensor": {
                    "value": "self.log_prob(y_batch_train, conditional=x_batch_train, stack=stack)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_158": {
                "input": {
                    "value": "es_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((self.n_stack,), dtype=tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tf.tensor_scatter_nd_update(tf.expand_dims(es_count, 1), improving, tf.zeros((tf.reduce_sum(tf.cast(state, dtype=tf.int64)), 1), dtype=tf.int64)), 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tf.tensor_scatter_nd_add(tf.expand_dims(es_count, 1), not_improving, tf.ones((tf.reduce_sum(tf.cast(~state, dtype=tf.int64)), 1), dtype=tf.int64)), 1)",
                            "Call"
                        ],
                        [
                            "tf.gather(es_count, remaining_indices)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_160": {
                "shape": {
                    "value": "(tf.reduce_sum(tf.cast(state, dtype=tf.int64)), 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_181": {
                "input": {
                    "value": "es_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((self.n_stack,), dtype=tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tf.tensor_scatter_nd_update(tf.expand_dims(es_count, 1), improving, tf.zeros((tf.reduce_sum(tf.cast(state, dtype=tf.int64)), 1), dtype=tf.int64)), 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tf.tensor_scatter_nd_add(tf.expand_dims(es_count, 1), not_improving, tf.ones((tf.reduce_sum(tf.cast(~state, dtype=tf.int64)), 1), dtype=tf.int64)), 1)",
                            "Call"
                        ],
                        [
                            "tf.gather(es_count, remaining_indices)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_183": {
                "shape": {
                    "value": "(tf.reduce_sum(tf.cast(~state, dtype=tf.int64)), 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_193": {
                "condition": {
                    "value": "~ended",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "subtract_378": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x[tf.newaxis, ...]",
                            "Subscript"
                        ],
                        [
                            "x[tf.newaxis, ...]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.expand_dims(mean, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_380": {
                "input": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.divide(tf.einsum('i...,i->...', x, self.weighting), weighted_sum)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_to_tensor_436": {
                "value": {
                    "value": "conditional",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(conditional, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "tf.cast(conditional, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_161": {
                "input_tensor": {
                    "value": "tf.cast(state, dtype=tf.int64)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_184": {
                "input_tensor": {
                    "value": "tf.cast(~state, dtype=tf.int64)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "squeeze_192": {
                "input": {
                    "value": "tf.where(ended)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_162": {
                "x": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "this_val_loss < tf.gather(temp_val_loss, stack)",
                            "Compare"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_185": {
                "x": {
                    "value": "~state",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_192": {
                "condition": {
                    "value": "ended",
                    "type": "variable",
                    "possible_values": [
                        [
                            "es_count >= patience",
                            "Compare"
                        ]
                    ]
                }
            }
        }
    },
    "modules/STAN.py": {
        "tensorflow": {}
    },
    "modules/pydelfi_t1/delfi.py": {
        "tensorflow": {
            "Session_68": {
                "variable": {
                    "value": "self.sess",
                    "type": "Attribute",
                    "possible_values": []
                },
                "config": {
                    "value": "tf.ConfigProto()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "placeholder_111": {
                "variable": {
                    "value": "self.x_train",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, self.npar)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_112": {
                "variable": {
                    "value": "self.y_train",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, self.D)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Saver_170": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_69": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ConfigProto_68": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "modules/pydelfi_t1/ndes.py": {
        "tensorflow": {
            "add_52": {
                "variable": {
                    "value": "self.m",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.matmul(h, Mmp * Wm)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "bm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('bm', [1, self.n_data], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('bm', [self.n_data, n_comps], initializer=tf.random_normal_initializer())",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "m",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_55": {
                "variable": {
                    "value": "self.logp",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.matmul(h, Mmp * Wp)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "bp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('bp', [1, self.n_data], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('bp', [self.n_data, n_comps], initializer=tf.random_normal_initializer())",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "logp",
                    "type": "str",
                    "possible_values": []
                }
            },
            "multiply_61": {
                "variable": {
                    "value": "self.L",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "-0.5",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "y": {
                    "value": "self.n_data * np.log(2 * np.pi) + tf.reduce_sum(self.u ** 2 - self.logp, axis=1, keepdims=True)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "L",
                    "type": "str",
                    "possible_values": []
                }
            },
            "mean_squared_error_66": {
                "variable": {
                    "value": "self.reg_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y_true": {
                    "value": "self.L",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "self.logpdf",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_131": {
                "variable": {
                    "value": "Mmp",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "Mmp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "degrees[-1][:, np.newaxis] < degrees[0]",
                            "Compare"
                        ],
                        [
                            "tf.constant(Mmp, dtype=dtype, name='Mmp')",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "name": {
                    "value": "Mmp",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_147": {
                "variable": {
                    "value": "Wx",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Wx",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.n_parameters, self.n_hiddens[0]]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(0.0, np.sqrt(1.0 / (self.n_parameters + 1)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_248": {
                "variable": {
                    "value": "self.L",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "-0.5 * n_data * np.log(2 * np.pi) - 0.5 * tf.reduce_sum(self.u ** 2, axis=1, keepdims=True)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "self.logdet_dudy",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "L",
                    "type": "str",
                    "possible_values": []
                }
            },
            "mean_squared_error_252": {
                "variable": {
                    "value": "self.reg_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y_true": {
                    "value": "self.L",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "self.logpdf",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_318": {
                "variable": {
                    "value": "(self.mu, self.sigma, self.alpha)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "self.layers[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[self.M * self.n_data, self.M * self.n_data * (self.n_data + 1) // 2, self.M]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_319": {
                "variable": {
                    "value": "self.mu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.mu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, self.M, self.n_data)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_320": {
                "variable": {
                    "value": "self.sigma",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.sigma",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, self.M, self.n_data * (self.n_data + 1) // 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "softmax_321": {
                "variable": {
                    "value": "self.alpha",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.alpha",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_prod_324": {
                "variable": {
                    "value": "self.det",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.linalg.diag_part(self.Sigma)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "identity_326": {
                "variable": {
                    "value": "self.mu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.mu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "mu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_327": {
                "variable": {
                    "value": "self.Sigma",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.Sigma",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "Sigma",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_328": {
                "variable": {
                    "value": "self.alpha",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.alpha",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "alpha",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_329": {
                "variable": {
                    "value": "self.det",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.det",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "det",
                    "type": "str",
                    "possible_values": []
                }
            },
            "log_332": {
                "x": {
                    "value": "self.alpha",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "mean_squared_error_336": {
                "variable": {
                    "value": "self.reg_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y_true": {
                    "value": "self.L",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "self.logpdf",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_127": {
                "variable": {
                    "value": "M",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "M",
                    "type": "variable",
                    "possible_values": [
                        [
                            "d0[:, np.newaxis] <= d1",
                            "Compare"
                        ],
                        [
                            "tf.constant(M, dtype=dtype, name='M' + str(l + 1))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "name": {
                    "value": "'M' + str(l + 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "get_variable_151": {
                "variable": {
                    "value": "W",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "'W' + str(l)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[N0, N1]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(0.0, np.sqrt(1.0 / (1 + N0)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_152": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "'b' + str(l)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, N1]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_158": {
                "variable": {
                    "value": "Wm",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Wm",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n_units[-1], self.n_data]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(0.0, np.sqrt(1.0 / (n_units[-1] + 1)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_159": {
                "variable": {
                    "value": "Wp",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Wp",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n_units[-1], self.n_data]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(0.0, np.sqrt(1.0 / (n_units[-1] + 1)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_160": {
                "variable": {
                    "value": "bm",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bm",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, self.n_data]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_161": {
                "variable": {
                    "value": "bp",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bp",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, self.n_data]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_167": {
                "variable": {
                    "value": "Wm",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Wm",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n_units[-1], self.n_data, n_comps]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(0.0, np.sqrt(1.0 / (n_units[-1] + 1)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_168": {
                "variable": {
                    "value": "Wp",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Wp",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n_units[-1], self.n_data, n_comps]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(0.0, np.sqrt(1.0 / (n_units[-1] + 1)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_169": {
                "variable": {
                    "value": "Wa",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Wa",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n_units[-1], self.n_data, n_comps]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(0.0, np.sqrt(1.0 / (n_units[-1] + 1)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_170": {
                "variable": {
                    "value": "bm",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bm",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.n_data, n_comps]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_171": {
                "variable": {
                    "value": "bp",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bp",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.n_data, n_comps]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_172": {
                "variable": {
                    "value": "ba",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "ba",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.n_data, n_comps]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "placeholder_42": {
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[None, n_parameters]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "parameters",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_43": {
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[None, n_data]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "data",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_44": {
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[None, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "logpdf",
                    "type": "str",
                    "possible_values": []
                }
            },
            "matmul_52": {
                "a": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "f(tf.matmul(self.parameters, Wx) + tf.matmul(self.data, Ms[0] * Ws[0]) + bs[0], name='h1')",
                            "Call"
                        ],
                        [
                            "f(tf.matmul(h, M * W) + b, name='h' + str(l + 2))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "Mmp * Wm",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "matmul_55": {
                "a": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "f(tf.matmul(self.parameters, Wx) + tf.matmul(self.data, Ms[0] * Ws[0]) + bs[0], name='h1')",
                            "Call"
                        ],
                        [
                            "f(tf.matmul(h, M * W) + b, name='h' + str(l + 2))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "Mmp * Wp",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_58": {
                "x": {
                    "value": "0.5 * self.logp",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_65": {
                "input_tensor": {
                    "value": "self.L",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "trn_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_220": {
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[None, n_parameters]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "parameters",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_221": {
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[None, n_data]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "data",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_222": {
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[None, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "logpdf",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_251": {
                "input_tensor": {
                    "value": "self.L",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "trn_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_293": {
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[None, self.n_parameters]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "parameters",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_294": {
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[None, self.n_data]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "data",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_295": {
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[None, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "logpdf",
                    "type": "str",
                    "possible_values": []
                }
            },
            "diag_323": {
                "diagonal": {
                    "value": "tf.linalg.diag_part(self.Sigma)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "diag_part_324": {
                "input": {
                    "value": "self.Sigma",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_335": {
                "input_tensor": {
                    "value": "self.L",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "trn_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_62": {
                "input_tensor": {
                    "value": "self.u ** 2 - self.logp",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "random_normal_initializer_147": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(1.0 / (self.n_parameters + 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_234": {
                "name_or_scope": {
                    "value": "'nde_' + str(index) + '_made_' + str(i + 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_243": {
                "input_tensor": {
                    "value": "made.logp",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_302": {
                "name_or_scope": {
                    "value": "'nde_' + str(index) + '_layer_' + str(i + 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_323": {
                "x": {
                    "value": "tf.linalg.diag_part(self.Sigma)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_332": {
                "input_tensor": {
                    "value": "tf.square(tf.einsum('ijlk,ijk->ijl', self.Sigma, tf.subtract(tf.expand_dims(self.data, 1), self.mu)))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_47": {
                "a": {
                    "value": "self.data",
                    "type": "Attribute",
                    "possible_values": []
                },
                "b": {
                    "value": "Ms[0] * Ws[0]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "matmul_49": {
                "a": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "f(tf.matmul(self.parameters, Wx) + tf.matmul(self.data, Ms[0] * Ws[0]) + bs[0], name='h1')",
                            "Call"
                        ],
                        [
                            "f(tf.matmul(h, M * W) + b, name='h' + str(l + 2))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "M * W",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "random_normal_initializer_151": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(1.0 / (1 + N0))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_initializer_152": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "random_normal_initializer_158": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(1.0 / (n_units[-1] + 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "random_normal_initializer_159": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(1.0 / (n_units[-1] + 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_initializer_160": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_161": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "random_normal_initializer_167": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(1.0 / (n_units[-1] + 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "random_normal_initializer_168": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(1.0 / (n_units[-1] + 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "random_normal_initializer_169": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(1.0 / (n_units[-1] + 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "random_normal_initializer_170": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "random_normal_initializer_171": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "random_normal_initializer_172": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_sum_248": {
                "input_tensor": {
                    "value": "self.u ** 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "add_315": {
                "x": {
                    "value": "tf.matmul(self.layers[-1], self.weights[-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.biases[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "diag_part_323": {
                "input": {
                    "value": "self.Sigma",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "exp_332": {
                "x": {
                    "value": "-0.5 * tf.reduce_sum(tf.square(tf.einsum('ijlk,ijk->ijl', self.Sigma, tf.subtract(tf.expand_dims(self.data, 1), self.mu))), 2) + tf.log(self.alpha) + tf.log(self.det) - self.n_data * np.log(2.0 * np.pi) / 2.0",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "get_variable_304": {
                "name": {
                    "value": "weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.n_parameters, self.n_hidden[i]]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(0.0, np.sqrt(2.0 / self.n_parameters))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_305": {
                "name": {
                    "value": "biases",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.n_hidden[i]]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_313": {
                "x": {
                    "value": "tf.matmul(self.layers[-1], self.weights[-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.biases[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "matmul_315": {
                "a": {
                    "value": "self.layers[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "self.weights[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "get_variable_307": {
                "name": {
                    "value": "weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.n_hidden[i], self.N]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(0.0, np.sqrt(2.0 / self.n_hidden[i]))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_308": {
                "name": {
                    "value": "biases",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.N]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_310": {
                "name": {
                    "value": "weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.n_hidden[i], self.n_hidden[i + 1]]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(0.0, np.sqrt(2 / self.n_hidden[i]))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_311": {
                "name": {
                    "value": "biases",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.n_hidden[i + 1]]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_313": {
                "a": {
                    "value": "self.layers[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "self.weights[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "random_normal_initializer_304": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(2.0 / self.n_parameters)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_initializer_305": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "random_normal_initializer_307": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(2.0 / self.n_hidden[i])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_initializer_308": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "random_normal_initializer_310": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(2 / self.n_hidden[i])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_initializer_311": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "square_332": {
                "x": {
                    "value": "tf.einsum('ijlk,ijk->ijl', self.Sigma, tf.subtract(tf.expand_dims(self.data, 1), self.mu))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "einsum_332": {
                "equation": {
                    "value": "ijlk,ijk->ijl",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "self.Sigma",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "tf.subtract(tf.expand_dims(self.data, 1), self.mu)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "subtract_332": {
                "x": {
                    "value": "tf.expand_dims(self.data, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.mu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_332": {
                "input": {
                    "value": "self.data",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "modules/pydelfi_t1/train.py": {
        "tensorflow": {
            "Saver_61": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "modules/pydelfi_t2/delfi.py": {
        "tensorflow": {
            "cholesky_73": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.Finv",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multiply_210": {
                "x": {
                    "value": "self.NDEs.weighted_log_posterior(theta)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.sqrt(P_variance)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_210": {
                "x": {
                    "value": "P_variance",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cholesky_382": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "(9.0 * self.Finv).astype(np.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_55": {
                "variable": {
                    "value": "self.prior.low",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "low",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros((self.npar,), dtype=np.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_56": {
                "variable": {
                    "value": "self.prior.high",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "high",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros((self.npar,), dtype=np.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_61": {
                "variable": {
                    "value": "self.prior.low",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "param_limits[0].astype(np.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_62": {
                "variable": {
                    "value": "self.prior.high",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "param_limits[1].astype(np.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_65": {
                "variable": {
                    "value": "self.prior.low",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "np.ones(self.npar) * np.finfo(np.float32).min",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_66": {
                "variable": {
                    "value": "self.prior.high",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "np.ones(self.npar) * np.finfo(np.float32).max",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cholesky_549": {
                "input": {
                    "value": "9 * self.Finv",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "modules/pydelfi_t2/ndes.py": {
        "tensorflow": {
            "ones_37": {
                "variable": {
                    "value": "self.weighting",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(self.n_stack,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "weighting",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_49": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(stack_size,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "zeros_68": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(stack_size,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "convert_to_tensor_96": {
                "variable": {
                    "value": "data_X",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "data_X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(data_X, dtype=self.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_97": {
                "variable": {
                    "value": "data_Y",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "data_Y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(data_Y, dtype=self.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shuffle_104": {
                "variable": {
                    "value": "is_train",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[True] * n_train + [False] * n_val",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_110": {
                "variable": {
                    "value": "n_train_batches",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "n_train_batches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "n_train // n_batch",
                            "BinOp"
                        ],
                        [
                            "1",
                            "Constant"
                        ],
                        [
                            "tf.cast(n_train_batches, dtype=self.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_115": {
                "variable": {
                    "value": "n_val_batches",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "n_val_batches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "int(n_val / n_batch)",
                            "Call"
                        ],
                        [
                            "1",
                            "Constant"
                        ],
                        [
                            "tf.cast(n_val_batches, dtype=self.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_128": {
                "variable": {
                    "value": "es_count",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(self.n_stack,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_129": {
                "variable": {
                    "value": "temp_train_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(self.n_stack,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "divide_130": {
                "variable": {
                    "value": "temp_val_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones(self.n_stack, dtype=self.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.convert_to_tensor(0, dtype=self.dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_215": {
                "variable": {
                    "value": "self.weighting",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "-temp_train_loss - tf.math.reduce_max(-temp_train_loss)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_350": {
                "variable": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(data, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "tf.cast(data, dtype=self.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_351": {
                "variable": {
                    "value": "conditional",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "conditional",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(conditional, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "tf.cast(conditional, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_359": {
                "variable": {
                    "value": "half",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_360": {
                "variable": {
                    "value": "two",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_361": {
                "variable": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(data, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "tf.cast(data, dtype=self.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_362": {
                "variable": {
                    "value": "conditional",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "conditional",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(conditional, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "tf.cast(conditional, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_369": {
                "variable": {
                    "value": "weighted_sum",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.weighting",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "divide_370": {
                "variable": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.einsum('i...,i->...', x, self.weighting)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "weighted_sum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(self.weighting)",
                            "Call"
                        ]
                    ]
                }
            },
            "divide_375": {
                "variable": {
                    "value": "variance",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(tf.square(tf.subtract(x, tf.expand_dims(mean, 0))), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "weighted_sum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(self.weighting)",
                            "Call"
                        ]
                    ]
                }
            },
            "LeakyReLU_399": {
                "alpha": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "RandomNormal_400": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                },
                "seed": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "Sequential_484": {
                "variable": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": []
                },
                "layers": {
                    "value": "[tf.keras.layers.Dense(self.architecture[layer + 1], input_shape=(size,), activation=self.activation, kernel_initializer=kernel_initializer) for (layer, size) in enumerate(self.architecture[:-1])]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "reduce_any_589": {
                "variable": {
                    "value": "rejected",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.logical_or(too_low, too_high)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_any_804": {
                "variable": {
                    "value": "rejected",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.logical_or(too_low, too_high)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Adam_20": {
                "lr": {
                    "value": "0.0001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "add_63": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((stack_size,))",
                            "Call"
                        ],
                        [
                            "tf.add(loss, neg_log_prob)",
                            "Call"
                        ],
                        [
                            "tf.zeros((stack_size,))",
                            "Call"
                        ],
                        [
                            "tf.add(loss, neg_log_prob)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "neg_log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_mean(self.log_prob(y_batch_train, conditional=x_batch_train, stack=stack), -1)",
                            "UnaryOp"
                        ],
                        [
                            "-tf.reduce_mean(self.log_prob(y_batch_train, conditional=x_batch_train, stack=stack), -1)",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "divide_64": {
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((stack_size,))",
                            "Call"
                        ],
                        [
                            "tf.add(loss, neg_log_prob)",
                            "Call"
                        ],
                        [
                            "tf.zeros((stack_size,))",
                            "Call"
                        ],
                        [
                            "tf.add(loss, neg_log_prob)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "n_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "add_74": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((stack_size,))",
                            "Call"
                        ],
                        [
                            "tf.add(loss, neg_log_prob)",
                            "Call"
                        ],
                        [
                            "tf.zeros((stack_size,))",
                            "Call"
                        ],
                        [
                            "tf.add(loss, neg_log_prob)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "neg_log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_mean(self.log_prob(y_batch_train, conditional=x_batch_train, stack=stack), -1)",
                            "UnaryOp"
                        ],
                        [
                            "-tf.reduce_mean(self.log_prob(y_batch_train, conditional=x_batch_train, stack=stack), -1)",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "divide_75": {
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((stack_size,))",
                            "Call"
                        ],
                        [
                            "tf.add(loss, neg_log_prob)",
                            "Call"
                        ],
                        [
                            "tf.zeros((stack_size,))",
                            "Call"
                        ],
                        [
                            "tf.add(loss, neg_log_prob)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "n_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "where_155": {
                "variable": {
                    "value": "improving",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "this_val_loss < tf.gather(temp_val_loss, stack)",
                            "Compare"
                        ]
                    ]
                }
            },
            "squeeze_156": {
                "variable": {
                    "value": "es_count",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.tensor_scatter_nd_update(tf.expand_dims(es_count, 1), improving, tf.zeros((tf.reduce_sum(tf.cast(state, dtype=tf.int64)), 1), dtype=tf.int64))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_166": {
                "variable": {
                    "value": "improving",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "improving",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(state)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(improving, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_167": {
                "variable": {
                    "value": "improving_stack",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "stack",
                    "type": "variable",
                    "possible_values": [
                        [
                            "list(range(self.n_stack))",
                            "Call"
                        ],
                        [
                            "self.remove_from_stack(stack, model_indices, epoch=epoch)",
                            "Call"
                        ],
                        [
                            "list(range(self.n_stack))",
                            "Call"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "indices": {
                    "value": "improving",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(state)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(improving, 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "tensor_scatter_nd_update_169": {
                "variable": {
                    "value": "temp_train_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "temp_train_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((self.n_stack,), dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(temp_train_loss, tf.expand_dims(improving_stack, 1), tf.gather(this_train_loss, improving))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.expand_dims(improving_stack, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "updates": {
                    "value": "tf.gather(this_train_loss, improving)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tensor_scatter_nd_update_173": {
                "variable": {
                    "value": "temp_val_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "temp_val_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.divide(tf.ones(self.n_stack, dtype=self.dtype), tf.convert_to_tensor(0, dtype=self.dtype))",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(temp_val_loss, tf.expand_dims(improving_stack, 1), tf.gather(this_val_loss, improving))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.expand_dims(improving_stack, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "updates": {
                    "value": "tf.gather(this_val_loss, improving)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_178": {
                "variable": {
                    "value": "not_improving",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "~state",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "squeeze_179": {
                "variable": {
                    "value": "es_count",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.tensor_scatter_nd_add(tf.expand_dims(es_count, 1), not_improving, tf.ones((tf.reduce_sum(tf.cast(~state, dtype=tf.int64)), 1), dtype=tf.int64))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_283": {
                "values": {
                    "value": "[self.model[element].conditional_log_prob(data, conditional=conditional) for element in stack]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_291": {
                "x": {
                    "value": "self.weighted_prob(data, conditional=conditional, stack=stack)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stack_302": {
                "values": {
                    "value": "[self.model[element].conditional_prob(data, conditional=conditional) for element in stack]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_310": {
                "input_tensor": {
                    "value": "tf.multiply(self.weighting, self.prob(data, conditional=conditional, stack=stack))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stack_320": {
                "values": {
                    "value": "[self.model[element].sample(n, conditional=conditional) for element in stack]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_342": {
                "x": {
                    "value": "self.log_prob(data, conditional=conditional, stack=stack)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(self.prior.log_prob(conditional), dtype=self.dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_352": {
                "x": {
                    "value": "self.weighted_log_prob(data, conditional=conditional, stack=stack)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(self.prior.log_prob(conditional), dtype=self.dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "multiply_363": {
                "x": {
                    "value": "half",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(0.5, dtype=self.dtype)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.add(self.weighted_log_prob(data, conditional=conditional, stack=stack), tf.multiply(two, self.prior.log_prob(conditional)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "LeakyReLU_448": {
                "alpha": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "RandomNormal_448": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                },
                "seed": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "squeeze_511": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._network(kwargs['conditional']).log_prob(x)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(log_prob, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_524": {
                "variable": {
                    "value": "prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._network(kwargs['conditional']).prob(x)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(prob, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_535": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample(n, conditional=None, stack=stack)",
                            "Call"
                        ],
                        [
                            "self._network(kwargs['conditional']).sample(n)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(samples, 1)",
                            "Call"
                        ],
                        [
                            "self.mvn.sample(n, seed=seed, **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(samples, tf.where(rejected), new_samples)",
                            "Call"
                        ],
                        [
                            "self.mvn.sample(n, seed=seed, **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(samples, tf.where(rejected), new_samples)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multiply_579": {
                "x": {
                    "value": "self.mvn.prob(x, **kwargs)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.u.prob(x, **kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_583": {
                "x": {
                    "value": "self.prob(x, **kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_any_590": {
                "input_tensor": {
                    "value": "rejected",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_591": {
                "variable": {
                    "value": "new_n",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(rejected, dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tensor_scatter_nd_update_593": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample(n, conditional=None, stack=stack)",
                            "Call"
                        ],
                        [
                            "self._network(kwargs['conditional']).sample(n)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(samples, 1)",
                            "Call"
                        ],
                        [
                            "self.mvn.sample(n, seed=seed, **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(samples, tf.where(rejected), new_samples)",
                            "Call"
                        ],
                        [
                            "self.mvn.sample(n, seed=seed, **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(samples, tf.where(rejected), new_samples)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.where(rejected)",
                    "type": "Call",
                    "possible_values": []
                },
                "updates": {
                    "value": "new_samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.mvn.sample(new_n, seed=seed, **kwargs)",
                            "Call"
                        ],
                        [
                            "self.mvn.sample(new_n, seed=seed, **kwargs)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_any_597": {
                "variable": {
                    "value": "rejected",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.logical_or(too_low, too_high)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "LinearOperatorLowerTriangular_776": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "tril": {
                    "value": "scale_tril",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor_util.convert_nonref_to_tensor(scale_tril, name='scale_tril', dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "is_non_singular": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "is_self_adjoint": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "is_positive_definite": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "log_794": {
                "x": {
                    "value": "self._log_prob(x, **kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "multiply_797": {
                "x": {
                    "value": "self.mvn.prob(x, **kwargs)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.u.prob(x, **kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_any_805": {
                "input_tensor": {
                    "value": "rejected",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_806": {
                "variable": {
                    "value": "new_n",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(rejected, dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tensor_scatter_nd_update_808": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample(n, conditional=None, stack=stack)",
                            "Call"
                        ],
                        [
                            "self._network(kwargs['conditional']).sample(n)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(samples, 1)",
                            "Call"
                        ],
                        [
                            "self.mvn.sample(n, seed=seed, **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(samples, tf.where(rejected), new_samples)",
                            "Call"
                        ],
                        [
                            "self.mvn.sample(n, seed=seed, **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(samples, tf.where(rejected), new_samples)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.where(rejected)",
                    "type": "Call",
                    "possible_values": []
                },
                "updates": {
                    "value": "new_samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.mvn.sample(new_n, seed=seed, **kwargs)",
                            "Call"
                        ],
                        [
                            "self.mvn.sample(new_n, seed=seed, **kwargs)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_any_812": {
                "variable": {
                    "value": "rejected",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.logical_or(too_low, too_high)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_58": {
                "variable": {
                    "value": "neg_total_log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "neg_log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_mean(self.log_prob(y_batch_train, conditional=x_batch_train, stack=stack), -1)",
                            "UnaryOp"
                        ],
                        [
                            "-tf.reduce_mean(self.log_prob(y_batch_train, conditional=x_batch_train, stack=stack), -1)",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "ones_130": {
                "shape": {
                    "value": "self.n_stack",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_130": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_any_191": {
                "input_tensor": {
                    "value": "ended",
                    "type": "variable",
                    "possible_values": [
                        [
                            "es_count >= patience",
                            "Compare"
                        ]
                    ]
                }
            },
            "gather_192": {
                "variable": {
                    "value": "model_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "stack",
                    "type": "variable",
                    "possible_values": [
                        [
                            "list(range(self.n_stack))",
                            "Call"
                        ],
                        [
                            "self.remove_from_stack(stack, model_indices, epoch=epoch)",
                            "Call"
                        ],
                        [
                            "list(range(self.n_stack))",
                            "Call"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.squeeze(tf.where(ended), 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "squeeze_193": {
                "variable": {
                    "value": "remaining_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.where(~ended)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_194": {
                "variable": {
                    "value": "es_count",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "es_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((self.n_stack,), dtype=tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tf.tensor_scatter_nd_update(tf.expand_dims(es_count, 1), improving, tf.zeros((tf.reduce_sum(tf.cast(state, dtype=tf.int64)), 1), dtype=tf.int64)), 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tf.tensor_scatter_nd_add(tf.expand_dims(es_count, 1), not_improving, tf.ones((tf.reduce_sum(tf.cast(~state, dtype=tf.int64)), 1), dtype=tf.int64)), 1)",
                            "Call"
                        ],
                        [
                            "tf.gather(es_count, remaining_indices)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "remaining_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.where(~ended), 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_217": {
                "values": {
                    "value": "train_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "multiply_311": {
                "x": {
                    "value": "self.weighting",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.prob(data, conditional=conditional, stack=stack)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_344": {
                "x": {
                    "value": "self.prior.log_prob(conditional)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_353": {
                "x": {
                    "value": "self.prior.log_prob(conditional)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_364": {
                "x": {
                    "value": "self.weighted_log_prob(data, conditional=conditional, stack=stack)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.multiply(two, self.prior.log_prob(conditional))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "einsum_371": {
                "equation": {
                    "value": "i...,i->...",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x[tf.newaxis, ...]",
                            "Subscript"
                        ],
                        [
                            "x[tf.newaxis, ...]",
                            "Subscript"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "self.weighting",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_376": {
                "input_tensor": {
                    "value": "tf.square(tf.subtract(x, tf.expand_dims(mean, 0)))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Dense_492": {
                "units": {
                    "value": "tfp.layers.MixtureSameFamily.params_size(self.n_components, component_params_size=tfp.layers.MultivariateNormalTriL.params_size(self.n_data))",
                    "type": "Call",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "kernel_initializer",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "name_scope_556": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'truncatedMultivariateNormalTriL'",
                            "MethodArgument"
                        ],
                        [
                            "'truncatedMultivariateNormalTriL'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "logical_or_589": {
                "x": {
                    "value": "too_low",
                    "type": "variable",
                    "possible_values": [
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ]
                    ]
                },
                "y": {
                    "value": "too_high",
                    "type": "variable",
                    "possible_values": [
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ]
                    ]
                }
            },
            "name_scope_766": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'truncatedMultivariateNormalTriL'",
                            "MethodArgument"
                        ],
                        [
                            "'truncatedMultivariateNormalTriL'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "logical_or_804": {
                "x": {
                    "value": "too_low",
                    "type": "variable",
                    "possible_values": [
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ]
                    ]
                },
                "y": {
                    "value": "too_high",
                    "type": "variable",
                    "possible_values": [
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ]
                    ]
                }
            },
            "GradientTape_55": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_mean_73": {
                "input_tensor": {
                    "value": "self.log_prob(y_batch_train, conditional=x_batch_train, stack=stack)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_153": {
                "params": {
                    "value": "temp_val_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.divide(tf.ones(self.n_stack, dtype=self.dtype), tf.convert_to_tensor(0, dtype=self.dtype))",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(temp_val_loss, tf.expand_dims(improving_stack, 1), tf.gather(this_val_loss, improving))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "stack",
                    "type": "variable",
                    "possible_values": [
                        [
                            "list(range(self.n_stack))",
                            "Call"
                        ],
                        [
                            "self.remove_from_stack(stack, model_indices, epoch=epoch)",
                            "Call"
                        ],
                        [
                            "list(range(self.n_stack))",
                            "Call"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "self.stack",
                            "Attribute"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "tensor_scatter_nd_update_157": {
                "tensor": {
                    "value": "tf.expand_dims(es_count, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "improving",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(state)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(improving, 1)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "tf.zeros((tf.reduce_sum(tf.cast(state, dtype=tf.int64)), 1), dtype=tf.int64)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_171": {
                "input": {
                    "value": "improving_stack",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(stack, improving)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_172": {
                "params": {
                    "value": "this_train_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.single_train_epoch(train_dataset, stack, variables_list, stack_size, n_train_batches)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "improving",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(state)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(improving, 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_175": {
                "input": {
                    "value": "improving_stack",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(stack, improving)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_176": {
                "params": {
                    "value": "this_val_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.single_validate_epoch(val_dataset, stack, stack_size, 1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "improving",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(state)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(improving, 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "tensor_scatter_nd_add_180": {
                "tensor": {
                    "value": "tf.expand_dims(es_count, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "not_improving",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(~state)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "tf.ones((tf.reduce_sum(tf.cast(~state, dtype=tf.int64)), 1), dtype=tf.int64)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_max_215": {
                "input_tensor": {
                    "value": "-temp_train_loss",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "multiply_365": {
                "x": {
                    "value": "two",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(2.0, dtype=self.dtype)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.prior.log_prob(conditional)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "square_377": {
                "x": {
                    "value": "tf.subtract(x, tf.expand_dims(mean, 0))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Dense_485": {
                "units": {
                    "value": "self.architecture[layer + 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input_shape": {
                    "value": "(size,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "self.activation",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "kernel_initializer",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cast_591": {
                "x": {
                    "value": "rejected",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_593": {
                "condition": {
                    "value": "rejected",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_or_597": {
                "x": {
                    "value": "too_low",
                    "type": "variable",
                    "possible_values": [
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ]
                    ]
                },
                "y": {
                    "value": "too_high",
                    "type": "variable",
                    "possible_values": [
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ]
                    ]
                }
            },
            "cast_806": {
                "x": {
                    "value": "rejected",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_808": {
                "condition": {
                    "value": "rejected",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(tf.logical_or(too_low, too_high), -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_or_812": {
                "x": {
                    "value": "too_low",
                    "type": "variable",
                    "possible_values": [
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ],
                        [
                            "samples < self.low",
                            "Compare"
                        ]
                    ]
                },
                "y": {
                    "value": "too_high",
                    "type": "variable",
                    "possible_values": [
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ],
                        [
                            "samples > self.high",
                            "Compare"
                        ]
                    ]
                }
            },
            "reduce_mean_57": {
                "input_tensor": {
                    "value": "self.log_prob(y_batch_train, conditional=x_batch_train, stack=stack)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_158": {
                "input": {
                    "value": "es_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((self.n_stack,), dtype=tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tf.tensor_scatter_nd_update(tf.expand_dims(es_count, 1), improving, tf.zeros((tf.reduce_sum(tf.cast(state, dtype=tf.int64)), 1), dtype=tf.int64)), 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tf.tensor_scatter_nd_add(tf.expand_dims(es_count, 1), not_improving, tf.ones((tf.reduce_sum(tf.cast(~state, dtype=tf.int64)), 1), dtype=tf.int64)), 1)",
                            "Call"
                        ],
                        [
                            "tf.gather(es_count, remaining_indices)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_160": {
                "shape": {
                    "value": "(tf.reduce_sum(tf.cast(state, dtype=tf.int64)), 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_181": {
                "input": {
                    "value": "es_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((self.n_stack,), dtype=tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tf.tensor_scatter_nd_update(tf.expand_dims(es_count, 1), improving, tf.zeros((tf.reduce_sum(tf.cast(state, dtype=tf.int64)), 1), dtype=tf.int64)), 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tf.tensor_scatter_nd_add(tf.expand_dims(es_count, 1), not_improving, tf.ones((tf.reduce_sum(tf.cast(~state, dtype=tf.int64)), 1), dtype=tf.int64)), 1)",
                            "Call"
                        ],
                        [
                            "tf.gather(es_count, remaining_indices)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_183": {
                "shape": {
                    "value": "(tf.reduce_sum(tf.cast(~state, dtype=tf.int64)), 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_193": {
                "condition": {
                    "value": "~ended",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "subtract_378": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x[tf.newaxis, ...]",
                            "Subscript"
                        ],
                        [
                            "x[tf.newaxis, ...]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.expand_dims(mean, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_380": {
                "input": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.divide(tf.einsum('i...,i->...', x, self.weighting), weighted_sum)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_to_tensor_436": {
                "value": {
                    "value": "conditional",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(conditional, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "tf.cast(conditional, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_161": {
                "input_tensor": {
                    "value": "tf.cast(state, dtype=tf.int64)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_184": {
                "input_tensor": {
                    "value": "tf.cast(~state, dtype=tf.int64)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "squeeze_192": {
                "input": {
                    "value": "tf.where(ended)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_162": {
                "x": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "this_val_loss < tf.gather(temp_val_loss, stack)",
                            "Compare"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_185": {
                "x": {
                    "value": "~state",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_192": {
                "condition": {
                    "value": "ended",
                    "type": "variable",
                    "possible_values": [
                        [
                            "es_count >= patience",
                            "Compare"
                        ]
                    ]
                }
            }
        }
    }
}