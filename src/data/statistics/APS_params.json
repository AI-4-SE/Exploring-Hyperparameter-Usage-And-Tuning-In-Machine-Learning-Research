{
    "actor_critic.py": {
        "tensorflow": {
            "concat_11": {
                "variable": {
                    "value": "modified_observations",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[obs, goal]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "flatten_49": {
                "variable": {
                    "value": "flat_action_spec",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "action_spec",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reshape_95": {
                "variable": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(predictions, [-1, self._output_dim])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, self._output_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Dense_79": {
                "units": {
                    "value": "self._output_dim if self._output_dim is not None else 1",
                    "type": "IfExp",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.compat.v1.keras.initializers.RandomUniform(minval=-0.003, maxval=0.003)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "value",
                    "type": "str",
                    "possible_values": []
                }
            },
            "VarianceScaling_58": {
                "scale": {
                    "value": "1.0 / 3.0",
                    "type": "BinOp",
                    "possible_values": []
                },
                "mode": {
                    "value": "fan_in",
                    "type": "str",
                    "possible_values": []
                },
                "distribution": {
                    "value": "uniform",
                    "type": "str",
                    "possible_values": []
                }
            },
            "VarianceScaling_66": {
                "scale": {
                    "value": "1.0 / 3.0",
                    "type": "BinOp",
                    "possible_values": []
                },
                "mode": {
                    "value": "fan_in",
                    "type": "str",
                    "possible_values": []
                },
                "distribution": {
                    "value": "uniform",
                    "type": "str",
                    "possible_values": []
                }
            },
            "VarianceScaling_74": {
                "scale": {
                    "value": "1.0 / 3.0",
                    "type": "BinOp",
                    "possible_values": []
                },
                "mode": {
                    "value": "fan_in",
                    "type": "str",
                    "possible_values": []
                },
                "distribution": {
                    "value": "uniform",
                    "type": "str",
                    "possible_values": []
                }
            },
            "RandomUniform_82": {
                "minval": {
                    "value": "-0.003",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "0.003",
                    "type": "float",
                    "possible_values": []
                }
            }
        }
    },
    "agent.py": {
        "tensorflow": {
            "AdamOptimizer_49": {
                "variable": {
                    "value": "self._actor_optimizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.0001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "AdamOptimizer_50": {
                "variable": {
                    "value": "self._critic_optimizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.0001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Variable_52": {
                "variable": {
                    "value": "self._train_iter",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "map_structure_319": {
                "variable": {
                    "value": "transitions",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "lambda x: tf.squeeze(x, [1])",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "transitions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "trajectory.to_transition(experience)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda x: tf.squeeze(x, [1]), transitions)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_341": {
                "variable": {
                    "value": "pairwise_dist",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "dist_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "Checkpoint_100": {
                "variable": {
                    "value": "self._ckpt",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "check_numerics_147": {
                "tensor": {
                    "value": "critic_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.critic_loss(time_steps, actions, next_time_steps)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(input_tensor=critic_loss_list)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(labels=tf.stop_gradient(td_targets), logits=q_values)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(input_tensor=critic_loss)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=tf.stop_gradient(td_targets), logits=q_values)",
                            "Call"
                        ],
                        [
                            "common.element_wise_huber_loss(td_targets, q_values)",
                            "Call"
                        ]
                    ]
                },
                "message": {
                    "value": "Critic loss is inf or nan",
                    "type": "str",
                    "possible_values": []
                }
            },
            "check_numerics_156": {
                "tensor": {
                    "value": "actor_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.actor_loss(time_steps)",
                            "Call"
                        ],
                        [
                            "tf.add_n(actor_losses)",
                            "Call"
                        ]
                    ]
                },
                "message": {
                    "value": "Actor loss is inf or nan.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_n_183": {
                "variable": {
                    "value": "actor_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "actor_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "stack_237": {
                "values": {
                    "value": "expected_q_values_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "reduce_mean_304": {
                "variable": {
                    "value": "critic_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "critic_loss_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "CheckpointManager_102": {
                "variable": {
                    "value": "self._load_manager",
                    "type": "Attribute",
                    "possible_values": []
                },
                "checkpoint": {
                    "value": "self._ckpt",
                    "type": "Attribute",
                    "possible_values": []
                },
                "directory": {
                    "value": "load_model_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "max_to_keep": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "CheckpointManager_110": {
                "variable": {
                    "value": "self._save_manager",
                    "type": "Attribute",
                    "possible_values": []
                },
                "checkpoint": {
                    "value": "self._ckpt",
                    "type": "Attribute",
                    "possible_values": []
                },
                "directory": {
                    "value": "save_model_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "max_to_keep": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "name_scope_120": {
                "name": {
                    "value": "get_target_updater",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GradientTape_143": {
                "watch_accessed_variables": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "GradientTape_152": {
                "watch_accessed_variables": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "name_scope_166": {
                "name": {
                    "value": "actor_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "flatten_172": {
                "variable": {
                    "value": "actions",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "actions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.flatten(actions)",
                            "Call"
                        ],
                        [
                            "policy_steps.action",
                            "Attribute"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reduce_sum_179": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "common.element_wise_squared_loss(tf.stop_gradient(dqda + action), action)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(input_tensor=loss, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(input_tensor=loss)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_180": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "common.element_wise_squared_loss(tf.stop_gradient(dqda + action), action)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(input_tensor=loss, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(input_tensor=loss)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_193": {
                "name": {
                    "value": "state_values",
                    "type": "str",
                    "possible_values": []
                }
            },
            "maximum_206": {
                "variable": {
                    "value": "expected_q_values",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "expected_q_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._get_expected_q_values(time_steps, actions)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(expected_q_values, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.maximum(expected_q_values, min_q_val)",
                            "Call"
                        ],
                        [
                            "tf.minimum(expected_q_values, max_q_val)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(expected_q_values, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(q_probs * tiled_bin_range, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "min_q_val",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-1.0 * self._max_episode_steps",
                            "BinOp"
                        ]
                    ]
                }
            },
            "minimum_207": {
                "variable": {
                    "value": "expected_q_values",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "expected_q_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._get_expected_q_values(time_steps, actions)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(expected_q_values, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.maximum(expected_q_values, min_q_val)",
                            "Call"
                        ],
                        [
                            "tf.minimum(expected_q_values, max_q_val)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(expected_q_values, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(q_probs * tiled_bin_range, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "max_q_val",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "Constant"
                        ]
                    ]
                }
            },
            "softmax_222": {
                "variable": {
                    "value": "q_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "q_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "q_values_list",
                            "Name"
                        ],
                        [
                            "-1 - tf.exp(q_values)",
                            "BinOp"
                        ],
                        [
                            "q_values_list[ensemble_index]",
                            "Subscript"
                        ],
                        [
                            "self._get_state_values(time_steps, aggregate=aggregate)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "range_224": {
                "variable": {
                    "value": "bin_range",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_226": {
                "variable": {
                    "value": "tiled_bin_range",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(neg_bin_range, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_228": {
                "variable": {
                    "value": "expected_q_values",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "q_probs * tiled_bin_range",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "name_scope_244": {
                "name": {
                    "value": "critic_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_301": {
                "variable": {
                    "value": "critic_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "critic_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.critic_loss(time_steps, actions, next_time_steps)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(input_tensor=critic_loss_list)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(labels=tf.stop_gradient(td_targets), logits=q_values)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(input_tensor=critic_loss)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=tf.stop_gradient(td_targets), logits=q_values)",
                            "Call"
                        ],
                        [
                            "common.element_wise_huber_loss(td_targets, q_values)",
                            "Call"
                        ]
                    ]
                }
            },
            "group_131": {
                "*inputs": {
                    "value": "critic_update_list + [actor_update]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "GradientTape_168": {
                "watch_accessed_variables": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "name_scope_185": {
                "name": {
                    "value": "Losses/",
                    "type": "str",
                    "possible_values": []
                }
            },
            "scalar_186": {
                "name": {
                    "value": "actor_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "actor_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.actor_loss(time_steps)",
                            "Call"
                        ],
                        [
                            "tf.add_n(actor_losses)",
                            "Call"
                        ]
                    ]
                },
                "step": {
                    "value": "self.train_step_counter",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_197": {
                "variable": {
                    "value": "expected_q_values",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "expected_q_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._get_expected_q_values(time_steps, actions)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(expected_q_values, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.maximum(expected_q_values, min_q_val)",
                            "Call"
                        ],
                        [
                            "tf.minimum(expected_q_values, max_q_val)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(expected_q_values, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(q_probs * tiled_bin_range, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_260": {
                "variable": {
                    "value": "target_q_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "target_q_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "target_q_values_list[ensemble_index]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_261": {
                "variable": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.zeros(batch_size, dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "self._max_episode_steps",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_263": {
                "variable": {
                    "value": "col_1",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reduce_sum_265": {
                "variable": {
                    "value": "col_last",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "target_q_probs[:, -2:]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "tf.nn.softmax(target_q_values, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "concat_267": {
                "variable": {
                    "value": "shifted_target_q_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[col_1, col_middle, col_last]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_269": {
                "variable": {
                    "value": "td_targets",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "next_time_steps.is_last()",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(tf.zeros(batch_size, dtype=tf.int32), self._max_episode_steps)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "shifted_target_q_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([col_1, col_middle, col_last], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_271": {
                "variable": {
                    "value": "td_targets",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "td_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.compat.v1.where(next_time_steps.is_last(), one_hot, shifted_target_q_probs)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(td_targets)",
                            "Call"
                        ],
                        [
                            "tf.compat.v1.where(next_time_steps.is_last(), ones, original_td_targets)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(td_targets)",
                            "Call"
                        ],
                        [
                            "tf.compat.v1.where(next_time_steps.is_last(), ones, original_td_targets)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(td_targets)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_293": {
                "variable": {
                    "value": "critic_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.stop_gradient(td_targets)",
                    "type": "Call",
                    "possible_values": []
                },
                "logits": {
                    "value": "q_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "q_values_list",
                            "Name"
                        ],
                        [
                            "-1 - tf.exp(q_values)",
                            "BinOp"
                        ],
                        [
                            "q_values_list[ensemble_index]",
                            "Subscript"
                        ],
                        [
                            "self._get_state_values(time_steps, aggregate=aggregate)",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_319": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_like_336": {
                "input": {
                    "value": "goal_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "obs_tensor",
                            "Name"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "expand_dims_336": {
                "input": {
                    "value": "obs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "obs_tensor[obs_index]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stop_gradient_178": {
                "input": {
                    "value": "dqda + action",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_min_199": {
                "variable": {
                    "value": "expected_q_values",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "expected_q_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._get_expected_q_values(time_steps, actions)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(expected_q_values, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.maximum(expected_q_values, min_q_val)",
                            "Call"
                        ],
                        [
                            "tf.minimum(expected_q_values, max_q_val)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(expected_q_values, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(q_probs * tiled_bin_range, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_226": {
                "input": {
                    "value": "neg_bin_range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-1.0 * bin_range",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_273": {
                "variable": {
                    "value": "ones",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sigmoid_274": {
                "variable": {
                    "value": "sigmoids",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "target_q_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "target_q_values_list[ensemble_index]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "where_277": {
                "variable": {
                    "value": "td_targets",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "next_time_steps.is_last()",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "ones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones(shape=(batch_size,), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "-tf.ones(shape=(batch_size,))",
                            "UnaryOp"
                        ]
                    ]
                },
                "y": {
                    "value": "original_td_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sigmoids / (sigmoids + 1)",
                            "BinOp"
                        ],
                        [
                            "next_time_steps.reward + next_time_steps.discount * target_q_values",
                            "BinOp"
                        ]
                    ]
                }
            },
            "stop_gradient_279": {
                "variable": {
                    "value": "td_targets",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "td_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.compat.v1.where(next_time_steps.is_last(), one_hot, shifted_target_q_probs)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(td_targets)",
                            "Call"
                        ],
                        [
                            "tf.compat.v1.where(next_time_steps.is_last(), ones, original_td_targets)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(td_targets)",
                            "Call"
                        ],
                        [
                            "tf.compat.v1.where(next_time_steps.is_last(), ones, original_td_targets)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(td_targets)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_cross_entropy_with_logits_296": {
                "variable": {
                    "value": "critic_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.stop_gradient(td_targets)",
                    "type": "Call",
                    "possible_values": []
                },
                "logits": {
                    "value": "q_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "q_values_list",
                            "Name"
                        ],
                        [
                            "-1 - tf.exp(q_values)",
                            "BinOp"
                        ],
                        [
                            "q_values_list[ensemble_index]",
                            "Subscript"
                        ],
                        [
                            "self._get_state_values(time_steps, aggregate=aggregate)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_262": {
                "shape": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "q_probs.shape[0]",
                            "Subscript"
                        ],
                        [
                            "target_actions.shape[0]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_286": {
                "variable": {
                    "value": "td_targets",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "next_time_steps.is_last()",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "ones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones(shape=(batch_size,), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "-tf.ones(shape=(batch_size,))",
                            "UnaryOp"
                        ]
                    ]
                },
                "y": {
                    "value": "original_td_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sigmoids / (sigmoids + 1)",
                            "BinOp"
                        ],
                        [
                            "next_time_steps.reward + next_time_steps.discount * target_q_values",
                            "BinOp"
                        ]
                    ]
                }
            },
            "stop_gradient_288": {
                "variable": {
                    "value": "td_targets",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "td_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.compat.v1.where(next_time_steps.is_last(), one_hot, shifted_target_q_probs)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(td_targets)",
                            "Call"
                        ],
                        [
                            "tf.compat.v1.where(next_time_steps.is_last(), ones, original_td_targets)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(td_targets)",
                            "Call"
                        ],
                        [
                            "tf.compat.v1.where(next_time_steps.is_last(), ones, original_td_targets)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(td_targets)",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_234": {
                "x": {
                    "value": "q_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "q_values_list",
                            "Name"
                        ],
                        [
                            "-1 - tf.exp(q_values)",
                            "BinOp"
                        ],
                        [
                            "q_values_list[ensemble_index]",
                            "Subscript"
                        ],
                        [
                            "self._get_state_values(time_steps, aggregate=aggregate)",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_294": {
                "input": {
                    "value": "td_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.compat.v1.where(next_time_steps.is_last(), one_hot, shifted_target_q_probs)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(td_targets)",
                            "Call"
                        ],
                        [
                            "tf.compat.v1.where(next_time_steps.is_last(), ones, original_td_targets)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(td_targets)",
                            "Call"
                        ],
                        [
                            "tf.compat.v1.where(next_time_steps.is_last(), ones, original_td_targets)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(td_targets)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_281": {
                "shape": {
                    "value": "(batch_size,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "stop_gradient_297": {
                "input": {
                    "value": "td_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.compat.v1.where(next_time_steps.is_last(), one_hot, shifted_target_q_probs)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(td_targets)",
                            "Call"
                        ],
                        [
                            "tf.compat.v1.where(next_time_steps.is_last(), ones, original_td_targets)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(td_targets)",
                            "Call"
                        ],
                        [
                            "tf.compat.v1.where(next_time_steps.is_last(), ones, original_td_targets)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(td_targets)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "main.py": {
        "tensorflow": {
            "enable_v2_behavior_15": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "enable_eager_execution_16": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "set_verbosity_17": {
                "level": {
                    "value": "tf.compat.v1.logging.INFO",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "search_policy.py": {
        "tensorflow": {
            "Variable_20": {
                "variable": {
                    "value": "self._train_iter",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_21": {
                "variable": {
                    "value": "self._edge_len_threshold",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "edge_len_threshold",
                    "type": "variable",
                    "possible_values": [
                        [
                            "5.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_22": {
                "variable": {
                    "value": "self._num_points",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "num_points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1000",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Checkpoint_66": {
                "variable": {
                    "value": "self._ckpt",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "CheckpointManager_67": {
                "variable": {
                    "value": "self._manager",
                    "type": "Attribute",
                    "possible_values": []
                },
                "checkpoint": {
                    "value": "self._ckpt",
                    "type": "Attribute",
                    "possible_values": []
                },
                "directory": {
                    "value": "path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "nx.shortest_path(g2, 'start', 'goal')",
                            "Call"
                        ]
                    ]
                },
                "max_to_keep": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_108": {
                "condition": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pairwise_dist > self._edge_len_threshold",
                            "Compare"
                        ]
                    ]
                },
                "x": {
                    "value": "tf.fill(pairwise_dist.shape, np.inf)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "pairwise_dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._agent._get_pairwise_dist(points, aggregate=self._combine_ensemble_method)",
                            "Call"
                        ],
                        [
                            "self._mask(pairwise_dist)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_168": {
                "variable": {
                    "value": "time_step.observation[goal]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "value": {
                    "value": "waypoint[None]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "fill_108": {
                "dims": {
                    "value": "pairwise_dist.shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "np.inf",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_min_128": {
                "input_tensor": {
                    "value": "search_dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sum([tf.expand_dims(obs_to_active_set_dist, 2), tf.expand_dims(self._way_dist, 0), tf.expand_dims(tf.transpose(a=active_set_to_goal_dist), axis=1)])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "argmin_129": {
                "input": {
                    "value": "tf.reduce_min(input_tensor=search_dist, axis=[2])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_122": {
                "input": {
                    "value": "obs_to_active_set_dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._agent._get_pairwise_dist(obs_tensor, self._active_set, aggregate=self._combine_ensemble_method)",
                            "Call"
                        ],
                        [
                            "self._mask(obs_to_active_set_dist)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_123": {
                "input": {
                    "value": "self._way_dist",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_124": {
                "input": {
                    "value": "tf.transpose(a=active_set_to_goal_dist)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_124": {
                "a": {
                    "value": "active_set_to_goal_dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._agent._get_pairwise_dist(self._active_set, goal_tensor, aggregate=self._combine_ensemble_method)",
                            "Call"
                        ],
                        [
                            "self._mask(active_set_to_goal_dist)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_min_130": {
                "input_tensor": {
                    "value": "search_dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sum([tf.expand_dims(obs_to_active_set_dist, 2), tf.expand_dims(self._way_dist, 0), tf.expand_dims(tf.transpose(a=active_set_to_goal_dist), axis=1)])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "train.py": {
        "tensorflow": {
            "get_or_create_global_step_22": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_or_create_global_step_225": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "set_random_seed_19": {
                "seed": {
                    "value": "random_seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "info_230": {
                "msg": {
                    "value": "'\\t dist = %d' % dist",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_243": {
                "msg": {
                    "value": "'\\t\\t predicted_dist = %.1f (%.1f)' % (np.mean(pred_dist), np.std(pred_dist))",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_64": {
                "msg": {
                    "value": "'step = %d' % global_step.numpy()",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_237": {
                "msg": {
                    "value": "\\t\\t %s = %.2f",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "key",
                    "type": "variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "value.numpy()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_67": {
                "msg": {
                    "value": "'\\t dist = %d' % dist",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_80": {
                "msg": {
                    "value": "'\\t\\t predicted_dist = %.1f (%.1f)' % (np.mean(pred_dist), np.std(pred_dist))",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_74": {
                "msg": {
                    "value": "\\t\\t %s = %.2f",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "key",
                    "type": "variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "value.numpy()",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "util.py": {
        "tensorflow": {
            "convert_to_tensor_29": {
                "value": {
                    "value": "state[None]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    }
}