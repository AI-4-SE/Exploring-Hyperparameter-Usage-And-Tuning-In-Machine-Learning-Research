{
    "data.py": {
        "sklearn": {
            "f1_score_631": {
                "variable": {
                    "value": "f1",
                    "type": "variable",
                    "possible_values": []
                },
                "y_true": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[line.rstrip() for line in open(join(data_dir, 'labels.train'))]",
                            "ListComp"
                        ],
                        [
                            "['contradiction', 'entailment', 'neutral']",
                            "List"
                        ],
                        [
                            "[line.rstrip() for line in open(join(data_dir, 'labels.test'))]",
                            "ListComp"
                        ],
                        [
                            "[line.rstrip() for line in open(join(data_dir, 'labels.' + set_type))]",
                            "ListComp"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "preds",
                            "Method Argument"
                        ],
                        [
                            "preds",
                            "Method Argument"
                        ],
                        [
                            "preds",
                            "Method Argument"
                        ],
                        [
                            "preds",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "mixout.py": {
        "torch": {
            "Parameter_86": {
                "variable": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(out_features, in_features)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_88": {
                "variable": {
                    "value": "self.bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(out_features)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "linear_103": {
                "input": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input",
                            "Method Argument"
                        ],
                        [
                            "input",
                            "Method Argument"
                        ],
                        [
                            "input",
                            "Method Argument"
                        ],
                        [
                            "input",
                            "Method Argument"
                        ]
                    ]
                },
                "weight": {
                    "value": "mixout(self.weight, self.target, self.p, self.training)",
                    "type": "Call",
                    "possible_values": []
                },
                "bias": {
                    "value": "self.bias",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "models.py": {
        "torch": {
            "Dropout_12": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "config.hidden_dropout_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softplus_42": {
                "variable": {
                    "value": "std",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "emb2std(emb)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mul_51": {
                "variable": {
                    "value": "mu_diff_sq",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mu_diff",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mu_p - mu_q",
                            "BinOp"
                        ]
                    ]
                },
                "other": {
                    "value": "mu_diff",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mu_p - mu_q",
                            "BinOp"
                        ]
                    ]
                }
            },
            "sum_52": {
                "variable": {
                    "value": "logdet_std_q",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "2 * torch.log(torch.clamp(std_q, min=1e-08))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sum_53": {
                "variable": {
                    "value": "logdet_std_p",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "2 * torch.log(torch.clamp(std_p, min=1e-08))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "randn_60": {
                "variable": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "self.sample_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mu.shape[0]",
                            "Subscript"
                        ],
                        [
                            "pooled_output.shape[0]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "mu.shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "Sequential_22": {
                "variable": {
                    "value": "self.mlp",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(config.hidden_size, intermediate_dim)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Linear_29": {
                "variable": {
                    "value": "self.emb2mu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.hidden_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.ib_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_30": {
                "variable": {
                    "value": "self.emb2std",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.hidden_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.ib_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Parameter_31": {
                "variable": {
                    "value": "self.mu_p",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.randn(self.ib_dim)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_32": {
                "variable": {
                    "value": "self.std_p",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.randn(self.ib_dim)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Linear_33": {
                "variable": {
                    "value": "self.classifier",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.ib_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.config.num_labels",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_35": {
                "variable": {
                    "value": "self.classifier",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.config.num_labels",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Tanh_17": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ReLU_17": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Sigmoid_17": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sum_54": {
                "input": {
                    "value": "torch.div(mu_diff_sq, std_p ** 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "MSELoss_79": {
                "variable": {
                    "value": "loss_fct",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "mean_81": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss_fct(logits.view(-1, self.sample_size), labels[:, None].float().expand(-1, self.sample_size))",
                            "Call"
                        ],
                        [
                            "torch.mean(loss, dim=-1)",
                            "Call"
                        ],
                        [
                            "torch.mean(loss, dim=0)",
                            "Call"
                        ],
                        [
                            "loss_fct(logits, labels[:, None].expand(-1, self.sample_size))",
                            "Call"
                        ],
                        [
                            "torch.mean(loss, dim=-1)",
                            "Call"
                        ],
                        [
                            "torch.mean(loss, dim=0)",
                            "Call"
                        ],
                        [
                            "loss_fct(mean_logits.view(-1), labels.float().view(-1))",
                            "Call"
                        ],
                        [
                            "loss_fct(mean_logits, labels)",
                            "Call"
                        ],
                        [
                            "{}",
                            "Dict"
                        ]
                    ]
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "mean_82": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss_fct(logits.view(-1, self.sample_size), labels[:, None].float().expand(-1, self.sample_size))",
                            "Call"
                        ],
                        [
                            "torch.mean(loss, dim=-1)",
                            "Call"
                        ],
                        [
                            "torch.mean(loss, dim=0)",
                            "Call"
                        ],
                        [
                            "loss_fct(logits, labels[:, None].expand(-1, self.sample_size))",
                            "Call"
                        ],
                        [
                            "torch.mean(loss, dim=-1)",
                            "Call"
                        ],
                        [
                            "torch.mean(loss, dim=0)",
                            "Call"
                        ],
                        [
                            "loss_fct(mean_logits.view(-1), labels.float().view(-1))",
                            "Call"
                        ],
                        [
                            "loss_fct(mean_logits, labels)",
                            "Call"
                        ],
                        [
                            "{}",
                            "Dict"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "CrossEntropyLoss_84": {
                "variable": {
                    "value": "loss_fct",
                    "type": "variable",
                    "possible_values": []
                },
                "reduce": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "mean_86": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss_fct(logits.view(-1, self.sample_size), labels[:, None].float().expand(-1, self.sample_size))",
                            "Call"
                        ],
                        [
                            "torch.mean(loss, dim=-1)",
                            "Call"
                        ],
                        [
                            "torch.mean(loss, dim=0)",
                            "Call"
                        ],
                        [
                            "loss_fct(logits, labels[:, None].expand(-1, self.sample_size))",
                            "Call"
                        ],
                        [
                            "torch.mean(loss, dim=-1)",
                            "Call"
                        ],
                        [
                            "torch.mean(loss, dim=0)",
                            "Call"
                        ],
                        [
                            "loss_fct(mean_logits.view(-1), labels.float().view(-1))",
                            "Call"
                        ],
                        [
                            "loss_fct(mean_logits, labels)",
                            "Call"
                        ],
                        [
                            "{}",
                            "Dict"
                        ]
                    ]
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "mean_87": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss_fct(logits.view(-1, self.sample_size), labels[:, None].float().expand(-1, self.sample_size))",
                            "Call"
                        ],
                        [
                            "torch.mean(loss, dim=-1)",
                            "Call"
                        ],
                        [
                            "torch.mean(loss, dim=0)",
                            "Call"
                        ],
                        [
                            "loss_fct(logits, labels[:, None].expand(-1, self.sample_size))",
                            "Call"
                        ],
                        [
                            "torch.mean(loss, dim=-1)",
                            "Call"
                        ],
                        [
                            "torch.mean(loss, dim=0)",
                            "Call"
                        ],
                        [
                            "loss_fct(mean_logits.view(-1), labels.float().view(-1))",
                            "Call"
                        ],
                        [
                            "loss_fct(mean_logits, labels)",
                            "Call"
                        ],
                        [
                            "{}",
                            "Dict"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "MSELoss_91": {
                "variable": {
                    "value": "loss_fct",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "CrossEntropyLoss_94": {
                "variable": {
                    "value": "loss_fct",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "softplus_168": {
                "variable": {
                    "value": "std_p",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.std_p.view(1, -1).expand(batch_size, -1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Linear_23": {
                "in_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "intermediate_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(self.hidden_dim + config.hidden_size) // 2",
                            "BinOp"
                        ]
                    ]
                }
            },
            "Linear_25": {
                "in_features": {
                    "value": "intermediate_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(self.hidden_dim + config.hidden_size) // 2",
                            "BinOp"
                        ]
                    ]
                },
                "out_features": {
                    "value": "self.hidden_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "randn_31": {
                "*size": {
                    "value": "self.ib_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "randn_32": {
                "*size": {
                    "value": "self.ib_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "log_52": {
                "input": {
                    "value": "torch.clamp(std_q, min=1e-08)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_53": {
                "input": {
                    "value": "torch.clamp(std_p, min=1e-08)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "div_54": {
                "input": {
                    "value": "mu_diff_sq",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.mul(mu_diff, mu_diff)",
                            "Call"
                        ]
                    ]
                },
                "other": {
                    "value": "std_p ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "clamp_52": {
                "input": {
                    "value": "std_q",
                    "type": "variable",
                    "possible_values": [
                        [
                            "std_q",
                            "Method Argument"
                        ]
                    ]
                },
                "min": {
                    "value": "1e-08",
                    "type": "float",
                    "possible_values": []
                }
            },
            "clamp_53": {
                "input": {
                    "value": "std_p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.nn.functional.softplus(self.std_p.view(1, -1).expand(batch_size, -1))",
                            "Call"
                        ],
                        [
                            "std_p",
                            "Method Argument"
                        ]
                    ]
                },
                "min": {
                    "value": "1e-08",
                    "type": "float",
                    "possible_values": []
                }
            },
            "MSELoss_186": {
                "variable": {
                    "value": "loss_fct",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "CrossEntropyLoss_189": {
                "variable": {
                    "value": "loss_fct",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "prior_wd_optim.py": {
        "torch": {}
    },
    "run_glue.py": {
        "torch": {
            "DataLoader_121": {
                "variable": {
                    "value": "train_dataloader",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "train_dataset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "load_and_cache_examples(args, args.task_name, tokenizer, eval_type='train')",
                            "Call"
                        ],
                        [
                            "train_dataset",
                            "Method Argument"
                        ]
                    ]
                },
                "sampler": {
                    "value": "train_sampler",
                    "type": "variable",
                    "possible_values": [
                        [
                            "RandomSampler(train_dataset) if args.local_rank == -1 else DistributedSampler(train_dataset)",
                            "IfExp"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "args.train_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tensor_424": {
                "variable": {
                    "value": "all_input_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "[f.input_ids for f in features]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.long",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tensor_425": {
                "variable": {
                    "value": "all_attention_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "[f.attention_mask for f in features]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.long",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tensor_426": {
                "variable": {
                    "value": "all_token_type_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "[f.token_type_ids for f in features]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.long",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TensorDataset_432": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                },
                "*tensors": {
                    "value": "all_input_ids",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "manual_seed_92": {
                "seed": {
                    "value": "args.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "manual_seed_95": {
                "seed": {
                    "value": "args.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "SummaryWriter_117": {
                "variable": {
                    "value": "tb_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "DataParallel_165": {
                "variable": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": []
                },
                "module": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.nn.DataParallel(model)",
                            "Call"
                        ],
                        [
                            "amp.initialize(model, optimizer, opt_level=args.fp16_opt_level)",
                            "Call"
                        ],
                        [
                            "torch.nn.parallel.DistributedDataParallel(model, device_ids=[args.local_rank], output_device=args.local_rank, find_unused_parameters=True)",
                            "Call"
                        ],
                        [
                            "torch.nn.DataParallel(model)",
                            "Call"
                        ],
                        [
                            "model_class.from_pretrained(args.model_name_or_path, from_tf=bool('.ckpt' in args.model_name_or_path), config=config, cache_dir=args.cache_dir if args.cache_dir else None)",
                            "Call"
                        ],
                        [
                            "model_class.from_pretrained(args.output_dir)",
                            "Call"
                        ],
                        [
                            "model_class.from_pretrained(checkpoint)",
                            "Call"
                        ],
                        [
                            "model",
                            "Method Argument"
                        ],
                        [
                            "model",
                            "Method Argument"
                        ],
                        [
                            "model",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "DistributedDataParallel_169": {
                "variable": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": []
                },
                "module": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.nn.DataParallel(model)",
                            "Call"
                        ],
                        [
                            "amp.initialize(model, optimizer, opt_level=args.fp16_opt_level)",
                            "Call"
                        ],
                        [
                            "torch.nn.parallel.DistributedDataParallel(model, device_ids=[args.local_rank], output_device=args.local_rank, find_unused_parameters=True)",
                            "Call"
                        ],
                        [
                            "torch.nn.DataParallel(model)",
                            "Call"
                        ],
                        [
                            "model_class.from_pretrained(args.model_name_or_path, from_tf=bool('.ckpt' in args.model_name_or_path), config=config, cache_dir=args.cache_dir if args.cache_dir else None)",
                            "Call"
                        ],
                        [
                            "model_class.from_pretrained(args.output_dir)",
                            "Call"
                        ],
                        [
                            "model_class.from_pretrained(checkpoint)",
                            "Call"
                        ],
                        [
                            "model",
                            "Method Argument"
                        ],
                        [
                            "model",
                            "Method Argument"
                        ],
                        [
                            "model",
                            "Method Argument"
                        ]
                    ]
                },
                "device_ids": {
                    "value": "[args.local_rank]",
                    "type": "List",
                    "possible_values": []
                },
                "output_device": {
                    "value": "args.local_rank",
                    "type": "Attribute",
                    "possible_values": []
                },
                "find_unused_parameters": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "load_394": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "cached_features_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "join(data_dir, 'cached_type_{}_task_{}_model_{}'.format(eval_type, task, list(filter(None, args.model_name_or_path.split('/'))).pop()))",
                            "Call"
                        ],
                        [
                            "join(data_dir, 'cached_type_{}_task_{}_sample_train_{}_num_samples_{}_model_{}_data_seed_{}'.format(eval_type, task, args.sample_train, args.num_samples, list(filter(None, args.model_name_or_path.split('/'))).pop(), args.data_seed))",
                            "Call"
                        ],
                        [
                            "join(data_dir, 'cached_type_{}_task_{}_sample_train_{}_num_samples_{}_model_{}'.format(eval_type, task, args.sample_train, args.num_samples, list(filter(None, args.model_name_or_path.split('/'))).pop()))",
                            "Call"
                        ]
                    ]
                }
            },
            "tensor_428": {
                "variable": {
                    "value": "all_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "[f.label for f in features]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.long",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "device_641": {
                "variable": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": []
                },
                "type": {
                    "value": "cuda if torch.cuda.is_available() and (not args.no_cuda) else cpu",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "device_count_642": {
                "variable": {
                    "value": "args.n_gpu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "device_645": {
                "variable": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": []
                },
                "type": {
                    "value": "cuda",
                    "type": "str",
                    "possible_values": []
                },
                "index": {
                    "value": "args.local_rank",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "manual_seed_all_94": {
                "seed": {
                    "value": "args.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "save_110": {
                "obj": {
                    "value": "args",
                    "type": "variable",
                    "possible_values": [
                        [
                            "parser.parse_args()",
                            "Call"
                        ],
                        [
                            "get_args()",
                            "Call"
                        ],
                        [
                            "args",
                            "Method Argument"
                        ],
                        [
                            "args",
                            "Method Argument"
                        ],
                        [
                            "args",
                            "Method Argument"
                        ],
                        [
                            "args",
                            "Method Argument"
                        ],
                        [
                            "args",
                            "Method Argument"
                        ],
                        [
                            "args",
                            "Method Argument"
                        ],
                        [
                            "args",
                            "Method Argument"
                        ]
                    ]
                },
                "f": {
                    "value": "os.path.join(output_dir, 'training_args.bin')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "save_112": {
                "obj": {
                    "value": "optimizer.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "os.path.join(output_dir, 'optimizer.pt')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "save_113": {
                "obj": {
                    "value": "scheduler.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "os.path.join(output_dir, 'scheduler.pt')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "RandomSampler_120": {
                "data_source": {
                    "value": "train_dataset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "load_and_cache_examples(args, args.task_name, tokenizer, eval_type='train')",
                            "Call"
                        ],
                        [
                            "train_dataset",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "DistributedSampler_120": {
                "dataset": {
                    "value": "train_dataset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "load_and_cache_examples(args, args.task_name, tokenizer, eval_type='train')",
                            "Call"
                        ],
                        [
                            "train_dataset",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "SequentialSampler_283": {
                "variable": {
                    "value": "eval_sampler",
                    "type": "variable",
                    "possible_values": []
                },
                "data_source": {
                    "value": "eval_dataset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "load_and_cache_examples(args, eval_task, tokenizer, eval_type)",
                            "Call"
                        ]
                    ]
                }
            },
            "DataLoader_284": {
                "variable": {
                    "value": "eval_dataloader",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "eval_dataset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "load_and_cache_examples(args, eval_task, tokenizer, eval_type)",
                            "Call"
                        ]
                    ]
                },
                "sampler": {
                    "value": "eval_sampler",
                    "type": "variable",
                    "possible_values": [
                        [
                            "SequentialSampler(eval_dataset)",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "args.eval_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cat_337": {
                "variable": {
                    "value": "all_zs[eval_task + _ + eval_type]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "tensors": {
                    "value": "zs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "save_417": {
                "obj": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.load(cached_features_file)",
                            "Call"
                        ],
                        [
                            "convert_examples_to_features(examples, tokenizer, label_list=label_list, max_length=args.max_seq_length, pad_on_left=bool(args.model_type in ['xlnet']), pad_token=tokenizer.convert_tokens_to_ids([tokenizer.pad_token])[0], pad_token_segment_id=4 if args.model_type in ['xlnet'] else 0, output_mode=output_mode, no_label=True if eval_type == 'test' and task in args.glue_tasks else False)",
                            "Call"
                        ]
                    ]
                },
                "f": {
                    "value": "cached_features_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "join(data_dir, 'cached_type_{}_task_{}_model_{}'.format(eval_type, task, list(filter(None, args.model_name_or_path.split('/'))).pop()))",
                            "Call"
                        ],
                        [
                            "join(data_dir, 'cached_type_{}_task_{}_sample_train_{}_num_samples_{}_model_{}_data_seed_{}'.format(eval_type, task, args.sample_train, args.num_samples, list(filter(None, args.model_name_or_path.split('/'))).pop(), args.data_seed))",
                            "Call"
                        ],
                        [
                            "join(data_dir, 'cached_type_{}_task_{}_sample_train_{}_num_samples_{}_model_{}'.format(eval_type, task, args.sample_train, args.num_samples, list(filter(None, args.model_name_or_path.split('/'))).pop()))",
                            "Call"
                        ]
                    ]
                }
            },
            "tensor_430": {
                "variable": {
                    "value": "all_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "[f.label for f in features]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.float",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "set_device_644": {
                "device": {
                    "value": "args.local_rank",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "save_803": {
                "obj": {
                    "value": "args",
                    "type": "variable",
                    "possible_values": [
                        [
                            "parser.parse_args()",
                            "Call"
                        ],
                        [
                            "get_args()",
                            "Call"
                        ],
                        [
                            "args",
                            "Method Argument"
                        ],
                        [
                            "args",
                            "Method Argument"
                        ],
                        [
                            "args",
                            "Method Argument"
                        ],
                        [
                            "args",
                            "Method Argument"
                        ],
                        [
                            "args",
                            "Method Argument"
                        ],
                        [
                            "args",
                            "Method Argument"
                        ],
                        [
                            "args",
                            "Method Argument"
                        ]
                    ]
                },
                "f": {
                    "value": "os.path.join(args.output_dir, 'training_args.bin')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "load_153": {
                "f": {
                    "value": "os.path.join(args.model_name_or_path, 'optimizer.pt')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "load_154": {
                "f": {
                    "value": "os.path.join(args.model_name_or_path, 'scheduler.pt')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "DataParallel_288": {
                "variable": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": []
                },
                "module": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.nn.DataParallel(model)",
                            "Call"
                        ],
                        [
                            "amp.initialize(model, optimizer, opt_level=args.fp16_opt_level)",
                            "Call"
                        ],
                        [
                            "torch.nn.parallel.DistributedDataParallel(model, device_ids=[args.local_rank], output_device=args.local_rank, find_unused_parameters=True)",
                            "Call"
                        ],
                        [
                            "torch.nn.DataParallel(model)",
                            "Call"
                        ],
                        [
                            "model_class.from_pretrained(args.model_name_or_path, from_tf=bool('.ckpt' in args.model_name_or_path), config=config, cache_dir=args.cache_dir if args.cache_dir else None)",
                            "Call"
                        ],
                        [
                            "model_class.from_pretrained(args.output_dir)",
                            "Call"
                        ],
                        [
                            "model_class.from_pretrained(checkpoint)",
                            "Call"
                        ],
                        [
                            "model",
                            "Method Argument"
                        ],
                        [
                            "model",
                            "Method Argument"
                        ],
                        [
                            "model",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "clip_grad_norm__228": {
                "parameters": {
                    "value": "amp.master_params(optimizer)",
                    "type": "Call",
                    "possible_values": []
                },
                "max_norm": {
                    "value": "args.max_grad_norm",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "clip_grad_norm__230": {
                "parameters": {
                    "value": "model.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "max_norm": {
                    "value": "args.max_grad_norm",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "no_grad_300": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "is_available_641": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    }
}