{
    "mesh.py": {
        "tensorflow": {
            "list_physical_devices_76": {
                "variable": {
                    "value": "gpus",
                    "type": "variable",
                    "possible_values": []
                },
                "device_type": {
                    "value": "GPU",
                    "type": "str",
                    "possible_values": []
                }
            },
            "set_memory_growth_80": {
                "device": {
                    "value": "gpu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gpus",
                            "Name"
                        ]
                    ]
                },
                "enable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "training/callbacks/classification_images.py": {
        "tensorflow": {
            "create_file_writer_36": {
                "variable": {
                    "value": "self.writer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logdir": {
                    "value": "os.path.join(output_path, 'images')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_45": {
                "variable": {
                    "value": "self.Hoc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "data['Hoc']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, 4, 4)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_46": {
                "variable": {
                    "value": "self.img",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "data['jpg']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_102": {
                "tensor": {
                    "value": "tf.io.decode_raw(data.read(), tf.uint8)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(height, width, 4)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "decode_raw_102": {
                "input_bytes": {
                    "value": "data.read()",
                    "type": "Call",
                    "possible_values": []
                },
                "out_type": {
                    "value": "tf.uint8",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "image_124": {
                "name": {
                    "value": "'images/{}'.format(i)",
                    "type": "Call",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.expand_dims(img[1], axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "step": {
                    "value": "epoch",
                    "type": "variable",
                    "possible_values": []
                },
                "max_outputs": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_124": {
                "input": {
                    "value": "img[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_49": {
                "tensor": {
                    "value": "data['n']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            }
        }
    },
    "training/callbacks/image_tensorboard.py": {
        "tensorflow": {
            "image_53": {
                "name": {
                    "value": "m.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "m.images(logs[m.name])",
                    "type": "Call",
                    "possible_values": []
                },
                "step": {
                    "value": "epoch",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "image_58": {
                "name": {
                    "value": "m.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "m.images(logs['val_{}'.format(m.name)])",
                    "type": "Call",
                    "possible_values": []
                },
                "step": {
                    "value": "epoch",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "training/callbacks/one_cycle.py": {
        "tensorflow": {}
    },
    "training/callbacks/seeker_images.py": {
        "tensorflow": {
            "create_file_writer_36": {
                "variable": {
                    "value": "self.writer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logdir": {
                    "value": "os.path.join(output_path, 'images')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_45": {
                "variable": {
                    "value": "self.Hoc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "data['Hoc']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, 4, 4)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_46": {
                "variable": {
                    "value": "self.img",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "data['jpg']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "concat_58": {
                "variable": {
                    "value": "self.nm",
                    "type": "Attribute",
                    "possible_values": []
                },
                "values": {
                    "value": "[unmap_visual_mesh(data['V'][r[0]:r[1]], height=self.Hoc[i][2, 3], **self.map_args) for (i, r) in enumerate(self.ranges)]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reciprocal_78": {
                "variable": {
                    "value": "px_angle",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "f",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lens['focal_length']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "linspace_85": {
                "variable": {
                    "value": "theta",
                    "type": "variable",
                    "possible_values": []
                },
                "start": {
                    "value": "angle - 0.5 * width * px_angle",
                    "type": "BinOp",
                    "possible_values": []
                },
                "stop": {
                    "value": "angle + 0.5 * width * px_angle",
                    "type": "BinOp",
                    "possible_values": []
                },
                "num": {
                    "value": "2 * width",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_87": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.sin(theta)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "linspace_91": {
                "variable": {
                    "value": "psi",
                    "type": "variable",
                    "possible_values": []
                },
                "start": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stop": {
                    "value": "2.0 * math.pi",
                    "type": "BinOp",
                    "possible_values": []
                },
                "num": {
                    "value": "pts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "2 * tf.cast(2.0 * math.pi * f * tf.math.tan(angle), dtype=tf.int32)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "gather_102": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(X, on_screen)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "on_screen",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._on_screen(px, dims)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_103": {
                "variable": {
                    "value": "Y",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "Y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(Y, on_screen)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(Y, tf.stack([tf.range(tf.shape(Y)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(X, axis=-2), Y), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "on_screen",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._on_screen(px, dims)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_104": {
                "variable": {
                    "value": "px",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "px",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(px, on_screen)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "on_screen",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._on_screen(px, dims)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_all_107": {
                "variable": {
                    "value": "X_near",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.math.abs(X) <= 0.75",
                    "type": "Compare",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_all_108": {
                "variable": {
                    "value": "Y_near",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.math.abs(Y) <= 0.75",
                    "type": "Compare",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "squeeze_111": {
                "variable": {
                    "value": "tp",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.where(tf.logical_and(X_near, Y_near))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "squeeze_112": {
                "variable": {
                    "value": "fp",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.where(tf.logical_and(X_near, tf.logical_not(Y_near)))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "squeeze_113": {
                "variable": {
                    "value": "fn",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.where(tf.logical_and(tf.logical_not(X_near), Y_near))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "squeeze_114": {
                "variable": {
                    "value": "tn",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.where(tf.logical_and(tf.logical_not(X_near), tf.logical_not(Y_near)))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "clip_by_value_117": {
                "variable": {
                    "value": "weight",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "1.0 - tf.norm(X, axis=-1) / math.sqrt(2.0 * 0.75 ** 2.0)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "scatter_nd_120": {
                "variable": {
                    "value": "tp",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.gather(px, tp)",
                    "type": "Call",
                    "possible_values": []
                },
                "updates": {
                    "value": "tf.gather(weight, tp)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "dims",
                    "type": "variable",
                    "possible_values": [
                        [
                            "img.shape[:2]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scatter_nd_121": {
                "variable": {
                    "value": "fp",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.gather(px, fp)",
                    "type": "Call",
                    "possible_values": []
                },
                "updates": {
                    "value": "tf.gather(weight, fp)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "dims",
                    "type": "variable",
                    "possible_values": [
                        [
                            "img.shape[:2]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scatter_nd_122": {
                "variable": {
                    "value": "fn",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.gather(px, fn)",
                    "type": "Call",
                    "possible_values": []
                },
                "updates": {
                    "value": "tf.gather(weight, fn)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "dims",
                    "type": "variable",
                    "possible_values": [
                        [
                            "img.shape[:2]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "einsum_125": {
                "variable": {
                    "value": "tp",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ij,k->ijk",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "tp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.where(tf.logical_and(X_near, Y_near)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(tf.gather(px, tp), tf.gather(weight, tp), dims)",
                            "Call"
                        ],
                        [
                            "tf.einsum('ij,k->ijk', tp, tf.constant([1.0, 1.0, 0.0]))",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "tf.constant([1.0, 1.0, 0.0])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "einsum_126": {
                "variable": {
                    "value": "fp",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ij,k->ijk",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "fp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.where(tf.logical_and(X_near, tf.logical_not(Y_near))), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(tf.gather(px, fp), tf.gather(weight, fp), dims)",
                            "Call"
                        ],
                        [
                            "tf.einsum('ij,k->ijk', fp, tf.constant([1.0, 0.0, 0.0]))",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "tf.constant([1.0, 0.0, 0.0])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "einsum_127": {
                "variable": {
                    "value": "fn",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ij,k->ijk",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "fn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.where(tf.logical_and(tf.logical_not(X_near), Y_near)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(tf.gather(px, fn), tf.gather(weight, fn), dims)",
                            "Call"
                        ],
                        [
                            "tf.einsum('ij,k->ijk', fn, tf.constant([0.0, 0.0, 1.0]))",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "tf.constant([0.0, 0.0, 1.0])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_nd_139": {
                "variable": {
                    "value": "Y",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "Y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(Y, on_screen)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(Y, tf.stack([tf.range(tf.shape(Y)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(X, axis=-2), Y), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.stack([tf.range(tf.shape(Y)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(X, axis=-2), Y), axis=-1), axis=-1, output_type=tf.int32)], axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_image_dtype_160": {
                "variable": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "tf.image.decode_image(img, channels=3, expand_animations=False)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "einsum_171": {
                "variable": {
                    "value": "uTCc",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ij,ki->kj",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "Hoc[:3, :3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "uTCo",
                    "type": "variable",
                    "possible_values": [
                        [
                            "map_visual_mesh(nm + X * self.scale, height=Hoc[2, 3], **self.map_args)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_172": {
                "variable": {
                    "value": "target_px",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.round(project(uTCc, dims, projection, f, centre, k))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "einsum_179": {
                "variable": {
                    "value": "uRCc",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ij,ki->kj",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "Hoc[:3, :3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "uRCo",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._ring(angle=tf.atan(self.max_distance / Hoc[2, 3]), width=2, f=f)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_180": {
                "variable": {
                    "value": "ring_px",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.round(project(uRCc, dims, projection, f, centre, k))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_183": {
                "variable": {
                    "value": "ring_px",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "ring_px",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.round(project(uRCc, dims, projection, f, centre, k)), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.gather(ring_px, self._on_screen(ring_px, dims))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "self._on_screen(ring_px, dims)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scatter_nd_184": {
                "variable": {
                    "value": "ring_overlay",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "ring_px",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.round(project(uRCc, dims, projection, f, centre, k)), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.gather(ring_px, self._on_screen(ring_px, dims))",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "tf.ones_like(ring_px[:, 0], dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "dims",
                    "type": "variable",
                    "possible_values": [
                        [
                            "img.shape[:2]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "clip_by_value_187": {
                "variable": {
                    "value": "ring_overlay",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "tf.einsum('ij,k->ijk', ring_overlay, tf.constant([1.0, 1.0, 1.0]))",
                    "type": "Call",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "squeeze_69": {
                "input": {
                    "value": "tf.where(tf.reduce_all(tf.logical_and(px >= 0, px <= tf.expand_dims(dims, 0)), axis=-1))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_95": {
                "tensor": {
                    "value": "tf.stack([x, y, tf.broadcast_to(tf.expand_dims(z, axis=1), x.shape)], axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "clip_by_value_130": {
                "t": {
                    "value": "tp + fp + fn",
                    "type": "BinOp",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reshape_48": {
                "tensor": {
                    "value": "data['lens']['projection']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_49": {
                "tensor": {
                    "value": "data['lens']['focal_length']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_50": {
                "tensor": {
                    "value": "data['lens']['centre']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_51": {
                "tensor": {
                    "value": "data['lens']['k']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_52": {
                "tensor": {
                    "value": "data['lens']['fov']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "where_70": {
                "condition": {
                    "value": "tf.reduce_all(tf.logical_and(px >= 0, px <= tf.expand_dims(dims, 0)), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_81": {
                "x": {
                    "value": "2.0 * math.pi * f * tf.math.tan(angle)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cos_86": {
                "x": {
                    "value": "theta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linspace(angle - 0.5 * width * px_angle, angle + 0.5 * width * px_angle, 2 * width)",
                            "Call"
                        ]
                    ]
                }
            },
            "sin_87": {
                "x": {
                    "value": "theta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linspace(angle - 0.5 * width * px_angle, angle + 0.5 * width * px_angle, 2 * width)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_92": {
                "input": {
                    "value": "tf.cos(psi)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_93": {
                "input": {
                    "value": "tf.sin(psi)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_95": {
                "values": {
                    "value": "[x, y, tf.broadcast_to(tf.expand_dims(z, axis=1), x.shape)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "where_111": {
                "condition": {
                    "value": "tf.logical_and(X_near, Y_near)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_112": {
                "condition": {
                    "value": "tf.logical_and(X_near, tf.logical_not(Y_near))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_113": {
                "condition": {
                    "value": "tf.logical_and(tf.logical_not(X_near), Y_near)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_114": {
                "condition": {
                    "value": "tf.logical_and(tf.logical_not(X_near), tf.logical_not(Y_near))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_120": {
                "params": {
                    "value": "weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.clip_by_value(1.0 - tf.norm(X, axis=-1) / math.sqrt(2.0 * 0.75 ** 2.0), 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.where(tf.logical_and(X_near, Y_near)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(tf.gather(px, tp), tf.gather(weight, tp), dims)",
                            "Call"
                        ],
                        [
                            "tf.einsum('ij,k->ijk', tp, tf.constant([1.0, 1.0, 0.0]))",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_121": {
                "params": {
                    "value": "weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.clip_by_value(1.0 - tf.norm(X, axis=-1) / math.sqrt(2.0 * 0.75 ** 2.0), 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "fp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.where(tf.logical_and(X_near, tf.logical_not(Y_near))), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(tf.gather(px, fp), tf.gather(weight, fp), dims)",
                            "Call"
                        ],
                        [
                            "tf.einsum('ij,k->ijk', fp, tf.constant([1.0, 0.0, 0.0]))",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_122": {
                "params": {
                    "value": "weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.clip_by_value(1.0 - tf.norm(X, axis=-1) / math.sqrt(2.0 * 0.75 ** 2.0), 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "fn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.where(tf.logical_and(tf.logical_not(X_near), Y_near)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(tf.gather(px, fn), tf.gather(weight, fn), dims)",
                            "Call"
                        ],
                        [
                            "tf.einsum('ij,k->ijk', fn, tf.constant([0.0, 0.0, 1.0]))",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_125": {
                "value": {
                    "value": "[1.0, 1.0, 0.0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_126": {
                "value": {
                    "value": "[1.0, 0.0, 0.0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_127": {
                "value": {
                    "value": "[0.0, 0.0, 1.0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_141": {
                "values": {
                    "value": "[tf.range(tf.shape(Y)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(X, axis=-2), Y), axis=-1), axis=-1, output_type=tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "decode_image_160": {
                "contents": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.convert_image_dtype(tf.image.decode_image(img, channels=3, expand_animations=False), tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "expand_animations": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "round_172": {
                "x": {
                    "value": "project(uTCc, dims, projection, f, centre, k)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "round_180": {
                "x": {
                    "value": "project(uRCc, dims, projection, f, centre, k)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_like_184": {
                "input": {
                    "value": "ring_px[:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "einsum_187": {
                "equation": {
                    "value": "ij,k->ijk",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "ring_overlay",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.scatter_nd(ring_px, tf.ones_like(ring_px[:, 0], dtype=tf.float32), dims)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(tf.einsum('ij,k->ijk', ring_overlay, tf.constant([1.0, 1.0, 1.0])), 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "tf.constant([1.0, 1.0, 1.0])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_all_70": {
                "input_tensor": {
                    "value": "tf.logical_and(px >= 0, px <= tf.expand_dims(dims, 0))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cos_92": {
                "x": {
                    "value": "psi",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linspace(0.0, 2.0 * math.pi, pts)",
                            "Call"
                        ]
                    ]
                }
            },
            "sin_93": {
                "x": {
                    "value": "psi",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linspace(0.0, 2.0 * math.pi, pts)",
                            "Call"
                        ]
                    ]
                }
            },
            "abs_107": {
                "x": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(X, on_screen)",
                            "Call"
                        ]
                    ]
                }
            },
            "abs_108": {
                "x": {
                    "value": "Y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(Y, on_screen)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(Y, tf.stack([tf.range(tf.shape(Y)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(X, axis=-2), Y), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_and_111": {
                "x": {
                    "value": "X_near",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_all(tf.math.abs(X) <= 0.75, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "Y_near",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_all(tf.math.abs(Y) <= 0.75, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_and_112": {
                "x": {
                    "value": "X_near",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_all(tf.math.abs(X) <= 0.75, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.logical_not(Y_near)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_and_113": {
                "x": {
                    "value": "tf.logical_not(X_near)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "Y_near",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_all(tf.math.abs(Y) <= 0.75, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_and_114": {
                "x": {
                    "value": "tf.logical_not(X_near)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.logical_not(Y_near)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "atan_178": {
                "x": {
                    "value": "self.max_distance / Hoc[2, 3]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_187": {
                "value": {
                    "value": "[1.0, 1.0, 1.0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "image_218": {
                "name": {
                    "value": "'images/{}'.format(i)",
                    "type": "Call",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.expand_dims(img[1], axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "step": {
                    "value": "epoch",
                    "type": "variable",
                    "possible_values": []
                },
                "max_outputs": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "logical_and_70": {
                "x": {
                    "value": "px >= 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "px <= tf.expand_dims(dims, 0)",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "tan_81": {
                "x": {
                    "value": "angle",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "broadcast_to_95": {
                "input": {
                    "value": "tf.expand_dims(z, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "x.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "logical_not_112": {
                "x": {
                    "value": "Y_near",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_all(tf.math.abs(Y) <= 0.75, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_not_113": {
                "x": {
                    "value": "X_near",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_all(tf.math.abs(X) <= 0.75, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_not_114": {
                "x": {
                    "value": "Y_near",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_all(tf.math.abs(Y) <= 0.75, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "norm_117": {
                "tensor": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(X, on_screen)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_max_133": {
                "input_tensor": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "range_143": {
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmin_144": {
                "input": {
                    "value": "tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(X, axis=-2), Y), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_218": {
                "input": {
                    "value": "img[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_95": {
                "input": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.cos(theta)",
                            "UnaryOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_145": {
                "input_tensor": {
                    "value": "tf.math.squared_difference(tf.expand_dims(X, axis=-2), Y)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_70": {
                "input": {
                    "value": "dims",
                    "type": "variable",
                    "possible_values": [
                        [
                            "img.shape[:2]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_143": {
                "input": {
                    "value": "Y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(Y, on_screen)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(Y, tf.stack([tf.range(tf.shape(Y)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(X, axis=-2), Y), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ]
                    ]
                }
            },
            "squared_difference_145": {
                "x": {
                    "value": "tf.expand_dims(X, axis=-2)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "Y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(Y, on_screen)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(Y, tf.stack([tf.range(tf.shape(Y)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(X, axis=-2), Y), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_145": {
                "input": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(X, on_screen)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "training/dataset/example/image.py": {
        "tensorflow": {
            "floor_27": {
                "variable": {
                    "value": "y_0",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "C[:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "floor_28": {
                "variable": {
                    "value": "x_0",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "C[:, 1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "decode_image_70": {
                "variable": {
                    "value": "decoded",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.adjust_brightness(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_contrast(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_hue(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_saturation(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_gamma(image, tf.random.truncated_normal(shape=(), **v_gamma), tf.random.truncated_normal(shape=(), **v_gain))",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "expand_animations": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_71": {
                "variable": {
                    "value": "dimensions",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "decoded",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.io.decode_image(image, channels=3, expand_animations=False, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(decoded, (dimensions[0], dimensions[1], 3))",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_72": {
                "variable": {
                    "value": "decoded",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "decoded",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.io.decode_image(image, channels=3, expand_animations=False, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(decoded, (dimensions[0], dimensions[1], 3))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(dimensions[0], dimensions[1], 3)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "add_n_60": {
                "inputs": {
                    "value": "p_weighted",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.multiply(val, tf.expand_dims(w, axis=-1)) for (val, w) in zip(p_val, [tf.multiply(1.0 - y_w, 1.0 - x_w), tf.multiply(1.0 - y_w, x_w), tf.multiply(y_w, 1.0 - x_w), tf.multiply(y_w, x_w)])]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "adjust_brightness_85": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.adjust_brightness(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_contrast(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_hue(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_saturation(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_gamma(image, tf.random.truncated_normal(shape=(), **v_gamma), tf.random.truncated_normal(shape=(), **v_gain))",
                            "Call"
                        ]
                    ]
                },
                "delta": {
                    "value": "tf.random.truncated_normal(shape=(), **v)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "adjust_contrast_88": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.adjust_brightness(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_contrast(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_hue(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_saturation(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_gamma(image, tf.random.truncated_normal(shape=(), **v_gamma), tf.random.truncated_normal(shape=(), **v_gain))",
                            "Call"
                        ]
                    ]
                },
                "contrast_factor": {
                    "value": "tf.random.truncated_normal(shape=(), **v)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "adjust_hue_91": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.adjust_brightness(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_contrast(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_hue(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_saturation(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_gamma(image, tf.random.truncated_normal(shape=(), **v_gamma), tf.random.truncated_normal(shape=(), **v_gain))",
                            "Call"
                        ]
                    ]
                },
                "delta": {
                    "value": "tf.random.truncated_normal(shape=(), **v)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "adjust_saturation_94": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.adjust_brightness(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_contrast(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_hue(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_saturation(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_gamma(image, tf.random.truncated_normal(shape=(), **v_gamma), tf.random.truncated_normal(shape=(), **v_gain))",
                            "Call"
                        ]
                    ]
                },
                "saturation_factor": {
                    "value": "tf.random.truncated_normal(shape=(), **v)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "adjust_gamma_98": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.adjust_brightness(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_contrast(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_hue(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_saturation(image, tf.random.truncated_normal(shape=(), **v))",
                            "Call"
                        ],
                        [
                            "tf.image.adjust_gamma(image, tf.random.truncated_normal(shape=(), **v_gamma), tf.random.truncated_normal(shape=(), **v_gain))",
                            "Call"
                        ]
                    ]
                },
                "gamma": {
                    "value": "tf.random.truncated_normal(shape=(), **v_gamma)",
                    "type": "Call",
                    "possible_values": []
                },
                "gain": {
                    "value": "tf.random.truncated_normal(shape=(), **v_gain)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "clip_by_value_34": {
                "t": {
                    "value": "tf.cast(tf.stack([a, b], axis=-1), tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "[[0, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "[tf.shape(img)[:2] - 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_nd_43": {
                "params": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "multiply_47": {
                "x": {
                    "value": "val",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.expand_dims(w, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "FixedLenFeature_64": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_34": {
                "x": {
                    "value": "tf.stack([a, b], axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_47": {
                "input": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "truncated_normal_85": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "truncated_normal_88": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "truncated_normal_91": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "truncated_normal_94": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "truncated_normal_99": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "stack_34": {
                "values": {
                    "value": "[a, b]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "multiply_51": {
                "x": {
                    "value": "1.0 - y_w",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "1.0 - x_w",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "multiply_52": {
                "x": {
                    "value": "1.0 - y_w",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "x_w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "C[:, 1] - x_0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "multiply_53": {
                "x": {
                    "value": "y_w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "C[:, 0] - y_0",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "1.0 - x_w",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "multiply_54": {
                "x": {
                    "value": "y_w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "C[:, 0] - y_0",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "x_w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "C[:, 1] - x_0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_34": {
                "input": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "training/dataset/label/classification.py": {
        "tensorflow": {
            "decode_png_31": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_png(mask, channels=4)",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_nd_32": {
                "variable": {
                    "value": "Y",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_png(mask, channels=4)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.clip_by_value(tf.cast(tf.round(C), tf.int32), [[0, 0]], [tf.shape(mask)[:2] - 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_image_dtype_35": {
                "variable": {
                    "value": "W",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "Y[:, 3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_54": {
                "variable": {
                    "value": "Y",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "cs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "FixedLenFeature_25": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "clip_by_value_32": {
                "t": {
                    "value": "tf.cast(tf.round(C), tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "[[0, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "[tf.shape(mask)[:2] - 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_32": {
                "x": {
                    "value": "tf.round(C)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_39": {
                "condition": {
                    "value": "tf.logical_and(tf.reduce_any(tf.stack([tf.reduce_all(input_tensor=tf.equal(Y[:, :3], [v]), axis=-1) for v in c['colours']], axis=-1), axis=-1), tf.greater(W, 0.0))",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "round_32": {
                "x": {
                    "value": "C",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "logical_and_40": {
                "x": {
                    "value": "tf.reduce_any(tf.stack([tf.reduce_all(input_tensor=tf.equal(Y[:, :3], [v]), axis=-1) for v in c['colours']], axis=-1), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.greater(W, 0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_any_41": {
                "input_tensor": {
                    "value": "tf.stack([tf.reduce_all(input_tensor=tf.equal(Y[:, :3], [v]), axis=-1) for v in c['colours']], axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "greater_48": {
                "x": {
                    "value": "W",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.convert_image_dtype(Y[:, 3], tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "shape_32": {
                "input": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_png(mask, channels=4)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_42": {
                "values": {
                    "value": "[tf.reduce_all(input_tensor=tf.equal(Y[:, :3], [v]), axis=-1) for v in c['colours']]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_all_43": {
                "input_tensor": {
                    "value": "tf.equal(Y[:, :3], [v])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "equal_43": {
                "x": {
                    "value": "Y[:, :3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "[v]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "training/dataset/label/seeker.py": {
        "tensorflow": {
            "constant_29": {
                "variable": {
                    "value": "self.geometry",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "geometry['shape']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "GeometryType",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_50": {
                "variable": {
                    "value": "px",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.round(project(targets, dims, projection, focal_length, centre, k))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_all_51": {
                "variable": {
                    "value": "on_screen",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.logical_and(px >= 0, px < tf.expand_dims(dims, 0))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_52": {
                "variable": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features['seeker/targets']",
                            "Subscript"
                        ],
                        [
                            "tf.gather(targets, tf.squeeze(tf.where(on_screen), axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.squeeze(tf.where(on_screen), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "normalize_55": {
                "variable": {
                    "value": "(uOCo, l)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.einsum('ij,kj->ki', Hoc[:3, :3], targets)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_60": {
                "variable": {
                    "value": "uOCo",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "uOCo",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(uOCo, tf.squeeze(tf.where(tf.logical_and(ratio > self.min_ratio, ratio < self.max_ratio)), axis=-1))",
                            "Call"
                        ],
                        [
                            "tf.gather(uOCo, tf.squeeze(tf.where(uOCo[:, 2] < 0), axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.squeeze(tf.where(tf.logical_and(ratio > self.min_ratio, ratio < self.max_ratio)), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_65": {
                "variable": {
                    "value": "uOCo",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "uOCo",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(uOCo, tf.squeeze(tf.where(tf.logical_and(ratio > self.min_ratio, ratio < self.max_ratio)), axis=-1))",
                            "Call"
                        ],
                        [
                            "tf.gather(uOCo, tf.squeeze(tf.where(uOCo[:, 2] < 0), axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.squeeze(tf.where(uOCo[:, 2] < 0), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_76": {
                "variable": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.tile(mesh_nm, (1, n_targets))",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "tile_77": {
                "variable": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "target_nm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "unmap_visual_mesh(uOCo, **args)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "(n_nodes, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_80": {
                "variable": {
                    "value": "diff",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "difference_visual_mesh(t, m, **args)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(n_nodes, n_targets, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "cond_91": {
                "variable": {
                    "value": "distance",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.size(distance) > 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : distance",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "random_distance",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "uniform_88": {
                "variable": {
                    "value": "theta",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[tf.shape(distance)[0], 1]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "-math.pi",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "math.pi",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenSequenceFeature_36": {
                "shape": {
                    "value": "[3]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "allow_missing": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_46": {
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "round_50": {
                "x": {
                    "value": "project(targets, dims, projection, focal_length, centre, k)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_and_51": {
                "x": {
                    "value": "px >= 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "px < tf.expand_dims(dims, 0)",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "squeeze_52": {
                "input": {
                    "value": "tf.where(on_screen)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "einsum_55": {
                "equation": {
                    "value": "ij,kj->ki",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "Hoc[:3, :3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features['seeker/targets']",
                            "Subscript"
                        ],
                        [
                            "tf.gather(targets, tf.squeeze(tf.where(on_screen), axis=-1))",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_59": {
                "input": {
                    "value": "l",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "squeeze_61": {
                "input": {
                    "value": "tf.where(tf.logical_and(ratio > self.min_ratio, ratio < self.max_ratio))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "squeeze_65": {
                "input": {
                    "value": "tf.where(uOCo[:, 2] < 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_74": {
                "input": {
                    "value": "mesh_nm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "unmap_visual_mesh(V, **args)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_75": {
                "input": {
                    "value": "target_nm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "unmap_visual_mesh(uOCo, **args)",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_76": {
                "input": {
                    "value": "mesh_nm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "unmap_visual_mesh(V, **args)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "(1, n_targets)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "where_52": {
                "condition": {
                    "value": "on_screen",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_all(tf.logical_and(px >= 0, px < tf.expand_dims(dims, 0)), axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_61": {
                "condition": {
                    "value": "tf.logical_and(ratio > self.min_ratio, ratio < self.max_ratio)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_65": {
                "condition": {
                    "value": "uOCo[:, 2] < 0",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "stack_89": {
                "values": {
                    "value": "[tf.cos(theta), tf.sin(theta)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "size_91": {
                "input": {
                    "value": "distance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "diff / self.scale",
                            "BinOp"
                        ],
                        [
                            "tf.cond(tf.size(distance) > 0, lambda : distance, random_distance)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_51": {
                "input": {
                    "value": "dims",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(image)[:2]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "logical_and_61": {
                "x": {
                    "value": "ratio > self.min_ratio",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "ratio < self.max_ratio",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "shape_88": {
                "input": {
                    "value": "distance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "diff / self.scale",
                            "BinOp"
                        ],
                        [
                            "tf.cond(tf.size(distance) > 0, lambda : distance, random_distance)",
                            "Call"
                        ]
                    ]
                }
            },
            "cos_89": {
                "x": {
                    "value": "theta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random.uniform([tf.shape(distance)[0], 1], -math.pi, math.pi)",
                            "Call"
                        ]
                    ]
                }
            },
            "sin_89": {
                "x": {
                    "value": "theta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random.uniform([tf.shape(distance)[0], 1], -math.pi, math.pi)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "training/dataset/orientation/ground.py": {
        "tensorflow": {
            "tensor_scatter_nd_add_36": {
                "variable": {
                    "value": "Hoc",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "Hoc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensor_scatter_nd_add(Hoc, [[3, 2]], tf.expand_dims(tf.random.truncated_normal(shape=(), mean=v['mean'], stddev=v['stddev']), 0))",
                            "Call"
                        ],
                        [
                            "tf.matmul(random_rotation(v['mean'], v['stddev']), Hoc)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "[[3, 2]]",
                    "type": "List",
                    "possible_values": []
                },
                "updates": {
                    "value": "tf.expand_dims(tf.random.truncated_normal(shape=(), mean=v['mean'], stddev=v['stddev']), 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_46": {
                "variable": {
                    "value": "Hoc",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "random_rotation(v['mean'], v['stddev'])",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "Hoc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensor_scatter_nd_add(Hoc, [[3, 2]], tf.expand_dims(tf.random.truncated_normal(shape=(), mean=v['mean'], stddev=v['stddev']), 0))",
                            "Call"
                        ],
                        [
                            "tf.matmul(random_rotation(v['mean'], v['stddev']), Hoc)",
                            "Call"
                        ]
                    ]
                }
            },
            "FixedLenFeature_27": {
                "shape": {
                    "value": "[4, 4]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_39": {
                "input": {
                    "value": "tf.random.truncated_normal(shape=(), mean=v['mean'], stddev=v['stddev'])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "truncated_normal_39": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "mean": {
                    "value": "v['mean']",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "self.augmentations['height']",
                            "Subscript"
                        ],
                        [
                            "self.augmentations['rotation']",
                            "Subscript"
                        ]
                    ]
                },
                "stddev": {
                    "value": "v['stddev']",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "self.augmentations['height']",
                            "Subscript"
                        ],
                        [
                            "self.augmentations['rotation']",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "training/dataset/orientation/random_rotation.py": {
        "tensorflow": {
            "uniform_23": {
                "variable": {
                    "value": "uv",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "acos_28": {
                "variable": {
                    "value": "phi",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "2.0 * uv[1] - 1.0",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "truncated_normal_40": {
                "variable": {
                    "value": "angle",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "mean": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": []
                },
                "stddev": {
                    "value": "stddev",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cos_41": {
                "variable": {
                    "value": "ca",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "angle",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random.truncated_normal((), mean, stddev)",
                            "Call"
                        ]
                    ]
                }
            },
            "sin_43": {
                "variable": {
                    "value": "sa",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "angle",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random.truncated_normal((), mean, stddev)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_46": {
                "value": {
                    "value": "[[ux * ux * ia + ca, uy * ux * ia - uz * sa, uz * ux * ia + uy * sa, 0.0], [ux * uy * ia + uz * sa, uy * uy * ia + ca, uz * uy * ia - ux * sa, 0.0], [ux * uz * ia - uy * sa, uy * uz * ia + ux * sa, uz * uz * ia + ca, 0.0], [0.0, 0.0, 0.0, 1.0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cos_31": {
                "x": {
                    "value": "phi",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.acos(2.0 * uv[1] - 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "sin_31": {
                "x": {
                    "value": "phi",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.acos(2.0 * uv[1] - 1.0)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "training/dataset/orientation/spotlight.py": {
        "tensorflow": {
            "normalize_93": {
                "variable": {
                    "value": "(z, h)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensor": {
                    "value": "-rOCc",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "normalize_103": {
                "variable": {
                    "value": "(y, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.linalg.cross(z, world_z)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "normalize_104": {
                "variable": {
                    "value": "(x, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.linalg.cross(y, z)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stack_107": {
                "variable": {
                    "value": "Roc",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x, y, z]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_108": {
                "variable": {
                    "value": "spotlight_Hoc",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.pad(Roc, [[0, 1], [0, 0]]), tf.convert_to_tensor([[0], [0], h, [1]], Roc.dtype)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "FixedLenFeature_33": {
                "variable": {
                    "value": "f[lens/fov]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "squeeze_80": {
                "variable": {
                    "value": "world_z",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.matmul(random_rotation(v['mean'], v['stddev'])[:3, :3], tf.expand_dims(world_z, -1))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "FixedLenFeature_29": {
                "shape": {
                    "value": "[4, 4]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenSequenceFeature_30": {
                "shape": {
                    "value": "[3]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "allow_missing": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "uniform_47": {
                "variable": {
                    "value": "r",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "minval": {
                    "value": "p['limits'][0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "maxval": {
                    "value": "p['limits'][1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "uniform_50": {
                "variable": {
                    "value": "theta",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "fov",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features['lens/fov']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "uniform_51": {
                "variable": {
                    "value": "psi",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "minval": {
                    "value": "-math.pi",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "math.pi",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_54": {
                "variable": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[targets, tf.expand_dims(tf.stack([r * tf.math.cos(theta), r * tf.math.cos(psi) * tf.math.sin(theta), r * tf.math.sin(psi) * tf.math.sin(theta)], axis=0), axis=0)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "uniform_85": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "tf.shape(targets)[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "clip_by_value_99": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.clip_by_value(h, tf.constant(v['limits'][0], dtype=h.dtype), tf.constant(v['limits'][1], dtype=h.dtype))",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "tf.constant(v['limits'][0], dtype=h.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "tf.constant(v['limits'][1], dtype=h.dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cross_103": {
                "a": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "world_z",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Hoc[2, :3]",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(tf.matmul(random_rotation(v['mean'], v['stddev'])[:3, :3], tf.expand_dims(world_z, -1)), -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "cross_104": {
                "a": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "matmul_81": {
                "a": {
                    "value": "random_rotation(v['mean'], v['stddev'])[:3, :3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "tf.expand_dims(world_z, -1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "pad_109": {
                "tensor": {
                    "value": "Roc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([x, y, z], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 1], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "convert_to_tensor_109": {
                "value": {
                    "value": "[[0], [0], h, [1]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "Roc.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_81": {
                "input": {
                    "value": "world_z",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Hoc[2, :3]",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(tf.matmul(random_rotation(v['mean'], v['stddev'])[:3, :3], tf.expand_dims(world_z, -1)), -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_85": {
                "input": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features['spotlight/targets']",
                            "Subscript"
                        ],
                        [
                            "tf.concat([targets, tf.expand_dims(tf.stack([r * tf.math.cos(theta), r * tf.math.cos(psi) * tf.math.sin(theta), r * tf.math.sin(psi) * tf.math.sin(theta)], axis=0), axis=0)], axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "truncated_normal_90": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "mean": {
                    "value": "v['mean']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "stddev": {
                    "value": "v['stddev']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "constant_100": {
                "value": {
                    "value": "v['limits'][1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "h.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_57": {
                "input": {
                    "value": "tf.stack([r * tf.math.cos(theta), r * tf.math.cos(psi) * tf.math.sin(theta), r * tf.math.sin(psi) * tf.math.sin(theta)], axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_58": {
                "values": {
                    "value": "[r * tf.math.cos(theta), r * tf.math.cos(psi) * tf.math.sin(theta), r * tf.math.sin(psi) * tf.math.sin(theta)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cos_60": {
                "x": {
                    "value": "theta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random.uniform((), 0, fov)",
                            "Call"
                        ]
                    ]
                }
            },
            "sin_61": {
                "x": {
                    "value": "theta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random.uniform((), 0, fov)",
                            "Call"
                        ]
                    ]
                }
            },
            "sin_62": {
                "x": {
                    "value": "psi",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random.uniform((), -math.pi, math.pi)",
                            "Call"
                        ]
                    ]
                }
            },
            "cos_61": {
                "x": {
                    "value": "psi",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random.uniform((), -math.pi, math.pi)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "training/dataset/projection/visual_mesh.py": {
        "tensorflow": {
            "constant_31": {
                "variable": {
                    "value": "self.geometry",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "geometry['shape']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "GeometryType",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_80": {
                "variable": {
                    "value": "G",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "G",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(G, (-1, self.n_neighbours))",
                            "Call"
                        ],
                        [
                            "tf.where(G < 0, tf.expand_dims(G[:, 0], 1), G)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1, self.n_neighbours)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "FixedLenFeature_41": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_42": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_43": {
                "shape": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_44": {
                "shape": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_45": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "einsum_70": {
                "equation": {
                    "value": "ij,ki->kj",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "Hoc[:3, :3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "V",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "where_87": {
                "variable": {
                    "value": "G",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "G < 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.expand_dims(G[:, 0], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "G",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(G, (-1, self.n_neighbours))",
                            "Call"
                        ],
                        [
                            "tf.where(G < 0, tf.expand_dims(G[:, 0], 1), G)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_and_100": {
                "x": {
                    "value": "valid",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.size(C) > 0",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "shape_71": {
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_52": {
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "expand_dims_87": {
                "input": {
                    "value": "G[:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "size_100": {
                "input": {
                    "value": "C",
                    "type": "variable",
                    "possible_values": [
                        [
                            "project(tf.einsum('ij,ki->kj', Hoc[:3, :3], V), tf.shape(image)[:2], features['lens/projection'], features['lens/focal_length'], features['lens/centre'], features['lens/k'])",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "training/dataset/view/monoscopic.py": {
        "tensorflow": {
            "expand_dims_34": {
                "input": {
                    "value": "tf.shape(view['G'])[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_33": {
                "input": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_34": {
                "input": {
                    "value": "view['G']",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "training/dataset/visual_mesh_dataset.py": {
        "tensorflow": {
            "parse_single_example_63": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "serialized": {
                    "value": "proto",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "self.dataset_features",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cumsum_98": {
                "variable": {
                    "value": "cn",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.math.reduce_sum(n, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "exclusive": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_99": {
                "variable": {
                    "value": "n_elems",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "n",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch['n']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "concat_102": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.reshape(batch['X'].values, shape=[-1, 3], name='vmdataset/_reduce/reshape/X'), tf.constant([[-1.0, -1.0, -1.0]], dtype=tf.float32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "vmdataset/_reduce/concat/X",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_135": {
                "variable": {
                    "value": "G",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.where(G < 0, n_elems, G), tf.fill([1, tf.shape(G)[-1]], n_elems)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_98": {
                "input_tensor": {
                    "value": "n",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch['n']",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dense_to_ragged_batch_173": {
                "batch_size": {
                    "value": "self.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_104": {
                "tensor": {
                    "value": "batch['X'].values",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "vmdataset/_reduce/reshape/X",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_105": {
                "value": {
                    "value": "[[-1.0, -1.0, -1.0]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_132": {
                "input": {
                    "value": "cn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.cumsum(tf.math.reduce_sum(n, axis=1), exclusive=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "where_135": {
                "condition": {
                    "value": "G < 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "n_elems",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.reduce_sum(n)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "G",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(batch['G'] + tf.expand_dims(tf.expand_dims(cn, -1), -1)).values",
                            "Attribute"
                        ],
                        [
                            "tf.concat([tf.where(G < 0, n_elems, G), tf.fill([1, tf.shape(G)[-1]], n_elems)], axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "fill_135": {
                "dims": {
                    "value": "[1, tf.shape(G)[-1]]",
                    "type": "List",
                    "possible_values": []
                },
                "value": {
                    "value": "n_elems",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.reduce_sum(n)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_all_170": {
                "input_tensor": {
                    "value": "args['valid']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "TFRecordDataset_158": {
                "filenames": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.view.prefixes()",
                            "Call"
                        ],
                        [
                            "self.view.prefixes()",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_135": {
                "input": {
                    "value": "G",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(batch['G'] + tf.expand_dims(tf.expand_dims(cn, -1), -1)).values",
                            "Attribute"
                        ],
                        [
                            "tf.concat([tf.where(G < 0, n_elems, G), tf.fill([1, tf.shape(G)[-1]], n_elems)], axis=0)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "training/export.py": {
        "tensorflow": {
            "latest_checkpoint_43": {
                "variable": {
                    "value": "checkpoint_file",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "output_path",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "convert_to_tensor_85": {
                "variable": {
                    "value": "first",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "stages[0][0]['weights']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reshape_86": {
                "variable": {
                    "value": "first",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "first",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(stages[0][0]['weights'])",
                            "Call"
                        ],
                        [
                            "tf.reshape(first, (-1, 3, first.shape[-1]))",
                            "Call"
                        ],
                        [
                            "tf.pad(first, [[0, 0], [0, 1], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(first, (-1, first.shape[-1]))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1, 3, first.shape[-1])",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "pad_87": {
                "variable": {
                    "value": "first",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "first",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(stages[0][0]['weights'])",
                            "Call"
                        ],
                        [
                            "tf.reshape(first, (-1, 3, first.shape[-1]))",
                            "Call"
                        ],
                        [
                            "tf.pad(first, [[0, 0], [0, 1], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(first, (-1, first.shape[-1]))",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [0, 1], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_88": {
                "variable": {
                    "value": "first",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "first",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(stages[0][0]['weights'])",
                            "Call"
                        ],
                        [
                            "tf.reshape(first, (-1, 3, first.shape[-1]))",
                            "Call"
                        ],
                        [
                            "tf.pad(first, [[0, 0], [0, 1], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(first, (-1, first.shape[-1]))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1, first.shape[-1])",
                    "type": "Tuple",
                    "possible_values": []
                }
            }
        }
    },
    "training/find_lr.py": {
        "tensorflow": {
            "Adam_102": {
                "variable": {
                    "value": "optimiser",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "min_lr",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "SGD_104": {
                "variable": {
                    "value": "optimiser",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "min_lr",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "TerminateOnNaN_125": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "LearningRateScheduler_126": {
                "schedule": {
                    "value": "lr_schedule",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "training/layer/depthwise_seperable_graph_convolution.py": {
        "tensorflow": {
            "Dense_22": {
                "variable": {
                    "value": "self.pointwise",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "einsum_36": {
                "variable": {
                    "value": "depthwise",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ijk,jk->ik",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "self.depthwise_weights",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_46": {
                "variable": {
                    "value": "convolved",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.gather(X, G, name='NetworkGather')",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, G.shape[-1], X.shape[-1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_46": {
                "params": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "G",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "NetworkGather",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "training/layer/graph_convolution.py": {
        "tensorflow": {
            "Dense_22": {
                "variable": {
                    "value": "self.dense",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_26": {
                "tensor": {
                    "value": "tf.gather(X, G, name='NetworkGather')",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, X.shape[-1] * G.shape[-1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_26": {
                "params": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "G",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "NetworkGather",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "training/loss/focal_loss.py": {
        "tensorflow": {
            "squeeze_23": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.where(tf.reduce_any(tf.greater(y_true, 0.0), axis=-1))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_24": {
                "variable": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(y_true, idx)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.where(tf.reduce_any(tf.greater(y_true, 0.0), axis=-1)), axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_25": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(y_pred, idx)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.where(tf.reduce_any(tf.greater(y_true, 0.0), axis=-1)), axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_28": {
                "variable": {
                    "value": "C",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(y_true, idx)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "divide_no_nan_29": {
                "variable": {
                    "value": "C",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.math.reduce_max(C)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "C",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.reduce_sum(y_true, axis=0, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.math.divide_no_nan(tf.math.reduce_max(C), C)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_32": {
                "variable": {
                    "value": "p_t",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.equal(y_true, 1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(y_pred, idx)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1.0 - y_pred",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_33": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.multiply(C, -tf.math.pow(1.0 - p_t, gamma) * tf.math.log(p_t))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "where_23": {
                "condition": {
                    "value": "tf.reduce_any(tf.greater(y_true, 0.0), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_max_29": {
                "input_tensor": {
                    "value": "C",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.reduce_sum(y_true, axis=0, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.math.divide_no_nan(tf.math.reduce_max(C), C)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_32": {
                "x": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(y_true, idx)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "multiply_33": {
                "x": {
                    "value": "C",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.reduce_sum(y_true, axis=0, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.math.divide_no_nan(tf.math.reduce_max(C), C)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "-tf.math.pow(1.0 - p_t, gamma) * tf.math.log(p_t)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_any_23": {
                "input_tensor": {
                    "value": "tf.greater(y_true, 0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "greater_23": {
                "x": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(y_true, idx)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "log_33": {
                "x": {
                    "value": "p_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.equal(y_true, 1.0), y_pred, 1.0 - y_pred)",
                            "Call"
                        ]
                    ]
                }
            },
            "pow_33": {
                "x": {
                    "value": "1.0 - p_t",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "2.0",
                            "MethodArgument"
                        ]
                    ]
                }
            }
        }
    },
    "training/loss/seeker_loss.py": {
        "tensorflow": {
            "gather_nd_26": {
                "variable": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_true, -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "clip_by_value_46": {
                "variable": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_true, -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "clip_by_value_51": {
                "variable": {
                    "value": "loss_factor",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "tf.divide(tf.math.abs(y_true) - signed_end, unsigned_end - signed_end)",
                    "type": "Call",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reduce_mean_52": {
                "variable": {
                    "value": "near_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.add(tf.multiply(tf.math.squared_difference(y_true, y_pred), 1.0 - loss_factor), tf.multiply(tf.math.squared_difference(tf.math.abs(y_true), tf.math.abs(y_pred)), loss_factor))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "squared_difference_62": {
                "variable": {
                    "value": "far_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_max(tf.abs(y_true), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_max(tf.abs(y_pred), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_67": {
                "variable": {
                    "value": "far_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.reduce_max(tf.abs(y_pred), axis=-1) < unsigned_end",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "far_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.squared_difference(tf.reduce_max(tf.abs(y_true), axis=-1), tf.reduce_max(tf.abs(y_pred), axis=-1))",
                            "Call"
                        ],
                        [
                            "tf.where(tf.reduce_max(tf.abs(y_pred), axis=-1) < unsigned_end, far_loss, tf.zeros_like(far_loss))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(far_loss)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_all_70": {
                "variable": {
                    "value": "near",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.abs(y_true) < unsigned_end",
                    "type": "Compare",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "logical_not_71": {
                "variable": {
                    "value": "far",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "near",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_all(tf.abs(y_true) < unsigned_end, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_72": {
                "variable": {
                    "value": "near_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "near",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_all(tf.abs(y_true) < unsigned_end, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "tf.math.reciprocal_no_nan(tf.math.count_nonzero(near, dtype=near_loss.dtype))",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_73": {
                "variable": {
                    "value": "far_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "far",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_not(near)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "tf.math.reciprocal_no_nan(tf.math.count_nonzero(far, dtype=near_loss.dtype))",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_76": {
                "input_tensor": {
                    "value": "near_loss * near_weights + far_loss * far_weights",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "stack_28": {
                "values": {
                    "value": "[tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "divide_51": {
                "x": {
                    "value": "tf.math.abs(y_true) - signed_end",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "unsigned_end - signed_end",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "add_53": {
                "x": {
                    "value": "tf.multiply(tf.math.squared_difference(y_true, y_pred), 1.0 - loss_factor)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.multiply(tf.math.squared_difference(tf.math.abs(y_true), tf.math.abs(y_pred)), loss_factor)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_max_63": {
                "input_tensor": {
                    "value": "tf.abs(y_pred)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_like_67": {
                "input": {
                    "value": "far_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.squared_difference(tf.reduce_max(tf.abs(y_true), axis=-1), tf.reduce_max(tf.abs(y_pred), axis=-1))",
                            "Call"
                        ],
                        [
                            "tf.where(tf.reduce_max(tf.abs(y_pred), axis=-1) < unsigned_end, far_loss, tf.zeros_like(far_loss))",
                            "Call"
                        ]
                    ]
                }
            },
            "reciprocal_no_nan_72": {
                "x": {
                    "value": "tf.math.count_nonzero(near, dtype=near_loss.dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reciprocal_no_nan_73": {
                "x": {
                    "value": "tf.math.count_nonzero(far, dtype=near_loss.dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "multiply_54": {
                "x": {
                    "value": "tf.math.squared_difference(y_true, y_pred)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "1.0 - loss_factor",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "multiply_55": {
                "x": {
                    "value": "tf.math.squared_difference(tf.math.abs(y_true), tf.math.abs(y_pred))",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "loss_factor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.clip_by_value(tf.divide(tf.math.abs(y_true) - signed_end, unsigned_end - signed_end), 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "abs_63": {
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_max_67": {
                "input_tensor": {
                    "value": "tf.abs(y_pred)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "abs_70": {
                "x": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_true, -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "count_nonzero_72": {
                "input": {
                    "value": "near",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_all(tf.abs(y_true) < unsigned_end, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "near_loss.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "count_nonzero_73": {
                "input": {
                    "value": "far",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_not(near)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "near_loss.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "range_30": {
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmin_31": {
                "input": {
                    "value": "tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "abs_51": {
                "x": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_true, -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "squared_difference_54": {
                "x": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_true, -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "squared_difference_55": {
                "x": {
                    "value": "tf.math.abs(y_true)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.math.abs(y_pred)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "abs_67": {
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_sum_32": {
                "input_tensor": {
                    "value": "tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "abs_55": {
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_30": {
                "input": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_true, -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "squared_difference_32": {
                "x": {
                    "value": "tf.expand_dims(y_pred, axis=-2)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_true, -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_32": {
                "input": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "training/make_dataset.py": {
        "tensorflow": {
            "Feature_17": {
                "float_list": {
                    "value": "tf.train.FloatList(value=[value])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_21": {
                "float_list": {
                    "value": "tf.train.FloatList(value=value)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_25": {
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[value])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TFRecordWriter_30": {
                "path": {
                    "value": "output_file",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "FloatList_17": {
                "value": {
                    "value": "[value]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "FloatList_21": {
                "value": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "BytesList_25": {
                "value": {
                    "value": "[value]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Example_49": {
                "features": {
                    "value": "tf.train.Features(feature={'image': bytes_feature(image), 'mask': bytes_feature(mask), 'lens/projection': bytes_feature(lens['projection'].encode('utf-8')), 'lens/fov': float_feature(lens['fov']), 'lens/focal_length': float_feature(lens['focal_length']), 'lens/centre': float_list_feature(lens['centre']), 'lens/k': float_list_feature(lens['k']), 'Hoc': float_list_feature(np.array(lens['Hoc']).flatten().tolist())})",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Features_50": {
                "feature": {
                    "value": "{'image': bytes_feature(image), 'mask': bytes_feature(mask), 'lens/projection': bytes_feature(lens['projection'].encode('utf-8')), 'lens/fov': float_feature(lens['fov']), 'lens/focal_length': float_feature(lens['focal_length']), 'lens/centre': float_list_feature(lens['centre']), 'lens/k': float_list_feature(lens['k']), 'Hoc': float_list_feature(np.array(lens['Hoc']).flatten().tolist())}",
                    "type": "Dict",
                    "possible_values": []
                }
            }
        }
    },
    "training/metrics/average_precision.py": {
        "tensorflow": {
            "cast_27": {
                "variable": {
                    "value": "tp",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.linalg.diag_part(self.confusion)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_29": {
                "variable": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(self.confusion, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_31": {
                "input_tensor": {
                    "value": "tp / p",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "diag_part_27": {
                "input": {
                    "value": "self.confusion",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_29": {
                "input_tensor": {
                    "value": "self.confusion",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "training/metrics/average_recall.py": {
        "tensorflow": {
            "cast_27": {
                "variable": {
                    "value": "tp",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.linalg.diag_part(self.confusion)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_29": {
                "variable": {
                    "value": "tp_fn",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(self.confusion, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_31": {
                "input_tensor": {
                    "value": "tp / tp_fn",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "diag_part_27": {
                "input": {
                    "value": "self.confusion",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_29": {
                "input_tensor": {
                    "value": "self.confusion",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "training/metrics/class_precision.py": {
        "tensorflow": {
            "cast_28": {
                "variable": {
                    "value": "tp",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.confusion[self.idx, self.idx]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_30": {
                "variable": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(self.confusion[:, self.idx])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_30": {
                "input_tensor": {
                    "value": "self.confusion[:, self.idx]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "training/metrics/class_recall.py": {
        "tensorflow": {
            "cast_28": {
                "variable": {
                    "value": "tp",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.confusion[self.idx, self.idx]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_30": {
                "variable": {
                    "value": "tp_fn",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(self.confusion[self.idx, :])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_30": {
                "input_tensor": {
                    "value": "self.confusion[self.idx, :]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "training/metrics/confusion_base.py": {
        "tensorflow": {
            "stack_28": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.argmax(input=y_true, axis=-1, output_type=self.confusion.dtype), tf.argmax(input=y_pred, axis=-1, output_type=self.confusion.dtype)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_37": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.argmax(input=y_true, axis=-1, output_type=self.confusion.dtype), tf.argmax(input=y_pred, axis=-1, output_type=self.confusion.dtype)], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(idx, tf.squeeze(tf.where(tf.reduce_any(tf.greater(y_true, 0.0), axis=-1)), axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.squeeze(tf.where(tf.reduce_any(tf.greater(y_true, 0.0), axis=-1)), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "squeeze_37": {
                "input": {
                    "value": "tf.where(tf.reduce_any(tf.greater(y_true, 0.0), axis=-1))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "ones_like_40": {
                "input": {
                    "value": "idx[:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.confusion.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_43": {
                "input": {
                    "value": "self.confusion",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_30": {
                "input": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "self.confusion.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_31": {
                "input": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "self.confusion.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_37": {
                "condition": {
                    "value": "tf.reduce_any(tf.greater(y_true, 0.0), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_any_37": {
                "input_tensor": {
                    "value": "tf.greater(y_true, 0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "greater_37": {
                "x": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            }
        }
    },
    "training/metrics/seeker_confusion_base.py": {
        "tensorflow": {
            "gather_nd_30": {
                "variable": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.where(tf.reduce_all(tf.math.abs(y_true) <= self.threshold, axis=-1), 1.0, 0.0)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_46": {
                "variable": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.reduce_all(tf.math.abs(y_true) <= self.threshold, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "where_47": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.reduce_all(tf.math.abs(y_pred) <= self.threshold, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "stack_32": {
                "values": {
                    "value": "[tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_all_46": {
                "input_tensor": {
                    "value": "tf.math.abs(y_true) <= self.threshold",
                    "type": "Compare",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_all_47": {
                "input_tensor": {
                    "value": "tf.math.abs(y_pred) <= self.threshold",
                    "type": "Compare",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_50": {
                "values": {
                    "value": "[y_true, 1.0 - y_true]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_51": {
                "values": {
                    "value": "[y_pred, 1.0 - y_pred]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "range_34": {
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmin_35": {
                "input": {
                    "value": "tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "abs_46": {
                "x": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.where(tf.reduce_all(tf.math.abs(y_true) <= self.threshold, axis=-1), 1.0, 0.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "abs_47": {
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.reduce_all(tf.math.abs(y_pred) <= self.threshold, axis=-1), 1.0, 0.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_36": {
                "input_tensor": {
                    "value": "tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_34": {
                "input": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.where(tf.reduce_all(tf.math.abs(y_true) <= self.threshold, axis=-1), 1.0, 0.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "squared_difference_36": {
                "x": {
                    "value": "tf.expand_dims(y_pred, axis=-2)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.where(tf.reduce_all(tf.math.abs(y_true) <= self.threshold, axis=-1), 1.0, 0.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_36": {
                "input": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.reduce_all(tf.math.abs(y_pred) <= self.threshold, axis=-1), 1.0, 0.0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "training/metrics/seeker_precision.py": {
        "tensorflow": {
            "cast_27": {
                "variable": {
                    "value": "tp",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.linalg.diag_part(self.confusion)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_29": {
                "variable": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(self.confusion, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_31": {
                "input_tensor": {
                    "value": "tp / p",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "diag_part_27": {
                "input": {
                    "value": "self.confusion",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_29": {
                "input_tensor": {
                    "value": "self.confusion",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "training/metrics/seeker_recall.py": {
        "tensorflow": {
            "cast_27": {
                "variable": {
                    "value": "tp",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.linalg.diag_part(self.confusion)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_29": {
                "variable": {
                    "value": "tp_fn",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(self.confusion, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_31": {
                "input_tensor": {
                    "value": "tp / tp_fn",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "diag_part_27": {
                "input": {
                    "value": "self.confusion",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_29": {
                "input_tensor": {
                    "value": "self.confusion",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "training/metrics/seeker_stddev.py": {
        "tensorflow": {
            "gather_nd_32": {
                "variable": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_true, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.gather(y_true, idx), dtype=tf.float64)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "clip_by_value_47": {
                "variable": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_true, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.gather(y_true, idx), dtype=tf.float64)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "squeeze_50": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.where(tf.reduce_all(tf.abs(y_pred) <= self.threshold, axis=-1))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_51": {
                "variable": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.gather(y_true, idx)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_52": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.gather(y_pred, idx)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_56": {
                "variable": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.math.squared_difference(y_pred, y_true)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_63": {
                "x": {
                    "value": "self.s / tf.cast(self.n - 1, tf.float64)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "stack_34": {
                "values": {
                    "value": "[tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_50": {
                "condition": {
                    "value": "tf.reduce_all(tf.abs(y_pred) <= self.threshold, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_51": {
                "params": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_true, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.gather(y_true, idx), dtype=tf.float64)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.where(tf.reduce_all(tf.abs(y_pred) <= self.threshold, axis=-1)), axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_52": {
                "params": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.gather(y_pred, idx), dtype=tf.float64)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.where(tf.reduce_all(tf.abs(y_pred) <= self.threshold, axis=-1)), axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_55": {
                "input": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_true, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.gather(y_true, idx), dtype=tf.float64)",
                            "Call"
                        ]
                    ]
                },
                "out_type": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "squared_difference_56": {
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.gather(y_pred, idx), dtype=tf.float64)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_true, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.gather(y_true, idx), dtype=tf.float64)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_66": {
                "input": {
                    "value": "self.n",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_67": {
                "input": {
                    "value": "self.s",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_all_50": {
                "input_tensor": {
                    "value": "tf.abs(y_pred) <= self.threshold",
                    "type": "Compare",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_63": {
                "x": {
                    "value": "self.n - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "range_36": {
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmin_37": {
                "input": {
                    "value": "tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_38": {
                "input_tensor": {
                    "value": "tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "abs_50": {
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.gather(y_pred, idx), dtype=tf.float64)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_36": {
                "input": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_true, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.gather(y_true, idx), dtype=tf.float64)",
                            "Call"
                        ]
                    ]
                }
            },
            "squared_difference_38": {
                "x": {
                    "value": "tf.expand_dims(y_pred, axis=-2)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_true, -1.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.gather(y_true, idx), dtype=tf.float64)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_38": {
                "input": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.gather(y_pred, idx), dtype=tf.float64)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "training/metrics/test/__init__.py": {
        "tensorflow": {}
    },
    "training/metrics/test/bucket.py": {
        "tensorflow": {
            "sqrt_20": {
                "x": {
                    "value": "tf.add(tf.math.squared_difference(x[:-1], x[1:]), tf.math.squared_difference(y[:-1], y[1:]))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "abs_24": {
                "x": {
                    "value": "x[1:] - x[:-1]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_28": {
                "x": {
                    "value": "x[1:] - x[:-1]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "add_20": {
                "x": {
                    "value": "tf.math.squared_difference(x[:-1], x[1:])",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.math.squared_difference(y[:-1], y[1:])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "squared_difference_20": {
                "x": {
                    "value": "y[:-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "y[1:]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "training/metrics/test/confusion.py": {
        "tensorflow": {
            "stack_34": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.argmax(input=y_true, axis=-1, output_type=self.confusion.dtype), tf.argmax(input=y_pred, axis=-1, output_type=self.confusion.dtype)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_43": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.argmax(input=y_true, axis=-1, output_type=self.confusion.dtype), tf.argmax(input=y_pred, axis=-1, output_type=self.confusion.dtype)], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(idx, tf.squeeze(tf.where(tf.reduce_any(tf.greater(y_true, 0.0), axis=-1)), axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.squeeze(tf.where(tf.reduce_any(tf.greater(y_true, 0.0), axis=-1)), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "squeeze_43": {
                "input": {
                    "value": "tf.where(tf.reduce_any(tf.greater(y_true, 0.0), axis=-1))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "ones_like_46": {
                "input": {
                    "value": "idx[:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.confusion.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_49": {
                "input": {
                    "value": "self.confusion",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_68": {
                "variable": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.confusion[:, i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_70": {
                "variable": {
                    "value": "tp_fn",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.confusion[i, :]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "argmax_36": {
                "input": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "self.confusion.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_37": {
                "input": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "self.confusion.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_43": {
                "condition": {
                    "value": "tf.reduce_any(tf.greater(y_true, 0.0), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_any_43": {
                "input_tensor": {
                    "value": "tf.greater(y_true, 0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "greater_43": {
                "x": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            }
        }
    },
    "training/metrics/test/confusion_curve.py": {
        "tensorflow": {
            "cumsum_42": {
                "variable": {
                    "value": "thresholded",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(y_true[:, self.class_index], tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([c, 1 - c], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "reverse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_44": {
                "variable": {
                    "value": "rp",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "c[:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_45": {
                "variable": {
                    "value": "rn",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "c[:, 1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "squeeze_30": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.where(tf.reduce_any(y_pred != 0, axis=-1))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_31": {
                "variable": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(y_true, idx)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.where(tf.reduce_any(y_pred != 0, axis=-1)), axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_32": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(y_pred, idx)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.where(tf.reduce_any(y_pred != 0, axis=-1)), axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_35": {
                "variable": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y_true[:, self.class_index]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_36": {
                "variable": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[c, 1 - c]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_37": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "y_pred[:, self.class_index]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "where_58": {
                "condition": {
                    "value": "tp + fn == 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones_like(v)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tp / (tp + fn)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fp)",
                            "BinOp"
                        ],
                        [
                            "tp / (tp + fp)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fn)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tp)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tn)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tp)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tn)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "where_64": {
                "condition": {
                    "value": "tn + fp == 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones_like(v)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tp / (tp + fn)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fp)",
                            "BinOp"
                        ],
                        [
                            "tp / (tp + fp)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fn)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tp)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tn)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tp)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tn)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "where_70": {
                "condition": {
                    "value": "tp + fp == 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones_like(v)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tp / (tp + fn)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fp)",
                            "BinOp"
                        ],
                        [
                            "tp / (tp + fp)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fn)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tp)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tn)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tp)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tn)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "where_76": {
                "condition": {
                    "value": "tn + fn == 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones_like(v)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tp / (tp + fn)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fp)",
                            "BinOp"
                        ],
                        [
                            "tp / (tp + fp)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fn)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tp)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tn)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tp)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tn)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "where_82": {
                "condition": {
                    "value": "fn + tp == 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.zeros_like(v)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tp / (tp + fn)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fp)",
                            "BinOp"
                        ],
                        [
                            "tp / (tp + fp)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fn)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tp)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tn)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tp)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tn)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "where_88": {
                "condition": {
                    "value": "fp + tn == 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.zeros_like(v)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tp / (tp + fn)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fp)",
                            "BinOp"
                        ],
                        [
                            "tp / (tp + fp)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fn)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tp)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tn)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tp)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tn)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "where_94": {
                "condition": {
                    "value": "fp + tp == 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.zeros_like(v)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tp / (tp + fn)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fp)",
                            "BinOp"
                        ],
                        [
                            "tp / (tp + fp)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fn)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tp)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tn)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tp)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tn)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "where_100": {
                "condition": {
                    "value": "fn + tn == 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.zeros_like(v)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tp / (tp + fn)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fp)",
                            "BinOp"
                        ],
                        [
                            "tp / (tp + fp)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fn)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tp)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tn)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tp)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tn)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "subtract_118": {
                "x": {
                    "value": "tf.sqrt(_ppv(X, c) * _tpr(X, c) * _tnr(X, c) * _npv(X, c))",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.sqrt(_fdr(X, c) * _fnr(X, c) * _fpr(X, c) * _for(X, c))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_125": {
                "x": {
                    "value": "tf.squeeze(X, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_like_58": {
                "input": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tp / (tp + fn)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fp)",
                            "BinOp"
                        ],
                        [
                            "tp / (tp + fp)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fn)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tp)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tn)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tp)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tn)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "ones_like_64": {
                "input": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tp / (tp + fn)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fp)",
                            "BinOp"
                        ],
                        [
                            "tp / (tp + fp)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fn)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tp)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tn)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tp)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tn)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "ones_like_70": {
                "input": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tp / (tp + fn)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fp)",
                            "BinOp"
                        ],
                        [
                            "tp / (tp + fp)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fn)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tp)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tn)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tp)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tn)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "ones_like_76": {
                "input": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tp / (tp + fn)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fp)",
                            "BinOp"
                        ],
                        [
                            "tp / (tp + fp)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fn)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tp)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tn)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tp)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tn)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "zeros_like_82": {
                "input": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tp / (tp + fn)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fp)",
                            "BinOp"
                        ],
                        [
                            "tp / (tp + fp)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fn)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tp)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tn)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tp)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tn)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "zeros_like_88": {
                "input": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tp / (tp + fn)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fp)",
                            "BinOp"
                        ],
                        [
                            "tp / (tp + fp)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fn)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tp)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tn)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tp)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tn)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "zeros_like_94": {
                "input": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tp / (tp + fn)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fp)",
                            "BinOp"
                        ],
                        [
                            "tp / (tp + fp)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fn)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tp)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tn)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tp)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tn)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "zeros_like_100": {
                "input": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tp / (tp + fn)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fp)",
                            "BinOp"
                        ],
                        [
                            "tp / (tp + fp)",
                            "BinOp"
                        ],
                        [
                            "tn / (tn + fn)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tp)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tn)",
                            "BinOp"
                        ],
                        [
                            "fp / (fp + tp)",
                            "BinOp"
                        ],
                        [
                            "fn / (fn + tn)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "sqrt_119": {
                "x": {
                    "value": "_ppv(X, c) * _tpr(X, c) * _tnr(X, c) * _npv(X, c)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sqrt_120": {
                "x": {
                    "value": "_fdr(X, c) * _fnr(X, c) * _fpr(X, c) * _for(X, c)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "squeeze_125": {
                "input": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(y_pred[:, self.class_index], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "where_30": {
                "condition": {
                    "value": "tf.reduce_any(y_pred != 0, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_any_30": {
                "input_tensor": {
                    "value": "y_pred != 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "training/metrics/test/curve.py": {
        "tensorflow": {
            "argsort_51": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self._sort_axis(X, c)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_52": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(X, idx)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(idx, tf.multiply(X, tf.cast(weights, X.dtype)), (self.n_points, *X.shape[1:]))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(X, tf.cast(tf.reduce_sum(c, axis=-1, keepdims=True), X.dtype))",
                            "Call"
                        ],
                        [
                            "tf.gather(X, valid_idx)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(self._sort_axis(X, c))",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.expand_dims(curve * (self.n_points / curve[-1]), axis=-1), dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(idx, 0, self.n_points - 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_53": {
                "variable": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(c, idx)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(idx, c, (self.n_points, *c.shape[1:]))",
                            "Call"
                        ],
                        [
                            "tf.gather(c, valid_idx)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(self._sort_axis(X, c))",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.expand_dims(curve * (self.n_points / curve[-1]), axis=-1), dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(idx, 0, self.n_points - 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "pad_76": {
                "variable": {
                    "value": "curve",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.math.cumsum(curve)",
                    "type": "Call",
                    "possible_values": []
                },
                "paddings": {
                    "value": "[[1, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_79": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.expand_dims(curve * (self.n_points / curve[-1]), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "clip_by_value_80": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(self._sort_axis(X, c))",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.expand_dims(curve * (self.n_points / curve[-1]), axis=-1), dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(idx, 0, self.n_points - 1)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "self.n_points - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_83": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.math.reduce_sum(c, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "scatter_nd_86": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(self._sort_axis(X, c))",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.expand_dims(curve * (self.n_points / curve[-1]), axis=-1), dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(idx, 0, self.n_points - 1)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "tf.multiply(X, tf.cast(weights, X.dtype))",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(self.n_points, *X.shape[1:])",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "scatter_nd_87": {
                "variable": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(self._sort_axis(X, c))",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.expand_dims(curve * (self.n_points / curve[-1]), axis=-1), dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(idx, 0, self.n_points - 1)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(c, idx)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(idx, c, (self.n_points, *c.shape[1:]))",
                            "Call"
                        ],
                        [
                            "tf.gather(c, valid_idx)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(self.n_points, *c.shape[1:])",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "divide_88": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(X, idx)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(idx, tf.multiply(X, tf.cast(weights, X.dtype)), (self.n_points, *X.shape[1:]))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(X, tf.cast(tf.reduce_sum(c, axis=-1, keepdims=True), X.dtype))",
                            "Call"
                        ],
                        [
                            "tf.gather(X, valid_idx)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.cast(tf.reduce_sum(c, axis=-1, keepdims=True), X.dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "squeeze_91": {
                "variable": {
                    "value": "valid_idx",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.where(tf.reduce_sum(c, axis=1))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_92": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(X, idx)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(idx, tf.multiply(X, tf.cast(weights, X.dtype)), (self.n_points, *X.shape[1:]))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(X, tf.cast(tf.reduce_sum(c, axis=-1, keepdims=True), X.dtype))",
                            "Call"
                        ],
                        [
                            "tf.gather(X, valid_idx)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "valid_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.where(tf.reduce_sum(c, axis=1)), axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_93": {
                "variable": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(c, idx)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(idx, c, (self.n_points, *c.shape[1:]))",
                            "Call"
                        ],
                        [
                            "tf.gather(c, valid_idx)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "valid_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.where(tf.reduce_sum(c, axis=1)), axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "py_function_109": {
                "func": {
                    "value": "add_value",
                    "type": "variable",
                    "possible_values": []
                },
                "inp": {
                    "value": "(X, c)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_150": {
                "values": {
                    "value": "[self._sort_axis(self.X, self.c), self._x_axis(self.X, self.c), self._y_axis(self.X, self.c)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cumsum_76": {
                "x": {
                    "value": "curve",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._bucket_axis(x_values, y_values)",
                            "Call"
                        ],
                        [
                            "tf.pad(tf.math.cumsum(curve), [[1, 0]])",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_79": {
                "input": {
                    "value": "curve * (self.n_points / curve[-1])",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_83": {
                "input_tensor": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(c, idx)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(idx, c, (self.n_points, *c.shape[1:]))",
                            "Call"
                        ],
                        [
                            "tf.gather(c, valid_idx)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "multiply_86": {
                "x": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(X, idx)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(idx, tf.multiply(X, tf.cast(weights, X.dtype)), (self.n_points, *X.shape[1:]))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(X, tf.cast(tf.reduce_sum(c, axis=-1, keepdims=True), X.dtype))",
                            "Call"
                        ],
                        [
                            "tf.gather(X, valid_idx)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.cast(weights, X.dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_88": {
                "x": {
                    "value": "tf.reduce_sum(c, axis=-1, keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "X.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_91": {
                "condition": {
                    "value": "tf.reduce_sum(c, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_115": {
                "input": {
                    "value": "self.X",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_116": {
                "input": {
                    "value": "self.c",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_143": {
                "values": {
                    "value": "[x_axis, y_axis, sort_axis]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_86": {
                "x": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.math.reduce_sum(c, axis=-1), axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "X.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_88": {
                "input_tensor": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(c, idx)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(idx, c, (self.n_points, *c.shape[1:]))",
                            "Call"
                        ],
                        [
                            "tf.gather(c, valid_idx)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_91": {
                "input_tensor": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(c, idx)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(idx, c, (self.n_points, *c.shape[1:]))",
                            "Call"
                        ],
                        [
                            "tf.gather(c, valid_idx)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_105": {
                "values": {
                    "value": "[self.X, X]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_106": {
                "values": {
                    "value": "[self.c, c]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_107": {
                "input": {
                    "value": "self.X",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_type": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "training/metrics/test/seeker_hourglass.py": {
        "tensorflow": {
            "gather_nd_40": {
                "variable": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(tf.reshape(y_true, shape=[-1]), -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "clip_by_value_56": {
                "variable": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "tf.reshape(y_true, shape=[-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reshape_57": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(y_pred, shape=[-1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_60": {
                "variable": {
                    "value": "coords",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.cast((self.n - 1) * ((y_pred + 1.0) / 2.0), dtype=tf.int32), tf.cast((self.n - 1) * ((y_true + 1.0) / 2.0), dtype=tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_83": {
                "variable": {
                    "value": "grid",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "grid",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(grid, tf.float64)",
                            "Call"
                        ],
                        [
                            "grid / tf.reduce_max(grid, axis=0, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "cm.viridis(grid)[:, :, :3]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_image_dtype_86": {
                "variable": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "grid",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(grid, tf.float64)",
                            "Call"
                        ],
                        [
                            "grid / tf.reduce_max(grid, axis=0, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "cm.viridis(grid)[:, :, :3]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.uint8",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_100": {
                "input": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.convert_image_dtype(grid, tf.uint8)",
                            "Call"
                        ],
                        [
                            "cv2.line(img.numpy(), (0, 0), (img.shape[0], img.shape[1]), (0, 0, 0), line_width)",
                            "Call"
                        ],
                        [
                            "cv2.rectangle(img, (tl_50[0], tl_50[1]), (br_50[0], br_50[1]), (255, 255, 255), line_width)",
                            "Call"
                        ],
                        [
                            "cv2.rectangle(img, (tl_75[0], tl_75[1]), (br_75[0], br_75[1]), (255, 0, 0), line_width)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_42": {
                "values": {
                    "value": "[tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_56": {
                "tensor": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(tf.reshape(y_true, shape=[-1]), -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "scatter_nd_70": {
                "indices": {
                    "value": "coords",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.cast((self.n - 1) * ((y_pred + 1.0) / 2.0), dtype=tf.int32), tf.cast((self.n - 1) * ((y_true + 1.0) / 2.0), dtype=tf.int32)], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "tf.ones_like(y_true, dtype=self.grid.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.shape(self.grid)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_77": {
                "input": {
                    "value": "self.grid",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_max_84": {
                "input_tensor": {
                    "value": "grid",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(grid, tf.float64)",
                            "Call"
                        ],
                        [
                            "grid / tf.reduce_max(grid, axis=0, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "cm.viridis(grid)[:, :, :3]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cast_62": {
                "x": {
                    "value": "(self.n - 1) * ((y_pred + 1.0) / 2.0)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_63": {
                "x": {
                    "value": "(self.n - 1) * ((y_true + 1.0) / 2.0)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_like_70": {
                "input": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(tf.reshape(y_true, shape=[-1]), -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.grid.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "encode_png_107": {
                "image": {
                    "value": "self.images(self.grid)[0, ...]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "range_44": {
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmin_45": {
                "input": {
                    "value": "tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_70": {
                "input": {
                    "value": "self.grid",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_46": {
                "input_tensor": {
                    "value": "tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_44": {
                "input": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(tf.reshape(y_true, shape=[-1]), -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "squared_difference_46": {
                "x": {
                    "value": "tf.expand_dims(y_pred, axis=-2)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(y_true, tf.stack([tf.range(tf.shape(y_true)[0], dtype=tf.int32), tf.math.argmin(tf.reduce_sum(tf.math.squared_difference(tf.expand_dims(y_pred, axis=-2), y_true), axis=-1), axis=-1, output_type=tf.int32)], axis=1))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(tf.reshape(y_true, shape=[-1]), -1.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_46": {
                "input": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(y_pred, shape=[-1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "training/model/visual_mesh_model.py": {
        "tensorflow": {}
    },
    "training/op/__init__.py": {
        "tensorflow": {
            "load_op_library_11": {
                "variable": {
                    "value": "_library",
                    "type": "variable",
                    "possible_values": []
                },
                "library_filename": {
                    "value": "/visualmesh/training/op/visualmesh_op.so",
                    "type": "str",
                    "possible_values": []
                }
            },
            "load_op_library_14": {
                "variable": {
                    "value": "_library",
                    "type": "variable",
                    "possible_values": []
                },
                "library_filename": {
                    "value": "os.path.join(os.path.dirname(__file__), 'visualmesh_op.so')",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "training/projection/__init__.py": {
        "tensorflow": {
            "acos_41": {
                "variable": {
                    "value": "theta",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "V[:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "rsqrt_42": {
                "variable": {
                    "value": "rsin_theta",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1.0 - tf.square(V[:, 0])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "stack_55": {
                "variable": {
                    "value": "screen",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[r_d * V[:, 2] * rsin_theta, r_d * V[:, 1] * rsin_theta]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_59": {
                "variable": {
                    "value": "screen",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.math.is_finite(screen)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "screen",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([r_d * V[:, 2] * rsin_theta, r_d * V[:, 1] * rsin_theta], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.is_finite(screen), screen, 0.0)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "tan_31": {
                "x": {
                    "value": "tf.clip_by_value(theta, 0.0, math.pi * 0.5)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sin_35": {
                "x": {
                    "value": "theta * 0.5",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "is_finite_59": {
                "x": {
                    "value": "screen",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([r_d * V[:, 2] * rsin_theta, r_d * V[:, 1] * rsin_theta], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.is_finite(screen), screen, 0.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "clip_by_value_31": {
                "t": {
                    "value": "theta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.acos(V[:, 0])",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "math.pi * 0.5",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "square_42": {
                "x": {
                    "value": "V[:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "zeros_like_50": {
                "variable": {
                    "value": "r_u",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "theta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.acos(V[:, 0])",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_62": {
                "x": {
                    "value": "dimensions",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "training/testing.py": {
        "tensorflow": {
            "latest_checkpoint_41": {
                "variable": {
                    "value": "checkpoint_file",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "output_path",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "training/training.py": {
        "tensorflow": {
            "latest_checkpoint_74": {
                "variable": {
                    "value": "checkpoint_file",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "output_path",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Adam_56": {
                "variable": {
                    "value": "optimiser",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "float(config['training']['learning_rate']['value'])",
                            "Call"
                        ],
                        [
                            "float(config['training']['learning_rate']['min_learning_rate'])",
                            "Call"
                        ]
                    ]
                }
            },
            "SGD_58": {
                "variable": {
                    "value": "optimiser",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "float(config['training']['learning_rate']['value'])",
                            "Call"
                        ],
                        [
                            "float(config['training']['learning_rate']['min_learning_rate'])",
                            "Call"
                        ]
                    ]
                }
            },
            "ModelCheckpoint_95": {
                "filepath": {
                    "value": "os.path.join(output_path, 'model')",
                    "type": "Call",
                    "possible_values": []
                },
                "monitor": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                },
                "save_weights_only": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "save_best_only": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "TerminateOnNaN_101": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    }
}