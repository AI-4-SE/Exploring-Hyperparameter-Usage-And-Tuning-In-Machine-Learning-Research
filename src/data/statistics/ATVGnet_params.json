{
    "code/atnet.py": {
        "torch": {
            "load_22": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "model_path",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "device_271": {
                "variable": {
                    "value": "config.cuda1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "type": {
                    "value": "'cuda:{}'.format(config.device_ids)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "L1Loss_62": {
                "variable": {
                    "value": "self.l1_loss_fn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "MSELoss_63": {
                "variable": {
                    "value": "self.mse_loss_fn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Adam_85": {
                "variable": {
                    "value": "self.opt_g",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "self.generator.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "config.lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "betas": {
                    "value": "(config.beta1, config.beta2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "DataLoader_103": {
                "variable": {
                    "value": "self.data_loader",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dataset": {
                    "value": "self.dataset",
                    "type": "Attribute",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "config.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_workers": {
                    "value": "config.num_thread",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "drop_last": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "DataParallel_68": {
                "variable": {
                    "value": "self.generator",
                    "type": "Attribute",
                    "possible_values": []
                },
                "module": {
                    "value": "self.generator",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device_ids": {
                    "value": "device_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[int(i) for i in config.device_ids.split(',')]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "mm_162": {
                "variable": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Variable(lmark.float()).cuda()",
                            "Call"
                        ],
                        [
                            "Variable(lmark.float())",
                            "Call"
                        ],
                        [
                            "lmark.view(lmark.size(0) * lmark.size(1), 6)",
                            "Call"
                        ],
                        [
                            "torch.mm(lmark, pca.t())",
                            "Call"
                        ],
                        [
                            "lmark + mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "lmark.view(config.batch_size, 16, 136)",
                            "Call"
                        ],
                        [
                            "lmark.data.cpu().numpy()",
                            "Call"
                        ],
                        [
                            "torch.mm(lmark, pca.t())",
                            "Call"
                        ],
                        [
                            "lmark + mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "lmark.data.cpu().numpy()",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "pca.t()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mm_166": {
                "variable": {
                    "value": "fake_lmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "fake_lmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.generator(example_landmark, audio)",
                            "Call"
                        ],
                        [
                            "fake_lmark.view(fake_lmark.size(0) * fake_lmark.size(1), 6)",
                            "Call"
                        ],
                        [
                            "torch.mm(fake_lmark, pca.t())",
                            "Call"
                        ],
                        [
                            "fake_lmark + mean.expand_as(fake_lmark)",
                            "BinOp"
                        ],
                        [
                            "fake_lmark.view(config.batch_size, 16, 136)",
                            "Call"
                        ],
                        [
                            "fake_lmark.data.cpu().numpy()",
                            "Call"
                        ],
                        [
                            "torch.mm(fake_lmark, pca.t())",
                            "Call"
                        ],
                        [
                            "fake_lmark + mean.expand_as(fake_lmark)",
                            "BinOp"
                        ],
                        [
                            "fake_lmark.data.cpu().numpy()",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "pca.t()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mm_183": {
                "variable": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Variable(lmark.float()).cuda()",
                            "Call"
                        ],
                        [
                            "Variable(lmark.float())",
                            "Call"
                        ],
                        [
                            "lmark.view(lmark.size(0) * lmark.size(1), 6)",
                            "Call"
                        ],
                        [
                            "torch.mm(lmark, pca.t())",
                            "Call"
                        ],
                        [
                            "lmark + mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "lmark.view(config.batch_size, 16, 136)",
                            "Call"
                        ],
                        [
                            "lmark.data.cpu().numpy()",
                            "Call"
                        ],
                        [
                            "torch.mm(lmark, pca.t())",
                            "Call"
                        ],
                        [
                            "lmark + mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "lmark.data.cpu().numpy()",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "pca.t()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mm_186": {
                "variable": {
                    "value": "fake_lmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "fake_lmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.generator(example_landmark, audio)",
                            "Call"
                        ],
                        [
                            "fake_lmark.view(fake_lmark.size(0) * fake_lmark.size(1), 6)",
                            "Call"
                        ],
                        [
                            "torch.mm(fake_lmark, pca.t())",
                            "Call"
                        ],
                        [
                            "fake_lmark + mean.expand_as(fake_lmark)",
                            "BinOp"
                        ],
                        [
                            "fake_lmark.view(config.batch_size, 16, 136)",
                            "Call"
                        ],
                        [
                            "fake_lmark.data.cpu().numpy()",
                            "Call"
                        ],
                        [
                            "torch.mm(fake_lmark, pca.t())",
                            "Call"
                        ],
                        [
                            "fake_lmark + mean.expand_as(fake_lmark)",
                            "BinOp"
                        ],
                        [
                            "fake_lmark.data.cpu().numpy()",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "pca.t()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "save_179": {
                "obj": {
                    "value": "self.generator.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "'{}/atnet_lstm_{}.pth'.format(config.model_dir, cc)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "save_196": {
                "obj": {
                    "value": "self.generator.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "'{}anet_single_{}.pth'.format(config.model_dir, cc)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "code/atnet_test.py": {
        "torch": {
            "load_27": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "model_path",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "DataLoader_108": {
                "variable": {
                    "value": "data_loader",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "LRW_1D_lstm_landmark_pca(config.dataset_dir, train=config.is_train)",
                            "Call"
                        ],
                        [
                            "GRID_1D_lstm_landmark_pca(config.dataset_dir, train=config.is_train)",
                            "Call"
                        ],
                        [
                            "LRW_1D_single_landmark_pca(config.dataset_dir, train=config.is_train)",
                            "Call"
                        ],
                        [
                            "GRID_1D_single_landmark_pca(config.dataset_dir, train=config.is_train)",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "config.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_workers": {
                    "value": "config.num_thread",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "drop_last": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "no_grad_124": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "mm_137": {
                "variable": {
                    "value": "fake_lmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "fake_lmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generator(example_landmark, audio)",
                            "Call"
                        ],
                        [
                            "fake_lmark.view(fake_lmark.size(0) * fake_lmark.size(1), 6)",
                            "Call"
                        ],
                        [
                            "torch.mm(fake_lmark, pca.t())",
                            "Call"
                        ],
                        [
                            "fake_lmark + mean.expand_as(fake_lmark)",
                            "BinOp"
                        ],
                        [
                            "fake_lmark.view(config.batch_size, 16, 136)",
                            "Call"
                        ],
                        [
                            "fake_lmark.data.cpu().numpy()",
                            "Call"
                        ],
                        [
                            "generator(example_landmark, audio)",
                            "Call"
                        ],
                        [
                            "torch.mm(fake_lmark, pca.t())",
                            "Call"
                        ],
                        [
                            "fake_lmark + mean.expand_as(fake_lmark)",
                            "BinOp"
                        ],
                        [
                            "fake_lmark.data.cpu().numpy()",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "pca.t()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mm_142": {
                "variable": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Variable(lmark.float()).cuda()",
                            "Call"
                        ],
                        [
                            "lmark.view(lmark.size(0) * lmark.size(1), 6)",
                            "Call"
                        ],
                        [
                            "torch.mm(lmark, pca.t())",
                            "Call"
                        ],
                        [
                            "lmark + mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "lmark.view(config.batch_size, 16, 136)",
                            "Call"
                        ],
                        [
                            "lmark.data.cpu().numpy()",
                            "Call"
                        ],
                        [
                            "torch.mm(lmark, pca.t())",
                            "Call"
                        ],
                        [
                            "lmark + mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "lmark.data.cpu().numpy()",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "pca.t()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mm_156": {
                "variable": {
                    "value": "fake_lmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "fake_lmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generator(example_landmark, audio)",
                            "Call"
                        ],
                        [
                            "fake_lmark.view(fake_lmark.size(0) * fake_lmark.size(1), 6)",
                            "Call"
                        ],
                        [
                            "torch.mm(fake_lmark, pca.t())",
                            "Call"
                        ],
                        [
                            "fake_lmark + mean.expand_as(fake_lmark)",
                            "BinOp"
                        ],
                        [
                            "fake_lmark.view(config.batch_size, 16, 136)",
                            "Call"
                        ],
                        [
                            "fake_lmark.data.cpu().numpy()",
                            "Call"
                        ],
                        [
                            "generator(example_landmark, audio)",
                            "Call"
                        ],
                        [
                            "torch.mm(fake_lmark, pca.t())",
                            "Call"
                        ],
                        [
                            "fake_lmark + mean.expand_as(fake_lmark)",
                            "BinOp"
                        ],
                        [
                            "fake_lmark.data.cpu().numpy()",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "pca.t()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mm_159": {
                "variable": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Variable(lmark.float()).cuda()",
                            "Call"
                        ],
                        [
                            "lmark.view(lmark.size(0) * lmark.size(1), 6)",
                            "Call"
                        ],
                        [
                            "torch.mm(lmark, pca.t())",
                            "Call"
                        ],
                        [
                            "lmark + mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "lmark.view(config.batch_size, 16, 136)",
                            "Call"
                        ],
                        [
                            "lmark.data.cpu().numpy()",
                            "Call"
                        ],
                        [
                            "torch.mm(lmark, pca.t())",
                            "Call"
                        ],
                        [
                            "lmark + mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "lmark.data.cpu().numpy()",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "pca.t()",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "code/convgru.py": {
        "torch": {
            "Conv2d_19": {
                "variable": {
                    "value": "self.reset_gate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "input_size + hidden_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "hidden_size",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kernel_size // 2",
                            "BinOp"
                        ]
                    ]
                }
            },
            "Conv2d_20": {
                "variable": {
                    "value": "self.update_gate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "input_size + hidden_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "hidden_size",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kernel_size // 2",
                            "BinOp"
                        ]
                    ]
                }
            },
            "Conv2d_21": {
                "variable": {
                    "value": "self.out_gate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "input_size + hidden_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "hidden_size",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kernel_size // 2",
                            "BinOp"
                        ]
                    ]
                }
            },
            "cat_46": {
                "variable": {
                    "value": "stacked_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[input_, prev_state]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_47": {
                "variable": {
                    "value": "update",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.update_gate(stacked_inputs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_48": {
                "variable": {
                    "value": "reset",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.reset_gate(stacked_inputs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tanh_49": {
                "variable": {
                    "value": "out_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.out_gate(torch.cat([input_, prev_state * reset], dim=1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "orthogonal_23": {
                "module": {
                    "value": "self.reset_gate.weight",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "orthogonal_24": {
                "module": {
                    "value": "self.update_gate.weight",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "orthogonal_25": {
                "module": {
                    "value": "self.out_gate.weight",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "is_available_40": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cat_49": {
                "tensors": {
                    "value": "[input_, prev_state * reset]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_43": {
                "*size": {
                    "value": "state_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[batch_size, self.hidden_size] + list(spatial_size)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "zeros_41": {
                "*size": {
                    "value": "state_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[batch_size, self.hidden_size] + list(spatial_size)",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "code/convolutional_rnn/functional.py": {
        "torch": {
            "relu_14": {
                "variable": {
                    "value": "hy",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "linear_func(input, w_ih, b_ih) + linear_func(hidden, w_hh, b_hh)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "tanh_22": {
                "variable": {
                    "value": "hy",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "linear_func(input, w_ih, b_ih) + linear_func(hidden, w_hh, b_hh)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sigmoid_40": {
                "variable": {
                    "value": "ingate",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "ingate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.sigmoid(ingate)",
                            "Call"
                        ],
                        [
                            "ingate + linear_func(cx, w_pi)",
                            "BinOp"
                        ],
                        [
                            "F.sigmoid(ingate)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_41": {
                "variable": {
                    "value": "forgetgate",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "forgetgate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.sigmoid(forgetgate)",
                            "Call"
                        ],
                        [
                            "forgetgate + linear_func(cx, w_pf)",
                            "BinOp"
                        ],
                        [
                            "F.sigmoid(forgetgate)",
                            "Call"
                        ]
                    ]
                }
            },
            "tanh_42": {
                "variable": {
                    "value": "cellgate",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "cellgate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.tanh(cellgate)",
                            "Call"
                        ],
                        [
                            "F.tanh(cellgate)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_43": {
                "variable": {
                    "value": "outgate",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "outgate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.sigmoid(outgate)",
                            "Call"
                        ],
                        [
                            "outgate + linear_func(cy, w_po)",
                            "BinOp"
                        ],
                        [
                            "F.sigmoid(outgate)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_61": {
                "variable": {
                    "value": "ingate",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "ingate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.sigmoid(ingate)",
                            "Call"
                        ],
                        [
                            "ingate + linear_func(cx, w_pi)",
                            "BinOp"
                        ],
                        [
                            "F.sigmoid(ingate)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_62": {
                "variable": {
                    "value": "forgetgate",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "forgetgate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.sigmoid(forgetgate)",
                            "Call"
                        ],
                        [
                            "forgetgate + linear_func(cx, w_pf)",
                            "BinOp"
                        ],
                        [
                            "F.sigmoid(forgetgate)",
                            "Call"
                        ]
                    ]
                }
            },
            "tanh_63": {
                "variable": {
                    "value": "cellgate",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "cellgate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.tanh(cellgate)",
                            "Call"
                        ],
                        [
                            "F.tanh(cellgate)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_67": {
                "variable": {
                    "value": "outgate",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "outgate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.sigmoid(outgate)",
                            "Call"
                        ],
                        [
                            "outgate + linear_func(cy, w_po)",
                            "BinOp"
                        ],
                        [
                            "F.sigmoid(outgate)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_88": {
                "variable": {
                    "value": "resetgate",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "i_r + h_r",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sigmoid_89": {
                "variable": {
                    "value": "inputgate",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "i_i + h_i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "tanh_90": {
                "variable": {
                    "value": "newgate",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "i_n + resetgate * h_n",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cat_151": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(output, 0).view(input.size(0), *output[0].size())",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(output, 0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(output, 0)",
                            "Call"
                        ],
                        [
                            "output.transpose(0, 1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_199": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(output, 0).view(input.size(0), *output[0].size())",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(output, 0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(output, 0)",
                            "Call"
                        ],
                        [
                            "output.transpose(0, 1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_235": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(output, 0).view(input.size(0), *output[0].size())",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(output, 0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(output, 0)",
                            "Call"
                        ],
                        [
                            "output.transpose(0, 1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pad_267": {
                "variable": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.cat(all_output, ch_dim)",
                            "Call"
                        ],
                        [
                            "F.dropout(input, p=dropout, training=train, inplace=False)",
                            "Call"
                        ],
                        [
                            "F.pad(input, ps, 'constant', 0)",
                            "Call"
                        ],
                        [
                            "input.transpose(0, 1)",
                            "Call"
                        ]
                    ]
                },
                "pad": {
                    "value": "ps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[(i + 1 - h + s * (h - 1) + d * (k - 1)) // 2 for (h, k, s, d) in list(zip(insize, kernel_size, _stride, _dilation))[::-1] for i in range(2)]",
                            "ListComp"
                        ]
                    ]
                },
                "mode": {
                    "value": "constant",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tanh_46": {
                "input": {
                    "value": "cy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forgetgate * cx + ingate * cellgate",
                            "BinOp"
                        ],
                        [
                            "forgetgate * cx + ingate * cellgate",
                            "BinOp"
                        ]
                    ]
                }
            },
            "tanh_69": {
                "input": {
                    "value": "cy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forgetgate * cx + ingate * cellgate",
                            "BinOp"
                        ],
                        [
                            "forgetgate * cx + ingate * cellgate",
                            "BinOp"
                        ]
                    ]
                }
            },
            "cat_119": {
                "variable": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "all_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "dim": {
                    "value": "ch_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input.dim() - weight[0][0].dim() + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "cat_131": {
                "variable": {
                    "value": "next_hidden",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "next_hidden",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "(torch.cat(next_h, 0).view(total_layers, *next_h[0].size()), torch.cat(next_c, 0).view(total_layers, *next_c[0].size()))",
                            "Tuple"
                        ],
                        [
                            "torch.cat(next_hidden, 0).view(total_layers, *next_hidden[0].size())",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dropout_122": {
                "variable": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.cat(all_output, ch_dim)",
                            "Call"
                        ],
                        [
                            "F.dropout(input, p=dropout, training=train, inplace=False)",
                            "Call"
                        ],
                        [
                            "F.pad(input, ps, 'constant', 0)",
                            "Call"
                        ],
                        [
                            "input.transpose(0, 1)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "dropout",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "MethodArgument"
                        ],
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                },
                "training": {
                    "value": "train",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                },
                "inplace": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cat_127": {
                "tensors": {
                    "value": "next_h",
                    "type": "variable",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_128": {
                "tensors": {
                    "value": "next_c",
                    "type": "variable",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_195": {
                "tensors": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_222": {
                "tensors": {
                    "value": "(h, ih[last_batch_size:batch_size])",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "code/convolutional_rnn/module.py": {
        "torch": {
            "Parameter_507": {
                "variable": {
                    "value": "self.weight_ih",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(gate_size, in_channels // groups, *self.kernel_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_508": {
                "variable": {
                    "value": "self.weight_hh",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(gate_size, out_channels // groups, *self.kernel_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "PackedSequence_167": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "PackedSequence(output, batch_sizes)",
                            "Call"
                        ]
                    ]
                },
                "batch_sizes": {
                    "value": "batch_sizes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ]
                    ]
                }
            },
            "Parameter_511": {
                "variable": {
                    "value": "self.bias_ih",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(gate_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_512": {
                "variable": {
                    "value": "self.bias_hh",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(gate_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_518": {
                "variable": {
                    "value": "self.weight_pi",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(out_channels, out_channels // groups, *self.kernel_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_519": {
                "variable": {
                    "value": "self.weight_pf",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(out_channels, out_channels // groups, *self.kernel_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_520": {
                "variable": {
                    "value": "self.weight_po",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(out_channels, out_channels // groups, *self.kernel_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_66": {
                "variable": {
                    "value": "w_ih",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(gate_size, layer_input_size // groups, *self.kernel_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_67": {
                "variable": {
                    "value": "w_hh",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(gate_size, out_channels // groups, *self.kernel_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_69": {
                "variable": {
                    "value": "b_ih",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(gate_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_70": {
                "variable": {
                    "value": "b_hh",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(gate_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_73": {
                "variable": {
                    "value": "w_pi",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(out_channels, out_channels // groups, *self.kernel_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_74": {
                "variable": {
                    "value": "w_pf",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(out_channels, out_channels // groups, *self.kernel_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_75": {
                "variable": {
                    "value": "w_po",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(out_channels, out_channels // groups, *self.kernel_size)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "code/dataset.py": {
        "torch": {
            "mm_54": {
                "variable": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path)",
                            "Call"
                        ],
                        [
                            "torch.FloatTensor(lmark) * 5.0",
                            "BinOp"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "self.pca",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_67": {
                "variable": {
                    "value": "mfccs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "mfccs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "mm_78": {
                "variable": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path)",
                            "Call"
                        ],
                        [
                            "torch.FloatTensor(lmark) * 5.0",
                            "BinOp"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "self.pca",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_91": {
                "variable": {
                    "value": "mfccs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "mfccs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "mm_140": {
                "variable": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path)",
                            "Call"
                        ],
                        [
                            "torch.FloatTensor(lmark) * 5.0",
                            "BinOp"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "self.pca",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "mm_184": {
                "variable": {
                    "value": "example_landmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "example_landmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lmark[r, :]",
                            "Subscript"
                        ],
                        [
                            "lmark[r, :]",
                            "Subscript"
                        ],
                        [
                            "lmark[r, :]",
                            "Subscript"
                        ],
                        [
                            "lmark[3, :]",
                            "Subscript"
                        ],
                        [
                            "torch.FloatTensor(example_landmark).view(1, -1)",
                            "Call"
                        ],
                        [
                            "example_landmark - self.mean.expand_as(example_landmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(example_landmark, self.pca)",
                            "Call"
                        ],
                        [
                            "torch.FloatTensor(example_landmark)",
                            "Call"
                        ],
                        [
                            "landmark[r - 1]",
                            "Subscript"
                        ],
                        [
                            "torch.FloatTensor(example_landmark.reshape(-1))",
                            "Call"
                        ],
                        [
                            "np.load('../image/musk1.npy')",
                            "Call"
                        ],
                        [
                            "torch.FloatTensor(example_landmark.reshape(-1)) * 5.0",
                            "BinOp"
                        ],
                        [
                            "landmark[r - 1]",
                            "Subscript"
                        ],
                        [
                            "torch.FloatTensor(example_landmark.reshape(-1))",
                            "Call"
                        ],
                        [
                            "landmark[r - 1]",
                            "Subscript"
                        ],
                        [
                            "torch.FloatTensor(example_landmark.reshape(-1))",
                            "Call"
                        ],
                        [
                            "landmark[r]",
                            "Subscript"
                        ],
                        [
                            "torch.FloatTensor(tp)",
                            "Call"
                        ],
                        [
                            "landmark[self.train_data[r][2]]",
                            "Subscript"
                        ],
                        [
                            "torch.FloatTensor((MS + np.dot(example_landmark.reshape(1, 6), EIGVECS)).reshape(-1))",
                            "Call"
                        ],
                        [
                            "landmarks[0]",
                            "Subscript"
                        ],
                        [
                            "landmark[r - 1]",
                            "Subscript"
                        ],
                        [
                            "torch.FloatTensor(example_landmark.reshape(-1))",
                            "Call"
                        ],
                        [
                            "landmark[r - 1]",
                            "Subscript"
                        ],
                        [
                            "torch.FloatTensor(example_landmark.reshape(-1))",
                            "Call"
                        ],
                        [
                            "np.load('../image/musk1.npy')",
                            "Call"
                        ],
                        [
                            "torch.FloatTensor(example_landmark.reshape(-1))",
                            "Call"
                        ],
                        [
                            "landmark[r - 1]",
                            "Subscript"
                        ],
                        [
                            "torch.FloatTensor(example_landmark.reshape(-1))",
                            "Call"
                        ],
                        [
                            "landmark[r - 1]",
                            "Subscript"
                        ],
                        [
                            "torch.FloatTensor(example_landmark.reshape(-1))",
                            "Call"
                        ],
                        [
                            "lmark[r, :]",
                            "Subscript"
                        ],
                        [
                            "lmark[r, :]",
                            "Subscript"
                        ],
                        [
                            "lmark[r, :]",
                            "Subscript"
                        ],
                        [
                            "lmark[r, :]",
                            "Subscript"
                        ]
                    ]
                },
                "mat2": {
                    "value": "self.pca",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "mm_874": {
                "variable": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path)",
                            "Call"
                        ],
                        [
                            "torch.FloatTensor(lmark) * 5.0",
                            "BinOp"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "self.pca",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_888": {
                "variable": {
                    "value": "mfccs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "mfccs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "mm_938": {
                "variable": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path)",
                            "Call"
                        ],
                        [
                            "torch.FloatTensor(lmark) * 5.0",
                            "BinOp"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "self.pca",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "mm_960": {
                "variable": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path)",
                            "Call"
                        ],
                        [
                            "torch.FloatTensor(lmark) * 5.0",
                            "BinOp"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "self.pca",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_974": {
                "variable": {
                    "value": "mfccs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "mfccs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "mm_846": {
                "variable": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "lmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path)",
                            "Call"
                        ],
                        [
                            "torch.FloatTensor(lmark) * 5.0",
                            "BinOp"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path) * 5.0",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(lmark)",
                            "Call"
                        ],
                        [
                            "lmark - self.mean.expand_as(lmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(lmark, self.pca)",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "self.pca",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_860": {
                "variable": {
                    "value": "mfccs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "mfccs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(mfccs, dim=0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "code/demo.py": {
        "torch": {
            "load_69": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "model_path",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "mm_212": {
                "variable": {
                    "value": "example_landmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "example_landmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "example_landmark.reshape((1, example_landmark.shape[0] * example_landmark.shape[1]))",
                            "Call"
                        ],
                        [
                            "Variable(torch.FloatTensor(example_landmark.astype(float))).cuda()",
                            "Call"
                        ],
                        [
                            "Variable(torch.FloatTensor(example_landmark.astype(float)))",
                            "Call"
                        ],
                        [
                            "example_landmark * 5.0",
                            "BinOp"
                        ],
                        [
                            "example_landmark - mean.expand_as(example_landmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(example_landmark, pca)",
                            "Call"
                        ],
                        [
                            "torch.mm(example_landmark, pca.t())",
                            "Call"
                        ],
                        [
                            "example_landmark + mean.expand_as(example_landmark)",
                            "BinOp"
                        ]
                    ]
                },
                "mat2": {
                    "value": "pca",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.FloatTensor(np.load('../basics/U_lrw1.npy')[:, :6]).cuda()",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_233": {
                "variable": {
                    "value": "input_mfcc",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "input_mfcc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(input_mfcc, dim=0)",
                            "Call"
                        ],
                        [
                            "input_mfcc.unsqueeze(0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "mm_237": {
                "variable": {
                    "value": "example_landmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "example_landmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "example_landmark.reshape((1, example_landmark.shape[0] * example_landmark.shape[1]))",
                            "Call"
                        ],
                        [
                            "Variable(torch.FloatTensor(example_landmark.astype(float))).cuda()",
                            "Call"
                        ],
                        [
                            "Variable(torch.FloatTensor(example_landmark.astype(float)))",
                            "Call"
                        ],
                        [
                            "example_landmark * 5.0",
                            "BinOp"
                        ],
                        [
                            "example_landmark - mean.expand_as(example_landmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(example_landmark, pca)",
                            "Call"
                        ],
                        [
                            "torch.mm(example_landmark, pca.t())",
                            "Call"
                        ],
                        [
                            "example_landmark + mean.expand_as(example_landmark)",
                            "BinOp"
                        ]
                    ]
                },
                "mat2": {
                    "value": "pca.t()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mm_240": {
                "variable": {
                    "value": "fake_lmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "fake_lmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "encoder(example_landmark, input_mfcc)",
                            "Call"
                        ],
                        [
                            "fake_lmark.view(fake_lmark.size(0) * fake_lmark.size(1), 6)",
                            "Call"
                        ],
                        [
                            "torch.mm(fake_lmark, pca.t())",
                            "Call"
                        ],
                        [
                            "fake_lmark + mean.expand_as(fake_lmark)",
                            "BinOp"
                        ],
                        [
                            "fake_lmark.unsqueeze(0)",
                            "Call"
                        ],
                        [
                            "fake_lmark.data.cpu().numpy()",
                            "Call"
                        ],
                        [
                            "np.reshape(fake_lmark, (fake_lmark.shape[1], 68, 2))",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "pca.t()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "no_grad_225": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "code/evaluation_matrix.py": {
        "torch": {}
    },
    "code/lrw_data.py": {
        "torch": {
            "stack_983": {
                "variable": {
                    "value": "landmarks",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "landmarks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(landmarks, dim=0)",
                            "Call"
                        ],
                        [
                            "landmarks.view(landmarks.size(0), 136)",
                            "Call"
                        ],
                        [
                            "landmarks - mean.expand_as(landmarks)",
                            "BinOp"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "mean_986": {
                "variable": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "landmarks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(landmarks, dim=0)",
                            "Call"
                        ],
                        [
                            "landmarks.view(landmarks.size(0), 136)",
                            "Call"
                        ],
                        [
                            "landmarks - mean.expand_as(landmarks)",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "svd_992": {
                "variable": {
                    "value": "(U, S, V)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "torch.t(landmarks)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "from_numpy_1010": {
                "variable": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "t_lmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.load(lmark_path)",
                            "Call"
                        ],
                        [
                            "np.load(lmark_path)",
                            "Call"
                        ]
                    ]
                }
            },
            "t_992": {
                "input": {
                    "value": "landmarks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(landmarks, dim=0)",
                            "Call"
                        ],
                        [
                            "landmarks.view(landmarks.size(0), 136)",
                            "Call"
                        ],
                        [
                            "landmarks - mean.expand_as(landmarks)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "mm_1015": {
                "variable": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "b - mean.expand_as(b)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(d, U[:, :20])",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "U[:, :20]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "mm_1019": {
                "variable": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "b - mean.expand_as(b)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(d, U[:, :20])",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "U[:, :20].t()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "from_numpy_981": {
                "ndarray": {
                    "value": "t_lmark[random.randint(0, 28)]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "code/models.py": {
        "torch": {
            "Sequential_21": {
                "variable": {
                    "value": "self.lmark_encoder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(6, 256)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_28": {
                "variable": {
                    "value": "self.audio_eocder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "conv2d(1, 64, 3, 1, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_37": {
                "variable": {
                    "value": "self.audio_eocder_fc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(1024 * 12, 2048)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "LSTM_44": {
                "variable": {
                    "value": "self.lstm",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "256 * 3",
                    "type": "BinOp",
                    "possible_values": []
                },
                "batch_first": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Sequential_45": {
                "variable": {
                    "value": "self.lstm_fc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(256, 6)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stack_61": {
                "variable": {
                    "value": "lstm_input",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "lstm_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(lstm_input, dim=1)",
                            "Call"
                        ],
                        [
                            "list()",
                            "Call"
                        ],
                        [
                            "torch.stack(lstm_input, dim=1)",
                            "Call"
                        ],
                        [
                            "list()",
                            "Call"
                        ],
                        [
                            "torch.stack(lstm_input, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Sequential_80": {
                "variable": {
                    "value": "self.audio_eocder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "conv2d(1, 64, 3, 1, 1, normalizer=None)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_89": {
                "variable": {
                    "value": "self.audio_eocder_fc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(1024 * 12, 2048)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_118": {
                "variable": {
                    "value": "self.image_encoder_dis",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "conv2d(3, 64, 3, 2, 1, normalizer=None)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_127": {
                "variable": {
                    "value": "self.encoder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(136, 256)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_133": {
                "variable": {
                    "value": "self.decoder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(1024, 512)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_139": {
                "variable": {
                    "value": "self.img_fc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(512 * 8 * 8, 512)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "LSTM_144": {
                "variable": {
                    "value": "self.lstm",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "1024",
                    "type": "int",
                    "possible_values": []
                },
                "batch_first": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Sequential_145": {
                "variable": {
                    "value": "self.lstm_fc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(256, 136)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_148": {
                "variable": {
                    "value": "self.decision",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(256, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "AvgPool1d_151": {
                "variable": {
                    "value": "self.aggregator",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "16",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Sigmoid_152": {
                "variable": {
                    "value": "self.activate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "stack_166": {
                "variable": {
                    "value": "lstm_input",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "lstm_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(lstm_input, dim=1)",
                            "Call"
                        ],
                        [
                            "list()",
                            "Call"
                        ],
                        [
                            "torch.stack(lstm_input, dim=1)",
                            "Call"
                        ],
                        [
                            "list()",
                            "Call"
                        ],
                        [
                            "torch.stack(lstm_input, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_174": {
                "variable": {
                    "value": "fc_out",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "fc_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(fc_out, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_175": {
                "variable": {
                    "value": "decision",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "decision",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(decision, dim=2)",
                            "Call"
                        ],
                        [
                            "self.aggregator(decision)",
                            "Call"
                        ],
                        [
                            "self.activate(decision)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Sequential_188": {
                "variable": {
                    "value": "self.image_encoder1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.ReflectionPad2d(3)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_198": {
                "variable": {
                    "value": "self.image_encoder2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "conv2d(128, 256, 3, 2, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_203": {
                "variable": {
                    "value": "self.landmark_encoder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(136, 64)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_208": {
                "variable": {
                    "value": "self.landmark_encoder_stage2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "conv2d(1, 256, 3)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_212": {
                "variable": {
                    "value": "self.lmark_att",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.ConvTranspose2d(512, 256, kernel_size=3, stride=2, padding=1, output_padding=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_221": {
                "variable": {
                    "value": "self.lmark_feature",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "conv2d(256, 512, 3)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_242": {
                "variable": {
                    "value": "self.base",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "*model",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "Sequential_246": {
                "variable": {
                    "value": "self.generator_color",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "*model",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "Sequential_251": {
                "variable": {
                    "value": "self.generator_attention",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "*model",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "Sequential_253": {
                "variable": {
                    "value": "self.bottle_neck",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "conv2d(1024, 128, 3, 1, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stack_282": {
                "variable": {
                    "value": "lmark_atts",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "lmark_atts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "list()",
                            "Call"
                        ],
                        [
                            "torch.stack(lmark_atts, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_283": {
                "variable": {
                    "value": "lstm_input",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "lstm_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(lstm_input, dim=1)",
                            "Call"
                        ],
                        [
                            "list()",
                            "Call"
                        ],
                        [
                            "torch.stack(lstm_input, dim=1)",
                            "Call"
                        ],
                        [
                            "list()",
                            "Call"
                        ],
                        [
                            "torch.stack(lstm_input, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_59": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[example_landmark_f, current_feature]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_67": {
                "tensors": {
                    "value": "fc_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(fc_out, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_164": {
                "variable": {
                    "value": "new_feature",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[lmark_feature, x]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Sequential_338": {
                "*args": {
                    "value": "*conv_block",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "Linear_22": {
                "in_features": {
                    "value": "6",
                    "type": "int",
                    "possible_values": []
                },
                "out_features": {
                    "value": "256",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ReLU_23": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_24": {
                "in_features": {
                    "value": "256",
                    "type": "int",
                    "possible_values": []
                },
                "out_features": {
                    "value": "512",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ReLU_25": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "MaxPool2d_31": {
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "(1, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "MaxPool2d_35": {
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "(2, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Linear_38": {
                "in_features": {
                    "value": "1024 * 12",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "2048",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ReLU_39": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_40": {
                "in_features": {
                    "value": "2048",
                    "type": "int",
                    "possible_values": []
                },
                "out_features": {
                    "value": "256",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ReLU_41": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_46": {
                "in_features": {
                    "value": "256",
                    "type": "int",
                    "possible_values": []
                },
                "out_features": {
                    "value": "6",
                    "type": "int",
                    "possible_values": []
                }
            },
            "MaxPool2d_83": {
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "(1, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "MaxPool2d_87": {
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "(2, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Linear_90": {
                "in_features": {
                    "value": "1024 * 12",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "2048",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ReLU_91": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_92": {
                "in_features": {
                    "value": "2048",
                    "type": "int",
                    "possible_values": []
                },
                "out_features": {
                    "value": "256",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ReLU_93": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_94": {
                "in_features": {
                    "value": "256",
                    "type": "int",
                    "possible_values": []
                },
                "out_features": {
                    "value": "6",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Linear_128": {
                "in_features": {
                    "value": "136",
                    "type": "int",
                    "possible_values": []
                },
                "out_features": {
                    "value": "256",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ReLU_129": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_130": {
                "in_features": {
                    "value": "256",
                    "type": "int",
                    "possible_values": []
                },
                "out_features": {
                    "value": "512",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ReLU_131": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_134": {
                "in_features": {
                    "value": "1024",
                    "type": "int",
                    "possible_values": []
                },
                "out_features": {
                    "value": "512",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ReLU_135": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_136": {
                "in_features": {
                    "value": "512",
                    "type": "int",
                    "possible_values": []
                },
                "out_features": {
                    "value": "136",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Tanh_137": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_140": {
                "in_features": {
                    "value": "512 * 8 * 8",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "512",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ReLU_141": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_146": {
                "in_features": {
                    "value": "256",
                    "type": "int",
                    "possible_values": []
                },
                "out_features": {
                    "value": "136",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Tanh_147": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_149": {
                "in_features": {
                    "value": "256",
                    "type": "int",
                    "possible_values": []
                },
                "out_features": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ReflectionPad2d_189": {
                "padding": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Linear_204": {
                "in_features": {
                    "value": "136",
                    "type": "int",
                    "possible_values": []
                },
                "out_features": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ReLU_205": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "ConvTranspose2d_213": {
                "in_channels": {
                    "value": "512",
                    "type": "int",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "256",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "output_padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_214": {
                "num_features": {
                    "value": "256",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ReLU_215": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "ConvTranspose2d_216": {
                "in_channels": {
                    "value": "256",
                    "type": "int",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "output_padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_217": {
                "num_features": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ReLU_218": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Sequential_239": {
                "variable": {
                    "value": "self.generator1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "*model",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "Conv2d_244": {
                "in_channels": {
                    "value": "ngf / 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "output_nc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "3",
                            "MethodArgument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "7",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Tanh_245": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Conv2d_249": {
                "in_channels": {
                    "value": "ngf / 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "7",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Sigmoid_250": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "stack_300": {
                "tensors": {
                    "value": "colors",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Conv2d_320": {
                "in_channels": {
                    "value": "dim",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "dim",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "Constant"
                        ],
                        [
                            "0",
                            "Constant"
                        ],
                        [
                            "1",
                            "Constant"
                        ],
                        [
                            "1",
                            "Constant"
                        ]
                    ]
                },
                "bias": {
                    "value": "use_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "ReLU_322": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_335": {
                "in_channels": {
                    "value": "dim",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "dim",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "Constant"
                        ],
                        [
                            "0",
                            "Constant"
                        ],
                        [
                            "1",
                            "Constant"
                        ],
                        [
                            "1",
                            "Constant"
                        ]
                    ]
                },
                "bias": {
                    "value": "use_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "zeros_50": {
                "*size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "audio.size(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "256",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_51": {
                "*size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "audio.size(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "256",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_154": {
                "*size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "example_landmark.size(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "256",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_155": {
                "*size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "example_landmark.size(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "256",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ConvTranspose2d_232": {
                "in_channels": {
                    "value": "ngf * mult",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "int(ngf * mult / 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "output_padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "bias": {
                    "value": "use_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "ReLU_237": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cat_276": {
                "tensors": {
                    "value": "[landmark, ex_landmark1]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_279": {
                "tensors": {
                    "value": "[image_feature, landmark - ex_landmark]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ReflectionPad2d_312": {
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Dropout_324": {
                "p": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "ReflectionPad2d_328": {
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ReplicationPad2d_314": {
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ReplicationPad2d_330": {
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "code/ops.py": {
        "torch": {
            "Sequential_12": {
                "variable": {
                    "value": "self.block",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "conv3d(channel_in, channel_out, 3, 1, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ReLU_17": {
                "variable": {
                    "value": "self.lrelu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "inplace": {
                    "value": "0.2",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Sequential_37": {
                "*args": {
                    "value": "*layer",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "Sequential_53": {
                "*args": {
                    "value": "*layer",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "Sequential_69": {
                "*args": {
                    "value": "*layer",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "Sequential_87": {
                "*args": {
                    "value": "*layer",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "Linear_33": {
                "in_features": {
                    "value": "channel_in",
                    "type": "variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "channel_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True if not normalizer else False",
                            "IfExp"
                        ],
                        [
                            "True if not normalizer else False",
                            "IfExp"
                        ],
                        [
                            "True if not normalizer else False",
                            "IfExp"
                        ],
                        [
                            "True if not normalizer else False",
                            "IfExp"
                        ]
                    ]
                }
            },
            "Conv2d_47": {
                "in_channels": {
                    "value": "channel_in",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "channel_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "ksize",
                    "type": "variable",
                    "possible_values": [
                        [
                            "3",
                            "MethodArgument"
                        ],
                        [
                            "4",
                            "MethodArgument"
                        ],
                        [
                            "3",
                            "MethodArgument"
                        ]
                    ]
                },
                "stride": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "2",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True if not normalizer else False",
                            "IfExp"
                        ],
                        [
                            "True if not normalizer else False",
                            "IfExp"
                        ],
                        [
                            "True if not normalizer else False",
                            "IfExp"
                        ],
                        [
                            "True if not normalizer else False",
                            "IfExp"
                        ]
                    ]
                }
            },
            "ConvTranspose2d_63": {
                "in_channels": {
                    "value": "channel_in",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "channel_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "ksize",
                    "type": "variable",
                    "possible_values": [
                        [
                            "3",
                            "MethodArgument"
                        ],
                        [
                            "4",
                            "MethodArgument"
                        ],
                        [
                            "3",
                            "MethodArgument"
                        ]
                    ]
                },
                "stride": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "2",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True if not normalizer else False",
                            "IfExp"
                        ],
                        [
                            "True if not normalizer else False",
                            "IfExp"
                        ],
                        [
                            "True if not normalizer else False",
                            "IfExp"
                        ],
                        [
                            "True if not normalizer else False",
                            "IfExp"
                        ]
                    ]
                }
            },
            "UpsamplingNearest2d_80": {
                "scale_factor": {
                    "value": "scale_factor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "2",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Conv2d_81": {
                "in_channels": {
                    "value": "channel_in",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "channel_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "ksize",
                    "type": "variable",
                    "possible_values": [
                        [
                            "3",
                            "MethodArgument"
                        ],
                        [
                            "4",
                            "MethodArgument"
                        ],
                        [
                            "3",
                            "MethodArgument"
                        ]
                    ]
                },
                "stride": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "2",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True if not normalizer else False",
                            "IfExp"
                        ],
                        [
                            "True if not normalizer else False",
                            "IfExp"
                        ],
                        [
                            "True if not normalizer else False",
                            "IfExp"
                        ],
                        [
                            "True if not normalizer else False",
                            "IfExp"
                        ]
                    ]
                }
            }
        }
    },
    "code/pytorch_ssim/__init__.py": {
        "torch": {
            "Tensor_8": {
                "variable": {
                    "value": "gauss",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "conv2d_18": {
                "variable": {
                    "value": "mu1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "img1",
                    "type": "variable",
                    "possible_values": []
                },
                "weight": {
                    "value": "window",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Variable(_2D_window.expand(channel, 1, window_size, window_size).contiguous())",
                            "Call"
                        ],
                        [
                            "create_window(window_size, channel)",
                            "Call"
                        ],
                        [
                            "window.cuda(img1.get_device())",
                            "Call"
                        ],
                        [
                            "window.type_as(img1)",
                            "Call"
                        ],
                        [
                            "self.window",
                            "Attribute"
                        ],
                        [
                            "create_window(self.window_size, channel)",
                            "Call"
                        ],
                        [
                            "window.cuda(img1.get_device())",
                            "Call"
                        ],
                        [
                            "window.type_as(img1)",
                            "Call"
                        ]
                    ]
                },
                "padding": {
                    "value": "window_size // 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "groups": {
                    "value": "channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "conv2d_19": {
                "variable": {
                    "value": "mu2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "img2",
                    "type": "variable",
                    "possible_values": []
                },
                "weight": {
                    "value": "window",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Variable(_2D_window.expand(channel, 1, window_size, window_size).contiguous())",
                            "Call"
                        ],
                        [
                            "create_window(window_size, channel)",
                            "Call"
                        ],
                        [
                            "window.cuda(img1.get_device())",
                            "Call"
                        ],
                        [
                            "window.type_as(img1)",
                            "Call"
                        ],
                        [
                            "self.window",
                            "Attribute"
                        ],
                        [
                            "create_window(self.window_size, channel)",
                            "Call"
                        ],
                        [
                            "window.cuda(img1.get_device())",
                            "Call"
                        ],
                        [
                            "window.type_as(img1)",
                            "Call"
                        ]
                    ]
                },
                "padding": {
                    "value": "window_size // 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "groups": {
                    "value": "channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "conv2d_25": {
                "input": {
                    "value": "img1 * img1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "weight": {
                    "value": "window",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Variable(_2D_window.expand(channel, 1, window_size, window_size).contiguous())",
                            "Call"
                        ],
                        [
                            "create_window(window_size, channel)",
                            "Call"
                        ],
                        [
                            "window.cuda(img1.get_device())",
                            "Call"
                        ],
                        [
                            "window.type_as(img1)",
                            "Call"
                        ],
                        [
                            "self.window",
                            "Attribute"
                        ],
                        [
                            "create_window(self.window_size, channel)",
                            "Call"
                        ],
                        [
                            "window.cuda(img1.get_device())",
                            "Call"
                        ],
                        [
                            "window.type_as(img1)",
                            "Call"
                        ]
                    ]
                },
                "padding": {
                    "value": "window_size // 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "groups": {
                    "value": "channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "conv2d_26": {
                "input": {
                    "value": "img2 * img2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "weight": {
                    "value": "window",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Variable(_2D_window.expand(channel, 1, window_size, window_size).contiguous())",
                            "Call"
                        ],
                        [
                            "create_window(window_size, channel)",
                            "Call"
                        ],
                        [
                            "window.cuda(img1.get_device())",
                            "Call"
                        ],
                        [
                            "window.type_as(img1)",
                            "Call"
                        ],
                        [
                            "self.window",
                            "Attribute"
                        ],
                        [
                            "create_window(self.window_size, channel)",
                            "Call"
                        ],
                        [
                            "window.cuda(img1.get_device())",
                            "Call"
                        ],
                        [
                            "window.type_as(img1)",
                            "Call"
                        ]
                    ]
                },
                "padding": {
                    "value": "window_size // 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "groups": {
                    "value": "channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "conv2d_27": {
                "input": {
                    "value": "img1 * img2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "weight": {
                    "value": "window",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Variable(_2D_window.expand(channel, 1, window_size, window_size).contiguous())",
                            "Call"
                        ],
                        [
                            "create_window(window_size, channel)",
                            "Call"
                        ],
                        [
                            "window.cuda(img1.get_device())",
                            "Call"
                        ],
                        [
                            "window.type_as(img1)",
                            "Call"
                        ],
                        [
                            "self.window",
                            "Attribute"
                        ],
                        [
                            "create_window(self.window_size, channel)",
                            "Call"
                        ],
                        [
                            "window.cuda(img1.get_device())",
                            "Call"
                        ],
                        [
                            "window.type_as(img1)",
                            "Call"
                        ]
                    ]
                },
                "padding": {
                    "value": "window_size // 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "groups": {
                    "value": "channel",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "code/test.py": {
        "torch": {
            "load_70": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "model_path",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "mm_297": {
                "variable": {
                    "value": "example_landmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "example_landmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "example_landmark.reshape((1, example_landmark.shape[0] * example_landmark.shape[1]))",
                            "Call"
                        ],
                        [
                            "Variable(torch.FloatTensor(example_landmark.astype(float))).cuda()",
                            "Call"
                        ],
                        [
                            "Variable(torch.FloatTensor(example_landmark.astype(float)))",
                            "Call"
                        ],
                        [
                            "example_landmark * 5.0",
                            "BinOp"
                        ],
                        [
                            "example_landmark - mean.expand_as(example_landmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(example_landmark, pca)",
                            "Call"
                        ],
                        [
                            "torch.mm(example_landmark, pca.t())",
                            "Call"
                        ],
                        [
                            "example_landmark + mean.expand_as(example_landmark)",
                            "BinOp"
                        ]
                    ]
                },
                "mat2": {
                    "value": "pca",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.FloatTensor(np.load('../basics/U_lrw1.npy')[:, :6]).cuda()",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_324": {
                "variable": {
                    "value": "input_mfcc",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "input_mfcc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(input_mfcc, dim=0)",
                            "Call"
                        ],
                        [
                            "input_mfcc.unsqueeze(0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "mm_329": {
                "variable": {
                    "value": "example_landmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "example_landmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "example_landmark.reshape((1, example_landmark.shape[0] * example_landmark.shape[1]))",
                            "Call"
                        ],
                        [
                            "Variable(torch.FloatTensor(example_landmark.astype(float))).cuda()",
                            "Call"
                        ],
                        [
                            "Variable(torch.FloatTensor(example_landmark.astype(float)))",
                            "Call"
                        ],
                        [
                            "example_landmark * 5.0",
                            "BinOp"
                        ],
                        [
                            "example_landmark - mean.expand_as(example_landmark)",
                            "BinOp"
                        ],
                        [
                            "torch.mm(example_landmark, pca)",
                            "Call"
                        ],
                        [
                            "torch.mm(example_landmark, pca.t())",
                            "Call"
                        ],
                        [
                            "example_landmark + mean.expand_as(example_landmark)",
                            "BinOp"
                        ]
                    ]
                },
                "mat2": {
                    "value": "pca.t()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mm_332": {
                "variable": {
                    "value": "fake_lmark",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "fake_lmark",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "encoder(example_landmark, input_mfcc)",
                            "Call"
                        ],
                        [
                            "fake_lmark.view(fake_lmark.size(0) * fake_lmark.size(1), 6)",
                            "Call"
                        ],
                        [
                            "torch.mm(fake_lmark, pca.t())",
                            "Call"
                        ],
                        [
                            "fake_lmark + mean.expand_as(fake_lmark)",
                            "BinOp"
                        ],
                        [
                            "fake_lmark.unsqueeze(0)",
                            "Call"
                        ],
                        [
                            "fake_lmark.data.cpu().numpy()",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "pca.t()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "no_grad_312": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "code/utils.py": {
        "torch": {
            "from_numpy_461": {
                "variable": {
                    "value": "im_as_ten",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "im_as_arr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.float32(cv2im)",
                            "Call"
                        ],
                        [
                            "np.ascontiguousarray(im_as_arr[..., ::-1])",
                            "Call"
                        ],
                        [
                            "im_as_arr.transpose(2, 0, 1)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "code/vgnet.py": {
        "torch": {
            "load_21": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "model_path",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "device_284": {
                "variable": {
                    "value": "config.cuda1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "type": {
                    "value": "'cuda:{}'.format(config.device_ids)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "BCELoss_60": {
                "variable": {
                    "value": "self.bce_loss_fn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "L1Loss_61": {
                "variable": {
                    "value": "self.l1_loss_fn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "MSELoss_62": {
                "variable": {
                    "value": "self.mse_loss_fn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Adam_94": {
                "variable": {
                    "value": "self.opt_g",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "self.generator.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "config.lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "betas": {
                    "value": "(config.beta1, config.beta2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Adam_96": {
                "variable": {
                    "value": "self.opt_d",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "self.discriminator.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "config.lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "betas": {
                    "value": "(config.beta1, config.beta2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "DataLoader_100": {
                "variable": {
                    "value": "self.data_loader",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dataset": {
                    "value": "self.dataset",
                    "type": "Attribute",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "config.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_workers": {
                    "value": "config.num_thread",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "drop_last": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "DataParallel_70": {
                "variable": {
                    "value": "self.generator",
                    "type": "Attribute",
                    "possible_values": []
                },
                "module": {
                    "value": "self.generator",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device_ids": {
                    "value": "device_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[int(i) for i in config.device_ids.split(',')]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "DataParallel_71": {
                "variable": {
                    "value": "self.discriminator",
                    "type": "Attribute",
                    "possible_values": []
                },
                "module": {
                    "value": "self.discriminator",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device_ids": {
                    "value": "device_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[int(i) for i in config.device_ids.split(',')]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "ones_64": {
                "*size": {
                    "value": "config.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_65": {
                "*size": {
                    "value": "config.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "mean_172": {
                "variable": {
                    "value": "loss_pix",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "diff",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.abs(fake_im - right_img) * loss_musk",
                            "BinOp"
                        ]
                    ]
                }
            },
            "load_209": {
                "f": {
                    "value": "gen_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(directory, 'generator_{}.pth'.format(epoch))",
                            "Call"
                        ]
                    ]
                }
            },
            "load_213": {
                "f": {
                    "value": "dis_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(directory, 'discriminator_{}.pth'.format(epoch))",
                            "Call"
                        ]
                    ]
                }
            },
            "abs_171": {
                "input": {
                    "value": "fake_im - right_img",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "save_201": {
                "obj": {
                    "value": "self.generator.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "'{}/vg_net_{}.pth'.format(config.model_dir, cc)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "code/vgnet_test.py": {
        "torch": {
            "load_23": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "model_path",
                    "type": "variable",
                    "possible_values": []
                },
                "map_location": {
                    "value": "lambda storage, loc: storage",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "upsample_73": {
                "variable": {
                    "value": "new_img",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image.view(image.size(0) * image.size(1), image.size(2), image.size(3), image.size(4))",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "(image.size(3) * 4, image.size(3) * 4)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "mode": {
                    "value": "bilinear",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DataLoader_91": {
                "variable": {
                    "value": "data_loader",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "LRWdataset(config.dataset_dir, train='test')",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "config.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_workers": {
                    "value": "config.num_thread",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "drop_last": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "no_grad_111": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "evaluation_matrix.py": {
        "torch": {}
    }
}