{
    "parser/bucket.py": {
        "tensorflow": {}
    },
    "parser/configurable.py": {
        "tensorflow": {}
    },
    "parser/dataset.py": {
        "tensorflow": {}
    },
    "parser/misc/bucketer.py": {
        "tensorflow": {}
    },
    "parser/misc/zipf.py": {
        "tensorflow": {
            "placeholder_63": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "x",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_64": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "y",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_67": {
                "variable": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "a",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "self.n_zipfs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_68": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "b",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "self.n_zipfs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_69": {
                "variable": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "s",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "self.n_zipfs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_uniform_initializer(-2, -0.5)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_70": {
                "variable": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "t",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "self.n_zipfs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_71": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.nn.softmax(affine(a, b))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_72": {
                "variable": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "affine(s, t)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "z",
                    "type": "str",
                    "possible_values": []
                }
            },
            "squeeze_73": {
                "variable": {
                    "value": "yhat",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.matmul(w, z)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "yhat",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_74": {
                "variable": {
                    "value": "ell",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "(tf.log(y) - yhat) ** 2 / 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "ell",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_75": {
                "input_tensor": {
                    "value": "(tf.reduce_max(w, axis=0) - 1) ** 2 / 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "softmax_71": {
                "logits": {
                    "value": "affine(a, b)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_73": {
                "a": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.nn.softmax(affine(a, b)), axis=1, name='w')",
                            "Call"
                        ],
                        [
                            "self.weight(self.ranks).T",
                            "Attribute"
                        ],
                        [
                            "self.weight(x)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(affine(s, t), axis=2, name='z')",
                            "Call"
                        ],
                        [
                            "self.zipf(self.ranks).T",
                            "Attribute"
                        ],
                        [
                            "self.zipf(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "Graph_114": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "exp_128": {
                "variable": {
                    "value": "yhat",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "graph.get_tensor_by_name('yhat:0')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "random_normal_initializer_67": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "random_normal_initializer_68": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "random_uniform_initializer_69": {
                "minval": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "-0.5",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "random_normal_initializer_70": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_116": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "log_66": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, shape=(None, 1), name='x')",
                            "Call"
                        ],
                        [
                            "x - np.max(x, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "np.exp(x)",
                            "Call"
                        ],
                        [
                            "x[..., None]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "global_variables_initializer_117": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "log_74": {
                "x": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, shape=(None, 1), name='y')",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_max_75": {
                "input_tensor": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.nn.softmax(affine(a, b)), axis=1, name='w')",
                            "Call"
                        ],
                        [
                            "self.weight(self.ranks).T",
                            "Attribute"
                        ],
                        [
                            "self.weight(x)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "parser/multibucket.py": {
        "tensorflow": {
            "embedding_lookup_59": {
                "params": {
                    "value": "tf.concat(embeddings, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "ids": {
                    "value": "self.placeholder",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_73": {
                "variable": {
                    "value": "self.placeholder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "self.name + '-multibucket'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_59": {
                "values": {
                    "value": "embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_57": {
                "name_or_scope": {
                    "value": "self.name + '-multibucket'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None if moving_params is None else True",
                            "IfExp"
                        ],
                        [
                            "True",
                            "bool"
                        ]
                    ]
                }
            }
        }
    },
    "parser/network.py": {
        "tensorflow": {
            "Variable_71": {
                "variable": {
                    "value": "self._global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Variable_72": {
                "variable": {
                    "value": "self._global_epoch",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "global_epoch",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Saver_109": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "self.save_vars",
                    "type": "Attribute",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ConfigProto_135": {
                "variable": {
                    "value": "config_proto",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_105": {
                "name_or_scope": {
                    "value": "self.name.title()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_total_loss_107": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_111": {
                "name_or_scope": {
                    "value": "self.name.title()",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Session_140": {
                "config": {
                    "value": "config_proto",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ],
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ]
                    ]
                }
            },
            "ConfigProto_242": {
                "variable": {
                    "value": "config_proto",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_301": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_304": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_141": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "latest_checkpoint_207": {
                "checkpoint_dir": {
                    "value": "self.save_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Graph_241": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_255": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "self.save_vars",
                    "type": "Attribute",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "latest_checkpoint_143": {
                "checkpoint_dir": {
                    "value": "self.save_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_210": {
                "name_or_scope": {
                    "value": "self.name.title()",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Session_247": {
                "config": {
                    "value": "config_proto",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ],
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_251": {
                "name_or_scope": {
                    "value": "self.name.title()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "latest_checkpoint_258": {
                "checkpoint_dir": {
                    "value": "self.save_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_262": {
                "name_or_scope": {
                    "value": "self.name.title()",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "parser/neural/functions.py": {
        "tensorflow": {
            "split_23": {
                "variable": {
                    "value": "(cell_act, gate_act)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(x.get_shape().as_list()) - 1",
                            "BinOp"
                        ],
                        [
                            "len(x.get_shape().as_list()) - 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "split_31": {
                "variable": {
                    "value": "(cell_act, gate_act)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(x.get_shape().as_list()) - 1",
                            "BinOp"
                        ],
                        [
                            "len(x.get_shape().as_list()) - 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "sigmoid_16": {
                "x": {
                    "value": "2 * x",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "tanh_19": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "identity_27": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "elu_38": {
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "relu_41": {
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "maximum_44": {
                "x": {
                    "value": "0.1 * x",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "softplus_35": {
                "features": {
                    "value": "2 * x",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "parser/neural/linalg.py": {
        "tensorflow": {
            "concat_47": {
                "variable": {
                    "value": "all_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "n_dims - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_53": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "all_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs, [-1, input_size])",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs, tf.stack([-1, bucket_size, input_size]))",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_57": {
                "variable": {
                    "value": "output_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "output_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output_shape)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output_shape)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output_shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_59": {
                "variable": {
                    "value": "all_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "all_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs, [-1, input_size])",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs, tf.stack([-1, bucket_size, input_size]))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, input_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_96": {
                "variable": {
                    "value": "all_inputs1",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "inputs1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[inputs1]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "n_dims1 - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_103": {
                "variable": {
                    "value": "all_inputs2",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "inputs2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[inputs2]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "n_dims2 - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_110": {
                "variable": {
                    "value": "shape1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "all_inputs1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs1, n_dims1 - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs1, tf.stack([-1, inputs1_bucket_size, inputs1_size]))",
                            "Call"
                        ],
                        [
                            "tf.concat([all_inputs1, bias1], 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_115": {
                "variable": {
                    "value": "output_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "output_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output_shape)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output_shape)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output_shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_117": {
                "variable": {
                    "value": "all_inputs1",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "all_inputs1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs1, n_dims1 - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs1, tf.stack([-1, inputs1_bucket_size, inputs1_size]))",
                            "Call"
                        ],
                        [
                            "tf.concat([all_inputs1, bias1], 2)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.stack([-1, inputs1_bucket_size, inputs1_size])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_122": {
                "variable": {
                    "value": "all_inputs2",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "all_inputs2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs2, n_dims2 - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs2, tf.stack([-1, inputs2_bucket_size, inputs2_size]))",
                            "Call"
                        ],
                        [
                            "tf.concat([all_inputs2, bias2], 2)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.stack([-1, inputs2_bucket_size, inputs2_size])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_161": {
                "variable": {
                    "value": "all_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "n_dims - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_168": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "all_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs, [-1, input_size])",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs, tf.stack([-1, bucket_size, input_size]))",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_172": {
                "variable": {
                    "value": "output_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "output_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output_shape)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output_shape)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output_shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_174": {
                "variable": {
                    "value": "all_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "all_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs, [-1, input_size])",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs, tf.stack([-1, bucket_size, input_size]))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.stack([-1, bucket_size, input_size])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_209": {
                "variable": {
                    "value": "ones",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "mask_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(success)",
                            "Call"
                        ],
                        [
                            "mask_shape ** keep_dims",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "zeros_210": {
                "variable": {
                    "value": "zeros",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "mask_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(success)",
                            "Call"
                        ],
                        [
                            "mask_shape ** keep_dims",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_218": {
                "variable": {
                    "value": "mask_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "success",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "bool"
                        ],
                        [
                            "True",
                            "bool"
                        ]
                    ]
                }
            },
            "get_variable_66": {
                "variable": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[input_size, output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(mat)",
                            "Call"
                        ],
                        [
                            "tf.constant_initializer(mat)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_82": {
                "variable": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(all_inputs, matrix) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(lin, output_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.reshape(all_inputs1, [-1, inputs1_size]), tf.reshape(weights, [inputs1_size, -1]))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "output_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output_shape)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output_shape)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output_shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_119": {
                "variable": {
                    "value": "bias1",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.stack([tf.shape(all_inputs1)[0], inputs1_bucket_size, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_120": {
                "variable": {
                    "value": "all_inputs1",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[all_inputs1, bias1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_124": {
                "variable": {
                    "value": "bias2",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.stack([tf.shape(all_inputs2)[0], inputs2_bucket_size, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_125": {
                "variable": {
                    "value": "all_inputs2",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[all_inputs2, bias2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_132": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[inputs1_size, output_size, inputs2_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(mat)",
                            "Call"
                        ],
                        [
                            "tf.constant_initializer(mat)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_140": {
                "variable": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.reshape(all_inputs1, [-1, inputs1_size])",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "tf.reshape(weights, [inputs1_size, -1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_143": {
                "variable": {
                    "value": "bilin",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.reshape(lin, tf.stack([-1, inputs1_bucket_size * output_size, inputs2_size]))",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "all_inputs2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs2, n_dims2 - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs2, tf.stack([-1, inputs2_bucket_size, inputs2_size]))",
                            "Call"
                        ],
                        [
                            "tf.concat([all_inputs2, bias2], 2)",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reshape_146": {
                "variable": {
                    "value": "bilin",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "bilin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.reshape(lin, tf.stack([-1, inputs1_bucket_size * output_size, inputs2_size])), all_inputs2, transpose_b=True)",
                            "Call"
                        ],
                        [
                            "tf.reshape(bilin, output_shape)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "output_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output_shape)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output_shape)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output_shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_182": {
                "variable": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[window_size, input_size, output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(mat)",
                            "Call"
                        ],
                        [
                            "tf.constant_initializer(mat)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_198": {
                "variable": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(all_inputs, matrix, 1, 'SAME') + bias",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(conv, output_shape)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "output_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output_shape)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output_shape)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output_shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_212": {
                "condition": {
                    "value": "rand < prob",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "ones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones(mask_shape, dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "zeros",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros(mask_shape, dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_60": {
                "name_or_scope": {
                    "value": "Linear",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_initializer_65": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "orthonormal_initializer(input_size, output_size // n_splits)",
                            "Call"
                        ],
                        [
                            "np.concatenate([mat] * n_splits, axis=1)",
                            "Call"
                        ],
                        [
                            "orthonormal_initializer(inputs1_size, inputs2_size)[:, None, :]",
                            "Subscript"
                        ],
                        [
                            "np.concatenate([mat] * output_size, axis=1)",
                            "Call"
                        ],
                        [
                            "orthonormal_initializer(input_size * window_size, output_size // n_splits)",
                            "Call"
                        ],
                        [
                            "np.concatenate([mat] * n_splits, axis=1)",
                            "Call"
                        ],
                        [
                            "np.reshape(mat, [window_size, input_size, output_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_74": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Biases",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_98": {
                "input": {
                    "value": "all_inputs1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs1, n_dims1 - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs1, tf.stack([-1, inputs1_bucket_size, inputs1_size]))",
                            "Call"
                        ],
                        [
                            "tf.concat([all_inputs1, bias1], 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_105": {
                "input": {
                    "value": "all_inputs2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs2, n_dims2 - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs2, tf.stack([-1, inputs2_bucket_size, inputs2_size]))",
                            "Call"
                        ],
                        [
                            "tf.concat([all_inputs2, bias2], 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_117": {
                "values": {
                    "value": "[-1, inputs1_bucket_size, inputs1_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_122": {
                "values": {
                    "value": "[-1, inputs2_bucket_size, inputs2_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_127": {
                "name_or_scope": {
                    "value": "Bilinear",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_163": {
                "input": {
                    "value": "all_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs, [-1, input_size])",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs, tf.stack([-1, bucket_size, input_size]))",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_174": {
                "values": {
                    "value": "[-1, bucket_size, input_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_175": {
                "name_or_scope": {
                    "value": "Convolutional",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_initializer_181": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "orthonormal_initializer(input_size, output_size // n_splits)",
                            "Call"
                        ],
                        [
                            "np.concatenate([mat] * n_splits, axis=1)",
                            "Call"
                        ],
                        [
                            "orthonormal_initializer(inputs1_size, inputs2_size)[:, None, :]",
                            "Subscript"
                        ],
                        [
                            "np.concatenate([mat] * output_size, axis=1)",
                            "Call"
                        ],
                        [
                            "orthonormal_initializer(input_size * window_size, output_size // n_splits)",
                            "Call"
                        ],
                        [
                            "np.concatenate([mat] * n_splits, axis=1)",
                            "Call"
                        ],
                        [
                            "np.reshape(mat, [window_size, input_size, output_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_190": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Biases",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_211": {
                "shape": {
                    "value": "mask_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(success)",
                            "Call"
                        ],
                        [
                            "mask_shape ** keep_dims",
                            "BinOp"
                        ]
                    ]
                }
            },
            "get_variable_scope_15": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "add_to_collection_70": {
                "name": {
                    "value": "Weights",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('Weights', [input_size, output_size], initializer=initializer)",
                            "Call"
                        ],
                        [
                            "moving_params.average(matrix)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('Weights', [window_size, input_size, output_size], initializer=initializer)",
                            "Call"
                        ],
                        [
                            "moving_params.average(matrix)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_81": {
                "a": {
                    "value": "all_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs, [-1, input_size])",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs, tf.stack([-1, bucket_size, input_size]))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('Weights', [input_size, output_size], initializer=initializer)",
                            "Call"
                        ],
                        [
                            "moving_params.average(matrix)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('Weights', [window_size, input_size, output_size], initializer=initializer)",
                            "Call"
                        ],
                        [
                            "moving_params.average(matrix)",
                            "Call"
                        ]
                    ]
                }
            },
            "split_84": {
                "value": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(all_inputs, matrix) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(lin, output_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.reshape(all_inputs1, [-1, inputs1_size]), tf.reshape(weights, [inputs1_size, -1]))",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "n_splits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "n_dims - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "stack_119": {
                "values": {
                    "value": "[tf.shape(all_inputs1)[0], inputs1_bucket_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_124": {
                "values": {
                    "value": "[tf.shape(all_inputs2)[0], inputs2_bucket_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_to_collection_136": {
                "name": {
                    "value": "Weights",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('Weights', [inputs1_size, output_size, inputs2_size], initializer=initializer)",
                            "Call"
                        ],
                        [
                            "moving_params.average(weights)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_140": {
                "tensor": {
                    "value": "all_inputs1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs1, n_dims1 - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs1, tf.stack([-1, inputs1_bucket_size, inputs1_size]))",
                            "Call"
                        ],
                        [
                            "tf.concat([all_inputs1, bias1], 2)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, inputs1_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_141": {
                "tensor": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('Weights', [inputs1_size, output_size, inputs2_size], initializer=initializer)",
                            "Call"
                        ],
                        [
                            "moving_params.average(weights)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[inputs1_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_143": {
                "tensor": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(all_inputs, matrix) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(lin, output_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.reshape(all_inputs1, [-1, inputs1_size]), tf.reshape(weights, [inputs1_size, -1]))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.stack([-1, inputs1_bucket_size * output_size, inputs2_size])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "split_149": {
                "value": {
                    "value": "bilin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.reshape(lin, tf.stack([-1, inputs1_bucket_size * output_size, inputs2_size])), all_inputs2, transpose_b=True)",
                            "Call"
                        ],
                        [
                            "tf.reshape(bilin, output_shape)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "n_splits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "n_dims - 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "add_to_collection_186": {
                "name": {
                    "value": "Weights",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('Weights', [input_size, output_size], initializer=initializer)",
                            "Call"
                        ],
                        [
                            "moving_params.average(matrix)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('Weights', [window_size, input_size, output_size], initializer=initializer)",
                            "Call"
                        ],
                        [
                            "moving_params.average(matrix)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv1d_197": {
                "input": {
                    "value": "all_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs, [-1, input_size])",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs, tf.stack([-1, bucket_size, input_size]))",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('Weights', [input_size, output_size], initializer=initializer)",
                            "Call"
                        ],
                        [
                            "moving_params.average(matrix)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('Weights', [window_size, input_size, output_size], initializer=initializer)",
                            "Call"
                        ],
                        [
                            "moving_params.average(matrix)",
                            "Call"
                        ]
                    ]
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "split_200": {
                "value": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(all_inputs, matrix, 1, 'SAME') + bias",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(conv, output_shape)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "n_splits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "n_dims - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "get_variable_scope_16": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "stack_143": {
                "values": {
                    "value": "[-1, inputs1_bucket_size * output_size, inputs2_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_scope_62": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_initializer_74": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_129": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_177": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_initializer_190": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "shape_119": {
                "input": {
                    "value": "all_inputs1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs1, n_dims1 - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs1, tf.stack([-1, inputs1_bucket_size, inputs1_size]))",
                            "Call"
                        ],
                        [
                            "tf.concat([all_inputs1, bias1], 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_124": {
                "input": {
                    "value": "all_inputs2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs2, n_dims2 - 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_inputs2, tf.stack([-1, inputs2_bucket_size, inputs2_size]))",
                            "Call"
                        ],
                        [
                            "tf.concat([all_inputs2, bias2], 2)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "parser/neural/models/embeds/base_embed.py": {
        "tensorflow": {
            "to_int32_67": {
                "variable": {
                    "value": "self._sequence_lengths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(self.tokens_to_keep, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_68": {
                "variable": {
                    "value": "self._n_tokens",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.sequence_lengths",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_55": {
                "variable": {
                    "value": "embeddings",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[TokenVocab.__call__(vocab, self.placeholder[:, :, i]) for (i, vocab) in enumerate(multivocab)]",
                            "ListComp"
                        ],
                        [
                            "tf.stack(embeddings, axis=2)",
                            "Call"
                        ],
                        [
                            "TokenVocab.__call__(vocab, self.placeholder)",
                            "Call"
                        ],
                        [
                            "self.linear_attention(embeddings)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_float_59": {
                "variable": {
                    "value": "self._tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.greater(self.placeholder[:, :, 0], vocab.PAD)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_64": {
                "variable": {
                    "value": "self._tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.greater(self.placeholder, vocab.PAD)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "placeholder_74": {
                "variable": {
                    "value": "self.placeholder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "'%s-bkt' % self.name",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_65": {
                "input": {
                    "value": "self.placeholder",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_66": {
                "input": {
                    "value": "self.placeholder",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_67": {
                "input_tensor": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_57": {
                "name_or_scope": {
                    "value": "Pre-Attn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "greater_59": {
                "x": {
                    "value": "self.placeholder[:, :, 0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "vocab.PAD",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "greater_64": {
                "x": {
                    "value": "self.placeholder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "vocab.PAD",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "parser/neural/models/embeds/cnn_embed.py": {
        "tensorflow": {
            "reduce_max_41": {
                "variable": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.CNN(embeddings, self.window_size, self.conv_size)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_38": {
                "name_or_scope": {
                    "value": "CNN",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "parser/neural/models/embeds/mlp_embed.py": {
        "tensorflow": {
            "variable_scope_38": {
                "name_or_scope": {
                    "value": "Attn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_41": {
                "name_or_scope": {
                    "value": "MLP",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "parser/neural/models/embeds/rnn_embed.py": {
        "tensorflow": {
            "unstack_42": {
                "variable": {
                    "value": "(state_fw, state_bw)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([state_fw, state_bw], 1)",
                            "Call"
                        ],
                        [
                            "tf.split(state, 2, axis=1)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "concat_45": {
                "variable": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[state_fw, state_bw]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_39": {
                "name_or_scope": {
                    "value": "RNN",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_49": {
                "name_or_scope": {
                    "value": "MLP",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_52": {
                "values": {
                    "value": "[hidden, state]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_43": {
                "value": {
                    "value": "state_fw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.split(state_fw, 2, axis=1)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_44": {
                "value": {
                    "value": "state_bw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.split(state_bw, 2, axis=1)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_47": {
                "value": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([state_fw, state_bw], 1)",
                            "Call"
                        ],
                        [
                            "tf.split(state, 2, axis=1)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "parser/neural/models/nlp/parsers/base_parser.py": {
        "tensorflow": {
            "to_float_58": {
                "variable": {
                    "value": "self._tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.greater(placeholder, self.ROOT)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_61": {
                "variable": {
                    "value": "self._sequence_lengths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.to_int32(tf.greater(placeholder, self.PAD))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_62": {
                "variable": {
                    "value": "self._n_tokens",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(self.tokens_to_keep)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "greater_58": {
                "x": {
                    "value": "placeholder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['words'].placeholder",
                            "Attribute"
                        ],
                        [
                            "placeholder[:, :, 0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "self.ROOT",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_59": {
                "input": {
                    "value": "placeholder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['words'].placeholder",
                            "Attribute"
                        ],
                        [
                            "placeholder[:, :, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_60": {
                "input": {
                    "value": "placeholder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['words'].placeholder",
                            "Attribute"
                        ],
                        [
                            "placeholder[:, :, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "to_int32_61": {
                "x": {
                    "value": "tf.greater(placeholder, self.PAD)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_62": {
                "input_tensor": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "greater_61": {
                "x": {
                    "value": "placeholder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['words'].placeholder",
                            "Attribute"
                        ],
                        [
                            "placeholder[:, :, 0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "self.PAD",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_66": {
                "name_or_scope": {
                    "value": "'RNN%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "parser/neural/models/nlp/parsers/bin_parser.py": {
        "tensorflow": {
            "to_int32_36": {
                "variable": {
                    "value": "int_tokens_to_keep",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_86": {
                "variable": {
                    "value": "n_arc_correct",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "arc_correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.equal(arc_preds, arc_targets)) * int_tokens_to_keep",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_87": {
                "variable": {
                    "value": "n_rel_correct",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "rel_correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.equal(rel_preds, rel_targets)) * int_tokens_to_keep",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_89": {
                "variable": {
                    "value": "n_correct",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "arc_correct * rel_correct",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_90": {
                "input_tensor": {
                    "value": "correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "arc_correct * rel_correct",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_41": {
                "variable": {
                    "value": "(arc_dep_mlp, rel_dep_mlp, p_dep_mlp)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "dep_mlp",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[self.arc_mlp_size, self.rel_mlp_size, self.p_mlp_size]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_42": {
                "variable": {
                    "value": "(arc_head_mlp, rel_head_mlp, p_head_mlp)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "head_mlp",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[self.arc_mlp_size, self.rel_mlp_size, self.p_mlp_size]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_54": {
                "variable": {
                    "value": "arc_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "arc_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.nn.softplus(arc_ps)",
                            "UnaryOp"
                        ],
                        [
                            "arc_logits + self.bilinear(arc_dep_mlp, arc_head_mlp, 1, add_bias2=False)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "to_int32_56": {
                "variable": {
                    "value": "arc_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(arc_logits, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_62": {
                "variable": {
                    "value": "arc_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "arc_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['heads'].placeholder",
                            "Attribute"
                        ]
                    ]
                },
                "logits": {
                    "value": "arc_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.nn.softplus(arc_ps)",
                            "UnaryOp"
                        ],
                        [
                            "arc_logits + self.bilinear(arc_dep_mlp, arc_head_mlp, 1, add_bias2=False)",
                            "BinOp"
                        ]
                    ]
                },
                "weights": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_68": {
                "variable": {
                    "value": "rel_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.bilinear(rel_dep_mlp, rel_head_mlp, len(self.vocabs['rels']))",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_70": {
                "variable": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "arc_preds if moving_params is not None else arc_targets",
                    "type": "IfExp",
                    "possible_values": []
                },
                "depth": {
                    "value": "self.bucket_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_72": {
                "variable": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(arc_preds if moving_params is not None else arc_targets, self.bucket_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(one_hot, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_74": {
                "variable": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.bilinear(rel_dep_mlp, rel_head_mlp, len(self.vocabs['rels']))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(arc_preds if moving_params is not None else arc_targets, self.bucket_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(one_hot, axis=3)",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_76": {
                "variable": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(rel_logits, one_hot)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(select_rel_logits, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_78": {
                "variable": {
                    "value": "rel_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(select_rel_logits, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_84": {
                "variable": {
                    "value": "rel_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "rel_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['rels'].placeholder",
                            "Attribute"
                        ]
                    ]
                },
                "logits": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(rel_logits, one_hot)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(select_rel_logits, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "weights": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_38": {
                "name_or_scope": {
                    "value": "MLP",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_44": {
                "name_or_scope": {
                    "value": "p",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_50": {
                "name_or_scope": {
                    "value": "Arc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_64": {
                "name_or_scope": {
                    "value": "Rel",
                    "type": "str",
                    "possible_values": []
                }
            },
            "to_int32_90": {
                "x": {
                    "value": "tf.equal(tf.reduce_sum(correct, axis=1), self.sequence_lengths - 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softplus_48": {
                "features": {
                    "value": "arc_ps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.bilinear(p_dep_mlp, p_head_mlp, 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_56": {
                "input": {
                    "value": "arc_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.nn.softplus(arc_ps)",
                            "UnaryOp"
                        ],
                        [
                            "arc_logits + self.bilinear(arc_dep_mlp, arc_head_mlp, 1, add_bias2=False)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "to_int32_60": {
                "x": {
                    "value": "tf.equal(arc_preds, arc_targets)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "argmax_78": {
                "input": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(rel_logits, one_hot)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(select_rel_logits, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "to_int32_82": {
                "x": {
                    "value": "tf.equal(rel_preds, rel_targets)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_90": {
                "x": {
                    "value": "tf.reduce_sum(correct, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.sequence_lengths - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "equal_60": {
                "x": {
                    "value": "arc_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.argmax(arc_logits, axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "arc_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['heads'].placeholder",
                            "Attribute"
                        ]
                    ]
                }
            },
            "equal_82": {
                "x": {
                    "value": "rel_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.argmax(select_rel_logits, axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "rel_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['rels'].placeholder",
                            "Attribute"
                        ]
                    ]
                }
            }
        }
    },
    "parser/neural/models/nlp/parsers/fish_parser.py": {
        "tensorflow": {
            "to_int32_36": {
                "variable": {
                    "value": "int_tokens_to_keep",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_94": {
                "variable": {
                    "value": "n_arc_correct",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "arc_correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.equal(arc_preds, arc_targets)) * int_tokens_to_keep",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_95": {
                "variable": {
                    "value": "n_rel_correct",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "rel_correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.equal(rel_preds, rel_targets)) * int_tokens_to_keep",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_97": {
                "variable": {
                    "value": "n_correct",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "arc_correct * rel_correct",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_98": {
                "input_tensor": {
                    "value": "correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "arc_correct * rel_correct",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_41": {
                "variable": {
                    "value": "(arc_dep_mlp, rel_dep_mlp, lambda_dep_mlp)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "dep_mlp",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[self.arc_mlp_size, self.rel_mlp_size, self.lambda_mlp_size]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_42": {
                "variable": {
                    "value": "(arc_head_mlp, rel_head_mlp, lambda_head_mlp)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "head_mlp",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[self.arc_mlp_size, self.rel_mlp_size, self.lambda_mlp_size]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_48": {
                "input": {
                    "value": "tf.range(self.bucket_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_50": {
                "input": {
                    "value": "tf.range(self.bucket_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "abs_52": {
                "variable": {
                    "value": "k_mat",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "i_mat - j_mat",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "softmax_62": {
                "variable": {
                    "value": "arc_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "arc_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(k_mat) * arc_lambdas - tf.exp(arc_lambdas) - tf.lgamma(tf.to_float(k_mat + 1))",
                            "BinOp"
                        ],
                        [
                            "arc_logits + self.bilinear(arc_dep_mlp, arc_head_mlp, 1, add_bias2=False)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "to_int32_64": {
                "variable": {
                    "value": "arc_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(arc_logits, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_70": {
                "variable": {
                    "value": "arc_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "arc_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['heads'].placeholder",
                            "Attribute"
                        ]
                    ]
                },
                "logits": {
                    "value": "arc_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(k_mat) * arc_lambdas - tf.exp(arc_lambdas) - tf.lgamma(tf.to_float(k_mat + 1))",
                            "BinOp"
                        ],
                        [
                            "arc_logits + self.bilinear(arc_dep_mlp, arc_head_mlp, 1, add_bias2=False)",
                            "BinOp"
                        ]
                    ]
                },
                "weights": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_76": {
                "variable": {
                    "value": "rel_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.bilinear(rel_dep_mlp, rel_head_mlp, len(self.vocabs['rels']))",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_78": {
                "variable": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "arc_preds if moving_params is not None else arc_targets",
                    "type": "IfExp",
                    "possible_values": []
                },
                "depth": {
                    "value": "self.bucket_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_80": {
                "variable": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(arc_preds if moving_params is not None else arc_targets, self.bucket_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(one_hot, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_82": {
                "variable": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.bilinear(rel_dep_mlp, rel_head_mlp, len(self.vocabs['rels']))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(arc_preds if moving_params is not None else arc_targets, self.bucket_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(one_hot, axis=3)",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_84": {
                "variable": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(rel_logits, one_hot)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(select_rel_logits, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_86": {
                "variable": {
                    "value": "rel_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(select_rel_logits, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_92": {
                "variable": {
                    "value": "rel_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "rel_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['rels'].placeholder",
                            "Attribute"
                        ]
                    ]
                },
                "logits": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(rel_logits, one_hot)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(select_rel_logits, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "weights": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_38": {
                "name_or_scope": {
                    "value": "MLP",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_44": {
                "name_or_scope": {
                    "value": "Lambda",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_58": {
                "name_or_scope": {
                    "value": "Arc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_72": {
                "name_or_scope": {
                    "value": "Rel",
                    "type": "str",
                    "possible_values": []
                }
            },
            "to_int32_98": {
                "x": {
                    "value": "tf.equal(tf.reduce_sum(correct, axis=1), self.sequence_lengths - 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "lgamma_56": {
                "x": {
                    "value": "tf.to_float(k_mat + 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "argmax_64": {
                "input": {
                    "value": "arc_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(k_mat) * arc_lambdas - tf.exp(arc_lambdas) - tf.lgamma(tf.to_float(k_mat + 1))",
                            "BinOp"
                        ],
                        [
                            "arc_logits + self.bilinear(arc_dep_mlp, arc_head_mlp, 1, add_bias2=False)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "to_int32_68": {
                "x": {
                    "value": "tf.equal(arc_preds, arc_targets)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "argmax_86": {
                "input": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(rel_logits, one_hot)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(select_rel_logits, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "to_int32_90": {
                "x": {
                    "value": "tf.equal(rel_preds, rel_targets)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_98": {
                "x": {
                    "value": "tf.reduce_sum(correct, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.sequence_lengths - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_54": {
                "input": {
                    "value": "self.sequence_lengths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_56": {
                "x": {
                    "value": "arc_lambdas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.bilinear(lambda_dep_mlp, lambda_head_mlp, 1) + 5",
                            "BinOp"
                        ]
                    ]
                }
            },
            "to_float_56": {
                "x": {
                    "value": "k_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.abs(i_mat - j_mat)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_68": {
                "x": {
                    "value": "arc_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.argmax(arc_logits, axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "arc_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['heads'].placeholder",
                            "Attribute"
                        ]
                    ]
                }
            },
            "equal_90": {
                "x": {
                    "value": "rel_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.argmax(select_rel_logits, axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "rel_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['rels'].placeholder",
                            "Attribute"
                        ]
                    ]
                }
            }
        }
    },
    "parser/neural/models/nlp/parsers/gama_parser.py": {
        "tensorflow": {
            "to_int32_36": {
                "variable": {
                    "value": "int_tokens_to_keep",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_101": {
                "variable": {
                    "value": "n_arc_correct",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "arc_correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.equal(arc_preds, arc_targets)) * int_tokens_to_keep",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_102": {
                "variable": {
                    "value": "n_rel_correct",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "rel_correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.equal(rel_preds, rel_targets)) * int_tokens_to_keep",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_104": {
                "variable": {
                    "value": "n_correct",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "arc_correct * rel_correct",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_105": {
                "input_tensor": {
                    "value": "correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "arc_correct * rel_correct",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_41": {
                "variable": {
                    "value": "(arc_dep_mlp, rel_dep_mlp, mu_dep_mlp, sigma_dep_mlp)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "dep_mlp",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[self.arc_mlp_size, self.rel_mlp_size, self.p_mlp_size, self.p_mlp_size]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_42": {
                "variable": {
                    "value": "(arc_head_mlp, rel_head_mlp, mu_head_mlp, sigma_head_mlp)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "head_mlp",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[self.arc_mlp_size, self.rel_mlp_size, self.p_mlp_size, self.p_mlp_size]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_52": {
                "variable": {
                    "value": "i_mat",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.range(self.bucket_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_54": {
                "variable": {
                    "value": "j_mat",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.range(self.bucket_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_float_56": {
                "variable": {
                    "value": "k_mat",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.abs(i_mat - j_mat)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_69": {
                "variable": {
                    "value": "arc_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "arc_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-0.5 * tf.log(2 * np.pi * arc_sigmas) - 0.5 * (k_mat - arc_mus) ** 2 / arc_sigmas",
                            "BinOp"
                        ],
                        [
                            "arc_logits + self.bilinear(arc_dep_mlp, arc_head_mlp, 1, add_bias2=False)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "to_int32_71": {
                "variable": {
                    "value": "arc_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(arc_logits, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_77": {
                "variable": {
                    "value": "arc_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "arc_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['heads'].placeholder",
                            "Attribute"
                        ]
                    ]
                },
                "logits": {
                    "value": "arc_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-0.5 * tf.log(2 * np.pi * arc_sigmas) - 0.5 * (k_mat - arc_mus) ** 2 / arc_sigmas",
                            "BinOp"
                        ],
                        [
                            "arc_logits + self.bilinear(arc_dep_mlp, arc_head_mlp, 1, add_bias2=False)",
                            "BinOp"
                        ]
                    ]
                },
                "weights": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_83": {
                "variable": {
                    "value": "rel_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.bilinear(rel_dep_mlp, rel_head_mlp, len(self.vocabs['rels']))",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_85": {
                "variable": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "arc_preds if moving_params is not None else arc_targets",
                    "type": "IfExp",
                    "possible_values": []
                },
                "depth": {
                    "value": "self.bucket_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_87": {
                "variable": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(arc_preds if moving_params is not None else arc_targets, self.bucket_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(one_hot, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_89": {
                "variable": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.bilinear(rel_dep_mlp, rel_head_mlp, len(self.vocabs['rels']))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(arc_preds if moving_params is not None else arc_targets, self.bucket_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(one_hot, axis=3)",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_91": {
                "variable": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(rel_logits, one_hot)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(select_rel_logits, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_93": {
                "variable": {
                    "value": "rel_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(select_rel_logits, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_99": {
                "variable": {
                    "value": "rel_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "rel_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['rels'].placeholder",
                            "Attribute"
                        ]
                    ]
                },
                "logits": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(rel_logits, one_hot)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(select_rel_logits, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "weights": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_38": {
                "name_or_scope": {
                    "value": "MLP",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_44": {
                "name_or_scope": {
                    "value": "dist",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_65": {
                "name_or_scope": {
                    "value": "Arc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_79": {
                "name_or_scope": {
                    "value": "Rel",
                    "type": "str",
                    "possible_values": []
                }
            },
            "to_int32_105": {
                "x": {
                    "value": "tf.equal(tf.reduce_sum(correct, axis=1), self.sequence_lengths - 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_45": {
                "name_or_scope": {
                    "value": "mu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_48": {
                "name_or_scope": {
                    "value": "sigma",
                    "type": "str",
                    "possible_values": []
                }
            },
            "abs_56": {
                "x": {
                    "value": "i_mat - j_mat",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "argmax_71": {
                "input": {
                    "value": "arc_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-0.5 * tf.log(2 * np.pi * arc_sigmas) - 0.5 * (k_mat - arc_mus) ** 2 / arc_sigmas",
                            "BinOp"
                        ],
                        [
                            "arc_logits + self.bilinear(arc_dep_mlp, arc_head_mlp, 1, add_bias2=False)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "to_int32_75": {
                "x": {
                    "value": "tf.equal(arc_preds, arc_targets)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "argmax_93": {
                "input": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(rel_logits, one_hot)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(select_rel_logits, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "to_int32_97": {
                "x": {
                    "value": "tf.equal(rel_preds, rel_targets)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_105": {
                "x": {
                    "value": "tf.reduce_sum(correct, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.sequence_lengths - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_58": {
                "x": {
                    "value": "2 * np.pi * arc_sigmas",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "equal_75": {
                "x": {
                    "value": "arc_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.argmax(arc_logits, axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "arc_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['heads'].placeholder",
                            "Attribute"
                        ]
                    ]
                }
            },
            "equal_97": {
                "x": {
                    "value": "rel_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.argmax(select_rel_logits, axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "rel_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['rels'].placeholder",
                            "Attribute"
                        ]
                    ]
                }
            }
        }
    },
    "parser/neural/models/nlp/parsers/parser.py": {
        "tensorflow": {
            "to_int32_36": {
                "variable": {
                    "value": "int_tokens_to_keep",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_80": {
                "variable": {
                    "value": "n_arc_correct",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "arc_correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.equal(arc_preds, arc_targets)) * int_tokens_to_keep",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_81": {
                "variable": {
                    "value": "n_rel_correct",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "rel_correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.equal(rel_preds, rel_targets)) * int_tokens_to_keep",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_83": {
                "variable": {
                    "value": "n_correct",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "arc_correct * rel_correct",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_84": {
                "input_tensor": {
                    "value": "correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "arc_correct * rel_correct",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_41": {
                "variable": {
                    "value": "(arc_dep_mlp, rel_dep_mlp)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "dep_mlp",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[self.arc_mlp_size, self.rel_mlp_size]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_42": {
                "variable": {
                    "value": "(arc_head_mlp, rel_head_mlp)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "head_mlp",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[self.arc_mlp_size, self.rel_mlp_size]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_48": {
                "variable": {
                    "value": "arc_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "arc_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.bilinear(arc_dep_mlp, arc_head_mlp, 1, add_bias2=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "to_int32_50": {
                "variable": {
                    "value": "arc_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(arc_logits, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_56": {
                "variable": {
                    "value": "arc_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "arc_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['heads'].placeholder",
                            "Attribute"
                        ]
                    ]
                },
                "logits": {
                    "value": "arc_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.bilinear(arc_dep_mlp, arc_head_mlp, 1, add_bias2=False)",
                            "Call"
                        ]
                    ]
                },
                "weights": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_62": {
                "variable": {
                    "value": "rel_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.bilinear(rel_dep_mlp, rel_head_mlp, len(self.vocabs['rels']))",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_64": {
                "variable": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "arc_preds if moving_params is not None else arc_targets",
                    "type": "IfExp",
                    "possible_values": []
                },
                "depth": {
                    "value": "self.bucket_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_66": {
                "variable": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(arc_preds if moving_params is not None else arc_targets, self.bucket_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(one_hot, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_68": {
                "variable": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.bilinear(rel_dep_mlp, rel_head_mlp, len(self.vocabs['rels']))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(arc_preds if moving_params is not None else arc_targets, self.bucket_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(one_hot, axis=3)",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_70": {
                "variable": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(rel_logits, one_hot)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(select_rel_logits, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_72": {
                "variable": {
                    "value": "rel_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(select_rel_logits, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_78": {
                "variable": {
                    "value": "rel_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "rel_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['rels'].placeholder",
                            "Attribute"
                        ]
                    ]
                },
                "logits": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(rel_logits, one_hot)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(select_rel_logits, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "weights": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_38": {
                "name_or_scope": {
                    "value": "MLP",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_44": {
                "name_or_scope": {
                    "value": "Arc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_58": {
                "name_or_scope": {
                    "value": "Rel",
                    "type": "str",
                    "possible_values": []
                }
            },
            "to_int32_84": {
                "x": {
                    "value": "tf.equal(tf.reduce_sum(correct, axis=1), self.sequence_lengths - 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "argmax_50": {
                "input": {
                    "value": "arc_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.bilinear(arc_dep_mlp, arc_head_mlp, 1, add_bias2=False)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "to_int32_54": {
                "x": {
                    "value": "tf.equal(arc_preds, arc_targets)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "argmax_72": {
                "input": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(rel_logits, one_hot)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(select_rel_logits, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "to_int32_76": {
                "x": {
                    "value": "tf.equal(rel_preds, rel_targets)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_84": {
                "x": {
                    "value": "tf.reduce_sum(correct, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.sequence_lengths - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "equal_54": {
                "x": {
                    "value": "arc_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.argmax(arc_logits, axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "arc_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['heads'].placeholder",
                            "Attribute"
                        ]
                    ]
                }
            },
            "equal_76": {
                "x": {
                    "value": "rel_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.argmax(select_rel_logits, axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "rel_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['rels'].placeholder",
                            "Attribute"
                        ]
                    ]
                }
            }
        }
    },
    "parser/neural/models/nlp/parsers/xbar_parser.py": {
        "tensorflow": {
            "to_int32_36": {
                "variable": {
                    "value": "int_tokens_to_keep",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_95": {
                "variable": {
                    "value": "n_arc_correct",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "arc_correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.equal(arc_preds, arc_targets)) * int_tokens_to_keep",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_96": {
                "variable": {
                    "value": "n_rel_correct",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "rel_correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.equal(rel_preds, rel_targets)) * int_tokens_to_keep",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_98": {
                "variable": {
                    "value": "n_correct",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "arc_correct * rel_correct",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_99": {
                "input_tensor": {
                    "value": "correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "arc_correct * rel_correct",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_41": {
                "variable": {
                    "value": "(arc_dep_mlp, rel_dep_mlp, p_dep_mlp)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "dep_mlp",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[self.arc_mlp_size, self.rel_mlp_size, self.p_mlp_size]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_42": {
                "variable": {
                    "value": "(arc_head_mlp, rel_head_mlp, p_head_mlp)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "head_mlp",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[self.arc_mlp_size, self.rel_mlp_size, self.p_mlp_size]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_48": {
                "input": {
                    "value": "tf.range(self.bucket_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_50": {
                "input": {
                    "value": "tf.range(self.bucket_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_52": {
                "variable": {
                    "value": "k_mat",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "j_mat > i_mat",
                    "type": "Compare",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[self.batch_size, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softmax_63": {
                "variable": {
                    "value": "arc_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "arc_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.nn.softplus(tf.where(k_mat, arc_ps, -arc_ps))",
                            "UnaryOp"
                        ],
                        [
                            "arc_logits + self.bilinear(arc_dep_mlp, arc_head_mlp, 1, add_bias2=False)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "to_int32_65": {
                "variable": {
                    "value": "arc_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(arc_logits, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_71": {
                "variable": {
                    "value": "arc_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "arc_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['heads'].placeholder",
                            "Attribute"
                        ]
                    ]
                },
                "logits": {
                    "value": "arc_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.nn.softplus(tf.where(k_mat, arc_ps, -arc_ps))",
                            "UnaryOp"
                        ],
                        [
                            "arc_logits + self.bilinear(arc_dep_mlp, arc_head_mlp, 1, add_bias2=False)",
                            "BinOp"
                        ]
                    ]
                },
                "weights": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_77": {
                "variable": {
                    "value": "rel_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.bilinear(rel_dep_mlp, rel_head_mlp, len(self.vocabs['rels']))",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_79": {
                "variable": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "arc_preds if moving_params is not None else arc_targets",
                    "type": "IfExp",
                    "possible_values": []
                },
                "depth": {
                    "value": "self.bucket_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_81": {
                "variable": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(arc_preds if moving_params is not None else arc_targets, self.bucket_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(one_hot, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_83": {
                "variable": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.bilinear(rel_dep_mlp, rel_head_mlp, len(self.vocabs['rels']))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(arc_preds if moving_params is not None else arc_targets, self.bucket_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(one_hot, axis=3)",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_85": {
                "variable": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(rel_logits, one_hot)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(select_rel_logits, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_87": {
                "variable": {
                    "value": "rel_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(select_rel_logits, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_93": {
                "variable": {
                    "value": "rel_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "rel_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['rels'].placeholder",
                            "Attribute"
                        ]
                    ]
                },
                "logits": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(rel_logits, one_hot)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(select_rel_logits, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "weights": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_38": {
                "name_or_scope": {
                    "value": "MLP",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_44": {
                "name_or_scope": {
                    "value": "p",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_59": {
                "name_or_scope": {
                    "value": "Arc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_73": {
                "name_or_scope": {
                    "value": "Rel",
                    "type": "str",
                    "possible_values": []
                }
            },
            "to_int32_99": {
                "x": {
                    "value": "tf.equal(tf.reduce_sum(correct, axis=1), self.sequence_lengths - 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softplus_56": {
                "features": {
                    "value": "tf.where(k_mat, arc_ps, -arc_ps)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "argmax_65": {
                "input": {
                    "value": "arc_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.nn.softplus(tf.where(k_mat, arc_ps, -arc_ps))",
                            "UnaryOp"
                        ],
                        [
                            "arc_logits + self.bilinear(arc_dep_mlp, arc_head_mlp, 1, add_bias2=False)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "to_int32_69": {
                "x": {
                    "value": "tf.equal(arc_preds, arc_targets)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "argmax_87": {
                "input": {
                    "value": "select_rel_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(rel_logits, one_hot)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(select_rel_logits, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "to_int32_91": {
                "x": {
                    "value": "tf.equal(rel_preds, rel_targets)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_99": {
                "x": {
                    "value": "tf.reduce_sum(correct, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.sequence_lengths - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_54": {
                "input": {
                    "value": "self.sequence_lengths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_56": {
                "condition": {
                    "value": "k_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(j_mat > i_mat, [self.batch_size, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "arc_ps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.bilinear(p_dep_mlp, p_head_mlp, 1, add_bias2=False)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "-arc_ps",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "equal_69": {
                "x": {
                    "value": "arc_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.argmax(arc_logits, axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "arc_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['heads'].placeholder",
                            "Attribute"
                        ]
                    ]
                }
            },
            "equal_91": {
                "x": {
                    "value": "rel_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.argmax(select_rel_logits, axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "rel_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['rels'].placeholder",
                            "Attribute"
                        ]
                    ]
                }
            }
        }
    },
    "parser/neural/models/nlp/taggers/base_tagger.py": {
        "tensorflow": {
            "to_float_56": {
                "variable": {
                    "value": "self._tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.greater(placeholder, self.ROOT)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_59": {
                "variable": {
                    "value": "self._sequence_lengths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.to_int32(tf.greater(placeholder, self.PAD))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_60": {
                "variable": {
                    "value": "self._n_tokens",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(self.tokens_to_keep)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "greater_56": {
                "x": {
                    "value": "placeholder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['words'].placeholder",
                            "Attribute"
                        ],
                        [
                            "placeholder[:, :, 0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "self.ROOT",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_57": {
                "input": {
                    "value": "placeholder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['words'].placeholder",
                            "Attribute"
                        ],
                        [
                            "placeholder[:, :, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_58": {
                "input": {
                    "value": "placeholder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['words'].placeholder",
                            "Attribute"
                        ],
                        [
                            "placeholder[:, :, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "to_int32_59": {
                "x": {
                    "value": "tf.greater(placeholder, self.PAD)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_60": {
                "input_tensor": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "greater_59": {
                "x": {
                    "value": "placeholder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['words'].placeholder",
                            "Attribute"
                        ],
                        [
                            "placeholder[:, :, 0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "self.PAD",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_64": {
                "name_or_scope": {
                    "value": "'RNN%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "parser/neural/models/nlp/taggers/base_xtagger.py": {
        "tensorflow": {
            "to_float_56": {
                "variable": {
                    "value": "self._tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.greater(placeholder, self.ROOT)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_59": {
                "variable": {
                    "value": "self._sequence_lengths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.to_int32(tf.greater(placeholder, self.PAD))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_60": {
                "variable": {
                    "value": "self._n_tokens",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(self.tokens_to_keep)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "greater_56": {
                "x": {
                    "value": "placeholder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['words'].placeholder",
                            "Attribute"
                        ],
                        [
                            "placeholder[:, :, 0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "self.ROOT",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_57": {
                "input": {
                    "value": "placeholder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['words'].placeholder",
                            "Attribute"
                        ],
                        [
                            "placeholder[:, :, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_58": {
                "input": {
                    "value": "placeholder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['words'].placeholder",
                            "Attribute"
                        ],
                        [
                            "placeholder[:, :, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "to_int32_59": {
                "x": {
                    "value": "tf.greater(placeholder, self.PAD)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_60": {
                "input_tensor": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "greater_59": {
                "x": {
                    "value": "placeholder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['words'].placeholder",
                            "Attribute"
                        ],
                        [
                            "placeholder[:, :, 0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "self.PAD",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_64": {
                "name_or_scope": {
                    "value": "'RNN%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "parser/neural/models/nlp/taggers/tagger.py": {
        "tensorflow": {
            "to_int32_36": {
                "variable": {
                    "value": "int_tokens_to_keep",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_50": {
                "variable": {
                    "value": "n_correct",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.equal(preds, targets)) * int_tokens_to_keep",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_51": {
                "input_tensor": {
                    "value": "correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.equal(preds, targets)) * int_tokens_to_keep",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_43": {
                "variable": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.linear(mlp, len(self.vocabs['tags']))",
                            "Call"
                        ]
                    ]
                }
            },
            "to_int32_44": {
                "variable": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(logits, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_47": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['tags'].placeholder",
                            "Attribute"
                        ]
                    ]
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.linear(mlp, len(self.vocabs['tags']))",
                            "Call"
                        ]
                    ]
                },
                "weights": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_38": {
                "name_or_scope": {
                    "value": "MLP",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_41": {
                "name_or_scope": {
                    "value": "Tag",
                    "type": "str",
                    "possible_values": []
                }
            },
            "to_int32_51": {
                "x": {
                    "value": "tf.equal(tf.reduce_sum(correct, axis=1), self.sequence_lengths - 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "argmax_44": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.linear(mlp, len(self.vocabs['tags']))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "to_int32_46": {
                "x": {
                    "value": "tf.equal(preds, targets)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_51": {
                "x": {
                    "value": "tf.reduce_sum(correct, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.sequence_lengths - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "equal_46": {
                "x": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.argmax(logits, axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['tags'].placeholder",
                            "Attribute"
                        ]
                    ]
                }
            }
        }
    },
    "parser/neural/models/nlp/taggers/xtagger.py": {
        "tensorflow": {
            "to_int32_36": {
                "variable": {
                    "value": "int_tokens_to_keep",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_58": {
                "variable": {
                    "value": "n_correct",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tag_correct * xtag_correct",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_59": {
                "variable": {
                    "value": "n_tag_correct",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tag_correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.equal(tag_preds, tag_targets)) * int_tokens_to_keep",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_60": {
                "variable": {
                    "value": "n_xtag_correct",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "xtag_correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.equal(xtag_preds, xtag_targets)) * int_tokens_to_keep",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_61": {
                "input_tensor": {
                    "value": "correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tag_correct * xtag_correct",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_43": {
                "variable": {
                    "value": "tag_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "tag_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.linear(tag_mlp, len(self.vocabs['tags']))",
                            "Call"
                        ]
                    ]
                }
            },
            "to_int32_44": {
                "variable": {
                    "value": "tag_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(tag_logits, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_47": {
                "variable": {
                    "value": "tag_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "tag_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['tags'].placeholder",
                            "Attribute"
                        ]
                    ]
                },
                "logits": {
                    "value": "tag_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.linear(tag_mlp, len(self.vocabs['tags']))",
                            "Call"
                        ]
                    ]
                },
                "weights": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_51": {
                "variable": {
                    "value": "xtag_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "xtag_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.linear(xtag_mlp, len(self.vocabs['xtags']))",
                            "Call"
                        ]
                    ]
                }
            },
            "to_int32_52": {
                "variable": {
                    "value": "xtag_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(xtag_logits, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_55": {
                "variable": {
                    "value": "xtag_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "xtag_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['xtags'].placeholder",
                            "Attribute"
                        ]
                    ]
                },
                "logits": {
                    "value": "xtag_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.linear(xtag_mlp, len(self.vocabs['xtags']))",
                            "Call"
                        ]
                    ]
                },
                "weights": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_38": {
                "name_or_scope": {
                    "value": "MLP",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_41": {
                "name_or_scope": {
                    "value": "Tag",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_49": {
                "name_or_scope": {
                    "value": "XTag",
                    "type": "str",
                    "possible_values": []
                }
            },
            "to_int32_61": {
                "x": {
                    "value": "tf.equal(tf.reduce_sum(correct, axis=1), self.sequence_lengths - 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "argmax_44": {
                "input": {
                    "value": "tag_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.linear(tag_mlp, len(self.vocabs['tags']))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "to_int32_46": {
                "x": {
                    "value": "tf.equal(tag_preds, tag_targets)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "argmax_52": {
                "input": {
                    "value": "xtag_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.linear(xtag_mlp, len(self.vocabs['xtags']))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "to_int32_54": {
                "x": {
                    "value": "tf.equal(xtag_preds, xtag_targets)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_61": {
                "x": {
                    "value": "tf.reduce_sum(correct, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.sequence_lengths - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "equal_46": {
                "x": {
                    "value": "tag_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.argmax(tag_logits, axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tag_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['tags'].placeholder",
                            "Attribute"
                        ]
                    ]
                }
            },
            "equal_54": {
                "x": {
                    "value": "xtag_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.argmax(xtag_logits, axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "xtag_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vocabs['xtags'].placeholder",
                            "Attribute"
                        ]
                    ]
                }
            }
        }
    },
    "parser/neural/models/nn.py": {
        "tensorflow": {
            "convert_to_tensor_32": {
                "variable": {
                    "value": "ZERO",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "convert_to_tensor_33": {
                "variable": {
                    "value": "ONE",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "softmax_257": {
                "variable": {
                    "value": "attn_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "attn_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.linear(inputs, 1, add_bias=False)",
                            "Call"
                        ],
                        [
                            "self.bilinear(inputs, inputs, 1, add_bias2=False, add_bias=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_258": {
                "variable": {
                    "value": "attn_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attn_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(attn_logits)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(attn_prob, -1)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(attn_logits)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "matmul_260": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "attn_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(attn_logits)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(attn_prob, -1)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(attn_logits)",
                            "Call"
                        ]
                    ]
                },
                "transpose_a": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "squeeze_261": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(inputs, attn_prob, transpose_a=True)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(outputs, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.matmul(attn_prob, inputs)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_270": {
                "variable": {
                    "value": "attn_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "attn_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.linear(inputs, 1, add_bias=False)",
                            "Call"
                        ],
                        [
                            "self.bilinear(inputs, inputs, 1, add_bias2=False, add_bias=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_272": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "attn_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(attn_logits)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(attn_prob, -1)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(attn_logits)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_n_69": {
                "variable": {
                    "value": "total_masks",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "drop_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "concat_86": {
                "values": {
                    "value": "embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_initializer_89": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "concat_94": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "n_dims - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "stack_104": {
                "variable": {
                    "value": "noise_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[self.batch_size] + [1] * (n_dims - 2) + [input_size]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "dropout_105": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "keep_prob or self.mlp_keep_prob",
                            "BoolOp"
                        ],
                        [
                            "1",
                            "int"
                        ],
                        [
                            "keep_prob or self.mlp_keep_prob",
                            "BoolOp"
                        ],
                        [
                            "1",
                            "int"
                        ],
                        [
                            "keep_prob or self.conv_keep_prob",
                            "BoolOp"
                        ],
                        [
                            "1",
                            "int"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "noise_shape": {
                    "value": "noise_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([self.batch_size] + [1] * (n_dims - 2) + [input_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_initializer_122": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "concat_127": {
                "variable": {
                    "value": "inputs1",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "inputs1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs1, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs1, keep_prob, noise_shape=noise_shape1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "n_dims - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_134": {
                "variable": {
                    "value": "inputs2",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "inputs2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs2, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs2, keep_prob, noise_shape=noise_shape2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "n_dims - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "stack_148": {
                "variable": {
                    "value": "noise_shape1",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[self.batch_size] + [1] * (n_dims1 - 2) + [inputs1_size]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "stack_149": {
                "variable": {
                    "value": "noise_shape2",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[self.batch_size] + [1] * (n_dims2 - 2) + [inputs2_size]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "dropout_150": {
                "variable": {
                    "value": "inputs1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs1, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs1, keep_prob, noise_shape=noise_shape1)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "keep_prob or self.mlp_keep_prob",
                            "BoolOp"
                        ],
                        [
                            "1",
                            "int"
                        ],
                        [
                            "keep_prob or self.mlp_keep_prob",
                            "BoolOp"
                        ],
                        [
                            "1",
                            "int"
                        ],
                        [
                            "keep_prob or self.conv_keep_prob",
                            "BoolOp"
                        ],
                        [
                            "1",
                            "int"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "noise_shape": {
                    "value": "noise_shape1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([self.batch_size] + [1] * (n_dims1 - 2) + [inputs1_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "dropout_151": {
                "variable": {
                    "value": "inputs2",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs2, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs2, keep_prob, noise_shape=noise_shape2)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "keep_prob or self.mlp_keep_prob",
                            "BoolOp"
                        ],
                        [
                            "1",
                            "int"
                        ],
                        [
                            "keep_prob or self.mlp_keep_prob",
                            "BoolOp"
                        ],
                        [
                            "1",
                            "int"
                        ],
                        [
                            "keep_prob or self.conv_keep_prob",
                            "BoolOp"
                        ],
                        [
                            "1",
                            "int"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "noise_shape": {
                    "value": "noise_shape2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([self.batch_size] + [1] * (n_dims2 - 2) + [inputs2_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_173": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "n_dims - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "dropout_184": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, n_dims - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "keep_prob or self.mlp_keep_prob",
                            "BoolOp"
                        ],
                        [
                            "1",
                            "int"
                        ],
                        [
                            "keep_prob or self.mlp_keep_prob",
                            "BoolOp"
                        ],
                        [
                            "1",
                            "int"
                        ],
                        [
                            "keep_prob or self.conv_keep_prob",
                            "BoolOp"
                        ],
                        [
                            "1",
                            "int"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "squeeze_118": {
                "variable": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "linalg.linear(inputs, output_size, n_splits=n_splits, add_bias=add_bias, initializer=initializer, moving_params=self.moving_params)",
                            "Call"
                        ],
                        [
                            "[tf.squeeze(x, axis=n_dims - 1) for x in lin]",
                            "ListComp"
                        ],
                        [
                            "tf.squeeze(lin, axis=n_dims - 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "n_dims - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "squeeze_164": {
                "variable": {
                    "value": "bilin",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "bilin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "linalg.bilinear(inputs1, inputs2, output_size, n_splits, add_bias1=add_bias1, add_bias2=add_bias2, initializer=initializer, moving_params=self.moving_params)",
                            "Call"
                        ],
                        [
                            "[tf.squeeze(x, axis=n_dims1 - 1) for x in bilin]",
                            "ListComp"
                        ],
                        [
                            "tf.squeeze(bilin, axis=n_dims1 - 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "n_dims1 - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "squeeze_198": {
                "variable": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "linalg.convolutional(inputs, window_size, output_size, n_splits=n_splits, add_bias=add_bias, initializer=initializer, moving_params=self.moving_params)",
                            "Call"
                        ],
                        [
                            "[tf.squeeze(x, axis=n_dims - 1) for x in conv]",
                            "ListComp"
                        ],
                        [
                            "tf.squeeze(conv, axis=n_dims - 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "n_dims - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_65": {
                "variable": {
                    "value": "drop_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "linalg.random_mask(vocab.embed_keep_prob, tf.shape(placeholder))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "maximum_70": {
                "x": {
                    "value": "total_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n(drop_masks)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "squeeze_116": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "n_dims - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "squeeze_162": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "n_dims1 - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "squeeze_196": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "n_dims - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "unstack_62": {
                "value": {
                    "value": "placeholder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "vocab.generate_placeholder()",
                            "Call"
                        ],
                        [
                            "placeholders",
                            "variable"
                        ],
                        [
                            "tf.unstack(placeholder, axis=2)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_65": {
                "input": {
                    "value": "placeholder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "vocab.generate_placeholder()",
                            "Call"
                        ],
                        [
                            "placeholders",
                            "variable"
                        ],
                        [
                            "tf.unstack(placeholder, axis=2)[0]",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "parser/neural/optimizers/base_optimizer.py": {
        "tensorflow": {
            "trainable_variables_53": {
                "variable": {
                    "value": "var_list",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "gradients_63": {
                "variable": {
                    "value": "grads",
                    "type": "variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "xs": {
                    "value": "var_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ]
                    ]
                },
                "colocate_gradients_with_ops": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "gate_gradients": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "aggregation_method": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "assign_add_165": {
                "variable": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "tm1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_accumulator(x_tm1, '%s/tm1' % name, shape=[])",
                            "Call"
                        ],
                        [
                            "self.get_accumulator(x_tm1, '%s/tm1' % name, shape=[shape[0]] + [1] * (len(shape) - 1))",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "assign_171": {
                "variable": {
                    "value": "b_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "b_tm1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_accumulator(x_tm1, '%s' % name)",
                            "Call"
                        ],
                        [
                            "self.get_accumulator(x_tm1, '%s' % name)",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "beta_t * b_tm1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "assign_add_172": {
                "variable": {
                    "value": "b_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "b_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.assign(b_tm1, beta_t * b_tm1)",
                            "Call"
                        ],
                        [
                            "tf.assign_add(b_t, (1 - beta_t) * a_t)",
                            "Call"
                        ],
                        [
                            "tf.scatter_update(b_tm1, idxs, beta_t_ * b_tm1_)",
                            "Call"
                        ],
                        [
                            "tf.scatter_add(b_t, idxs, (1 - beta_t_) * a_t_)",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "(1 - beta_t) * a_t",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "gather_180": {
                "variable": {
                    "value": "b_tm1_",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "b_tm1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_accumulator(x_tm1, '%s' % name)",
                            "Call"
                        ],
                        [
                            "self.get_accumulator(x_tm1, '%s' % name)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "idxs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cache['idxs']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "gather_183": {
                "variable": {
                    "value": "tm1_",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "tm1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_accumulator(x_tm1, '%s/tm1' % name, shape=[])",
                            "Call"
                        ],
                        [
                            "self.get_accumulator(x_tm1, '%s/tm1' % name, shape=[shape[0]] + [1] * (len(shape) - 1))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "idxs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cache['idxs']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scatter_add_184": {
                "variable": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "tm1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_accumulator(x_tm1, '%s/tm1' % name, shape=[])",
                            "Call"
                        ],
                        [
                            "self.get_accumulator(x_tm1, '%s/tm1' % name, shape=[shape[0]] + [1] * (len(shape) - 1))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "idxs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cache['idxs']",
                            "Subscript"
                        ]
                    ]
                },
                "updates": {
                    "value": "tf.ones_like(tm1_)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_185": {
                "variable": {
                    "value": "t_",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.assign_add(tm1, 1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_add(tm1, idxs, tf.ones_like(tm1_))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "idxs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cache['idxs']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scatter_update_191": {
                "variable": {
                    "value": "b_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "b_tm1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_accumulator(x_tm1, '%s' % name)",
                            "Call"
                        ],
                        [
                            "self.get_accumulator(x_tm1, '%s' % name)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "idxs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cache['idxs']",
                            "Subscript"
                        ]
                    ]
                },
                "updates": {
                    "value": "beta_t_ * b_tm1_",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scatter_add_192": {
                "variable": {
                    "value": "b_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "b_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.assign(b_tm1, beta_t * b_tm1)",
                            "Call"
                        ],
                        [
                            "tf.assign_add(b_t, (1 - beta_t) * a_t)",
                            "Call"
                        ],
                        [
                            "tf.scatter_update(b_tm1, idxs, beta_t_ * b_tm1_)",
                            "Call"
                        ],
                        [
                            "tf.scatter_add(b_t, idxs, (1 - beta_t_) * a_t_)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "idxs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cache['idxs']",
                            "Subscript"
                        ]
                    ]
                },
                "updates": {
                    "value": "(1 - beta_t_) * a_t_",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_145": {
                "variable": {
                    "value": "zeros",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_variable_shape(x_tm1)",
                            "Call"
                        ],
                        [
                            "self.get_variable_shape(x_tm1)",
                            "Call"
                        ],
                        [
                            "self.get_variable_shape(x_tm1)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "x_tm1.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_167": {
                "variable": {
                    "value": "beta_t",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.9",
                            "Method Argument"
                        ],
                        [
                            "0.9",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "'%s/decay' % name",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "convert_to_tensor_187": {
                "variable": {
                    "value": "beta_t",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.9",
                            "Method Argument"
                        ],
                        [
                            "0.9",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "'%s/decay' % name",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "clip_by_global_norm_201": {
                "variable": {
                    "value": "(S_t, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "t_list": {
                    "value": "S_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[cache['s_t'] for cache in caches]",
                            "ListComp"
                        ]
                    ]
                },
                "clip_norm": {
                    "value": "self.clip",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "group_225": {
                "*inputs": {
                    "value": "*update_ops",
                    "type": "Starred",
                    "possible_values": []
                },
                "name": {
                    "value": "update",
                    "type": "str",
                    "possible_values": []
                }
            },
            "trainable_variables_248": {
                "variable": {
                    "value": "moving_avg_variables",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Variable_36": {
                "initial_value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "control_dependencies_73": {
                "control_inputs": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "name_scope_75": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ones_like_184": {
                "input": {
                    "value": "tm1_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(tm1, idxs)",
                            "Call"
                        ]
                    ]
                }
            },
            "group_224": {
                "*inputs": {
                    "value": "*cache['updates']",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "moving_average_variables_249": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "control_dependencies_87": {
                "control_inputs": {
                    "value": "[self._finish(caches)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_to_collection_97": {
                "name": {
                    "value": "self.get_accumulator(x_tm1, 'x')",
                    "type": "Call",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.GraphKeys.MOVING_AVERAGE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "name_scope_146": {
                "name": {
                    "value": "'%s/%s' % (x_tm1.op.name, new_name)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Variable_148": {
                "variable": {
                    "value": "accumulator[x_tm1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "zeros",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros(shape, dtype=x_tm1.dtype)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "name_scope_209": {
                "name": {
                    "value": "'update_' + x_tm1.op.name",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "device_209": {
                "device_name": {
                    "value": "x_tm1.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scatter_sub_212": {
                "variable": {
                    "value": "x_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "x_tm1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "var_list",
                            "variable"
                        ],
                        [
                            "cache['x_tm1']",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "idxs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cache['idxs']",
                            "Subscript"
                        ]
                    ]
                },
                "updates": {
                    "value": "s_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cache['s_t']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "assign_sub_217": {
                "variable": {
                    "value": "x_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "x_tm1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "var_list",
                            "variable"
                        ],
                        [
                            "cache['x_tm1']",
                            "Subscript"
                        ]
                    ]
                },
                "value": {
                    "value": "s_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cache['s_t']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "name_scope_79": {
                "name": {
                    "value": "'update_' + x_tm1.op.name",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "device_79": {
                "device_name": {
                    "value": "x_tm1.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_81": {
                "variable": {
                    "value": "cache[g_t]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.is_finite(g_t)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "g_t",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.zeros_like(g_t)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_84": {
                "variable": {
                    "value": "cache[g_t]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.is_finite(g_t.values)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "g_t.values",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.zeros_like(g_t.values)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "device_88": {
                "device_name": {
                    "value": "self.global_step.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "device_147": {
                "device_name": {
                    "value": "x_tm1.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_214": {
                "variable": {
                    "value": "x_t_",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.scatter_sub(x_tm1, idxs, s_t)",
                            "Call"
                        ],
                        [
                            "tf.assign_sub(x_tm1, s_t)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "idxs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cache['idxs']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "all_variables_256": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "assign_add_89": {
                "ref": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "is_finite_81": {
                "x": {
                    "value": "g_t",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "zeros_like_81": {
                "input": {
                    "value": "g_t",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "is_finite_84": {
                "x": {
                    "value": "g_t.values",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_84": {
                "input": {
                    "value": "g_t.values",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "parser/neural/optimizers/radam_optimizer.py": {
        "tensorflow": {
            "where_74": {
                "variable": {
                    "value": "cache[s_t]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.is_finite(s_t)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "s_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.learning_rate * m_bar_t / v_bar_t",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(s_t)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "unique_82": {
                "variable": {
                    "value": "(idxs, idxs_)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "idxs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "unsorted_segment_sum_83": {
                "variable": {
                    "value": "g_t_",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "g_t",
                    "type": "variable",
                    "possible_values": []
                },
                "segment_ids": {
                    "value": "idxs_",
                    "type": "variable",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "tf.size(idxs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_103": {
                "variable": {
                    "value": "cache[s_t]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.is_finite(s_t_)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "s_t_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.learning_rate * m_bar_t_ / v_bar_t_",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(s_t_)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_68": {
                "variable": {
                    "value": "v_bar_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "v_t + self.epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "gather_88": {
                "variable": {
                    "value": "m_t_",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "m_t",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "idxs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "gather_96": {
                "variable": {
                    "value": "v_t_",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "v_t",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "idxs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sqrt_97": {
                "variable": {
                    "value": "v_bar_t_",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "v_t_ + self.epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "is_finite_74": {
                "x": {
                    "value": "s_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.learning_rate * m_bar_t / v_bar_t",
                            "BinOp"
                        ]
                    ]
                }
            },
            "zeros_like_74": {
                "input": {
                    "value": "s_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.learning_rate * m_bar_t / v_bar_t",
                            "BinOp"
                        ]
                    ]
                }
            },
            "size_83": {
                "input": {
                    "value": "idxs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "is_finite_103": {
                "x": {
                    "value": "s_t_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.learning_rate * m_bar_t_ / v_bar_t_",
                            "BinOp"
                        ]
                    ]
                }
            },
            "zeros_like_103": {
                "input": {
                    "value": "s_t_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.learning_rate * m_bar_t_ / v_bar_t_",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "parser/neural/optimizers/sgd_optimizer.py": {
        "tensorflow": {
            "unique_43": {
                "variable": {
                    "value": "(idxs, idxs_)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "idxs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "unsorted_segment_sum_44": {
                "variable": {
                    "value": "g_t_",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "g_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cache['g_t']",
                            "Subscript"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "idxs_",
                    "type": "variable",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "tf.size(idxs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "size_44": {
                "input": {
                    "value": "idxs",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "parser/neural/recur_cells/base_cell.py": {
        "tensorflow": {
            "get_variable_50": {
                "variable": {
                    "value": "zero_state",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Zero_state",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "self.state_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_54": {
                "variable": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.tile(zero_state, tf.stack([batch_size]))",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.stack([batch_size, self.state_size])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tile_54": {
                "input": {
                    "value": "zero_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('Zero_state', shape=self.state_size, dtype=dtype, initializer=tf.zeros_initializer())",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "tf.stack([batch_size])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stack_54": {
                "values": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_initializer_53": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "parser/neural/recur_cells/cif_lstm_cell.py": {
        "tensorflow": {
            "split_37": {
                "variable": {
                    "value": "(cell_tm1, hidden_tm1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_36": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "concat_53": {
                "values": {
                    "value": "[cell_t, hidden_t]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "parser/neural/recur_cells/gru_cell.py": {
        "tensorflow": {
            "split_37": {
                "variable": {
                    "value": "(cell_tm1, hidden_tm1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_36": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "concat_57": {
                "values": {
                    "value": "[cell_t, cell_t]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_39": {
                "name_or_scope": {
                    "value": "Gates",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_50": {
                "name_or_scope": {
                    "value": "Candidate",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "parser/neural/recur_cells/lstm_cell.py": {
        "tensorflow": {
            "split_37": {
                "variable": {
                    "value": "(cell_tm1, hidden_tm1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_36": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "concat_54": {
                "values": {
                    "value": "[cell_t, hidden_t]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "parser/neural/recur_cells/rnn_cell.py": {
        "tensorflow": {
            "variable_scope_35": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            }
        }
    },
    "parser/neural/rnn.py": {
        "tensorflow": {
            "reverse_sequence_36": {
                "variable": {
                    "value": "rev_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, ff_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ]
                    ]
                },
                "seq_lengths": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(sequence_length)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "seq_axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "batch_axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reverse_sequence_39": {
                "variable": {
                    "value": "output_bw",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output_bw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reverse_sequence(output_bw, sequence_length, 1, 0)",
                            "Call"
                        ]
                    ]
                },
                "seq_lengths": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(sequence_length)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "seq_axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "batch_axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_41": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[output_fw, output_bw]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_49": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, ff_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_int32_53": {
                "variable": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(sequence_length)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_58": {
                "variable": {
                    "value": "input_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, ff_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "unstack_59": {
                "variable": {
                    "value": "(time_steps, batch_size, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "input_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(inputs)",
                            "Call"
                        ]
                    ]
                },
                "num": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_69": {
                "variable": {
                    "value": "zero_output",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.stack([batch_size, cell.output_size])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_74": {
                "variable": {
                    "value": "time",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "time",
                    "type": "str",
                    "possible_values": []
                }
            },
            "TensorArray_76": {
                "variable": {
                    "value": "output_ta",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "time_steps",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor_array_name": {
                    "value": "dynamic_rnn_output",
                    "type": "str",
                    "possible_values": []
                }
            },
            "TensorArray_80": {
                "variable": {
                    "value": "input_ta",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "time_steps",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor_array_name": {
                    "value": "dynamic_rnn_input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "while_loop_133": {
                "variable": {
                    "value": "(_, final_state, output_final_ta)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cond": {
                    "value": "lambda time, _1, _2: time < time_steps",
                    "type": "Lambda",
                    "possible_values": []
                },
                "body": {
                    "value": "_time_step",
                    "type": "variable",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "(time, state, output_ta)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "parallel_iterations": {
                    "value": "parallel_iterations",
                    "type": "variable",
                    "possible_values": [
                        [
                            "32",
                            "int"
                        ]
                    ]
                }
            },
            "transpose_141": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "final_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "output_final_ta.stack()",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_32": {
                "name_or_scope": {
                    "value": "scope or 'BiRNN_FW'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "variable_scope_37": {
                "name_or_scope": {
                    "value": "scope or 'BiRNN_BW'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "tuple_43": {
                "tensors": {
                    "value": "[output_state_fw, output_state_bw]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_55": {
                "name_or_scope": {
                    "value": "scope or 'RNN'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "reduce_min_71": {
                "variable": {
                    "value": "min_sequence_length",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(sequence_length)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_max_72": {
                "variable": {
                    "value": "max_sequence_length",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(sequence_length)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_85": {
                "variable": {
                    "value": "noise_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[1, batch_size, const_depth]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dropout_86": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, ff_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "ff_keep_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ]
                    ]
                },
                "noise_shape": {
                    "value": "noise_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([1, batch_size, const_depth])",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_89": {
                "variable": {
                    "value": "ones",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.stack([batch_size, cell.output_size])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dropout_90": {
                "variable": {
                    "value": "state_dropout",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "ones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones(tf.stack([batch_size, cell.output_size]))",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "recur_keep_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_91": {
                "variable": {
                    "value": "state_dropout",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[ones] * (cell.state_size // cell.output_size - 1) + [state_dropout]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_69": {
                "values": {
                    "value": "[batch_size, cell.output_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cond_121": {
                "variable": {
                    "value": "(output, new_state)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "time >= max_sequence_length",
                    "type": "Compare",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "_empty_update",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "_maybe_copy_some_through",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "stack_89": {
                "values": {
                    "value": "[batch_size, cell.output_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cond_113": {
                "pred": {
                    "value": "time < min_sequence_length",
                    "type": "Compare",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : (new_output, new_state)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (tf.where(time >= sequence_length, zero_output, new_output), tf.where(time >= sequence_length, state, new_state))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "where_116": {
                "condition": {
                    "value": "time >= sequence_length",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "zero_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros(tf.stack([batch_size, cell.output_size]), inputs.dtype)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "new_output",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "where_117": {
                "condition": {
                    "value": "time >= sequence_length",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "initial_state",
                            "variable"
                        ],
                        [
                            "cell.zero_state(batch_size, dtype)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "new_state",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "parser/trash/retrained_vocab.py": {
        "tensorflow": {
            "placeholder_50": {
                "variable": {
                    "value": "row_idxs",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "row_idxs",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_51": {
                "variable": {
                    "value": "col_idxs",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "col_idxs",
                    "type": "str",
                    "possible_values": []
                }
            },
            "svd_52": {
                "variable": {
                    "value": "(S, U, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.pretrained_vocab.embeddings",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_55": {
                "variable": {
                    "value": "old_rows",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.pretrained_vocab.embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "row_idxs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, shape=(None,), name='row_idxs')",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_56": {
                "variable": {
                    "value": "old_cols",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.pretrained_vocab.embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "col_idxs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, shape=(None,), name='col_idxs')",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_57": {
                "variable": {
                    "value": "new_rows",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "row_idxs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, shape=(None,), name='row_idxs')",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_58": {
                "variable": {
                    "value": "new_cols",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "col_idxs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, shape=(None,), name='col_idxs')",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_59": {
                "variable": {
                    "value": "old_matmul",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "old_rows",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(self.pretrained_vocab.embeddings, row_idxs)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "old_cols",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(self.pretrained_vocab.embeddings, col_idxs)",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_60": {
                "variable": {
                    "value": "new_matmul",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "new_rows",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(self.embeddings, row_idxs)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "new_cols",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(self.embeddings, col_idxs)",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "expand_dims_63": {
                "variable": {
                    "value": "old_matmul",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.nn.softmax(old_matmul)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_64": {
                "variable": {
                    "value": "new_matmul",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.nn.softmax(new_matmul)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_63": {
                "logits": {
                    "value": "old_matmul",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(old_rows, old_cols, transpose_b=True)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.nn.softmax(old_matmul), axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_64": {
                "logits": {
                    "value": "new_matmul",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(new_rows, new_cols, transpose_b=True)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.nn.softmax(new_matmul), axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "to_float_65": {
                "x": {
                    "value": "tf.shape(row_idxs)[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_65": {
                "input_tensor": {
                    "value": "tf.matmul(old_matmul, tf.log(new_matmul))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_67": {
                "input_tensor": {
                    "value": "(old_matmul - new_matmul) ** 2 / 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_67": {
                "x": {
                    "value": "tf.shape(row_idxs)[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "matmul_65": {
                "a": {
                    "value": "old_matmul",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(old_rows, old_cols, transpose_b=True)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.nn.softmax(old_matmul), axis=1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.log(new_matmul)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_65": {
                "input": {
                    "value": "row_idxs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, shape=(None,), name='row_idxs')",
                            "Call"
                        ]
                    ]
                }
            },
            "log_65": {
                "x": {
                    "value": "new_matmul",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(new_rows, new_cols, transpose_b=True)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.nn.softmax(new_matmul), axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_67": {
                "input": {
                    "value": "row_idxs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, shape=(None,), name='row_idxs')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "parser/trash/weighted_mean.py": {
        "tensorflow": {
            "placeholder_35": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, None)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "'inputs-%s' % self.name",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_37": {
                "variable": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.greater(inputs, vocab.PAD)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_38": {
                "variable": {
                    "value": "self.sequence_lengths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.tokens_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_39": {
                "variable": {
                    "value": "self.n_tokens",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.sequence_lengths",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "greater_37": {
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, shape=(None, None), name='inputs-%s' % self.name)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "vocab.PAD",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_40": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, shape=(None, None), name='inputs-%s' % self.name)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_41": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, shape=(None, None), name='inputs-%s' % self.name)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "parser/vocabs/base_vocab.py": {
        "tensorflow": {
            "placeholder_82": {
                "variable": {
                    "value": "self.placeholder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "embedding_lookup_91": {
                "params": {
                    "value": "embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.embeddings if moving_params is None else moving_params.average(self.embeddings)",
                            "IfExp"
                        ]
                    ]
                },
                "ids": {
                    "value": "placeholder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.generate_placeholder() if placeholder is None else placeholder",
                            "IfExp"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "parser/vocabs/index_vocab.py": {
        "tensorflow": {
            "placeholder_52": {
                "variable": {
                    "value": "self.placeholder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "parser/vocabs/multivocab.py": {
        "tensorflow": {
            "add_n_58": {
                "inputs": {
                    "value": "embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[vocab(moving_params=moving_params) for vocab in self]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "stack_74": {
                "variable": {
                    "value": "self.placeholder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "values": {
                    "value": "[vocab.generate_placeholder() for vocab in self]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "parser/vocabs/ngram_multivocab.py": {
        "tensorflow": {
            "shape_100": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "placeholders",
                    "type": "variable",
                    "possible_values": [
                        [
                            "la.random_where(embed_keep_prob, placeholders, self.UNK, shape=shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_101": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[shape[0], 1, shape[2]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_104": {
                "values": {
                    "value": "embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[vocab.embedding_lookup(placeholders[:, :, i], embed_keep_prob=1, moving_params=moving_params) for (i, vocab) in enumerate(self)]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "parser/vocabs/ngram_vocab.py": {
        "tensorflow": {}
    },
    "parser/vocabs/pretrained_vocab.py": {
        "tensorflow": {
            "variable_scope_60": {
                "name_or_scope": {
                    "value": "self.name.title()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "device_74": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Variable_76": {
                "variable": {
                    "value": "self._embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "self._embeddings_array",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "Embeddings",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_64": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Weights",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_75": {
                "name_or_scope": {
                    "value": "self.name.title()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_63": {
                "name_or_scope": {
                    "value": "Linear",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "add_loss_65": {
                "loss": {
                    "value": "tf.nn.l2_loss(tf.matmul(tf.transpose(weights), weights) - tf.eye(self.token_embed_size))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "l2_loss_65": {
                "t": {
                    "value": "tf.matmul(tf.transpose(weights), weights) - tf.eye(self.token_embed_size)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "matmul_65": {
                "a": {
                    "value": "tf.transpose(weights)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('Weights')",
                            "Call"
                        ]
                    ]
                }
            },
            "eye_65": {
                "num_rows": {
                    "value": "self.token_embed_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "transpose_65": {
                "a": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('Weights')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "parser/vocabs/subtoken_vocab.py": {
        "tensorflow": {
            "embedding_lookup_86": {
                "params": {
                    "value": "embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.multibucket(self, keep_prob=self.embed_keep_prob, moving_params=moving_params)",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "placeholder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.generate_placeholder() if placeholder is None else placeholder",
                            "IfExp"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "device_74": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Variable_76": {
                "variable": {
                    "value": "self._embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "self._embeddings_array",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "Embeddings",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_75": {
                "name_or_scope": {
                    "value": "self.name.title()",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "parser/vocabs/token_vocab.py": {
        "tensorflow": {
            "device_70": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Variable_72": {
                "variable": {
                    "value": "self._embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "self._embeddings_array",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "Embeddings",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_71": {
                "name_or_scope": {
                    "value": "self.name.title()",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    }
}