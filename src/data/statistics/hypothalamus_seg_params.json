{
    "ext/neuron/vae_tools.py": {
        "sklearn": {
            "PCA_324": {
                "variable": {
                    "value": "pca",
                    "type": "Variable",
                    "possible_values": []
                },
                "n_components": {
                    "value": "nb_components",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "Session_87": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "initialize_all_variables_88": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "ext/lab2im/edit_tensors.py": {
        "tensorflow": {
            "convert_to_tensor_97": {
                "variable": {
                    "value": "sigma_tens",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "utils.reformat_to_list(sigma)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "split_127": {
                "variable": {
                    "value": "split_sigma",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "sigma_tens",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(utils.reformat_to_list(sigma), dtype='float32')",
                            "Call"
                        ],
                        [
                            "sigma",
                            "Name"
                        ],
                        [
                            "sigma_tens * tf.random.uniform(tf.shape(sigma_tens), minval=1 / blur_range, maxval=blur_range)",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(sigma_tens, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(sigma_tens, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "[1] * n_dims",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_159": {
                "variable": {
                    "value": "diff",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[mesh[f] - (windowsize[f] - 1) / 2 for f in range(len(windowsize))]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "equal_172": {
                "variable": {
                    "value": "sigma_is_0",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "sigma_tens",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(utils.reformat_to_list(sigma), dtype='float32')",
                            "Call"
                        ],
                        [
                            "sigma",
                            "Name"
                        ],
                        [
                            "sigma_tens * tf.random.uniform(tf.shape(sigma_tens), minval=1 / blur_range, maxval=blur_range)",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(sigma_tens, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(sigma_tens, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_176": {
                "variable": {
                    "value": "kernels",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "kernels",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "list()",
                            "Call"
                        ],
                        [
                            "K.sum(norms, -1)",
                            "Call"
                        ],
                        [
                            "tf.exp(kernels)",
                            "Call"
                        ],
                        [
                            "kernels / tf.reduce_sum(kernels)",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(kernels, -1), -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_178": {
                "input": {
                    "value": "kernels",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "list()",
                            "Call"
                        ],
                        [
                            "K.sum(norms, -1)",
                            "Call"
                        ],
                        [
                            "tf.exp(kernels)",
                            "Call"
                        ],
                        [
                            "kernels / tf.reduce_sum(kernels)",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(kernels, -1), -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_271": {
                "variable": {
                    "value": "tensor",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tensor",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "nrn_layers.Resize(size=resample_shape, interp_method=interp_method)(tensor)",
                            "Call"
                        ],
                        [
                            "nrn_layers.Resize(size=downsample_shape, interp_method='nearest')(tensor)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tensor, axis=ax)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "ax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "axis",
                            "Name"
                        ]
                    ]
                }
            },
            "is_tensor_50": {
                "x": {
                    "value": "downsample_res",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.array(downsample_res)",
                            "Call"
                        ],
                        [
                            "np.minimum(downsample_res, np.array(thickness))",
                            "Call"
                        ]
                    ]
                }
            },
            "is_tensor_96": {
                "x": {
                    "value": "sigma",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0.75 * downsample_res / current_res",
                            "BinOp"
                        ],
                        [
                            "mult_coef * downsample_res / current_res",
                            "BinOp"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.where(tf.math.equal(x, tf.convert_to_tensor(current_res, dtype='float32')), 0.5, 0.75 * x / tf.convert_to_tensor(current_res, dtype='float32')))(down_res)",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: mult_coef * x / tf.convert_to_tensor(current_res, dtype='float32'))(down_res)",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.where(tf.math.equal(x[0], 0.0), 0.0, x[1]))([down_res, sigma])",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_163": {
                "variable": {
                    "value": "diff",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(diff, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tf.concat([batchsize, tf.ones(tf.shape(tf.shape(diff)), dtype='int32')], axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_177": {
                "input_tensor": {
                    "value": "kernels",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "list()",
                            "Call"
                        ],
                        [
                            "K.sum(norms, -1)",
                            "Call"
                        ],
                        [
                            "tf.exp(kernels)",
                            "Call"
                        ],
                        [
                            "kernels / tf.reduce_sum(kernels)",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(kernels, -1), -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "split_109": {
                "value": {
                    "value": "tf.shape(sigma_tens)",
                    "type": "Call",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "exp_145": {
                "variable": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "exp_term - tf.math.log(np.sqrt(2 * np.pi) * split_sigma[i])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_158": {
                "x": {
                    "value": "f",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_166": {
                "variable": {
                    "value": "sigma_tens",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "sigma_tens",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(utils.reformat_to_list(sigma), dtype='float32')",
                            "Call"
                        ],
                        [
                            "sigma",
                            "Name"
                        ],
                        [
                            "sigma_tens * tf.random.uniform(tf.shape(sigma_tens), minval=1 / blur_range, maxval=blur_range)",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(sigma_tens, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(sigma_tens, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_169": {
                "variable": {
                    "value": "sigma_tens",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "sigma_tens",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(utils.reformat_to_list(sigma), dtype='float32')",
                            "Call"
                        ],
                        [
                            "sigma",
                            "Name"
                        ],
                        [
                            "sigma_tens * tf.random.uniform(tf.shape(sigma_tens), minval=1 / blur_range, maxval=blur_range)",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(sigma_tens, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(sigma_tens, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_174": {
                "x": {
                    "value": "tf.where(sigma_is_0, tf.ones_like(sigma_tens), np.sqrt(2 * np.pi) * sigma_tens)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_109": {
                "input": {
                    "value": "sigma_tens",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(utils.reformat_to_list(sigma), dtype='float32')",
                            "Call"
                        ],
                        [
                            "sigma",
                            "Name"
                        ],
                        [
                            "sigma_tens * tf.random.uniform(tf.shape(sigma_tens), minval=1 / blur_range, maxval=blur_range)",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(sigma_tens, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(sigma_tens, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "uniform_120": {
                "shape": {
                    "value": "tf.shape(sigma_tens)",
                    "type": "Call",
                    "possible_values": []
                },
                "minval": {
                    "value": "1 / blur_range",
                    "type": "BinOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "blur_range",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "tile_138": {
                "variable": {
                    "value": "locations",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(locations, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tf.concat([batchsize, tf.ones(tf.shape(tf.shape(locations)), dtype='int32')], axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_149": {
                "variable": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.exp(exp_term - tf.math.log(np.sqrt(2 * np.pi) * split_sigma[i]))",
                            "Call"
                        ],
                        [
                            "g / tf.reduce_sum(g)",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(g, axis=axis)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "axis",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "comb[i]",
                            "Subscript"
                        ],
                        [
                            "utils.reformat_to_list(axis)",
                            "Call"
                        ],
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "expand_dims_163": {
                "input": {
                    "value": "diff",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.stack([mesh[f] - (windowsize[f] - 1) / 2 for f in range(len(windowsize))], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(diff, axis=0), tf.concat([batchsize, tf.ones(tf.shape(tf.shape(diff)), dtype='int32')], axis=0))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_164": {
                "values": {
                    "value": "[batchsize, tf.ones(tf.shape(tf.shape(diff)), dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_174": {
                "condition": {
                    "value": "sigma_is_0",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.equal(sigma_tens, 0)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "tf.ones_like(sigma_tens)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "np.sqrt(2 * np.pi) * sigma_tens",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "where_80": {
                "condition": {
                    "value": "tf.math.equal(x[0], 0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "x[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_120": {
                "input": {
                    "value": "sigma_tens",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(utils.reformat_to_list(sigma), dtype='float32')",
                            "Call"
                        ],
                        [
                            "sigma",
                            "Name"
                        ],
                        [
                            "sigma_tens * tf.random.uniform(tf.shape(sigma_tens), minval=1 / blur_range, maxval=blur_range)",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(sigma_tens, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(sigma_tens, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_136": {
                "x": {
                    "value": "tf.range(0, wsize)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_146": {
                "input_tensor": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.exp(exp_term - tf.math.log(np.sqrt(2 * np.pi) * split_sigma[i]))",
                            "Call"
                        ],
                        [
                            "g / tf.reduce_sum(g)",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(g, axis=axis)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_150": {
                "input": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.exp(exp_term - tf.math.log(np.sqrt(2 * np.pi) * split_sigma[i]))",
                            "Call"
                        ],
                        [
                            "g / tf.reduce_sum(g)",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(g, axis=axis)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "where_173": {
                "condition": {
                    "value": "sigma_is_0",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.equal(sigma_tens, 0)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "tf.ones_like(sigma_tens)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "sigma_tens",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(utils.reformat_to_list(sigma), dtype='float32')",
                            "Call"
                        ],
                        [
                            "sigma",
                            "Name"
                        ],
                        [
                            "sigma_tens * tf.random.uniform(tf.shape(sigma_tens), minval=1 / blur_range, maxval=blur_range)",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(sigma_tens, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(sigma_tens, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_174": {
                "input": {
                    "value": "sigma_tens",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(utils.reformat_to_list(sigma), dtype='float32')",
                            "Call"
                        ],
                        [
                            "sigma",
                            "Name"
                        ],
                        [
                            "sigma_tens * tf.random.uniform(tf.shape(sigma_tens), minval=1 / blur_range, maxval=blur_range)",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(sigma_tens, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(sigma_tens, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "minimum_70": {
                "x": {
                    "value": "x[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "x[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "where_76": {
                "condition": {
                    "value": "tf.math.equal(x, tf.convert_to_tensor(current_res, dtype='float32'))",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "0.75 * x / tf.convert_to_tensor(current_res, dtype='float32')",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "equal_80": {
                "x": {
                    "value": "x[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "expand_dims_138": {
                "input": {
                    "value": "locations",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.range(0, wsize), 'float32') - (wsize - 1) / 2",
                            "BinOp"
                        ],
                        [
                            "tf.tile(tf.expand_dims(locations, axis=0), tf.concat([batchsize, tf.ones(tf.shape(tf.shape(locations)), dtype='int32')], axis=0))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_139": {
                "values": {
                    "value": "[batchsize, tf.ones(tf.shape(tf.shape(locations)), dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_145": {
                "x": {
                    "value": "np.sqrt(2 * np.pi) * split_sigma[i]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ones_164": {
                "shape": {
                    "value": "tf.shape(tf.shape(diff))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ones_like_173": {
                "input": {
                    "value": "sigma_tens",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(utils.reformat_to_list(sigma), dtype='float32')",
                            "Call"
                        ],
                        [
                            "sigma",
                            "Name"
                        ],
                        [
                            "sigma_tens * tf.random.uniform(tf.shape(sigma_tens), minval=1 / blur_range, maxval=blur_range)",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(sigma_tens, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(sigma_tens, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_253": {
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reshape_254": {
                "tensor": {
                    "value": "tf.convert_to_tensor(reliability_map, dtype='float32')",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "ones_like_259": {
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "equal_76": {
                "x": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.convert_to_tensor(current_res, dtype='float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_79": {
                "value": {
                    "value": "current_res",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.array(current_res)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_164": {
                "input": {
                    "value": "diff",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.stack([mesh[f] - (windowsize[f] - 1) / 2 for f in range(len(windowsize))], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(diff, axis=0), tf.concat([batchsize, tf.ones(tf.shape(tf.shape(diff)), dtype='int32')], axis=0))",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_254": {
                "value": {
                    "value": "reliability_map",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1",
                            "Constant"
                        ],
                        [
                            "reliability_map * np.reshape(tmp_reliability_map, shape)",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_76": {
                "value": {
                    "value": "current_res",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.array(current_res)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_77": {
                "value": {
                    "value": "current_res",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.array(current_res)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ones_139": {
                "shape": {
                    "value": "tf.shape(tf.shape(locations))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_139": {
                "input": {
                    "value": "locations",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.range(0, wsize), 'float32') - (wsize - 1) / 2",
                            "BinOp"
                        ],
                        [
                            "tf.tile(tf.expand_dims(locations, axis=0), tf.concat([batchsize, tf.ones(tf.shape(tf.shape(locations)), dtype='int32')], axis=0))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "ext/lab2im/edit_volumes.py": {
        "tensorflow": {
            "one_hot_2082": {
                "indices": {
                    "value": "tf.cast(x, dtype='int32')",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "n_labels",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "label_list.shape[0]",
                            "Subscript"
                        ],
                        [
                            "len(label_list)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "convert_to_tensor_2087": {
                "value": {
                    "value": "k",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "utils.add_axis(utils.build_binary_structure(connectivity, n_dims, shape=n_dims), axis=[-1, -1])",
                            "Call"
                        ],
                        [
                            "range(n_crop[2])",
                            "Call"
                        ],
                        [
                            "k * patch_shape[2]",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "split_2088": {
                "value": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.arange(0, volume_filt.shape[0])",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "[1] * n_labels",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "convolution_2089": {
                "input": {
                    "value": "x[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "filters": {
                    "value": "x[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "argmax_2095": {
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.arange(0, volume_filt.shape[0])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_2082": {
                "x": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.arange(0, volume_filt.shape[0])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convolution_2091": {
                "input": {
                    "value": "x[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "filters": {
                    "value": "x[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_2092": {
                "values": {
                    "value": "[x[0], x[1]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "ext/lab2im/layers.py": {
        "tensorflow": {
            "cast_253": {
                "variable": {
                    "value": "crop_idx",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.random.uniform([self.n_dims], 0, np.array(self.crop_max_val), 'float32')",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_254": {
                "variable": {
                    "value": "crop_idx",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[crop_idx, tf.zeros([1], dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_to_tensor_255": {
                "variable": {
                    "value": "crop_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self.crop_shape + [-1]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_388": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.cast(v, 'float32') for v in swapped_inputs]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "map_fn_389": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "self._single_flip",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "[inputs, rand_flip]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_390": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "[tf.cast(v, dtype='float32') for v in inputs]",
                            "ListComp"
                        ],
                        [
                            "[nrn_layers.SpatialTransformer(m)([v] + list_trans) for (m, v) in zip(self.inter_method, inputs)]",
                            "ListComp"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_slice, inputs, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in swapped_inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_flip, [inputs, rand_flip], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "K.clip(inputs, self.clip_values[0], self.clip_values[1])",
                            "Call"
                        ],
                        [
                            "inputs + noise",
                            "BinOp"
                        ],
                        [
                            "tf.math.pow(inputs, tf.math.exp(tf.random.normal(sample_shape, stddev=self.gamma_std)))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(inputs, m, M)",
                            "Call"
                        ],
                        [
                            "(inputs - m) / (M - m + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(inputs, values[i]), tf.zeros_like(inputs), inputs)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "self.list_n_channels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "convert_to_tensor_450": {
                "variable": {
                    "value": "self.shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "[np.max(indices) + 1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_451": {
                "variable": {
                    "value": "self.indices",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "utils.add_axis(indices, axis=[0, -1])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tile_460": {
                "variable": {
                    "value": "tmp_indices",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.indices",
                    "type": "Attribute",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tf.concat([batch, tf.convert_to_tensor([1, 1], dtype='int32')], axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_461": {
                "variable": {
                    "value": "labels",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.cast(inputs[0], dtype='int32') + self.max_label * i for i in range(self.n_channels)]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_464": {
                "variable": {
                    "value": "means",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs[1][..., i] for i in range(self.n_channels)]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_465": {
                "variable": {
                    "value": "tile_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[batch, tf.convert_to_tensor([1], dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_466": {
                "variable": {
                    "value": "means",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.scatter_nd(tmp_indices, means, self.shape), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tile_shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([batch, tf.convert_to_tensor([1], dtype='int32')], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batch, tf.convert_to_tensor([1], dtype='int32')], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batchsize, tf.ones([1], dtype='int32')], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "map_fn_467": {
                "variable": {
                    "value": "means_map",
                    "type": "Variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda x: tf.gather(x[0], x[1])",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "[means, labels]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_470": {
                "variable": {
                    "value": "stds",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs[2][..., i] for i in range(self.n_channels)]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_471": {
                "variable": {
                    "value": "stds",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.scatter_nd(tmp_indices, stds, self.shape), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tile_shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([batch, tf.convert_to_tensor([1], dtype='int32')], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batch, tf.convert_to_tensor([1], dtype='int32')], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batchsize, tf.ones([1], dtype='int32')], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "map_fn_472": {
                "variable": {
                    "value": "stds_map",
                    "type": "Variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda x: tf.gather(x[0], x[1])",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "[stds, labels]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_569": {
                "variable": {
                    "value": "self.min_res_tens",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self.min_res",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_891": {
                "variable": {
                    "value": "self.down_grid",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.stack(nrn_utils.volshape_to_ndgrid(down_tensor_shape), -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_892": {
                "variable": {
                    "value": "self.up_grid",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.stack(nrn_utils.volshape_to_ndgrid(self.resample_shape), -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_902": {
                "variable": {
                    "value": "subsample_res",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_905": {
                "variable": {
                    "value": "tile_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[batchsize, tf.ones([1], dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_910": {
                "variable": {
                    "value": "down_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.convert_to_tensor(np.array(self.inshape[:-1]) * self.volume_res, dtype='float32') / subsample_res",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_912": {
                "variable": {
                    "value": "down_zoom_factor",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "down_shape / tf.convert_to_tensor(self.inshape[:-1])",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_913": {
                "variable": {
                    "value": "up_zoom_factor",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.convert_to_tensor(self.resample_shape, dtype='int32') / down_shape",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tile_916": {
                "variable": {
                    "value": "down_loc",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.down_grid",
                    "type": "Attribute",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tf.concat([batchsize, tf.ones([self.n_dims + 1], dtype='int32')], 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tile_918": {
                "variable": {
                    "value": "inshape_tens",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.convert_to_tensor(self.inshape[:-1]), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tile_shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([batch, tf.convert_to_tensor([1], dtype='int32')], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batch, tf.convert_to_tensor([1], dtype='int32')], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batchsize, tf.ones([1], dtype='int32')], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "map_fn_921": {
                "variable": {
                    "value": "vol",
                    "type": "Variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "self._single_down_interpn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "[vol, down_loc]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_930": {
                "variable": {
                    "value": "up_loc",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.up_grid",
                    "type": "Attribute",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tf.concat([batchsize, tf.ones([self.n_dims + 1], dtype='int32')], axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "map_fn_932": {
                "variable": {
                    "value": "vol",
                    "type": "Variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "self._single_up_interpn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "[vol, up_loc]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_1117": {
                "variable": {
                    "value": "self.one",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_1214": {
                "variable": {
                    "value": "top",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "2 * x * y",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "list(range(1, len(self.inshape)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_1216": {
                "variable": {
                    "value": "bottom",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "bottom",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.square(x) + tf.math.square(y) + tf.keras.backend.epsilon()",
                            "BinOp"
                        ],
                        [
                            "tf.math.reduce_sum(bottom, axis=list(range(1, len(self.inshape))))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "list(range(1, len(self.inshape)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_1253": {
                "variable": {
                    "value": "weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "1 - gt[..., 0] + self.background_weight",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "convert_to_tensor_1289": {
                "variable": {
                    "value": "self.values_tens",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self.values",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_1294": {
                "variable": {
                    "value": "values",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.values_tens",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_1325": {
                "variable": {
                    "value": "self.lut",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "utils.get_mapping_lut(self.source_values, dest=self.dest_values)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ones_like_1460": {
                "variable": {
                    "value": "mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "[tf.cast(v, dtype='float32') for v in inputs]",
                            "ListComp"
                        ],
                        [
                            "[nrn_layers.SpatialTransformer(m)([v] + list_trans) for (m, v) in zip(self.inter_method, inputs)]",
                            "ListComp"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_slice, inputs, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in swapped_inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_flip, [inputs, rand_flip], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "K.clip(inputs, self.clip_values[0], self.clip_values[1])",
                            "Call"
                        ],
                        [
                            "inputs + noise",
                            "BinOp"
                        ],
                        [
                            "tf.math.pow(inputs, tf.math.exp(tf.random.normal(sample_shape, stddev=self.gamma_std)))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(inputs, m, M)",
                            "Call"
                        ],
                        [
                            "(inputs - m) / (M - m + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(inputs, values[i]), tf.zeros_like(inputs), inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_182": {
                "variable": {
                    "value": "trans_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[batchsize, tf.convert_to_tensor(self.small_shape, dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "uniform_183": {
                "variable": {
                    "value": "trans_std",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "maxval": {
                    "value": "self.nonlin_std",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "normal_184": {
                "variable": {
                    "value": "elastic_trans",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "trans_shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([batchsize, tf.convert_to_tensor(self.small_shape, dtype='int32')], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "stddev": {
                    "value": "trans_std",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.random.uniform((1, 1), maxval=self.nonlin_std)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_247": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.cast(v, 'float32') for v in inputs]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "map_fn_248": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "self._single_slice",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "[tf.cast(v, dtype='float32') for v in inputs]",
                            "ListComp"
                        ],
                        [
                            "[nrn_layers.SpatialTransformer(m)([v] + list_trans) for (m, v) in zip(self.inter_method, inputs)]",
                            "ListComp"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_slice, inputs, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in swapped_inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_flip, [inputs, rand_flip], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "K.clip(inputs, self.clip_values[0], self.clip_values[1])",
                            "Call"
                        ],
                        [
                            "inputs + noise",
                            "BinOp"
                        ],
                        [
                            "tf.math.pow(inputs, tf.math.exp(tf.random.normal(sample_shape, stddev=self.gamma_std)))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(inputs, m, M)",
                            "Call"
                        ],
                        [
                            "(inputs - m) / (M - m + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(inputs, values[i]), tf.zeros_like(inputs), inputs)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_249": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "[tf.cast(v, dtype='float32') for v in inputs]",
                            "ListComp"
                        ],
                        [
                            "[nrn_layers.SpatialTransformer(m)([v] + list_trans) for (m, v) in zip(self.inter_method, inputs)]",
                            "ListComp"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_slice, inputs, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in swapped_inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_flip, [inputs, rand_flip], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "K.clip(inputs, self.clip_values[0], self.clip_values[1])",
                            "Call"
                        ],
                        [
                            "inputs + noise",
                            "BinOp"
                        ],
                        [
                            "tf.math.pow(inputs, tf.math.exp(tf.random.normal(sample_shape, stddev=self.gamma_std)))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(inputs, m, M)",
                            "Call"
                        ],
                        [
                            "(inputs - m) / (M - m + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(inputs, values[i]), tf.zeros_like(inputs), inputs)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "self.list_n_channels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "slice_256": {
                "input_": {
                    "value": "vol",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "K.reshape(vol, [-1, *self.inshape])",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_down_interpn, [vol, down_loc], tf.float32)",
                            "Call"
                        ],
                        [
                            "vol + tf.random.normal(tf.shape(vol), stddev=tf.random.uniform(sample_shape, maxval=self.noise_std))",
                            "BinOp"
                        ],
                        [
                            "tf.map_fn(self._single_up_interpn, [vol, up_loc], tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "crop_idx",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.random.uniform([self.n_dims], 0, np.array(self.crop_max_val), 'float32'), dtype='int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([crop_idx, tf.zeros([1], dtype='int32')], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "crop_size",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(self.crop_shape + [-1], dtype='int32')",
                            "Call"
                        ]
                    ]
                }
            },
            "uniform_399": {
                "variable": {
                    "value": "flip_axis",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "self.n_dims",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "squeeze_401": {
                "variable": {
                    "value": "idx",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.random.uniform([1], 0, len(self.flip_axis), dtype='int32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_402": {
                "variable": {
                    "value": "flip_axis",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.convert_to_tensor(self.flip_axis, dtype='int32')[idx]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "uniform_578": {
                "variable": {
                    "value": "dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "self.n_dims",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tensor_scatter_nd_update_579": {
                "variable": {
                    "value": "mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.zeros([self.n_dims], dtype='bool')",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "dim",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.random.uniform(shape=(1, 1), minval=0, maxval=self.n_dims, dtype='int32')",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "tf.convert_to_tensor([True], dtype='bool')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_583": {
                "variable": {
                    "value": "tile_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[batch, tf.convert_to_tensor([1], dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_584": {
                "variable": {
                    "value": "self.min_res_tens",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(self.min_res_tens, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tile_shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([batch, tf.convert_to_tensor([1], dtype='int32')], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batch, tf.convert_to_tensor([1], dtype='int32')], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batchsize, tf.ones([1], dtype='int32')], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_586": {
                "variable": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[batch, tf.convert_to_tensor([self.n_dims], dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_587": {
                "variable": {
                    "value": "indices",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.range(0, batch[0]), tf.random.uniform(batch, 0, self.n_dims, dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tensor_scatter_nd_update_588": {
                "variable": {
                    "value": "mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.zeros(shape, dtype='bool')",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.concatenate([self.generation_labels + self.max_label * i for i in range(self.n_channels)], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.stack([tf.range(0, batch[0]), tf.random.uniform(batch, 0, self.n_dims, dtype='int32')], 1)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "tf.ones(batch, dtype='bool')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_712": {
                "variable": {
                    "value": "mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "bool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "map_fn_794": {
                "variable": {
                    "value": "image",
                    "type": "Variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "self._single_blur",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "[image, kernels]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_799": {
                "variable": {
                    "value": "split_channels",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[1] * self.n_channels",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_804": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "blurred_channel",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "list()",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "squeeze_807": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.convnd(tf.expand_dims(inputs[0], 0), inputs[1], [1] * (self.n_dims + 2), padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat(blurred_channel, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_909": {
                "variable": {
                    "value": "subsample_res",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(subsample_res, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tile_shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([batch, tf.convert_to_tensor([1], dtype='int32')], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batch, tf.convert_to_tensor([1], dtype='int32')], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batchsize, tf.ones([1], dtype='int32')], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_925": {
                "variable": {
                    "value": "sample_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[batchsize, tf.ones([self.n_dims], dtype='int32'), self.n_channels * tf.ones([1], dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "floor_942": {
                "variable": {
                    "value": "floor",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "up_loc",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(self.up_grid, tf.concat([batchsize, tf.ones([self.n_dims + 1], dtype='int32')], axis=0))",
                            "Call"
                        ],
                        [
                            "tf.cast(up_loc, 'float32') / l2i_et.expand_dims(up_zoom_factor, axis=[1] * self.n_dims)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "ceil_943": {
                "variable": {
                    "value": "ceil",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "up_loc",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(self.up_grid, tf.concat([batchsize, tf.ones([self.n_dims + 1], dtype='int32')], axis=0))",
                            "Call"
                        ],
                        [
                            "tf.cast(up_loc, 'float32') / l2i_et.expand_dims(up_zoom_factor, axis=[1] * self.n_dims)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "sqrt_951": {
                "variable": {
                    "value": "dist",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.math.reduce_sum(tf.math.square(dist), axis=-1, keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_1039": {
                "variable": {
                    "value": "std_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[batchsize, tf.convert_to_tensor(self.std_shape, dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_1040": {
                "variable": {
                    "value": "bias_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[batchsize, tf.convert_to_tensor(self.small_bias_shape, dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "normal_1043": {
                "variable": {
                    "value": "bias_field",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "bias_shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([batchsize, tf.convert_to_tensor(self.small_bias_shape, dtype='int32')], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "stddev": {
                    "value": "tf.random.uniform(std_shape, maxval=self.bias_field_std)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exp_1047": {
                "variable": {
                    "value": "bias_field",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "bias_field",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.random.normal(bias_shape, stddev=tf.random.uniform(std_shape, maxval=self.bias_field_std))",
                            "Call"
                        ],
                        [
                            "nrn_layers.Resize(size=self.inshape[0][1:self.n_dims + 1], interp_method='linear')(bias_field)",
                            "Call"
                        ],
                        [
                            "tf.math.exp(bias_field)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_1137": {
                "variable": {
                    "value": "sample_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[batchsize, tf.ones([self.n_dims], dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "uniform_1147": {
                "variable": {
                    "value": "noise_stddev",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "sample_shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([batchsize, tf.ones([self.n_dims], dtype='int32'), self.n_channels * tf.ones([1], dtype='int32')], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batchsize, tf.ones([self.n_dims], dtype='int32')], 0)",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.concat([sample_shape, self.n_channels * self.one], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([sample_shape, self.one], 0)",
                            "Call"
                        ]
                    ]
                },
                "maxval": {
                    "value": "self.noise_std",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "clip_by_value_1177": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "t": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "[tf.cast(v, dtype='float32') for v in inputs]",
                            "ListComp"
                        ],
                        [
                            "[nrn_layers.SpatialTransformer(m)([v] + list_trans) for (m, v) in zip(self.inter_method, inputs)]",
                            "ListComp"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_slice, inputs, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in swapped_inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_flip, [inputs, rand_flip], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "K.clip(inputs, self.clip_values[0], self.clip_values[1])",
                            "Call"
                        ],
                        [
                            "inputs + noise",
                            "BinOp"
                        ],
                        [
                            "tf.math.pow(inputs, tf.math.exp(tf.random.normal(sample_shape, stddev=self.gamma_std)))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(inputs, m, M)",
                            "Call"
                        ],
                        [
                            "(inputs - m) / (M - m + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(inputs, values[i]), tf.zeros_like(inputs), inputs)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "m",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "K.min(inputs, axis=list(range(1, self.expand_minmax_dim + 1)))",
                            "Call"
                        ],
                        [
                            "l2i_et.expand_dims(m, axis=[1] * self.expand_minmax_dim)",
                            "Call"
                        ],
                        [
                            "intensities[:, max(int(self.perc[0] * self.flatten_shape), 0), ...]",
                            "Subscript"
                        ]
                    ]
                },
                "clip_value_max": {
                    "value": "M",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "K.max(inputs, axis=list(range(1, self.expand_minmax_dim + 1)))",
                            "Call"
                        ],
                        [
                            "l2i_et.expand_dims(M, axis=[1] * self.expand_minmax_dim)",
                            "Call"
                        ],
                        [
                            "intensities[:, min(int(self.perc[1] * self.flatten_shape), self.flatten_shape - 1), ...]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "pow_1182": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "[tf.cast(v, dtype='float32') for v in inputs]",
                            "ListComp"
                        ],
                        [
                            "[nrn_layers.SpatialTransformer(m)([v] + list_trans) for (m, v) in zip(self.inter_method, inputs)]",
                            "ListComp"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_slice, inputs, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in swapped_inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_flip, [inputs, rand_flip], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "K.clip(inputs, self.clip_values[0], self.clip_values[1])",
                            "Call"
                        ],
                        [
                            "inputs + noise",
                            "BinOp"
                        ],
                        [
                            "tf.math.pow(inputs, tf.math.exp(tf.random.normal(sample_shape, stddev=self.gamma_std)))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(inputs, m, M)",
                            "Call"
                        ],
                        [
                            "(inputs - m) / (M - m + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(inputs, values[i]), tf.zeros_like(inputs), inputs)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.math.exp(tf.random.normal(sample_shape, stddev=self.gamma_std))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_1296": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.equal(inputs, values[i])",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.zeros_like(inputs)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "[tf.cast(v, dtype='float32') for v in inputs]",
                            "ListComp"
                        ],
                        [
                            "[nrn_layers.SpatialTransformer(m)([v] + list_trans) for (m, v) in zip(self.inter_method, inputs)]",
                            "ListComp"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_slice, inputs, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in swapped_inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_flip, [inputs, rand_flip], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "K.clip(inputs, self.clip_values[0], self.clip_values[1])",
                            "Call"
                        ],
                        [
                            "inputs + noise",
                            "BinOp"
                        ],
                        [
                            "tf.math.pow(inputs, tf.math.exp(tf.random.normal(sample_shape, stddev=self.gamma_std)))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(inputs, m, M)",
                            "Call"
                        ],
                        [
                            "(inputs - m) / (M - m + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(inputs, values[i]), tf.zeros_like(inputs), inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_1330": {
                "params": {
                    "value": "self.lut",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.cast(inputs, dtype='int32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_1372": {
                "variable": {
                    "value": "self.pad_margin_tens",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "pad",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.transpose(np.array([[0] + utils.reformat_to_list(self.pad_margin, self.n_dims) + [0]] * 2))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pad_1395": {
                "tensor": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "[tf.cast(v, dtype='float32') for v in inputs]",
                            "ListComp"
                        ],
                        [
                            "[nrn_layers.SpatialTransformer(m)([v] + list_trans) for (m, v) in zip(self.inter_method, inputs)]",
                            "ListComp"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_slice, inputs, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in swapped_inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_flip, [inputs, rand_flip], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "K.clip(inputs, self.clip_values[0], self.clip_values[1])",
                            "Call"
                        ],
                        [
                            "inputs + noise",
                            "BinOp"
                        ],
                        [
                            "tf.math.pow(inputs, tf.math.exp(tf.random.normal(sample_shape, stddev=self.gamma_std)))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(inputs, m, M)",
                            "Call"
                        ],
                        [
                            "(inputs - m) / (M - m + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(inputs, values[i]), tf.zeros_like(inputs), inputs)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "self.pad_margin_tens",
                    "type": "Attribute",
                    "possible_values": []
                },
                "mode": {
                    "value": "CONSTANT",
                    "type": "str",
                    "possible_values": []
                },
                "constant_values": {
                    "value": "self.value",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "round_1465": {
                "variable": {
                    "value": "idx1",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.random.uniform([1], minval=axis_boundaries[0] * self.inputshape[axis], maxval=axis_boundaries[1] * self.inputshape[axis])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "round_1468": {
                "variable": {
                    "value": "idx2",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.random.uniform([1], minval=axis_boundaries[2] * self.inputshape[axis], maxval=axis_boundaries[3] * self.inputshape[axis] - 1) - idx1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_1472": {
                "variable": {
                    "value": "split_idx",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.concat([idx1, idx2, idx3], axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "split_1475": {
                "variable": {
                    "value": "split_list",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "[tf.cast(v, dtype='float32') for v in inputs]",
                            "ListComp"
                        ],
                        [
                            "[nrn_layers.SpatialTransformer(m)([v] + list_trans) for (m, v) in zip(self.inter_method, inputs)]",
                            "ListComp"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_slice, inputs, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in swapped_inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_flip, [inputs, rand_flip], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "K.clip(inputs, self.clip_values[0], self.clip_values[1])",
                            "Call"
                        ],
                        [
                            "inputs + noise",
                            "BinOp"
                        ],
                        [
                            "tf.math.pow(inputs, tf.math.exp(tf.random.normal(sample_shape, stddev=self.gamma_std)))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(inputs, m, M)",
                            "Call"
                        ],
                        [
                            "(inputs - m) / (M - m + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(inputs, values[i]), tf.zeros_like(inputs), inputs)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "split_idx",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.concat([idx1, idx2, idx3], axis=0), dtype='int32')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "axis",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "concat_1476": {
                "variable": {
                    "value": "tmp_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.zeros_like(split_list[0]), tf.ones_like(split_list[1]), tf.zeros_like(split_list[2])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "axis",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "cast_161": {
                "x": {
                    "value": "v",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "split_162": {
                "value": {
                    "value": "tf.shape(inputs[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[1, self.n_dims + 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_196": {
                "x": {
                    "value": "v",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "t",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "map_fn_242": {
                "fn": {
                    "value": "self._single_slice",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "[tf.cast(v, dtype='float32') for v in inputs]",
                            "ListComp"
                        ],
                        [
                            "[nrn_layers.SpatialTransformer(m)([v] + list_trans) for (m, v) in zip(self.inter_method, inputs)]",
                            "ListComp"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_slice, inputs, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in swapped_inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_flip, [inputs, rand_flip], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "K.clip(inputs, self.clip_values[0], self.clip_values[1])",
                            "Call"
                        ],
                        [
                            "inputs + noise",
                            "BinOp"
                        ],
                        [
                            "tf.math.pow(inputs, tf.math.exp(tf.random.normal(sample_shape, stddev=self.gamma_std)))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(inputs, m, M)",
                            "Call"
                        ],
                        [
                            "(inputs - m) / (M - m + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(inputs, values[i]), tf.zeros_like(inputs), inputs)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "uniform_253": {
                "shape": {
                    "value": "[self.n_dims]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "np.array(self.crop_max_val)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_363": {
                "variable": {
                    "value": "self.swap_lut",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "swap_lut",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "utils.get_mapping_lut(self.label_list, label_list_swap)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "split_376": {
                "value": {
                    "value": "tf.shape(inputs[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[1, self.n_dims + 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "uniform_377": {
                "shape": {
                    "value": "tf.concat([batchsize, tf.ones(1, dtype='int32')], axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_392": {
                "x": {
                    "value": "v",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "t",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "gather_395": {
                "params": {
                    "value": "self.swap_lut",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "inputs[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "split_459": {
                "value": {
                    "value": "tf.shape(inputs[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_460": {
                "values": {
                    "value": "[batch, tf.convert_to_tensor([1, 1], dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_466": {
                "input": {
                    "value": "tf.scatter_nd(tmp_indices, means, self.shape)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_471": {
                "input": {
                    "value": "tf.scatter_nd(tmp_indices, stds, self.shape)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "uniform_596": {
                "variable": {
                    "value": "new_resolution_iso",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[self.n_dims]",
                            "List"
                        ],
                        [
                            "tf.concat([batch, tf.convert_to_tensor([self.n_dims], dtype='int32')], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batchsize, self.flatten_shape * self.one, self.n_channels * self.one], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batchsize, self.flatten_shape * self.one], 0)",
                            "Call"
                        ]
                    ]
                },
                "minval": {
                    "value": "self.min_res",
                    "type": "Attribute",
                    "possible_values": []
                },
                "maxval": {
                    "value": "self.max_res_iso",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_734": {
                "variable": {
                    "value": "image",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[self.convnd(tf.expand_dims(image[..., n], -1), self.kernels, self.stride, 'SAME') for n in range(self.n_channels)]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "map_fn_792": {
                "variable": {
                    "value": "image",
                    "type": "Variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "self._single_blur",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "[image, kernel]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_891": {
                "values": {
                    "value": "nrn_utils.volshape_to_ndgrid(down_tensor_shape)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_892": {
                "values": {
                    "value": "nrn_utils.volshape_to_ndgrid(self.resample_shape)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "split_904": {
                "value": {
                    "value": "tf.shape(vol)",
                    "type": "Call",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_916": {
                "values": {
                    "value": "[batchsize, tf.ones([self.n_dims + 1], dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_917": {
                "x": {
                    "value": "down_loc",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(self.down_grid, tf.concat([batchsize, tf.ones([self.n_dims + 1], dtype='int32')], 0))",
                            "Call"
                        ],
                        [
                            "tf.cast(down_loc, 'float32') / l2i_et.expand_dims(down_zoom_factor, axis=[1] * self.n_dims)",
                            "BinOp"
                        ],
                        [
                            "K.clip(down_loc, 0.0, tf.cast(inshape_tens, 'float32'))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_918": {
                "input": {
                    "value": "tf.convert_to_tensor(self.inshape[:-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_920": {
                "x": {
                    "value": "inshape_tens",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.convert_to_tensor(self.inshape[:-1]), 0), tile_shape)",
                            "Call"
                        ],
                        [
                            "l2i_et.expand_dims(inshape_tens, axis=[1] * self.n_dims)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "normal_927": {
                "shape": {
                    "value": "tf.shape(vol)",
                    "type": "Call",
                    "possible_values": []
                },
                "stddev": {
                    "value": "tf.random.uniform(sample_shape, maxval=self.noise_std)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_930": {
                "values": {
                    "value": "[batchsize, tf.ones([self.n_dims + 1], dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_931": {
                "x": {
                    "value": "up_loc",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(self.up_grid, tf.concat([batchsize, tf.ones([self.n_dims + 1], dtype='int32')], axis=0))",
                            "Call"
                        ],
                        [
                            "tf.cast(up_loc, 'float32') / l2i_et.expand_dims(up_zoom_factor, axis=[1] * self.n_dims)",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "split_1135": {
                "value": {
                    "value": "tf.shape(inputs)",
                    "type": "Call",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_1139": {
                "variable": {
                    "value": "sample_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[sample_shape, self.n_channels * self.one]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_1141": {
                "variable": {
                    "value": "sample_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[sample_shape, self.one]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "normal_1149": {
                "variable": {
                    "value": "noise",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.shape(inputs)",
                    "type": "Call",
                    "possible_values": []
                },
                "stddev": {
                    "value": "noise_stddev",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.random.uniform(sample_shape, maxval=self.noise_std)",
                            "Call"
                        ]
                    ]
                }
            },
            "normal_1151": {
                "variable": {
                    "value": "noise",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.shape(tf.split(inputs, [1, -1], -1)[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "stddev": {
                    "value": "noise_stddev",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.random.uniform(sample_shape, maxval=self.noise_std)",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_1152": {
                "variable": {
                    "value": "noise",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "noise",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.random.normal(tf.shape(inputs), stddev=noise_stddev)",
                            "Call"
                        ],
                        [
                            "tf.random.normal(tf.shape(tf.split(inputs, [1, -1], -1)[0]), stddev=noise_stddev)",
                            "Call"
                        ],
                        [
                            "tf.tile(noise, tf.convert_to_tensor([1] * (self.n_dims + 1) + [self.n_channels]))",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "tf.convert_to_tensor([1] * (self.n_dims + 1) + [self.n_channels])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sort_1167": {
                "variable": {
                    "value": "intensities",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "tf.reshape(inputs, shape)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "epsilon_1215": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cast_1330": {
                "x": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "[tf.cast(v, dtype='float32') for v in inputs]",
                            "ListComp"
                        ],
                        [
                            "[nrn_layers.SpatialTransformer(m)([v] + list_trans) for (m, v) in zip(self.inter_method, inputs)]",
                            "ListComp"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_slice, inputs, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in swapped_inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_flip, [inputs, rand_flip], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "K.clip(inputs, self.clip_values[0], self.clip_values[1])",
                            "Call"
                        ],
                        [
                            "inputs + noise",
                            "BinOp"
                        ],
                        [
                            "tf.math.pow(inputs, tf.math.exp(tf.random.normal(sample_shape, stddev=self.gamma_std)))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(inputs, m, M)",
                            "Call"
                        ],
                        [
                            "(inputs - m) / (M - m + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(inputs, values[i]), tf.zeros_like(inputs), inputs)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_1378": {
                "variable": {
                    "value": "tensor_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.convert_to_tensor(input_shape)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_1380": {
                "variable": {
                    "value": "self.pad_shape_tens",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self.pad_shape_tens",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "maximum_1381": {
                "variable": {
                    "value": "self.pad_shape_tens",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tensor_shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.convert_to_tensor(input_shape), 'int32')",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.pad_shape_tens",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_1386": {
                "variable": {
                    "value": "self.pad_margin_tens",
                    "type": "Attribute",
                    "possible_values": []
                },
                "values": {
                    "value": "[min_margins, max_margins]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "squeeze_1482": {
                "input": {
                    "value": "K.greater(tf.random.uniform([1], 0, 1), 1 - self.prob_mask)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_162": {
                "input": {
                    "value": "inputs[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cast_250": {
                "x": {
                    "value": "v",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "t",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "zeros_254": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_376": {
                "input": {
                    "value": "inputs[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "concat_377": {
                "values": {
                    "value": "[batchsize, tf.ones(1, dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_388": {
                "x": {
                    "value": "v",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "uniform_401": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "len(self.flip_axis)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_459": {
                "input": {
                    "value": "inputs[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "convert_to_tensor_465": {
                "value": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "scatter_nd_466": {
                "indices": {
                    "value": "tmp_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(self.indices, tf.concat([batch, tf.convert_to_tensor([1, 1], dtype='int32')], axis=0))",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "means",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([inputs[1][..., i] for i in range(self.n_channels)], 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.scatter_nd(tmp_indices, means, self.shape), 0), tile_shape)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "self.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_467": {
                "params": {
                    "value": "x[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "indices": {
                    "value": "x[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "scatter_nd_471": {
                "indices": {
                    "value": "tmp_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(self.indices, tf.concat([batch, tf.convert_to_tensor([1, 1], dtype='int32')], axis=0))",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "stds",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([inputs[2][..., i] for i in range(self.n_channels)], 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.scatter_nd(tmp_indices, stds, self.shape), 0), tile_shape)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "self.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_472": {
                "params": {
                    "value": "x[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "indices": {
                    "value": "x[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "normal_474": {
                "shape": {
                    "value": "tf.shape(labels)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_579": {
                "shape": {
                    "value": "[self.n_dims]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "bool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_580": {
                "value": {
                    "value": "[True]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "bool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "split_582": {
                "value": {
                    "value": "tf.shape(inputs)",
                    "type": "Call",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_584": {
                "input": {
                    "value": "self.min_res_tens",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_588": {
                "shape": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[self.n_dims]",
                            "List"
                        ],
                        [
                            "tf.concat([batch, tf.convert_to_tensor([self.n_dims], dtype='int32')], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batchsize, self.flatten_shape * self.one, self.n_channels * self.one], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batchsize, self.flatten_shape * self.one], 0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "bool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ones_588": {
                "shape": {
                    "value": "batch",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.split(tf.shape(inputs[0]), [1, -1])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.split(tf.shape(inputs), [1, -1])[0]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "bool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "uniform_603": {
                "variable": {
                    "value": "new_resolution_aniso",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[self.n_dims]",
                            "List"
                        ],
                        [
                            "tf.concat([batch, tf.convert_to_tensor([self.n_dims], dtype='int32')], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batchsize, self.flatten_shape * self.one, self.n_channels * self.one], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batchsize, self.flatten_shape * self.one], 0)",
                            "Call"
                        ]
                    ]
                },
                "minval": {
                    "value": "self.min_res",
                    "type": "Attribute",
                    "possible_values": []
                },
                "maxval": {
                    "value": "self.max_res_aniso",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "uniform_610": {
                "variable": {
                    "value": "new_resolution_iso",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[self.n_dims]",
                            "List"
                        ],
                        [
                            "tf.concat([batch, tf.convert_to_tensor([self.n_dims], dtype='int32')], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batchsize, self.flatten_shape * self.one, self.n_channels * self.one], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batchsize, self.flatten_shape * self.one], 0)",
                            "Call"
                        ]
                    ]
                },
                "minval": {
                    "value": "self.min_res",
                    "type": "Attribute",
                    "possible_values": []
                },
                "maxval": {
                    "value": "self.max_res_iso",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "uniform_611": {
                "variable": {
                    "value": "new_resolution_aniso",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[self.n_dims]",
                            "List"
                        ],
                        [
                            "tf.concat([batch, tf.convert_to_tensor([self.n_dims], dtype='int32')], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batchsize, self.flatten_shape * self.one, self.n_channels * self.one], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batchsize, self.flatten_shape * self.one], 0)",
                            "Call"
                        ]
                    ]
                },
                "minval": {
                    "value": "self.min_res",
                    "type": "Attribute",
                    "possible_values": []
                },
                "maxval": {
                    "value": "self.max_res_aniso",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "uniform_620": {
                "shape": {
                    "value": "tf.shape(self.min_res_tens)",
                    "type": "Call",
                    "possible_values": []
                },
                "minval": {
                    "value": "self.min_res_tens",
                    "type": "Attribute",
                    "possible_values": []
                },
                "maxval": {
                    "value": "new_resolution",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.min_res_tens",
                            "Attribute"
                        ],
                        [
                            "K.switch(tf.squeeze(K.less(tf.random.uniform([1], 0, 1), self.prob_min)), self.min_res_tens, new_resolution_iso)",
                            "Call"
                        ],
                        [
                            "K.switch(tf.squeeze(K.less(tf.random.uniform([1], 0, 1), self.prob_min)), self.min_res_tens, tf.where(mask, new_resolution_aniso, self.min_res_tens))",
                            "Call"
                        ],
                        [
                            "K.switch(tf.squeeze(K.less(tf.random.uniform([1], 0, 1), self.prob_iso)), new_resolution_iso, tf.where(mask, new_resolution_aniso, self.min_res_tens))",
                            "Call"
                        ],
                        [
                            "K.switch(tf.squeeze(K.less(tf.random.uniform([1], 0, 1), self.prob_min)), self.min_res_tens, new_resolution)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_724": {
                "variable": {
                    "value": "image",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[self.convnd(tf.expand_dims(image[..., n], -1), k, self.stride, 'SAME') for n in range(self.n_channels)]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_737": {
                "variable": {
                    "value": "maskb",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tensor_scatter_nd_update(tf.zeros([self.n_dims], dtype='bool'), dim, tf.convert_to_tensor([True], dtype='bool'))",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(tf.zeros(shape, dtype='bool'), indices, tf.ones(batch, dtype='bool'))",
                            "Call"
                        ],
                        [
                            "tf.cast(inputs[1], 'bool')",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.ones_like(inputs)",
                            "Call"
                        ],
                        [
                            "mask * tmp_mask",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_738": {
                "variable": {
                    "value": "maskb",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[self.convnd(tf.expand_dims(maskb[..., n], -1), self.kernels, self.stride, 'SAME') for n in range(self.n_channels)]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "where_741": {
                "variable": {
                    "value": "image",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "mask",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tensor_scatter_nd_update(tf.zeros([self.n_dims], dtype='bool'), dim, tf.convert_to_tensor([True], dtype='bool'))",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(tf.zeros(shape, dtype='bool'), indices, tf.ones(batch, dtype='bool'))",
                            "Call"
                        ],
                        [
                            "tf.cast(inputs[1], 'bool')",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.ones_like(inputs)",
                            "Call"
                        ],
                        [
                            "mask * tmp_mask",
                            "BinOp"
                        ]
                    ]
                },
                "x": {
                    "value": "image",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.concat([self.convnd(tf.expand_dims(image[..., n], -1), self.kernels, self.stride, 'SAME') for n in range(self.n_channels)], -1)",
                            "Call"
                        ],
                        [
                            "tf.concat([self.convnd(tf.expand_dims(image[..., n], -1), k, self.stride, 'SAME') for n in range(self.n_channels)], -1)",
                            "Call"
                        ],
                        [
                            "image / (maskb + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, image, tf.zeros_like(image))",
                            "Call"
                        ],
                        [
                            "image / (maskb + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, image, tf.zeros_like(image))",
                            "Call"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.map_fn(self._single_blur, [image, kernels], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_blur, [image, kernel], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(image)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_806": {
                "input": {
                    "value": "inputs[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_904": {
                "input": {
                    "value": "vol",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "K.reshape(vol, [-1, *self.inshape])",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_down_interpn, [vol, down_loc], tf.float32)",
                            "Call"
                        ],
                        [
                            "vol + tf.random.normal(tf.shape(vol), stddev=tf.random.uniform(sample_shape, maxval=self.noise_std))",
                            "BinOp"
                        ],
                        [
                            "tf.map_fn(self._single_up_interpn, [vol, up_loc], tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_905": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_909": {
                "input": {
                    "value": "subsample_res",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(inputs[1], dtype='float32')",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(subsample_res, 0), tile_shape)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_to_tensor_910": {
                "value": {
                    "value": "np.array(self.inshape[:-1]) * self.volume_res",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_912": {
                "value": {
                    "value": "self.inshape[:-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "convert_to_tensor_913": {
                "value": {
                    "value": "self.resample_shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_918": {
                "value": {
                    "value": "self.inshape[:-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_927": {
                "input": {
                    "value": "vol",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "K.reshape(vol, [-1, *self.inshape])",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_down_interpn, [vol, down_loc], tf.float32)",
                            "Call"
                        ],
                        [
                            "vol + tf.random.normal(tf.shape(vol), stddev=tf.random.uniform(sample_shape, maxval=self.noise_std))",
                            "BinOp"
                        ],
                        [
                            "tf.map_fn(self._single_up_interpn, [vol, up_loc], tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "minimum_950": {
                "x": {
                    "value": "f_dist",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "up_loc - floor",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "c_dist",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "ceil - up_loc",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_951": {
                "input_tensor": {
                    "value": "tf.math.square(dist)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "split_1038": {
                "value": {
                    "value": "tf.shape(inputs[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "multiply_1049": {
                "x": {
                    "value": "bias_field",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.random.normal(bias_shape, stddev=tf.random.uniform(std_shape, maxval=self.bias_field_std))",
                            "Call"
                        ],
                        [
                            "nrn_layers.Resize(size=self.inshape[0][1:self.n_dims + 1], interp_method='linear')(bias_field)",
                            "Call"
                        ],
                        [
                            "tf.math.exp(bias_field)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "v",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "shape_1135": {
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "[tf.cast(v, dtype='float32') for v in inputs]",
                            "ListComp"
                        ],
                        [
                            "[nrn_layers.SpatialTransformer(m)([v] + list_trans) for (m, v) in zip(self.inter_method, inputs)]",
                            "ListComp"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_slice, inputs, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in swapped_inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_flip, [inputs, rand_flip], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "K.clip(inputs, self.clip_values[0], self.clip_values[1])",
                            "Call"
                        ],
                        [
                            "inputs + noise",
                            "BinOp"
                        ],
                        [
                            "tf.math.pow(inputs, tf.math.exp(tf.random.normal(sample_shape, stddev=self.gamma_std)))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(inputs, m, M)",
                            "Call"
                        ],
                        [
                            "(inputs - m) / (M - m + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(inputs, values[i]), tf.zeros_like(inputs), inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_1164": {
                "variable": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[batchsize, self.flatten_shape * self.one, self.n_channels * self.one]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_1166": {
                "variable": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[batchsize, self.flatten_shape * self.one]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_1182": {
                "x": {
                    "value": "tf.random.normal(sample_shape, stddev=self.gamma_std)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "square_1215": {
                "x": {
                    "value": "y",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs[1]",
                            "Subscript"
                        ],
                        [
                            "K.clip(y / tf.math.reduce_sum(y, axis=-1, keepdims=True), 0, 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_1296": {
                "x": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "[tf.cast(v, dtype='float32') for v in inputs]",
                            "ListComp"
                        ],
                        [
                            "[nrn_layers.SpatialTransformer(m)([v] + list_trans) for (m, v) in zip(self.inter_method, inputs)]",
                            "ListComp"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_slice, inputs, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in swapped_inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_flip, [inputs, rand_flip], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "K.clip(inputs, self.clip_values[0], self.clip_values[1])",
                            "Call"
                        ],
                        [
                            "inputs + noise",
                            "BinOp"
                        ],
                        [
                            "tf.math.pow(inputs, tf.math.exp(tf.random.normal(sample_shape, stddev=self.gamma_std)))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(inputs, m, M)",
                            "Call"
                        ],
                        [
                            "(inputs - m) / (M - m + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(inputs, values[i]), tf.zeros_like(inputs), inputs)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "values[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "zeros_like_1296": {
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "[tf.cast(v, dtype='float32') for v in inputs]",
                            "ListComp"
                        ],
                        [
                            "[nrn_layers.SpatialTransformer(m)([v] + list_trans) for (m, v) in zip(self.inter_method, inputs)]",
                            "ListComp"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_slice, inputs, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in swapped_inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_flip, [inputs, rand_flip], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "K.clip(inputs, self.clip_values[0], self.clip_values[1])",
                            "Call"
                        ],
                        [
                            "inputs + noise",
                            "BinOp"
                        ],
                        [
                            "tf.math.pow(inputs, tf.math.exp(tf.random.normal(sample_shape, stddev=self.gamma_std)))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(inputs, m, M)",
                            "Call"
                        ],
                        [
                            "(inputs - m) / (M - m + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(inputs, values[i]), tf.zeros_like(inputs), inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "uniform_1465": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "axis_boundaries[0] * self.inputshape[axis]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "axis_boundaries[1] * self.inputshape[axis]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_1472": {
                "values": {
                    "value": "[idx1, idx2, idx3]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_to_tensor_182": {
                "value": {
                    "value": "self.small_shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_247": {
                "x": {
                    "value": "v",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "map_fn_383": {
                "fn": {
                    "value": "self._single_swap",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "[inputs[i], rand_flip]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "types[i]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "[v.dtype for v in inputs]",
                            "ListComp"
                        ],
                        [
                            "[v.dtype for v in inputs]",
                            "ListComp"
                        ],
                        [
                            "[v.dtype for v in inputs]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "convert_to_tensor_402": {
                "value": {
                    "value": "self.flip_axis",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_460": {
                "value": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_461": {
                "x": {
                    "value": "inputs[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_474": {
                "input": {
                    "value": "labels",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.cast(inputs[0], dtype='int32') + self.max_label * i for i in range(self.n_channels)], -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_582": {
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "[tf.cast(v, dtype='float32') for v in inputs]",
                            "ListComp"
                        ],
                        [
                            "[nrn_layers.SpatialTransformer(m)([v] + list_trans) for (m, v) in zip(self.inter_method, inputs)]",
                            "ListComp"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_slice, inputs, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in swapped_inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_flip, [inputs, rand_flip], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "K.clip(inputs, self.clip_values[0], self.clip_values[1])",
                            "Call"
                        ],
                        [
                            "inputs + noise",
                            "BinOp"
                        ],
                        [
                            "tf.math.pow(inputs, tf.math.exp(tf.random.normal(sample_shape, stddev=self.gamma_std)))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(inputs, m, M)",
                            "Call"
                        ],
                        [
                            "(inputs - m) / (M - m + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(inputs, values[i]), tf.zeros_like(inputs), inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_583": {
                "value": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_586": {
                "value": {
                    "value": "[self.n_dims]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "uniform_587": {
                "shape": {
                    "value": "batch",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.split(tf.shape(inputs[0]), [1, -1])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.split(tf.shape(inputs), [1, -1])[0]",
                            "Subscript"
                        ]
                    ]
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "self.n_dims",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "squeeze_597": {
                "input": {
                    "value": "K.less(tf.random.uniform([1], 0, 1), self.prob_min)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_620": {
                "input": {
                    "value": "self.min_res_tens",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_727": {
                "variable": {
                    "value": "maskb",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tensor_scatter_nd_update(tf.zeros([self.n_dims], dtype='bool'), dim, tf.convert_to_tensor([True], dtype='bool'))",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(tf.zeros(shape, dtype='bool'), indices, tf.ones(batch, dtype='bool'))",
                            "Call"
                        ],
                        [
                            "tf.cast(inputs[1], 'bool')",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.ones_like(inputs)",
                            "Call"
                        ],
                        [
                            "mask * tmp_mask",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_728": {
                "variable": {
                    "value": "maskb",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[self.convnd(tf.expand_dims(maskb[..., n], -1), k, self.stride, 'SAME') for n in range(self.n_channels)]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "where_731": {
                "variable": {
                    "value": "image",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "mask",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tensor_scatter_nd_update(tf.zeros([self.n_dims], dtype='bool'), dim, tf.convert_to_tensor([True], dtype='bool'))",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(tf.zeros(shape, dtype='bool'), indices, tf.ones(batch, dtype='bool'))",
                            "Call"
                        ],
                        [
                            "tf.cast(inputs[1], 'bool')",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.ones_like(inputs)",
                            "Call"
                        ],
                        [
                            "mask * tmp_mask",
                            "BinOp"
                        ]
                    ]
                },
                "x": {
                    "value": "image",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.concat([self.convnd(tf.expand_dims(image[..., n], -1), self.kernels, self.stride, 'SAME') for n in range(self.n_channels)], -1)",
                            "Call"
                        ],
                        [
                            "tf.concat([self.convnd(tf.expand_dims(image[..., n], -1), k, self.stride, 'SAME') for n in range(self.n_channels)], -1)",
                            "Call"
                        ],
                        [
                            "image / (maskb + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, image, tf.zeros_like(image))",
                            "Call"
                        ],
                        [
                            "image / (maskb + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, image, tf.zeros_like(image))",
                            "Call"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.map_fn(self._single_blur, [image, kernels], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_blur, [image, kernel], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(image)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_802": {
                "input": {
                    "value": "channel",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "split_channels",
                            "Name"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_803": {
                "input": {
                    "value": "blurred",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.convnd(tf.expand_dims(channel, 0), inputs[1], [1] * (self.n_dims + 2), padding='SAME')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_916": {
                "shape": {
                    "value": "[self.n_dims + 1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ones_925": {
                "shape": {
                    "value": "[self.n_dims]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "uniform_927": {
                "shape": {
                    "value": "sample_shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([batchsize, tf.ones([self.n_dims], dtype='int32'), self.n_channels * tf.ones([1], dtype='int32')], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batchsize, tf.ones([self.n_dims], dtype='int32')], 0)",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.concat([sample_shape, self.n_channels * self.one], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([sample_shape, self.one], 0)",
                            "Call"
                        ]
                    ]
                },
                "maxval": {
                    "value": "self.noise_std",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_930": {
                "shape": {
                    "value": "[self.n_dims + 1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "square_951": {
                "x": {
                    "value": "dist",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.minimum(f_dist, c_dist) * l2i_et.expand_dims(subsample_res, axis=[1] * self.n_dims)",
                            "BinOp"
                        ],
                        [
                            "tf.math.sqrt(tf.math.reduce_sum(tf.math.square(dist), axis=-1, keepdims=True))",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_1038": {
                "input": {
                    "value": "inputs[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "convert_to_tensor_1039": {
                "value": {
                    "value": "self.std_shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_1040": {
                "value": {
                    "value": "self.small_bias_shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "uniform_1043": {
                "shape": {
                    "value": "std_shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([batchsize, tf.convert_to_tensor(self.std_shape, dtype='int32')], 0)",
                            "Call"
                        ]
                    ]
                },
                "maxval": {
                    "value": "self.bias_field_std",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_1137": {
                "shape": {
                    "value": "[self.n_dims]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_1149": {
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "[tf.cast(v, dtype='float32') for v in inputs]",
                            "ListComp"
                        ],
                        [
                            "[nrn_layers.SpatialTransformer(m)([v] + list_trans) for (m, v) in zip(self.inter_method, inputs)]",
                            "ListComp"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_slice, inputs, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in swapped_inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_flip, [inputs, rand_flip], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "K.clip(inputs, self.clip_values[0], self.clip_values[1])",
                            "Call"
                        ],
                        [
                            "inputs + noise",
                            "BinOp"
                        ],
                        [
                            "tf.math.pow(inputs, tf.math.exp(tf.random.normal(sample_shape, stddev=self.gamma_std)))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(inputs, m, M)",
                            "Call"
                        ],
                        [
                            "(inputs - m) / (M - m + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(inputs, values[i]), tf.zeros_like(inputs), inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_1151": {
                "input": {
                    "value": "tf.split(inputs, [1, -1], -1)[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "convert_to_tensor_1152": {
                "value": {
                    "value": "[1] * (self.n_dims + 1) + [self.n_channels]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_1167": {
                "tensor": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "[tf.cast(v, dtype='float32') for v in inputs]",
                            "ListComp"
                        ],
                        [
                            "[nrn_layers.SpatialTransformer(m)([v] + list_trans) for (m, v) in zip(self.inter_method, inputs)]",
                            "ListComp"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_slice, inputs, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in swapped_inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_flip, [inputs, rand_flip], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "K.clip(inputs, self.clip_values[0], self.clip_values[1])",
                            "Call"
                        ],
                        [
                            "inputs + noise",
                            "BinOp"
                        ],
                        [
                            "tf.math.pow(inputs, tf.math.exp(tf.random.normal(sample_shape, stddev=self.gamma_std)))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(inputs, m, M)",
                            "Call"
                        ],
                        [
                            "(inputs - m) / (M - m + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(inputs, values[i]), tf.zeros_like(inputs), inputs)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[self.n_dims]",
                            "List"
                        ],
                        [
                            "tf.concat([batch, tf.convert_to_tensor([self.n_dims], dtype='int32')], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batchsize, self.flatten_shape * self.one, self.n_channels * self.one], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batchsize, self.flatten_shape * self.one], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "normal_1182": {
                "shape": {
                    "value": "sample_shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([batchsize, tf.ones([self.n_dims], dtype='int32'), self.n_channels * tf.ones([1], dtype='int32')], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([batchsize, tf.ones([self.n_dims], dtype='int32')], 0)",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.concat([sample_shape, self.n_channels * self.one], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([sample_shape, self.one], 0)",
                            "Call"
                        ]
                    ]
                },
                "stddev": {
                    "value": "self.gamma_std",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_1210": {
                "input_tensor": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "K.clip(x / tf.math.reduce_sum(x, axis=-1, keepdims=True), 0, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_1211": {
                "input_tensor": {
                    "value": "y",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs[1]",
                            "Subscript"
                        ],
                        [
                            "K.clip(y / tf.math.reduce_sum(y, axis=-1, keepdims=True), 0, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "convert_to_tensor_1378": {
                "value": {
                    "value": "input_shape",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "uniform_1468": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "axis_boundaries[2] * self.inputshape[axis]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "axis_boundaries[3] * self.inputshape[axis] - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_like_1476": {
                "input": {
                    "value": "split_list[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ones_like_1477": {
                "input": {
                    "value": "split_list[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "zeros_like_1478": {
                "input": {
                    "value": "split_list[2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "uniform_1482": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_377": {
                "shape": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "squeeze_604": {
                "input": {
                    "value": "K.less(tf.random.uniform([1], 0, 1), self.prob_min)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_606": {
                "condition": {
                    "value": "mask",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tensor_scatter_nd_update(tf.zeros([self.n_dims], dtype='bool'), dim, tf.convert_to_tensor([True], dtype='bool'))",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(tf.zeros(shape, dtype='bool'), indices, tf.ones(batch, dtype='bool'))",
                            "Call"
                        ],
                        [
                            "tf.cast(inputs[1], 'bool')",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.ones_like(inputs)",
                            "Call"
                        ],
                        [
                            "mask * tmp_mask",
                            "BinOp"
                        ]
                    ]
                },
                "x": {
                    "value": "new_resolution_aniso",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.random.uniform(shape, minval=self.min_res, maxval=self.max_res_aniso)",
                            "Call"
                        ],
                        [
                            "tf.random.uniform(shape, minval=self.min_res, maxval=self.max_res_aniso)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.min_res_tens",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "squeeze_612": {
                "input": {
                    "value": "K.less(tf.random.uniform([1], 0, 1), self.prob_iso)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_614": {
                "condition": {
                    "value": "mask",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tensor_scatter_nd_update(tf.zeros([self.n_dims], dtype='bool'), dim, tf.convert_to_tensor([True], dtype='bool'))",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(tf.zeros(shape, dtype='bool'), indices, tf.ones(batch, dtype='bool'))",
                            "Call"
                        ],
                        [
                            "tf.cast(inputs[1], 'bool')",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.ones_like(inputs)",
                            "Call"
                        ],
                        [
                            "mask * tmp_mask",
                            "BinOp"
                        ]
                    ]
                },
                "x": {
                    "value": "new_resolution_aniso",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.random.uniform(shape, minval=self.min_res, maxval=self.max_res_aniso)",
                            "Call"
                        ],
                        [
                            "tf.random.uniform(shape, minval=self.min_res, maxval=self.max_res_aniso)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.min_res_tens",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "squeeze_615": {
                "input": {
                    "value": "K.less(tf.random.uniform([1], 0, 1), self.prob_min)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_741": {
                "input": {
                    "value": "image",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.concat([self.convnd(tf.expand_dims(image[..., n], -1), self.kernels, self.stride, 'SAME') for n in range(self.n_channels)], -1)",
                            "Call"
                        ],
                        [
                            "tf.concat([self.convnd(tf.expand_dims(image[..., n], -1), k, self.stride, 'SAME') for n in range(self.n_channels)], -1)",
                            "Call"
                        ],
                        [
                            "image / (maskb + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, image, tf.zeros_like(image))",
                            "Call"
                        ],
                        [
                            "image / (maskb + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, image, tf.zeros_like(image))",
                            "Call"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.map_fn(self._single_blur, [image, kernels], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_blur, [image, kernel], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_926": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "uniform_597": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_like_731": {
                "input": {
                    "value": "image",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.concat([self.convnd(tf.expand_dims(image[..., n], -1), self.kernels, self.stride, 'SAME') for n in range(self.n_channels)], -1)",
                            "Call"
                        ],
                        [
                            "tf.concat([self.convnd(tf.expand_dims(image[..., n], -1), k, self.stride, 'SAME') for n in range(self.n_channels)], -1)",
                            "Call"
                        ],
                        [
                            "image / (maskb + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, image, tf.zeros_like(image))",
                            "Call"
                        ],
                        [
                            "image / (maskb + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, image, tf.zeros_like(image))",
                            "Call"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.map_fn(self._single_blur, [image, kernels], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_blur, [image, kernel], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_734": {
                "input": {
                    "value": "image[..., n]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "split_1151": {
                "value": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "[tf.cast(v, dtype='float32') for v in inputs]",
                            "ListComp"
                        ],
                        [
                            "[nrn_layers.SpatialTransformer(m)([v] + list_trans) for (m, v) in zip(self.inter_method, inputs)]",
                            "ListComp"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_slice, inputs, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "tf.concat([tf.cast(v, 'float32') for v in swapped_inputs], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(self._single_flip, [inputs, rand_flip], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.split(inputs, self.list_n_channels, axis=-1)",
                            "Call"
                        ],
                        [
                            "[inputs]",
                            "List"
                        ],
                        [
                            "K.clip(inputs, self.clip_values[0], self.clip_values[1])",
                            "Call"
                        ],
                        [
                            "inputs + noise",
                            "BinOp"
                        ],
                        [
                            "tf.math.pow(inputs, tf.math.exp(tf.random.normal(sample_shape, stddev=self.gamma_std)))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(inputs, m, M)",
                            "Call"
                        ],
                        [
                            "(inputs - m) / (M - m + K.epsilon())",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(inputs, values[i]), tf.zeros_like(inputs), inputs)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "[1, -1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "uniform_604": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "uniform_612": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "uniform_615": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_724": {
                "input": {
                    "value": "image[..., n]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_738": {
                "input": {
                    "value": "maskb[..., n]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_728": {
                "input": {
                    "value": "maskb[..., n]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "ext/lab2im/utils.py": {
        "tensorflow": {
            "matmul_727": {
                "a": {
                    "value": "T_shearing",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.eye(n_dims + 1)",
                            "Call"
                        ],
                        [
                            "create_shearing_transform(shearing, n_dims)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.eye(n_dims), axis=0), tf.concat([batchsize, tf.ones(2, dtype='int32')], axis=0))",
                            "Call"
                        ],
                        [
                            "tf.concat([shearing_row0, shearing_row1, shearing_row2], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([shearing_row0, shearing_row1], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "T_rot",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.eye(n_dims + 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.eye(n_dims), axis=0), tf.concat([batchsize, tf.ones(2, dtype='int32')], axis=0))",
                            "Call"
                        ],
                        [
                            "create_rotation_transform(rotation, n_dims)",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.matmul(Rx, Ry), Rz)",
                            "Call"
                        ],
                        [
                            "tf.concat([R_row0, R_row1], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_740": {
                "variable": {
                    "value": "T_last_row",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.concat([tf.zeros((1, n_dims)), tf.ones((1, 1))], axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_741": {
                "variable": {
                    "value": "T_last_row",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "T_last_row",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.concat([tf.zeros((1, n_dims)), tf.ones((1, 1))], axis=1), 0)",
                            "Call"
                        ],
                        [
                            "tf.tile(T_last_row, tf.concat([batchsize, tf.ones(2, dtype='int32')], axis=0))",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "tf.concat([batchsize, tf.ones(2, dtype='int32')], axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_742": {
                "variable": {
                    "value": "T",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[T, T_last_row]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_791": {
                "variable": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(shearing[..., 0], -1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tile_701": {
                "variable": {
                    "value": "T_rot",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.eye(n_dims), axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tf.concat([batchsize, tf.ones(2, dtype='int32')], axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tile_712": {
                "variable": {
                    "value": "T_shearing",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.eye(n_dims), axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tf.concat([batchsize, tf.ones(2, dtype='int32')], axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "diag_722": {
                "variable": {
                    "value": "T_scaling",
                    "type": "Variable",
                    "possible_values": []
                },
                "diagonal": {
                    "value": "scaling",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "draw_value_from_distribution(scaling_bounds, size=n_dims, centre=1, default_range=0.15, return_as_tensor=True, batchsize=batchsize)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "tile_724": {
                "variable": {
                    "value": "T_scaling",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.eye(n_dims), axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tf.concat([batchsize, tf.ones(2, dtype='int32')], axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_735": {
                "variable": {
                    "value": "T",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[T, tf.expand_dims(translation, axis=-1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_737": {
                "values": {
                    "value": "[tf.shape(T)[:2], tf.ones(1, dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_751": {
                "variable": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(rotation[..., 0], -1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_753": {
                "input": {
                    "value": "tf.convert_to_tensor([1.0, 0.0, 0.0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_754": {
                "variable": {
                    "value": "Rx_row1",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.zeros(shape), tf.expand_dims(tf.cos(rotation[..., 0]), -1), tf.expand_dims(-tf.sin(rotation[..., 0]), -1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_756": {
                "variable": {
                    "value": "Rx_row2",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.zeros(shape), tf.expand_dims(tf.sin(rotation[..., 0]), -1), tf.expand_dims(tf.cos(rotation[..., 0]), -1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_758": {
                "variable": {
                    "value": "Rx",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[Rx_row0, Rx_row1, Rx_row2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_760": {
                "variable": {
                    "value": "Ry_row0",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(tf.cos(rotation[..., 1]), -1), tf.zeros(shape), tf.expand_dims(tf.sin(rotation[..., 1]), -1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_762": {
                "input": {
                    "value": "tf.convert_to_tensor([0.0, 1.0, 0.0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_763": {
                "variable": {
                    "value": "Ry_row2",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(-tf.sin(rotation[..., 1]), -1), tf.zeros(shape), tf.expand_dims(tf.cos(rotation[..., 1]), -1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_765": {
                "variable": {
                    "value": "Ry",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[Ry_row0, Ry_row1, Ry_row2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_767": {
                "variable": {
                    "value": "Rz_row0",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(tf.cos(rotation[..., 2]), -1), tf.expand_dims(-tf.sin(rotation[..., 2]), -1), tf.zeros(shape)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_769": {
                "variable": {
                    "value": "Rz_row1",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(tf.sin(rotation[..., 2]), -1), tf.expand_dims(tf.cos(rotation[..., 2]), -1), tf.zeros(shape)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_771": {
                "input": {
                    "value": "tf.convert_to_tensor([0.0, 0.0, 1.0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_772": {
                "variable": {
                    "value": "Rz",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[Rz_row0, Rz_row1, Rz_row2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_774": {
                "a": {
                    "value": "Rx",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([Rx_row0, Rx_row1, Rx_row2], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "Ry",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([Ry_row0, Ry_row1, Ry_row2], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_793": {
                "variable": {
                    "value": "shearing_row0",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.ones(shape), tf.expand_dims(shearing[..., 0], -1), tf.expand_dims(shearing[..., 1], -1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_795": {
                "variable": {
                    "value": "shearing_row1",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(shearing[..., 2], -1), tf.ones(shape), tf.expand_dims(shearing[..., 3], -1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_797": {
                "variable": {
                    "value": "shearing_row2",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(shearing[..., 4], -1), tf.expand_dims(shearing[..., 5], -1), tf.ones(shape)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_799": {
                "variable": {
                    "value": "T_shearing",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[shearing_row0, shearing_row1, shearing_row2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_740": {
                "values": {
                    "value": "[tf.zeros((1, n_dims)), tf.ones((1, 1))]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_741": {
                "values": {
                    "value": "[batchsize, tf.ones(2, dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_777": {
                "variable": {
                    "value": "R_row0",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(tf.cos(rotation[..., 0]), -1), tf.expand_dims(tf.sin(rotation[..., 0]), -1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_779": {
                "variable": {
                    "value": "R_row1",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(-tf.sin(rotation[..., 0]), -1), tf.expand_dims(tf.cos(rotation[..., 0]), -1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_781": {
                "variable": {
                    "value": "T_rot",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[R_row0, R_row1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_791": {
                "input": {
                    "value": "shearing[..., 0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_802": {
                "variable": {
                    "value": "shearing_row0",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.ones(shape), tf.expand_dims(shearing[..., 0], -1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_803": {
                "variable": {
                    "value": "shearing_row1",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(shearing[..., 1], -1), tf.ones(shape)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_804": {
                "variable": {
                    "value": "T_shearing",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[shearing_row0, shearing_row1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_686": {
                "variable": {
                    "value": "rotation",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.concat([batchsize, tf.ones(1, dtype='int32')], axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_695": {
                "variable": {
                    "value": "rotation",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.concat([batchsize, 3 * tf.ones(1, dtype='int32')], axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_701": {
                "input": {
                    "value": "tf.eye(n_dims)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_702": {
                "values": {
                    "value": "[batchsize, tf.ones(2, dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_712": {
                "input": {
                    "value": "tf.eye(n_dims)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_713": {
                "values": {
                    "value": "[batchsize, tf.ones(2, dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_724": {
                "input": {
                    "value": "tf.eye(n_dims)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_725": {
                "values": {
                    "value": "[batchsize, tf.ones(2, dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_751": {
                "input": {
                    "value": "rotation[..., 0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_753": {
                "input": {
                    "value": "tf.expand_dims(tf.convert_to_tensor([1.0, 0.0, 0.0]), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[math.ceil(patch_shape[i] * factor[i]) for i in range(len(patch_shape))]",
                            "ListComp"
                        ],
                        [
                            "shape + [n_channels]",
                            "BinOp"
                        ],
                        [
                            "tf.shape(tf.expand_dims(rotation[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "tf.shape(tf.expand_dims(shearing[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "[connectivity * 2 + 1] * n_dims",
                            "BinOp"
                        ],
                        [
                            "reformat_to_list(shape, length=n_dims)",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.convert_to_tensor(hyperparameter.shape[1], 'int32'))([])",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.concat([x[0], tf.expand_dims(x[1], axis=0)], axis=0))([batchsize, shape])",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "tile_762": {
                "input": {
                    "value": "tf.expand_dims(tf.convert_to_tensor([0.0, 1.0, 0.0]), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[math.ceil(patch_shape[i] * factor[i]) for i in range(len(patch_shape))]",
                            "ListComp"
                        ],
                        [
                            "shape + [n_channels]",
                            "BinOp"
                        ],
                        [
                            "tf.shape(tf.expand_dims(rotation[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "tf.shape(tf.expand_dims(shearing[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "[connectivity * 2 + 1] * n_dims",
                            "BinOp"
                        ],
                        [
                            "reformat_to_list(shape, length=n_dims)",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.convert_to_tensor(hyperparameter.shape[1], 'int32'))([])",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.concat([x[0], tf.expand_dims(x[1], axis=0)], axis=0))([batchsize, shape])",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "tile_771": {
                "input": {
                    "value": "tf.expand_dims(tf.convert_to_tensor([0.0, 0.0, 1.0]), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[math.ceil(patch_shape[i] * factor[i]) for i in range(len(patch_shape))]",
                            "ListComp"
                        ],
                        [
                            "shape + [n_channels]",
                            "BinOp"
                        ],
                        [
                            "tf.shape(tf.expand_dims(rotation[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "tf.shape(tf.expand_dims(shearing[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "[connectivity * 2 + 1] * n_dims",
                            "BinOp"
                        ],
                        [
                            "reformat_to_list(shape, length=n_dims)",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.convert_to_tensor(hyperparameter.shape[1], 'int32'))([])",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.concat([x[0], tf.expand_dims(x[1], axis=0)], axis=0))([batchsize, shape])",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "cast_697": {
                "x": {
                    "value": "tf.random.uniform(tf.shape(rotation), maxval=4, dtype='int32') * 90",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "eye_701": {
                "num_rows": {
                    "value": "n_dims",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "len(shape) - 1",
                            "BinOp"
                        ],
                        [
                            "len(shape)",
                            "Call"
                        ],
                        [
                            "max(len(cropping), len(loss_cropping))",
                            "Call"
                        ],
                        [
                            "3",
                            "MethodArgument"
                        ],
                        [
                            "3",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "eye_712": {
                "num_rows": {
                    "value": "n_dims",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "len(shape) - 1",
                            "BinOp"
                        ],
                        [
                            "len(shape)",
                            "Call"
                        ],
                        [
                            "max(len(cropping), len(loss_cropping))",
                            "Call"
                        ],
                        [
                            "3",
                            "MethodArgument"
                        ],
                        [
                            "3",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "eye_724": {
                "num_rows": {
                    "value": "n_dims",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "len(shape) - 1",
                            "BinOp"
                        ],
                        [
                            "len(shape)",
                            "Call"
                        ],
                        [
                            "max(len(cropping), len(loss_cropping))",
                            "Call"
                        ],
                        [
                            "3",
                            "MethodArgument"
                        ],
                        [
                            "3",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "expand_dims_735": {
                "input": {
                    "value": "translation",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "draw_value_from_distribution(translation_bounds, size=n_dims, default_range=5, return_as_tensor=True, batchsize=batchsize)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_737": {
                "shape": {
                    "value": "tf.concat([tf.shape(T)[:2], tf.ones(1, dtype='int32')], 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_740": {
                "shape": {
                    "value": "(1, n_dims)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "ones_740": {
                "shape": {
                    "value": "(1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "ones_741": {
                "shape": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_754": {
                "shape": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[math.ceil(patch_shape[i] * factor[i]) for i in range(len(patch_shape))]",
                            "ListComp"
                        ],
                        [
                            "shape + [n_channels]",
                            "BinOp"
                        ],
                        [
                            "tf.shape(tf.expand_dims(rotation[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "tf.shape(tf.expand_dims(shearing[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "[connectivity * 2 + 1] * n_dims",
                            "BinOp"
                        ],
                        [
                            "reformat_to_list(shape, length=n_dims)",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.convert_to_tensor(hyperparameter.shape[1], 'int32'))([])",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.concat([x[0], tf.expand_dims(x[1], axis=0)], axis=0))([batchsize, shape])",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "expand_dims_754": {
                "input": {
                    "value": "tf.cos(rotation[..., 0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_755": {
                "input": {
                    "value": "-tf.sin(rotation[..., 0])",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_756": {
                "shape": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[math.ceil(patch_shape[i] * factor[i]) for i in range(len(patch_shape))]",
                            "ListComp"
                        ],
                        [
                            "shape + [n_channels]",
                            "BinOp"
                        ],
                        [
                            "tf.shape(tf.expand_dims(rotation[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "tf.shape(tf.expand_dims(shearing[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "[connectivity * 2 + 1] * n_dims",
                            "BinOp"
                        ],
                        [
                            "reformat_to_list(shape, length=n_dims)",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.convert_to_tensor(hyperparameter.shape[1], 'int32'))([])",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.concat([x[0], tf.expand_dims(x[1], axis=0)], axis=0))([batchsize, shape])",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "expand_dims_756": {
                "input": {
                    "value": "tf.sin(rotation[..., 0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_757": {
                "input": {
                    "value": "tf.cos(rotation[..., 0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_760": {
                "input": {
                    "value": "tf.cos(rotation[..., 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_760": {
                "shape": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[math.ceil(patch_shape[i] * factor[i]) for i in range(len(patch_shape))]",
                            "ListComp"
                        ],
                        [
                            "shape + [n_channels]",
                            "BinOp"
                        ],
                        [
                            "tf.shape(tf.expand_dims(rotation[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "tf.shape(tf.expand_dims(shearing[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "[connectivity * 2 + 1] * n_dims",
                            "BinOp"
                        ],
                        [
                            "reformat_to_list(shape, length=n_dims)",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.convert_to_tensor(hyperparameter.shape[1], 'int32'))([])",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.concat([x[0], tf.expand_dims(x[1], axis=0)], axis=0))([batchsize, shape])",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "expand_dims_761": {
                "input": {
                    "value": "tf.sin(rotation[..., 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_763": {
                "input": {
                    "value": "-tf.sin(rotation[..., 1])",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_763": {
                "shape": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[math.ceil(patch_shape[i] * factor[i]) for i in range(len(patch_shape))]",
                            "ListComp"
                        ],
                        [
                            "shape + [n_channels]",
                            "BinOp"
                        ],
                        [
                            "tf.shape(tf.expand_dims(rotation[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "tf.shape(tf.expand_dims(shearing[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "[connectivity * 2 + 1] * n_dims",
                            "BinOp"
                        ],
                        [
                            "reformat_to_list(shape, length=n_dims)",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.convert_to_tensor(hyperparameter.shape[1], 'int32'))([])",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.concat([x[0], tf.expand_dims(x[1], axis=0)], axis=0))([batchsize, shape])",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "expand_dims_764": {
                "input": {
                    "value": "tf.cos(rotation[..., 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_767": {
                "input": {
                    "value": "tf.cos(rotation[..., 2])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_768": {
                "input": {
                    "value": "-tf.sin(rotation[..., 2])",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_768": {
                "shape": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[math.ceil(patch_shape[i] * factor[i]) for i in range(len(patch_shape))]",
                            "ListComp"
                        ],
                        [
                            "shape + [n_channels]",
                            "BinOp"
                        ],
                        [
                            "tf.shape(tf.expand_dims(rotation[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "tf.shape(tf.expand_dims(shearing[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "[connectivity * 2 + 1] * n_dims",
                            "BinOp"
                        ],
                        [
                            "reformat_to_list(shape, length=n_dims)",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.convert_to_tensor(hyperparameter.shape[1], 'int32'))([])",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.concat([x[0], tf.expand_dims(x[1], axis=0)], axis=0))([batchsize, shape])",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "expand_dims_769": {
                "input": {
                    "value": "tf.sin(rotation[..., 2])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_770": {
                "input": {
                    "value": "tf.cos(rotation[..., 2])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_770": {
                "shape": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[math.ceil(patch_shape[i] * factor[i]) for i in range(len(patch_shape))]",
                            "ListComp"
                        ],
                        [
                            "shape + [n_channels]",
                            "BinOp"
                        ],
                        [
                            "tf.shape(tf.expand_dims(rotation[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "tf.shape(tf.expand_dims(shearing[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "[connectivity * 2 + 1] * n_dims",
                            "BinOp"
                        ],
                        [
                            "reformat_to_list(shape, length=n_dims)",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.convert_to_tensor(hyperparameter.shape[1], 'int32'))([])",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.concat([x[0], tf.expand_dims(x[1], axis=0)], axis=0))([batchsize, shape])",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "ones_793": {
                "shape": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[math.ceil(patch_shape[i] * factor[i]) for i in range(len(patch_shape))]",
                            "ListComp"
                        ],
                        [
                            "shape + [n_channels]",
                            "BinOp"
                        ],
                        [
                            "tf.shape(tf.expand_dims(rotation[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "tf.shape(tf.expand_dims(shearing[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "[connectivity * 2 + 1] * n_dims",
                            "BinOp"
                        ],
                        [
                            "reformat_to_list(shape, length=n_dims)",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.convert_to_tensor(hyperparameter.shape[1], 'int32'))([])",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.concat([x[0], tf.expand_dims(x[1], axis=0)], axis=0))([batchsize, shape])",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "expand_dims_793": {
                "input": {
                    "value": "shearing[..., 0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_794": {
                "input": {
                    "value": "shearing[..., 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_795": {
                "input": {
                    "value": "shearing[..., 2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "ones_795": {
                "shape": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[math.ceil(patch_shape[i] * factor[i]) for i in range(len(patch_shape))]",
                            "ListComp"
                        ],
                        [
                            "shape + [n_channels]",
                            "BinOp"
                        ],
                        [
                            "tf.shape(tf.expand_dims(rotation[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "tf.shape(tf.expand_dims(shearing[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "[connectivity * 2 + 1] * n_dims",
                            "BinOp"
                        ],
                        [
                            "reformat_to_list(shape, length=n_dims)",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.convert_to_tensor(hyperparameter.shape[1], 'int32'))([])",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.concat([x[0], tf.expand_dims(x[1], axis=0)], axis=0))([batchsize, shape])",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "expand_dims_796": {
                "input": {
                    "value": "shearing[..., 3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_797": {
                "input": {
                    "value": "shearing[..., 5]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "ones_798": {
                "shape": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[math.ceil(patch_shape[i] * factor[i]) for i in range(len(patch_shape))]",
                            "ListComp"
                        ],
                        [
                            "shape + [n_channels]",
                            "BinOp"
                        ],
                        [
                            "tf.shape(tf.expand_dims(rotation[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "tf.shape(tf.expand_dims(shearing[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "[connectivity * 2 + 1] * n_dims",
                            "BinOp"
                        ],
                        [
                            "reformat_to_list(shape, length=n_dims)",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.convert_to_tensor(hyperparameter.shape[1], 'int32'))([])",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.concat([x[0], tf.expand_dims(x[1], axis=0)], axis=0))([batchsize, shape])",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "concat_686": {
                "values": {
                    "value": "[batchsize, tf.ones(1, dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_695": {
                "values": {
                    "value": "[batchsize, 3 * tf.ones(1, dtype='int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_702": {
                "shape": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ones_713": {
                "shape": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ones_725": {
                "shape": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_753": {
                "value": {
                    "value": "[1.0, 0.0, 0.0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cos_754": {
                "x": {
                    "value": "rotation[..., 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "sin_756": {
                "x": {
                    "value": "rotation[..., 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cos_757": {
                "x": {
                    "value": "rotation[..., 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cos_760": {
                "x": {
                    "value": "rotation[..., 1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "sin_761": {
                "x": {
                    "value": "rotation[..., 1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "convert_to_tensor_762": {
                "value": {
                    "value": "[0.0, 1.0, 0.0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cos_764": {
                "x": {
                    "value": "rotation[..., 1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cos_767": {
                "x": {
                    "value": "rotation[..., 2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "sin_769": {
                "x": {
                    "value": "rotation[..., 2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cos_770": {
                "x": {
                    "value": "rotation[..., 2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "convert_to_tensor_771": {
                "value": {
                    "value": "[0.0, 0.0, 1.0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_777": {
                "input": {
                    "value": "tf.cos(rotation[..., 0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_778": {
                "input": {
                    "value": "tf.sin(rotation[..., 0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_779": {
                "input": {
                    "value": "-tf.sin(rotation[..., 0])",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_780": {
                "input": {
                    "value": "tf.cos(rotation[..., 0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "ones_802": {
                "shape": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[math.ceil(patch_shape[i] * factor[i]) for i in range(len(patch_shape))]",
                            "ListComp"
                        ],
                        [
                            "shape + [n_channels]",
                            "BinOp"
                        ],
                        [
                            "tf.shape(tf.expand_dims(rotation[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "tf.shape(tf.expand_dims(shearing[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "[connectivity * 2 + 1] * n_dims",
                            "BinOp"
                        ],
                        [
                            "reformat_to_list(shape, length=n_dims)",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.convert_to_tensor(hyperparameter.shape[1], 'int32'))([])",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.concat([x[0], tf.expand_dims(x[1], axis=0)], axis=0))([batchsize, shape])",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "expand_dims_802": {
                "input": {
                    "value": "shearing[..., 0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_803": {
                "input": {
                    "value": "shearing[..., 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "ones_803": {
                "shape": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[math.ceil(patch_shape[i] * factor[i]) for i in range(len(patch_shape))]",
                            "ListComp"
                        ],
                        [
                            "shape + [n_channels]",
                            "BinOp"
                        ],
                        [
                            "tf.shape(tf.expand_dims(rotation[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "tf.shape(tf.expand_dims(shearing[..., 0], -1))",
                            "Call"
                        ],
                        [
                            "[connectivity * 2 + 1] * n_dims",
                            "BinOp"
                        ],
                        [
                            "reformat_to_list(shape, length=n_dims)",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.convert_to_tensor(hyperparameter.shape[1], 'int32'))([])",
                            "Call"
                        ],
                        [
                            "KL.Lambda(lambda x: tf.concat([x[0], tf.expand_dims(x[1], axis=0)], axis=0))([batchsize, shape])",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_1009": {
                "value": {
                    "value": "hyperparameter.shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "uniform_697": {
                "shape": {
                    "value": "tf.shape(rotation)",
                    "type": "Call",
                    "possible_values": []
                },
                "maxval": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "sin_755": {
                "x": {
                    "value": "rotation[..., 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "sin_763": {
                "x": {
                    "value": "rotation[..., 1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "sin_768": {
                "x": {
                    "value": "rotation[..., 2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cos_777": {
                "x": {
                    "value": "rotation[..., 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "sin_778": {
                "x": {
                    "value": "rotation[..., 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cos_780": {
                "x": {
                    "value": "rotation[..., 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "concat_1011": {
                "values": {
                    "value": "[x[0], tf.expand_dims(x[1], axis=0)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "uniform_1013": {
                "shape": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "nib.load(path_volume)",
                            "Call"
                        ],
                        [
                            "np.expand_dims(x, axis=ax)",
                            "Call"
                        ],
                        [
                            "float(x)",
                            "Call"
                        ],
                        [
                            "False",
                            "Constant"
                        ],
                        [
                            "True",
                            "Constant"
                        ]
                    ]
                },
                "minval": {
                    "value": "hyperparameter[0, :]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "load_array_if_path(hyperparameter, load_as_numpy=True)",
                            "Call"
                        ],
                        [
                            "np.array([[centre - default_range] * size, [centre + default_range] * size])",
                            "Call"
                        ],
                        [
                            "np.array([[centre - hyperparameter] * size, [centre + hyperparameter] * size])",
                            "Call"
                        ],
                        [
                            "hyperparameter[modality_idx:modality_idx + 2, :]",
                            "Subscript"
                        ],
                        [
                            "np.transpose(np.tile(np.array(hyperparameter), (size, 1)))",
                            "Call"
                        ]
                    ]
                },
                "maxval": {
                    "value": "hyperparameter[1, :]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "load_array_if_path(hyperparameter, load_as_numpy=True)",
                            "Call"
                        ],
                        [
                            "np.array([[centre - default_range] * size, [centre + default_range] * size])",
                            "Call"
                        ],
                        [
                            "np.array([[centre - hyperparameter] * size, [centre + hyperparameter] * size])",
                            "Call"
                        ],
                        [
                            "hyperparameter[modality_idx:modality_idx + 2, :]",
                            "Subscript"
                        ],
                        [
                            "np.transpose(np.tile(np.array(hyperparameter), (size, 1)))",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_686": {
                "shape": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_697": {
                "input": {
                    "value": "rotation",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.zeros(1)",
                            "Call"
                        ],
                        [
                            "np.asarray(rotation) * (math.pi / 180)",
                            "BinOp"
                        ],
                        [
                            "np.zeros(n_dims)",
                            "Call"
                        ],
                        [
                            "np.asarray(rotation) * (math.pi / 180)",
                            "BinOp"
                        ],
                        [
                            "draw_value_from_distribution(rotation_bounds, size=1, default_range=15.0, return_as_tensor=True, batchsize=batchsize)",
                            "Call"
                        ],
                        [
                            "tf.zeros(tf.concat([batchsize, tf.ones(1, dtype='int32')], axis=0))",
                            "Call"
                        ],
                        [
                            "draw_value_from_distribution(rotation_bounds, size=n_dims, default_range=15.0, return_as_tensor=True, batchsize=batchsize)",
                            "Call"
                        ],
                        [
                            "tf.zeros(tf.concat([batchsize, 3 * tf.ones(1, dtype='int32')], axis=0))",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.random.uniform(tf.shape(rotation), maxval=4, dtype='int32') * 90, 'float32') + rotation",
                            "BinOp"
                        ],
                        [
                            "rotation * np.pi / 180",
                            "BinOp"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "ones_737": {
                "shape": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "sin_779": {
                "x": {
                    "value": "rotation[..., 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "normal_1017": {
                "shape": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "nib.load(path_volume)",
                            "Call"
                        ],
                        [
                            "np.expand_dims(x, axis=ax)",
                            "Call"
                        ],
                        [
                            "float(x)",
                            "Call"
                        ],
                        [
                            "False",
                            "Constant"
                        ],
                        [
                            "True",
                            "Constant"
                        ]
                    ]
                },
                "mean": {
                    "value": "hyperparameter[0, :]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "load_array_if_path(hyperparameter, load_as_numpy=True)",
                            "Call"
                        ],
                        [
                            "np.array([[centre - default_range] * size, [centre + default_range] * size])",
                            "Call"
                        ],
                        [
                            "np.array([[centre - hyperparameter] * size, [centre + hyperparameter] * size])",
                            "Call"
                        ],
                        [
                            "hyperparameter[modality_idx:modality_idx + 2, :]",
                            "Subscript"
                        ],
                        [
                            "np.transpose(np.tile(np.array(hyperparameter), (size, 1)))",
                            "Call"
                        ]
                    ]
                },
                "stddev": {
                    "value": "hyperparameter[1, :]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "load_array_if_path(hyperparameter, load_as_numpy=True)",
                            "Call"
                        ],
                        [
                            "np.array([[centre - default_range] * size, [centre + default_range] * size])",
                            "Call"
                        ],
                        [
                            "np.array([[centre - hyperparameter] * size, [centre + hyperparameter] * size])",
                            "Call"
                        ],
                        [
                            "hyperparameter[modality_idx:modality_idx + 2, :]",
                            "Subscript"
                        ],
                        [
                            "np.transpose(np.tile(np.array(hyperparameter), (size, 1)))",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_695": {
                "shape": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_737": {
                "input": {
                    "value": "T",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.matmul(T_scaling, tf.matmul(T_shearing, T_rot))",
                            "Call"
                        ],
                        [
                            "tf.concat([T, tf.expand_dims(translation, axis=-1)], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([T, tf.zeros(tf.concat([tf.shape(T)[:2], tf.ones(1, dtype='int32')], 0))], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([T, T_last_row], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_1011": {
                "input": {
                    "value": "x[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "ext/neuron/layers.py": {
        "tensorflow": {
            "reduce_sum_1160": {
                "variable": {
                    "value": "this_sum",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.expand_dims(x, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_1161": {
                "variable": {
                    "value": "this_bs",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "K.shape(x)[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "map_fn_264": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "self._single_int",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "[loc_shift] + inputs[1:]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_1081": {
                "variable": {
                    "value": "p",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(K.reshape(this_bs_int, (1,)), K.shape(self.mean))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_1127": {
                "variable": {
                    "value": "this_bs",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "this_bs_int",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "K.shape(x)[0]",
                            "Subscript"
                        ],
                        [
                            "K.shape(x)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_1148": {
                "variable": {
                    "value": "p",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(K.reshape(this_bs_int, (1,)), K.shape(self.cov))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_161": {
                "variable": {
                    "value": "trf_split",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "trf",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs[1:]",
                            "Subscript"
                        ],
                        [
                            "[trf[i] for i in ind_nonlinear_linear]",
                            "ListComp"
                        ],
                        [
                            "trf[0]",
                            "Subscript"
                        ],
                        [
                            "tf.map_fn(lambda x: self._single_aff_to_shift(x, vol.shape[1:-1]), trf, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(lambda x: self._non_linear_and_aff_to_shift(x, vol.shape[1:-1]), trf, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.concat(trf_lst, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(trf, [self.ndims, self.ndims + 1])",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "trf.shape[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_163": {
                "variable": {
                    "value": "trf",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "trf_lst",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[trf_split[1], trf_split[0], *trf_split[2:]]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_173": {
                "variable": {
                    "value": "trf",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "trf",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs[1:]",
                            "Subscript"
                        ],
                        [
                            "[trf[i] for i in ind_nonlinear_linear]",
                            "ListComp"
                        ],
                        [
                            "trf[0]",
                            "Subscript"
                        ],
                        [
                            "tf.map_fn(lambda x: self._single_aff_to_shift(x, vol.shape[1:-1]), trf, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(lambda x: self._non_linear_and_aff_to_shift(x, vol.shape[1:-1]), trf, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.concat(trf_lst, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(trf, [self.ndims, self.ndims + 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[self.ndims, self.ndims + 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_178": {
                "variable": {
                    "value": "trf[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "tensor": {
                    "value": "trf[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.ndims, self.ndims + 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "split_256": {
                "variable": {
                    "value": "loc_shift_split",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "loc_shift",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "K.reshape(loc_shift, [-1, *self.inshape[1:]])",
                            "Call"
                        ],
                        [
                            "tf.concat(loc_shift_lst, -1)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "loc_shift.shape[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_258": {
                "variable": {
                    "value": "loc_shift",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "loc_shift_lst",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[loc_shift_split[1], loc_shift_split[0], *loc_shift_split[2:]]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "map_fn_394": {
                "fn": {
                    "value": "self._single_resize",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "vol",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "K.reshape(vol, [-1, *self.inshape[0][1:]])",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "K.reshape(vol, [-1, *self.inshape[1:]])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "vol.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_513": {
                "variable": {
                    "value": "pool_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[shape[0], *self.orig_input_shape]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_596": {
                "variable": {
                    "value": "self.kernel",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.kernel",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "self.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_674": {
                "tensor": {
                    "value": "z",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.get_output()",
                            "Call"
                        ],
                        [
                            "input_shape[4]",
                            "Subscript"
                        ],
                        [
                            "conv_utils.conv_output_length(z, self.kernel_size[2], self.padding, self.strides[2])",
                            "Call"
                        ],
                        [
                            "input_shape[3]",
                            "Subscript"
                        ],
                        [
                            "K.ones(p)",
                            "Call"
                        ],
                        [
                            "K.ones(p)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "self.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_fn_154": {
                "variable": {
                    "value": "trf",
                    "type": "Variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda x: self._single_aff_to_shift(x, vol.shape[1:-1])",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "trf",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs[1:]",
                            "Subscript"
                        ],
                        [
                            "[trf[i] for i in ind_nonlinear_linear]",
                            "ListComp"
                        ],
                        [
                            "trf[0]",
                            "Subscript"
                        ],
                        [
                            "tf.map_fn(lambda x: self._single_aff_to_shift(x, vol.shape[1:-1]), trf, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(lambda x: self._non_linear_and_aff_to_shift(x, vol.shape[1:-1]), trf, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.concat(trf_lst, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(trf, [self.ndims, self.ndims + 1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_fn_157": {
                "variable": {
                    "value": "trf",
                    "type": "Variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda x: self._non_linear_and_aff_to_shift(x, vol.shape[1:-1])",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "trf",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs[1:]",
                            "Subscript"
                        ],
                        [
                            "[trf[i] for i in ind_nonlinear_linear]",
                            "ListComp"
                        ],
                        [
                            "trf[0]",
                            "Subscript"
                        ],
                        [
                            "tf.map_fn(lambda x: self._single_aff_to_shift(x, vol.shape[1:-1]), trf, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(lambda x: self._non_linear_and_aff_to_shift(x, vol.shape[1:-1]), trf, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.concat(trf_lst, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(trf, [self.ndims, self.ndims + 1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_fn_167": {
                "fn": {
                    "value": "self._single_transform",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "[vol, trf[0, :]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_fn_169": {
                "fn": {
                    "value": "self._single_transform",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "[vol, trf]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "ext/neuron/metrics.py": {
        "tensorflow": {
            "verify_tensor_all_finite_93": {
                "t": {
                    "value": "mloss",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "K.mean(K.sum(K.cast(loss, 'float32'), -1))",
                            "Call"
                        ]
                    ]
                },
                "msg": {
                    "value": "Loss not finite",
                    "type": "str",
                    "possible_values": []
                }
            },
            "verify_tensor_all_finite_272": {
                "t": {
                    "value": "mean_dice_metric",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "K.mean(dice_metric)",
                            "Call"
                        ]
                    ]
                },
                "msg": {
                    "value": "metric not finite",
                    "type": "str",
                    "possible_values": []
                }
            },
            "verify_tensor_all_finite_291": {
                "t": {
                    "value": "mean_dice_loss",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "K.mean(dice_loss)",
                            "Call"
                        ]
                    ]
                },
                "msg": {
                    "value": "Loss not finite",
                    "type": "str",
                    "possible_values": []
                }
            },
            "exp_332": {
                "x": {
                    "value": "y_true",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "utils.batch_gather(y_true, self.crop_indices)",
                            "Call"
                        ],
                        [
                            "K.cast(y_true, 'float16')",
                            "Call"
                        ],
                        [
                            "utils.batch_gather(y_true, self.crop_indices)",
                            "Call"
                        ],
                        [
                            "y_true / K.sum(y_true, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "K.clip(y_true, K.epsilon(), 1)",
                            "Call"
                        ],
                        [
                            "utils.batch_gather(y_true, self.crop_indices)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "ext/neuron/models.py": {
        "tensorflow": {
            "resize_bilinear_769": {
                "images": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "alpha * x",
                            "BinOp"
                        ]
                    ]
                },
                "size": {
                    "value": "enc_size[:-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "ext/neuron/utils.py": {
        "tensorflow": {
            "cast_77": {
                "variable": {
                    "value": "loc",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loc",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.stack(loc, -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(loc, 'float32')",
                            "Call"
                        ],
                        [
                            "tf.reshape(loc_matrix, list(volshape) + [nb_dims])",
                            "Call"
                        ],
                        [
                            "tf.reshape(loc_matrix, list(volshape) + [nb_dims])",
                            "Call"
                        ],
                        [
                            "[tf.cast(mesh[d], 'float32') + loc_shift[..., d] for d in range(nb_dims)]",
                            "ListComp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "stack_179": {
                "variable": {
                    "value": "offset",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "offset",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[grid[f] / zoom_factor[f] - grid[f] for f in range(ndims)]",
                            "ListComp"
                        ],
                        [
                            "tf.stack(offset, ndims)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "ndims",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "len(zoom_factor)",
                            "Call"
                        ],
                        [
                            "len(vol_shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_238": {
                "variable": {
                    "value": "mesh_matrix",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.stack(flat_mesh, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_241": {
                "variable": {
                    "value": "loc_matrix",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "affine_matrix",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(affine_matrix, 'float32')",
                            "Call"
                        ],
                        [
                            "tf.reshape(affine_matrix, [nb_dims, nb_dims + 1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "mesh_matrix",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.transpose(tf.stack(flat_mesh, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.transpose(tf.stack(flat_mesh, axis=1))",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_242": {
                "variable": {
                    "value": "loc_matrix",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "loc_matrix[:nb_dims, :]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reshape_243": {
                "variable": {
                    "value": "loc",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "loc_matrix",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.matmul(affine_matrix, mesh_matrix)",
                            "Call"
                        ],
                        [
                            "tf.transpose(loc_matrix[:nb_dims, :])",
                            "Call"
                        ],
                        [
                            "tf.matmul(transform_list[1], mesh_matrix)",
                            "Call"
                        ],
                        [
                            "tf.transpose(loc_matrix[:nb_dims, :])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "list(volshape) + [nb_dims]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "unstack_302": {
                "variable": {
                    "value": "non_linear_mesh",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "transform_list[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "transpose_305": {
                "variable": {
                    "value": "mesh_matrix",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.stack(flat_mesh, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_308": {
                "variable": {
                    "value": "loc_matrix",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "transform_list[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "mesh_matrix",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.transpose(tf.stack(flat_mesh, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.transpose(tf.stack(flat_mesh, axis=1))",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_309": {
                "variable": {
                    "value": "loc_matrix",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "loc_matrix[:nb_dims, :]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reshape_310": {
                "variable": {
                    "value": "loc",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "loc_matrix",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.matmul(affine_matrix, mesh_matrix)",
                            "Call"
                        ],
                        [
                            "tf.transpose(loc_matrix[:nb_dims, :])",
                            "Call"
                        ],
                        [
                            "tf.matmul(transform_list[1], mesh_matrix)",
                            "Call"
                        ],
                        [
                            "tf.transpose(loc_matrix[:nb_dims, :])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "list(volshape) + [nb_dims]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "stack_691": {
                "variable": {
                    "value": "norms_matrix",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "norms",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[exp_term[f] - np.log(sigma[f] * np.sqrt(2 * np.pi)) for f in range(nb_dims)]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "exp_693": {
                "variable": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "K.sum(norms_matrix, -1)",
                            "Call"
                        ],
                        [
                            "tf.exp(g)",
                            "Call"
                        ],
                        [
                            "g / tf.reduce_sum(g)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "stack_1299": {
                "variable": {
                    "value": "indices",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.range(batch_size), indices]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_62": {
                "variable": {
                    "value": "loc",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "loc",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.stack(loc, -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(loc, 'float32')",
                            "Call"
                        ],
                        [
                            "tf.reshape(loc_matrix, list(volshape) + [nb_dims])",
                            "Call"
                        ],
                        [
                            "tf.reshape(loc_matrix, list(volshape) + [nb_dims])",
                            "Call"
                        ],
                        [
                            "[tf.cast(mesh[d], 'float32') + loc_shift[..., d] for d in range(nb_dims)]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "floor_86": {
                "variable": {
                    "value": "loc0",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loc",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.stack(loc, -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(loc, 'float32')",
                            "Call"
                        ],
                        [
                            "tf.reshape(loc_matrix, list(volshape) + [nb_dims])",
                            "Call"
                        ],
                        [
                            "tf.reshape(loc_matrix, list(volshape) + [nb_dims])",
                            "Call"
                        ],
                        [
                            "[tf.cast(mesh[d], 'float32') + loc_shift[..., d] for d in range(nb_dims)]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "cast_139": {
                "variable": {
                    "value": "roundloc",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.round(loc)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "gather_150": {
                "variable": {
                    "value": "interp_vol",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.reshape(vol, [-1, vol.shape[-1]])",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "idx",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "sub2ind(vol.shape[:-1], roundloc)",
                            "Call"
                        ],
                        [
                            "sub2ind(vol.shape[:-1], subs)",
                            "Call"
                        ],
                        [
                            "list(range(nb_voxels))",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_210": {
                "variable": {
                    "value": "affine_matrix",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "affine_matrix",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(affine_matrix, 'float32')",
                            "Call"
                        ],
                        [
                            "tf.reshape(affine_matrix, [nb_dims, nb_dims + 1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_219": {
                "variable": {
                    "value": "affine_matrix",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "affine_matrix",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(affine_matrix, 'float32')",
                            "Call"
                        ],
                        [
                            "tf.reshape(affine_matrix, [nb_dims, nb_dims + 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[nb_dims, nb_dims + 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_284": {
                "variable": {
                    "value": "transform_list[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "tensor": {
                    "value": "transform_list[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[nb_dims, nb_dims + 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_591": {
                "variable": {
                    "value": "output[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, -1) + (1,) * (ndim - 2)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_592": {
                "variable": {
                    "value": "output[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, 1) + (1,) * (ndim - 2)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "tile_605": {
                "variable": {
                    "value": "output[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "output[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tf.stack(stack_sz)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_620": {
                "tensor": {
                    "value": "v",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "flat_vol_norm[idx, labelvol.flat]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_694": {
                "input_tensor": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "K.sum(norms_matrix, -1)",
                            "Call"
                        ],
                        [
                            "tf.exp(g)",
                            "Call"
                        ],
                        [
                            "g / tf.reduce_sum(g)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "gather_nd_1300": {
                "params": {
                    "value": "reference",
                    "type": "Variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(batch_size), indices], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_122": {
                "variable": {
                    "value": "vol_val",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.reshape(vol, [-1, volshape[-1]])",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "idx",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "sub2ind(vol.shape[:-1], roundloc)",
                            "Call"
                        ],
                        [
                            "sub2ind(vol.shape[:-1], subs)",
                            "Call"
                        ],
                        [
                            "list(range(nb_voxels))",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_177": {
                "x": {
                    "value": "f",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_230": {
                "x": {
                    "value": "f",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ones_237": {
                "shape": {
                    "value": "flat_mesh[0].shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "stack_238": {
                "values": {
                    "value": "flat_mesh",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[flatten(f) for f in mesh]",
                            "ListComp"
                        ],
                        [
                            "[flatten(mesh[i] + non_linear_mesh[i]) for i in range(len(mesh))]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_247": {
                "values": {
                    "value": "mesh",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "volshape_to_meshgrid(volshape, indexing=indexing)",
                            "Call"
                        ],
                        [
                            "[tf.cast(f, 'float32') for f in mesh]",
                            "ListComp"
                        ],
                        [
                            "[mesh[f] - (volshape[f] - 1) / 2 for f in range(len(volshape))]",
                            "ListComp"
                        ],
                        [
                            "volshape_to_meshgrid(volshape, indexing=indexing)",
                            "Call"
                        ],
                        [
                            "[tf.cast(f, 'float32') for f in mesh]",
                            "ListComp"
                        ],
                        [
                            "[mesh[f] - (volshape[f] - 1) / 2 for f in range(len(volshape))]",
                            "ListComp"
                        ],
                        [
                            "volshape_to_meshgrid(volshape, indexing=indexing)",
                            "Call"
                        ],
                        [
                            "volshape_to_meshgrid(windowsize, indexing=indexing)",
                            "Call"
                        ],
                        [
                            "[tf.cast(f, 'float32') for f in mesh]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "nb_dims",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "loc.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "len(volshape)",
                            "Call"
                        ],
                        [
                            "len(volshape)",
                            "Call"
                        ],
                        [
                            "len(volshape)",
                            "Call"
                        ],
                        [
                            "len(sigma)",
                            "Call"
                        ],
                        [
                            "np.ndim(labelvol)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_274": {
                "variable": {
                    "value": "transform_list[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "x": {
                    "value": "transform_list[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_295": {
                "x": {
                    "value": "f",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ones_304": {
                "shape": {
                    "value": "flat_mesh[0].shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "stack_305": {
                "values": {
                    "value": "flat_mesh",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[flatten(f) for f in mesh]",
                            "ListComp"
                        ],
                        [
                            "[flatten(mesh[i] + non_linear_mesh[i]) for i in range(len(mesh))]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_313": {
                "values": {
                    "value": "mesh",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "volshape_to_meshgrid(volshape, indexing=indexing)",
                            "Call"
                        ],
                        [
                            "[tf.cast(f, 'float32') for f in mesh]",
                            "ListComp"
                        ],
                        [
                            "[mesh[f] - (volshape[f] - 1) / 2 for f in range(len(volshape))]",
                            "ListComp"
                        ],
                        [
                            "volshape_to_meshgrid(volshape, indexing=indexing)",
                            "Call"
                        ],
                        [
                            "[tf.cast(f, 'float32') for f in mesh]",
                            "ListComp"
                        ],
                        [
                            "[mesh[f] - (volshape[f] - 1) / 2 for f in range(len(volshape))]",
                            "ListComp"
                        ],
                        [
                            "volshape_to_meshgrid(volshape, indexing=indexing)",
                            "Call"
                        ],
                        [
                            "volshape_to_meshgrid(windowsize, indexing=indexing)",
                            "Call"
                        ],
                        [
                            "[tf.cast(f, 'float32') for f in mesh]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "nb_dims",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "loc.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "len(volshape)",
                            "Call"
                        ],
                        [
                            "len(volshape)",
                            "Call"
                        ],
                        [
                            "len(volshape)",
                            "Call"
                        ],
                        [
                            "len(sigma)",
                            "Call"
                        ],
                        [
                            "np.ndim(labelvol)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_437": {
                "variable": {
                    "value": "out_time_pt",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "K.flatten(out_time_pt)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "size_586": {
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "cast_683": {
                "x": {
                    "value": "f",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "asinh_983": {
                "x": {
                    "value": "x * alpha",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "clip_by_value_90": {
                "t": {
                    "value": "loc[..., d]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "max_loc[d]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "clip_by_value_91": {
                "t": {
                    "value": "loc0[..., d]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "max_loc[d]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "clip_by_value_94": {
                "t": {
                    "value": "loc0lst[d] + 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "max_loc[d]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "round_139": {
                "x": {
                    "value": "loc",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.stack(loc, -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(loc, 'float32')",
                            "Call"
                        ],
                        [
                            "tf.reshape(loc_matrix, list(volshape) + [nb_dims])",
                            "Call"
                        ],
                        [
                            "tf.reshape(loc_matrix, list(volshape) + [nb_dims])",
                            "Call"
                        ],
                        [
                            "[tf.cast(mesh[d], 'float32') + loc_shift[..., d] for d in range(nb_dims)]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "cast_142": {
                "x": {
                    "value": "d - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "clip_by_value_143": {
                "t": {
                    "value": "roundloc[..., d]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "max_loc[d]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reshape_150": {
                "tensor": {
                    "value": "vol",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "K.expand_dims(vol, -1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, vol.shape[-1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_347": {
                "x": {
                    "value": "mesh[d]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_584": {
                "tensor": {
                    "value": "tf.stack(x)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "s0[:i] + (-1,) + s0[i + 1:]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "stack_605": {
                "values": {
                    "value": "stack_sz",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[*sz[:i], 1, *sz[i + 1:]]",
                            "List"
                        ]
                    ]
                }
            },
            "cast_95": {
                "x": {
                    "value": "f",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_122": {
                "tensor": {
                    "value": "vol",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "K.expand_dims(vol, -1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, volshape[-1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_584": {
                "values": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "map_fn_405": {
                "fn": {
                    "value": "transform",
                    "type": "Variable",
                    "possible_values": []
                },
                "elems": {
                    "value": "svec[1::2, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "svec[0::2, :]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "hypothalamus_seg/augmentation_model.py": {
        "tensorflow": {
            "one_hot_144": {
                "indices": {
                    "value": "tf.cast(x[..., 0], dtype='int32')",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "len(label_list)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "split_173": {
                "value": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[n_channels, -1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "len(im_shape)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_144": {
                "x": {
                    "value": "x[..., 0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "split_165": {
                "value": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[n_channels, -1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "len(im_shape)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "hypothalamus_seg/metrics_model.py": {
        "tensorflow": {
            "check_numerics_59": {
                "tensor": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "y_predicted",
                            "Name"
                        ]
                    ]
                },
                "message": {
                    "value": "Loss not finite",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "hypothalamus_seg/training.py": {
        "tensorflow": {}
    },
    "hypothalamus_seg/validate.py": {
        "tensorflow": {
            "summary_iterator_250": {
                "path": {
                    "value": "path",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "path_tensorboard_file",
                            "Name"
                        ]
                    ]
                }
            }
        }
    }
}