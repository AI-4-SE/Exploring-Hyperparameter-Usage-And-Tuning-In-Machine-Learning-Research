{
    "labeler.py": {
        "tensorflow": {
            "placeholder_95": {
                "variable": {
                    "value": "self.word_ids",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "word_ids",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "placeholder_96": {
                "variable": {
                    "value": "self.char_ids",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None, None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "char_ids",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "placeholder_97": {
                "variable": {
                    "value": "self.sentence_lengths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "sentence_lengths",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "placeholder_98": {
                "variable": {
                    "value": "self.word_lengths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "word_lengths",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "placeholder_99": {
                "variable": {
                    "value": "self.label_ids",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "label_ids",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "placeholder_100": {
                "variable": {
                    "value": "self.learningrate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "learningrate",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "placeholder_101": {
                "variable": {
                    "value": "self.is_training",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "is_training",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_117": {
                "variable": {
                    "value": "self.word_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "word_embeddings",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[len(self.word2id), self.config['word_embedding_size']]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer() if self.config['emb_initial_zero'] == True else self.initializer",
                    "type": "IfExp",
                    "possible_values": []
                },
                "trainable": {
                    "value": "True if self.config['train_embeddings'] == True else False",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "embedding_lookup_121": {
                "variable": {
                    "value": "input_tensor",
                    "type": "Name",
                    "possible_values": []
                },
                "params": {
                    "value": "self.word_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ids": {
                    "value": "self.word_ids",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_186": {
                "variable": {
                    "value": "input_tensor",
                    "type": "Name",
                    "possible_values": []
                },
                "x": {
                    "value": "input_tensor",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.nn.embedding_lookup(self.word_embeddings, self.word_ids)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(input_tensor, dropout_input, name='dropout_word')",
                            "Call"
                        ],
                        [
                            "tf.concat([input_tensor, char_output_tensor], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.multiply(input_tensor, attention_output) + tf.multiply(char_output_tensor, 1.0 - attention_output)",
                            "BinOp"
                        ],
                        [
                            "input_tensor",
                            "Name"
                        ]
                    ]
                },
                "rate": {
                    "value": "dropout_input",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self.config['dropout_input'] * tf.cast(self.is_training, tf.float32) + (1.0 - tf.cast(self.is_training, tf.float32))",
                            "BinOp"
                        ]
                    ]
                },
                "name": {
                    "value": "dropout_word",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "LSTMCell_188": {
                "variable": {
                    "value": "word_lstm_cell_fw",
                    "type": "Name",
                    "possible_values": []
                },
                "units": {
                    "value": "self.config['word_recurrent_size']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "use_peepholes": {
                    "value": "self.config['lstm_use_peepholes']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "state_is_tuple": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "initializer": {
                    "value": "self.initializer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "LSTMCell_193": {
                "variable": {
                    "value": "word_lstm_cell_bw",
                    "type": "Name",
                    "possible_values": []
                },
                "units": {
                    "value": "self.config['word_recurrent_size']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "use_peepholes": {
                    "value": "self.config['lstm_use_peepholes']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "state_is_tuple": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "initializer": {
                    "value": "self.initializer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dropout_203": {
                "variable": {
                    "value": "lstm_outputs_fw",
                    "type": "Name",
                    "possible_values": []
                },
                "x": {
                    "value": "lstm_outputs_fw",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.dropout(lstm_outputs_fw, dropout_word_lstm)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "dropout_word_lstm",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self.config['dropout_word_lstm'] * tf.cast(self.is_training, tf.float32) + (1.0 - tf.cast(self.is_training, tf.float32))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "dropout_204": {
                "variable": {
                    "value": "lstm_outputs_bw",
                    "type": "Name",
                    "possible_values": []
                },
                "x": {
                    "value": "lstm_outputs_bw",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.dropout(lstm_outputs_bw, dropout_word_lstm)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "dropout_word_lstm",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self.config['dropout_word_lstm'] * tf.cast(self.is_training, tf.float32) + (1.0 - tf.cast(self.is_training, tf.float32))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "concat_211": {
                "variable": {
                    "value": "processed_tensor",
                    "type": "Name",
                    "possible_values": []
                },
                "values": {
                    "value": "[lstm_outputs_fw, lstm_outputs_bw]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_218": {
                "variable": {
                    "value": "self.scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "inputs": {
                    "value": "processed_tensor",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.concat([lstm_outputs_fw, lstm_outputs_bw], 2)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(processed_tensor, self.config['hidden_layer_size'], activation=tf.tanh, kernel_initializer=self.initializer)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "len(self.label2id)",
                    "type": "Call",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "self.initializer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "output_ff",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "ConfigProto_396": {
                "variable": {
                    "value": "session_config",
                    "type": "Name",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_399": {
                "variable": {
                    "value": "self.session",
                    "type": "Attribute",
                    "possible_values": []
                },
                "config": {
                    "value": "session_config",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ]
                    ]
                }
            },
            "Saver_401": {
                "variable": {
                    "value": "self.saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "random_normal_initializer_109": {
                "variable": {
                    "value": "self.initializer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "mean": {
                    "value": "0.0",
                    "type": "Constant",
                    "possible_values": []
                },
                "stddev": {
                    "value": "0.1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "bidirectional_dynamic_rnn_200": {
                "variable": {
                    "value": "((lstm_outputs_fw, lstm_outputs_bw), _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell_fw": {
                    "value": "word_lstm_cell_fw",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.rnn_cell.LSTMCell(self.config['word_recurrent_size'], use_peepholes=self.config['lstm_use_peepholes'], state_is_tuple=True, initializer=self.initializer, reuse=False)",
                            "Call"
                        ]
                    ]
                },
                "cell_bw": {
                    "value": "word_lstm_cell_bw",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.rnn_cell.LSTMCell(self.config['word_recurrent_size'], use_peepholes=self.config['lstm_use_peepholes'], state_is_tuple=True, initializer=self.initializer, reuse=False)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "input_tensor",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.nn.embedding_lookup(self.word_embeddings, self.word_ids)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(input_tensor, dropout_input, name='dropout_word')",
                            "Call"
                        ],
                        [
                            "tf.concat([input_tensor, char_output_tensor], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.multiply(input_tensor, attention_output) + tf.multiply(char_output_tensor, 1.0 - attention_output)",
                            "BinOp"
                        ],
                        [
                            "input_tensor",
                            "Name"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "self.sentence_lengths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "time_major": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_215": {
                "variable": {
                    "value": "processed_tensor",
                    "type": "Name",
                    "possible_values": []
                },
                "inputs": {
                    "value": "processed_tensor",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.concat([lstm_outputs_fw, lstm_outputs_bw], 2)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(processed_tensor, self.config['hidden_layer_size'], activation=tf.tanh, kernel_initializer=self.initializer)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "self.config['hidden_layer_size']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.tanh",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "self.initializer",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_222": {
                "variable": {
                    "value": "self.crf_transition_params",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "output_crf_transitions",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[crf_num_tags, crf_num_tags]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "self.initializer",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_226": {
                "variable": {
                    "value": "self.probabilities",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.scores",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_227": {
                "variable": {
                    "value": "self.predictions",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.probabilities",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_228": {
                "variable": {
                    "value": "loss_",
                    "type": "Name",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "labels": {
                    "value": "self.label_ids",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sequence_mask_229": {
                "variable": {
                    "value": "mask",
                    "type": "Name",
                    "possible_values": []
                },
                "lengths": {
                    "value": "self.sentence_lengths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "tf.shape(self.word_ids)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "boolean_mask_230": {
                "variable": {
                    "value": "loss_",
                    "type": "Name",
                    "possible_values": []
                },
                "tensor": {
                    "value": "loss_",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=self.scores, labels=self.label_ids)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(loss_, mask)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.sequence_mask(self.sentence_lengths, maxlen=tf.shape(self.word_ids)[1])",
                            "Call"
                        ]
                    ]
                }
            },
            "where_239": {
                "variable": {
                    "value": "target_ids",
                    "type": "Name",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.greater_equal(target_ids, lmcost_max_vocab_size - 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "lmcost_max_vocab_size - 1 + tf.zeros_like(target_ids)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "target_ids",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.where(tf.greater_equal(target_ids, lmcost_max_vocab_size - 1), x=lmcost_max_vocab_size - 1 + tf.zeros_like(target_ids), y=target_ids)",
                            "Call"
                        ]
                    ]
                }
            },
            "dense_258": {
                "variable": {
                    "value": "lmcost_hidden_layer",
                    "type": "Name",
                    "possible_values": []
                },
                "inputs": {
                    "value": "input_tensor",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.nn.embedding_lookup(self.word_embeddings, self.word_ids)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(input_tensor, dropout_input, name='dropout_word')",
                            "Call"
                        ],
                        [
                            "tf.concat([input_tensor, char_output_tensor], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.multiply(input_tensor, attention_output) + tf.multiply(char_output_tensor, 1.0 - attention_output)",
                            "BinOp"
                        ],
                        [
                            "input_tensor",
                            "Name"
                        ]
                    ]
                },
                "units": {
                    "value": "self.config['lmcost_hidden_layer_size']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.tanh",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "self.initializer",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dense_259": {
                "variable": {
                    "value": "lmcost_output",
                    "type": "Name",
                    "possible_values": []
                },
                "inputs": {
                    "value": "lmcost_hidden_layer",
                    "type": "Name",
                    "possible_values": []
                },
                "units": {
                    "value": "lmcost_max_vocab_size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "min(len(self.word2id), self.config['lmcost_max_vocab_size'])",
                            "Call"
                        ]
                    ]
                },
                "activation": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "self.initializer",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_260": {
                "variable": {
                    "value": "lmcost_loss",
                    "type": "Name",
                    "possible_values": []
                },
                "logits": {
                    "value": "lmcost_output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.layers.dense(lmcost_hidden_layer, lmcost_max_vocab_size, activation=None, kernel_initializer=self.initializer)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "target_ids",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.where(tf.greater_equal(target_ids, lmcost_max_vocab_size - 1), x=lmcost_max_vocab_size - 1 + tf.zeros_like(target_ids), y=target_ids)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_261": {
                "variable": {
                    "value": "lmcost_loss",
                    "type": "Name",
                    "possible_values": []
                },
                "condition": {
                    "value": "lmcost_mask",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.sequence_mask(sentence_lengths, maxlen=tf.shape(target_ids)[1])[:, 1:-1]",
                            "Subscript"
                        ]
                    ]
                },
                "x": {
                    "value": "lmcost_loss",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=lmcost_output, labels=target_ids)",
                            "Call"
                        ],
                        [
                            "tf.where(lmcost_mask, lmcost_loss, tf.zeros_like(lmcost_loss))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(lmcost_loss)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "AdadeltaOptimizer_268": {
                "variable": {
                    "value": "optimizer",
                    "type": "Name",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learningrate",
                    "type": "Name",
                    "possible_values": []
                }
            },
            "clip_by_global_norm_278": {
                "variable": {
                    "value": "(grads, gnorm)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "t_list": {
                    "value": "grads",
                    "type": "Name",
                    "possible_values": []
                },
                "clip_norm": {
                    "value": "clip",
                    "type": "Name",
                    "possible_values": []
                }
            },
            "set_random_seed_395": {
                "seed": {
                    "value": "self.config['random_seed']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "trainable_variables_406": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_434": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_126": {
                "variable": {
                    "value": "self.char_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "char_embeddings",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[len(self.char2id), self.config['char_embedding_size']]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "self.initializer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "embedding_lookup_130": {
                "variable": {
                    "value": "char_input_tensor",
                    "type": "Name",
                    "possible_values": []
                },
                "params": {
                    "value": "self.char_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ids": {
                    "value": "self.char_ids",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_132": {
                "variable": {
                    "value": "s",
                    "type": "Name",
                    "possible_values": []
                },
                "input": {
                    "value": "char_input_tensor",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(self.char_embeddings, self.char_ids)",
                            "Call"
                        ],
                        [
                            "tf.reshape(char_input_tensor, shape=[s[0] * s[1], s[2], self.config['char_embedding_size']])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_133": {
                "variable": {
                    "value": "char_input_tensor",
                    "type": "Name",
                    "possible_values": []
                },
                "tensor": {
                    "value": "char_input_tensor",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(self.char_embeddings, self.char_ids)",
                            "Call"
                        ],
                        [
                            "tf.reshape(char_input_tensor, shape=[s[0] * s[1], s[2], self.config['char_embedding_size']])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[s[0] * s[1], s[2], self.config['char_embedding_size']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_134": {
                "variable": {
                    "value": "_word_lengths",
                    "type": "Name",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.word_lengths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[s[0] * s[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "LSTMCell_136": {
                "variable": {
                    "value": "char_lstm_cell_fw",
                    "type": "Name",
                    "possible_values": []
                },
                "units": {
                    "value": "self.config['char_recurrent_size']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "use_peepholes": {
                    "value": "self.config['lstm_use_peepholes']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "state_is_tuple": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "initializer": {
                    "value": "self.initializer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "LSTMCell_141": {
                "variable": {
                    "value": "char_lstm_cell_bw",
                    "type": "Name",
                    "possible_values": []
                },
                "units": {
                    "value": "self.config['char_recurrent_size']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "use_peepholes": {
                    "value": "self.config['lstm_use_peepholes']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "state_is_tuple": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "initializer": {
                    "value": "self.initializer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "bidirectional_dynamic_rnn_147": {
                "variable": {
                    "value": "char_lstm_outputs",
                    "type": "Name",
                    "possible_values": []
                },
                "cell_fw": {
                    "value": "char_lstm_cell_fw",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.rnn_cell.LSTMCell(self.config['char_recurrent_size'], use_peepholes=self.config['lstm_use_peepholes'], state_is_tuple=True, initializer=self.initializer, reuse=False)",
                            "Call"
                        ]
                    ]
                },
                "cell_bw": {
                    "value": "char_lstm_cell_bw",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.rnn_cell.LSTMCell(self.config['char_recurrent_size'], use_peepholes=self.config['lstm_use_peepholes'], state_is_tuple=True, initializer=self.initializer, reuse=False)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "char_input_tensor",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(self.char_embeddings, self.char_ids)",
                            "Call"
                        ],
                        [
                            "tf.reshape(char_input_tensor, shape=[s[0] * s[1], s[2], self.config['char_embedding_size']])",
                            "Call"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "_word_lengths",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reshape(self.word_lengths, shape=[s[0] * s[1]])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "time_major": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_149": {
                "variable": {
                    "value": "char_output_tensor",
                    "type": "Name",
                    "possible_values": []
                },
                "values": {
                    "value": "[char_output_fw, char_output_bw]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_150": {
                "variable": {
                    "value": "char_output_tensor",
                    "type": "Name",
                    "possible_values": []
                },
                "tensor": {
                    "value": "char_output_tensor",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.concat([char_output_fw, char_output_bw], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(char_output_tensor, shape=[s[0], s[1], 2 * self.config['char_recurrent_size']])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(char_output_tensor, char_hidden_layer_size, activation=tf.tanh, kernel_initializer=self.initializer)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[s[0], s[1], 2 * self.config['char_recurrent_size']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "control_dependencies_199": {
                "control_inputs": {
                    "value": "[tf.assert_equal(tf.shape(self.word_ids)[1], tf.reduce_max(self.sentence_lengths), message=\"Sentence dimensions don't match\")]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_237": {
                "name_or_scope": {
                    "value": "name",
                    "type": "Name",
                    "possible_values": []
                }
            },
            "variable_scope_257": {
                "name_or_scope": {
                    "value": "name",
                    "type": "Name",
                    "possible_values": []
                }
            },
            "reduce_sum_262": {
                "input_tensor": {
                    "value": "lmcost_loss",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=lmcost_output, labels=target_ids)",
                            "Call"
                        ],
                        [
                            "tf.where(lmcost_mask, lmcost_loss, tf.zeros_like(lmcost_loss))",
                            "Call"
                        ]
                    ]
                }
            },
            "AdamOptimizer_270": {
                "variable": {
                    "value": "optimizer",
                    "type": "Name",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learningrate",
                    "type": "Name",
                    "possible_values": []
                }
            },
            "global_variables_initializer_400": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_468": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_125": {
                "name_or_scope": {
                    "value": "chars",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "control_dependencies_125": {
                "control_inputs": {
                    "value": "[tf.assert_equal(tf.shape(self.char_ids)[2], tf.reduce_max(self.word_lengths), message=\"Char dimensions don't match\")]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dense_160": {
                "variable": {
                    "value": "char_output_tensor",
                    "type": "Name",
                    "possible_values": []
                },
                "inputs": {
                    "value": "char_output_tensor",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.concat([char_output_fw, char_output_bw], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(char_output_tensor, shape=[s[0], s[1], 2 * self.config['char_recurrent_size']])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(char_output_tensor, char_hidden_layer_size, activation=tf.tanh, kernel_initializer=self.initializer)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "char_hidden_layer_size",
                    "type": "Name",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.tanh",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "self.initializer",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_164": {
                "variable": {
                    "value": "input_tensor",
                    "type": "Name",
                    "possible_values": []
                },
                "values": {
                    "value": "[input_tensor, char_output_tensor]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_185": {
                "x": {
                    "value": "self.is_training",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_202": {
                "x": {
                    "value": "self.is_training",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_224": {
                "input_tensor": {
                    "value": "-log_likelihood",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_231": {
                "input_tensor": {
                    "value": "loss_",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=self.scores, labels=self.label_ids)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(loss_, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "greater_equal_239": {
                "x": {
                    "value": "target_ids",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.where(tf.greater_equal(target_ids, lmcost_max_vocab_size - 1), x=lmcost_max_vocab_size - 1 + tf.zeros_like(target_ids), y=target_ids)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "lmcost_max_vocab_size - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_248": {
                "variable": {
                    "value": "joint_input_tensor",
                    "type": "Name",
                    "possible_values": []
                },
                "values": {
                    "value": "[input_tensor_fw[:, :-2, :], input_tensor_bw[:, 2:, :]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_like_261": {
                "input": {
                    "value": "lmcost_loss",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=lmcost_output, labels=target_ids)",
                            "Call"
                        ],
                        [
                            "tf.where(lmcost_mask, lmcost_loss, tf.zeros_like(lmcost_loss))",
                            "Call"
                        ]
                    ]
                }
            },
            "GradientDescentOptimizer_272": {
                "variable": {
                    "value": "optimizer",
                    "type": "Name",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learningrate",
                    "type": "Name",
                    "possible_values": []
                }
            },
            "zeros_initializer_119": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "stop_gradient_168": {
                "variable": {
                    "value": "static_input_tensor",
                    "type": "Name",
                    "possible_values": []
                },
                "input": {
                    "value": "input_tensor",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.nn.embedding_lookup(self.word_embeddings, self.word_ids)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(input_tensor, dropout_input, name='dropout_word')",
                            "Call"
                        ],
                        [
                            "tf.concat([input_tensor, char_output_tensor], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.multiply(input_tensor, attention_output) + tf.multiply(char_output_tensor, 1.0 - attention_output)",
                            "BinOp"
                        ],
                        [
                            "input_tensor",
                            "Name"
                        ]
                    ]
                }
            },
            "equal_169": {
                "variable": {
                    "value": "is_unk",
                    "type": "Name",
                    "possible_values": []
                },
                "x": {
                    "value": "self.word_ids",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.word2id[self.UNK]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "l2_normalize_170": {
                "variable": {
                    "value": "char_output_tensor_normalised",
                    "type": "Name",
                    "possible_values": []
                },
                "x": {
                    "value": "char_output_tensor",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.concat([char_output_fw, char_output_bw], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(char_output_tensor, shape=[s[0], s[1], 2 * self.config['char_recurrent_size']])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(char_output_tensor, char_hidden_layer_size, activation=tf.tanh, kernel_initializer=self.initializer)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "l2_normalize_171": {
                "variable": {
                    "value": "static_input_tensor_normalised",
                    "type": "Name",
                    "possible_values": []
                },
                "x": {
                    "value": "static_input_tensor",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.stop_gradient(input_tensor)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "logical_not_173": {
                "variable": {
                    "value": "is_padding",
                    "type": "Name",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.sequence_mask(self.sentence_lengths, maxlen=tf.shape(self.word_ids)[1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_174": {
                "variable": {
                    "value": "cosine_cost_unk",
                    "type": "Name",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.logical_or(is_unk, is_padding)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.zeros_like(cosine_cost)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "cosine_cost",
                    "type": "Name",
                    "possible_values": [
                        [
                            "1.0 - tf.reduce_sum(tf.multiply(char_output_tensor_normalised, static_input_tensor_normalised), axis=2)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "concat_176": {
                "variable": {
                    "value": "attention_evidence_tensor",
                    "type": "Name",
                    "possible_values": []
                },
                "values": {
                    "value": "[input_tensor, char_output_tensor]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_177": {
                "variable": {
                    "value": "attention_output",
                    "type": "Name",
                    "possible_values": []
                },
                "inputs": {
                    "value": "attention_evidence_tensor",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.concat([input_tensor, char_output_tensor], axis=2)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "self.config['word_embedding_size']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.tanh",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "self.initializer",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dense_178": {
                "variable": {
                    "value": "attention_output",
                    "type": "Name",
                    "possible_values": []
                },
                "inputs": {
                    "value": "attention_output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.layers.dense(attention_evidence_tensor, self.config['word_embedding_size'], activation=tf.tanh, kernel_initializer=self.initializer)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(attention_output, self.config['word_embedding_size'], activation=tf.sigmoid, kernel_initializer=self.initializer)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "self.config['word_embedding_size']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.sigmoid",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "self.initializer",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assert_equal_199": {
                "x": {
                    "value": "tf.shape(self.word_ids)[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_max(self.sentence_lengths)",
                    "type": "Call",
                    "possible_values": []
                },
                "message": {
                    "value": "\"Sentence dimensions don't match\"",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "sequence_mask_242": {
                "lengths": {
                    "value": "sentence_lengths",
                    "type": "Name",
                    "possible_values": [
                        [
                            "numpy.array([len(sentence) for sentence in batch])",
                            "Call"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "tf.shape(target_ids)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "sequence_mask_243": {
                "lengths": {
                    "value": "sentence_lengths",
                    "type": "Name",
                    "possible_values": [
                        [
                            "numpy.array([len(sentence) for sentence in batch])",
                            "Call"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "tf.shape(target_ids)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "assert_equal_125": {
                "x": {
                    "value": "tf.shape(self.char_ids)[2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_max(self.word_lengths)",
                    "type": "Call",
                    "possible_values": []
                },
                "message": {
                    "value": "\"Char dimensions don't match\"",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_max_199": {
                "input_tensor": {
                    "value": "self.sentence_lengths",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_229": {
                "input": {
                    "value": "self.word_ids",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_239": {
                "input": {
                    "value": "target_ids",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.where(tf.greater_equal(target_ids, lmcost_max_vocab_size - 1), x=lmcost_max_vocab_size - 1 + tf.zeros_like(target_ids), y=target_ids)",
                            "Call"
                        ]
                    ]
                }
            },
            "sequence_mask_249": {
                "lengths": {
                    "value": "sentence_lengths",
                    "type": "Name",
                    "possible_values": [
                        [
                            "numpy.array([len(sentence) for sentence in batch])",
                            "Call"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "tf.shape(target_ids)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_max_125": {
                "input_tensor": {
                    "value": "self.word_lengths",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_172": {
                "input_tensor": {
                    "value": "tf.multiply(char_output_tensor_normalised, static_input_tensor_normalised)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "sequence_mask_173": {
                "lengths": {
                    "value": "self.sentence_lengths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "tf.shape(self.word_ids)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "logical_or_174": {
                "x": {
                    "value": "is_unk",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.equal(self.word_ids, self.word2id[self.UNK])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "is_padding",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.logical_not(tf.sequence_mask(self.sentence_lengths, maxlen=tf.shape(self.word_ids)[1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_175": {
                "input_tensor": {
                    "value": "cosine_cost_unk",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.where(tf.logical_or(is_unk, is_padding), x=tf.zeros_like(cosine_cost), y=cosine_cost)",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_179": {
                "x": {
                    "value": "char_output_tensor",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.concat([char_output_fw, char_output_bw], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(char_output_tensor, shape=[s[0], s[1], 2 * self.config['char_recurrent_size']])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(char_output_tensor, char_hidden_layer_size, activation=tf.tanh, kernel_initializer=self.initializer)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1.0 - attention_output",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_199": {
                "input": {
                    "value": "self.word_ids",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_125": {
                "input": {
                    "value": "self.char_ids",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multiply_172": {
                "x": {
                    "value": "char_output_tensor_normalised",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.l2_normalize(char_output_tensor, 2)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "static_input_tensor_normalised",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.l2_normalize(static_input_tensor, 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_174": {
                "input": {
                    "value": "cosine_cost",
                    "type": "Name",
                    "possible_values": [
                        [
                            "1.0 - tf.reduce_sum(tf.multiply(char_output_tensor_normalised, static_input_tensor_normalised), axis=2)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_242": {
                "input": {
                    "value": "target_ids",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.where(tf.greater_equal(target_ids, lmcost_max_vocab_size - 1), x=lmcost_max_vocab_size - 1 + tf.zeros_like(target_ids), y=target_ids)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_243": {
                "input": {
                    "value": "target_ids",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.where(tf.greater_equal(target_ids, lmcost_max_vocab_size - 1), x=lmcost_max_vocab_size - 1 + tf.zeros_like(target_ids), y=target_ids)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_249": {
                "input": {
                    "value": "target_ids",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.where(tf.greater_equal(target_ids, lmcost_max_vocab_size - 1), x=lmcost_max_vocab_size - 1 + tf.zeros_like(target_ids), y=target_ids)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_173": {
                "input": {
                    "value": "self.word_ids",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    }
}