{
    "cases/credit_scoring/credit_scoring_problem.py": {
        "sklearn": {}
    },
    "cases/credit_scoring/credit_scoring_problem_multiobj.py": {
        "sklearn": {}
    },
    "cases/multi_modal_genre_prediction.py": {
        "sklearn": {}
    },
    "cases/multi_target_levels_forecasting.py": {
        "sklearn": {
            "mean_absolute_error_94": {
                "variable": {
                    "value": "mae_value",
                    "possible_values": []
                },
                "y_true": {
                    "value": "np.ravel(test.target)",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "forecast",
                    "possible_values": [
                        [
                            "np.ravel(predicted_array)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "cases/multi_ts_level_forecasting.py": {
        "sklearn": {
            "mean_absolute_error_86": {
                "y_true": {
                    "value": "target",
                    "possible_values": [
                        [
                            "np.ravel(test_data.target)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "forecast",
                    "possible_values": [
                        [
                            "model.predict(test_data)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_squared_error_87": {
                "y_true": {
                    "value": "target",
                    "possible_values": [
                        [
                            "np.ravel(test_data.target)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "forecast",
                    "possible_values": [
                        [
                            "model.predict(test_data)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_absolute_percentage_error_88": {
                "y_true": {
                    "value": "target",
                    "possible_values": [
                        [
                            "np.ravel(test_data.target)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "forecast",
                    "possible_values": [
                        [
                            "model.predict(test_data)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "cases/river_levels_prediction/river_level_case_composer.py": {
        "sklearn": {
            "mean_squared_error_115": {
                "variable": {
                    "value": "mse_value",
                    "possible_values": []
                },
                "y_true": {
                    "value": "y_data_test",
                    "possible_values": [
                        [
                            "np.array(predict_input.target)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "preds",
                    "possible_values": [
                        [
                            "predicted_values.predict",
                            "Attribute"
                        ],
                        [
                            "fit_predict_for_pipeline(pipeline=obtained_pipeline, train_input=train_input, predict_input=predict_input)",
                            "Call"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_absolute_error_116": {
                "variable": {
                    "value": "mae_value",
                    "possible_values": []
                },
                "y_true": {
                    "value": "y_data_test",
                    "possible_values": [
                        [
                            "np.array(predict_input.target)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "preds",
                    "possible_values": [
                        [
                            "predicted_values.predict",
                            "Attribute"
                        ],
                        [
                            "fit_predict_for_pipeline(pipeline=obtained_pipeline, train_input=train_input, predict_input=predict_input)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_squared_error_132": {
                "variable": {
                    "value": "mse_value",
                    "possible_values": []
                },
                "y_true": {
                    "value": "y_data_test",
                    "possible_values": [
                        [
                            "np.array(predict_input.target)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "preds_tuned",
                    "possible_values": [
                        [
                            "fit_predict_for_pipeline(pipeline=tuned_pipeline, train_input=train_input, predict_input=predict_input)",
                            "Call"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_absolute_error_133": {
                "variable": {
                    "value": "mae_value",
                    "possible_values": []
                },
                "y_true": {
                    "value": "y_data_test",
                    "possible_values": [
                        [
                            "np.array(predict_input.target)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "preds_tuned",
                    "possible_values": [
                        [
                            "fit_predict_for_pipeline(pipeline=tuned_pipeline, train_input=train_input, predict_input=predict_input)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "cases/river_levels_prediction/river_level_case_manual.py": {
        "sklearn": {
            "mean_squared_error_52": {
                "variable": {
                    "value": "mse_value",
                    "possible_values": []
                },
                "y_true": {
                    "value": "y_data_test",
                    "possible_values": [
                        [
                            "np.array(predict_input.target)",
                            "Call"
                        ],
                        [
                            "np.ravel(y_data_test)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "preds",
                    "possible_values": [
                        [
                            "predicted_values.predict",
                            "Attribute"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_absolute_error_53": {
                "variable": {
                    "value": "mae_value",
                    "possible_values": []
                },
                "y_true": {
                    "value": "y_data_test",
                    "possible_values": [
                        [
                            "np.array(predict_input.target)",
                            "Call"
                        ],
                        [
                            "np.ravel(y_data_test)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "preds",
                    "possible_values": [
                        [
                            "predicted_values.predict",
                            "Attribute"
                        ]
                    ]
                }
            },
            "mean_squared_error_70": {
                "variable": {
                    "value": "mse_value",
                    "possible_values": []
                },
                "y_true": {
                    "value": "y_data_test",
                    "possible_values": [
                        [
                            "np.array(predict_input.target)",
                            "Call"
                        ],
                        [
                            "np.ravel(y_data_test)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "preds_tuned",
                    "possible_values": [
                        [
                            "predicted_values_tuned.predict",
                            "Attribute"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_absolute_error_72": {
                "variable": {
                    "value": "mae_value",
                    "possible_values": []
                },
                "y_true": {
                    "value": "y_data_test",
                    "possible_values": [
                        [
                            "np.array(predict_input.target)",
                            "Call"
                        ],
                        [
                            "np.ravel(y_data_test)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "preds_tuned",
                    "possible_values": [
                        [
                            "predicted_values_tuned.predict",
                            "Attribute"
                        ]
                    ]
                }
            }
        }
    },
    "cases/spam_detection.py": {
        "sklearn": {}
    },
    "cases/time_series_gapfilling_case.py": {
        "sklearn": {
            "mean_absolute_error_35": {
                "variable": {
                    "value": "mae_metric",
                    "possible_values": []
                },
                "y_true": {
                    "value": "actual",
                    "possible_values": [
                        [
                            "np.array(dataframe['temperature'])[gap_ids]",
                            "Subscript"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predicted",
                    "possible_values": []
                }
            },
            "median_absolute_error_41": {
                "variable": {
                    "value": "median_ae_metric",
                    "possible_values": []
                },
                "y_true": {
                    "value": "actual",
                    "possible_values": [
                        [
                            "np.array(dataframe['temperature'])[gap_ids]",
                            "Subscript"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predicted",
                    "possible_values": []
                }
            },
            "mean_squared_error_38": {
                "y_true": {
                    "value": "actual",
                    "possible_values": [
                        [
                            "np.array(dataframe['temperature'])[gap_ids]",
                            "Subscript"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predicted",
                    "possible_values": []
                }
            }
        }
    },
    "examples/advanced/automl/h2o_example.py": {
        "sklearn": {
            "mean_squared_error_100": {
                "variable": {
                    "value": "rmse",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_target",
                    "possible_values": [
                        [
                            "np.ravel(np.array(test_data.target))",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "test_pred",
                    "possible_values": [
                        [
                            "pipeline.predict(input_data=test_data)",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_pred.predict))",
                            "Call"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_absolute_error_101": {
                "variable": {
                    "value": "mae",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_target",
                    "possible_values": [
                        [
                            "np.ravel(np.array(test_data.target))",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "test_pred",
                    "possible_values": [
                        [
                            "pipeline.predict(input_data=test_data)",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_pred.predict))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "examples/advanced/automl/pipeline_from_automl.py": {
        "sklearn": {}
    },
    "examples/advanced/automl/tpot_example.py": {
        "sklearn": {
            "mean_squared_error_134": {
                "variable": {
                    "value": "rmse",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_target",
                    "possible_values": [
                        [
                            "np.ravel(np.array(test_data.target))",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "test_pred",
                    "possible_values": [
                        [
                            "pipeline.predict(input_data=test_data)",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_pred.predict))",
                            "Call"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_absolute_error_135": {
                "variable": {
                    "value": "mae",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_target",
                    "possible_values": [
                        [
                            "np.ravel(np.array(test_data.target))",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "test_pred",
                    "possible_values": [
                        [
                            "pipeline.predict(input_data=test_data)",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_pred.predict))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "examples/advanced/automl/tpot_vs_fedot.py": {
        "sklearn": {
            "make_pipeline_23": {
                "variable": {
                    "value": "exported_pipeline",
                    "possible_values": []
                },
                "*steps": {
                    "value": "StackingEstimator(estimator=BernoulliNB())",
                    "possible_values": []
                },
                "memory": {
                    "value": "RandomForestClassifier()",
                    "possible_values": []
                }
            },
            "RandomForestClassifier_25": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "BernoulliNB_24": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            }
        }
    },
    "examples/advanced/decompose/classification_refinement_example.py": {
        "sklearn": {}
    },
    "examples/advanced/decompose/refinement_forecast_example.py": {
        "sklearn": {
            "mean_squared_error_87": {
                "variable": {
                    "value": "mse",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_part.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "predicted_values",
                    "possible_values": [
                        [
                            "in_sample_fit_predict(pipeline, train_input, predict_input, horizon)",
                            "Call"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_absolute_error_88": {
                "variable": {
                    "value": "mae",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_part.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "predicted_values",
                    "possible_values": [
                        [
                            "in_sample_fit_predict(pipeline, train_input, predict_input, horizon)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "examples/advanced/decompose/regression_refinement_example.py": {
        "sklearn": {
            "train_test_split_47": {
                "variable": {
                    "value": "(x_data_train, x_data_test, y_data_train, y_data_test)",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "features",
                    "possible_values": []
                },
                "*arrays_1": {
                    "value": "target",
                    "possible_values": []
                },
                "test_size": {
                    "value": "0.2",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "True",
                    "possible_values": []
                },
                "random_state": {
                    "value": "10",
                    "possible_values": []
                }
            },
            "mean_squared_error_118": {
                "variable": {
                    "value": "mse_value",
                    "possible_values": []
                },
                "y_true": {
                    "value": "y_data_test",
                    "possible_values": [
                        [
                            "np.ravel(y_data_test)",
                            "Call"
                        ],
                        [
                            "predict_input.target",
                            "Attribute"
                        ],
                        [
                            "np.ravel(y_data_test)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "r_preds",
                    "possible_values": [
                        [
                            "predicted_values.predict",
                            "Attribute"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_absolute_error_119": {
                "variable": {
                    "value": "mae_value",
                    "possible_values": []
                },
                "y_true": {
                    "value": "y_data_test",
                    "possible_values": [
                        [
                            "np.ravel(y_data_test)",
                            "Call"
                        ],
                        [
                            "predict_input.target",
                            "Attribute"
                        ],
                        [
                            "np.ravel(y_data_test)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "r_preds",
                    "possible_values": [
                        [
                            "predicted_values.predict",
                            "Attribute"
                        ]
                    ]
                }
            },
            "mean_squared_error_123": {
                "variable": {
                    "value": "mse_value_non",
                    "possible_values": []
                },
                "y_true": {
                    "value": "y_data_test",
                    "possible_values": [
                        [
                            "np.ravel(y_data_test)",
                            "Call"
                        ],
                        [
                            "predict_input.target",
                            "Attribute"
                        ],
                        [
                            "np.ravel(y_data_test)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "non_preds",
                    "possible_values": [
                        [
                            "predicted_values.predict",
                            "Attribute"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_absolute_error_124": {
                "variable": {
                    "value": "mae_value_non",
                    "possible_values": []
                },
                "y_true": {
                    "value": "y_data_test",
                    "possible_values": [
                        [
                            "np.ravel(y_data_test)",
                            "Call"
                        ],
                        [
                            "predict_input.target",
                            "Attribute"
                        ],
                        [
                            "np.ravel(y_data_test)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "non_preds",
                    "possible_values": [
                        [
                            "predicted_values.predict",
                            "Attribute"
                        ]
                    ]
                }
            }
        }
    },
    "examples/advanced/gpu_example.py": {
        "sklearn": {
            "make_moons_82": {
                "variable": {
                    "value": "(X, y)",
                    "possible_values": []
                },
                "n_samples": {
                    "value": "samples",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "True",
                    "possible_values": []
                },
                "noise": {
                    "value": "0.1",
                    "possible_values": []
                },
                "random_state": {
                    "value": "137",
                    "possible_values": []
                }
            }
        }
    },
    "examples/advanced/multi_modal_pipeline.py": {
        "sklearn": {}
    },
    "examples/advanced/multitask_classification_regression.py": {
        "sklearn": {}
    },
    "examples/advanced/time_series_forecasting/composing_pipelines.py": {
        "sklearn": {
            "mean_squared_error_77": {
                "variable": {
                    "value": "rmse",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_target",
                    "possible_values": [
                        [
                            "np.ravel(test_data.target)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predict",
                    "possible_values": [
                        [
                            "np.ravel(np.array(prediction.predict))",
                            "Call"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_absolute_error_78": {
                "variable": {
                    "value": "mae",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_target",
                    "possible_values": [
                        [
                            "np.ravel(test_data.target)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predict",
                    "possible_values": [
                        [
                            "np.ravel(np.array(prediction.predict))",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_squared_error_117": {
                "variable": {
                    "value": "rmse",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_target",
                    "possible_values": [
                        [
                            "np.ravel(test_data.target)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predict_after",
                    "possible_values": [
                        [
                            "np.ravel(np.array(prediction_after.predict))",
                            "Call"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_absolute_error_118": {
                "variable": {
                    "value": "mae",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_target",
                    "possible_values": [
                        [
                            "np.ravel(test_data.target)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predict_after",
                    "possible_values": [
                        [
                            "np.ravel(np.array(prediction_after.predict))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "examples/advanced/time_series_forecasting/custom_model_tuning.py": {
        "sklearn": {
            "Ridge_32": {
                "variable": {
                    "value": "reg",
                    "possible_values": []
                },
                "alpha": {
                    "value": "alpha",
                    "possible_values": [
                        [
                            "params.get('alpha')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "examples/advanced/time_series_forecasting/exogenous.py": {
        "sklearn": {
            "mean_squared_error_126": {
                "variable": {
                    "value": "mse_before",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data",
                    "possible_values": [
                        [
                            "np.ravel(predict_input.target)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predicted",
                    "possible_values": [
                        [
                            "make_forecast(pipeline, train_input, predict_input, train_input_exog, predict_input_exog)",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(predicted))",
                            "Call"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_absolute_error_127": {
                "variable": {
                    "value": "mae_before",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data",
                    "possible_values": [
                        [
                            "np.ravel(predict_input.target)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predicted",
                    "possible_values": [
                        [
                            "make_forecast(pipeline, train_input, predict_input, train_input_exog, predict_input_exog)",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(predicted))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "examples/advanced/time_series_forecasting/multi_ts_arctic_forecasting.py": {
        "sklearn": {
            "mean_squared_error_19": {
                "variable": {
                    "value": "rmse",
                    "possible_values": []
                },
                "y_true": {
                    "value": "target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "predicted",
                    "possible_values": []
                },
                "squared": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "mean_absolute_error_20": {
                "variable": {
                    "value": "mae",
                    "possible_values": []
                },
                "y_true": {
                    "value": "target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "predicted",
                    "possible_values": []
                }
            }
        }
    },
    "examples/advanced/time_series_forecasting/nemo.py": {
        "sklearn": {
            "mean_squared_error_132": {
                "variable": {
                    "value": "mse_before",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data",
                    "possible_values": [
                        [
                            "time_series[-len_forecast:]",
                            "Subscript"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predicted",
                    "possible_values": [
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_absolute_error_133": {
                "variable": {
                    "value": "mae_before",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data",
                    "possible_values": [
                        [
                            "time_series[-len_forecast:]",
                            "Subscript"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predicted",
                    "possible_values": [
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_absolute_percentage_error_134": {
                "variable": {
                    "value": "mape_before",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data",
                    "possible_values": [
                        [
                            "time_series[-len_forecast:]",
                            "Subscript"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predicted",
                    "possible_values": [
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_squared_error_157": {
                "variable": {
                    "value": "mse_before",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data",
                    "possible_values": [
                        [
                            "time_series[-len_forecast:]",
                            "Subscript"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predicted",
                    "possible_values": [
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_absolute_error_158": {
                "variable": {
                    "value": "mae_before",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data",
                    "possible_values": [
                        [
                            "time_series[-len_forecast:]",
                            "Subscript"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predicted",
                    "possible_values": [
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_absolute_percentage_error_159": {
                "variable": {
                    "value": "mape_before",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data",
                    "possible_values": [
                        [
                            "time_series[-len_forecast:]",
                            "Subscript"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predicted",
                    "possible_values": [
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_squared_error_182": {
                "variable": {
                    "value": "mse_before",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data",
                    "possible_values": [
                        [
                            "time_series[-len_forecast:]",
                            "Subscript"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predicted",
                    "possible_values": [
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_absolute_error_183": {
                "variable": {
                    "value": "mae_before",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data",
                    "possible_values": [
                        [
                            "time_series[-len_forecast:]",
                            "Subscript"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predicted",
                    "possible_values": [
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_absolute_percentage_error_184": {
                "variable": {
                    "value": "mape_before",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data",
                    "possible_values": [
                        [
                            "time_series[-len_forecast:]",
                            "Subscript"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data))",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predicted",
                    "possible_values": [
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "examples/advanced/time_series_forecasting/nemo_multiple.py": {
        "sklearn": {
            "mean_squared_error_218": {
                "variable": {
                    "value": "mse_before",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data",
                    "possible_values": [
                        [
                            "np.ravel(test_data)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predicted",
                    "possible_values": [
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_absolute_error_219": {
                "variable": {
                    "value": "mae_before",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data",
                    "possible_values": [
                        [
                            "np.ravel(test_data)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predicted",
                    "possible_values": [
                        [
                            "np.ravel(np.array(predicted_values))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "examples/advanced/time_series_forecasting/sparse_lagged_tuning.py": {
        "sklearn": {
            "mean_absolute_error_89": {
                "variable": {
                    "value": "mae_before",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "old_predicted_values",
                    "possible_values": [
                        [
                            "predicted_values.predict",
                            "Attribute"
                        ],
                        [
                            "np.ravel(np.array(old_predicted_values))",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_absolute_error_90": {
                "variable": {
                    "value": "mae_after",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "new_predicted_values",
                    "possible_values": [
                        [
                            "predicted_values.predict",
                            "Attribute"
                        ],
                        [
                            "np.ravel(np.array(new_predicted_values))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "examples/project_import_export.py": {
        "sklearn": {}
    },
    "examples/simple/classification/classification_with_tuning.py": {
        "sklearn": {
            "train_test_split_54": {
                "variable": {
                    "value": "(x_data_train, x_data_test, y_data_train, y_data_test)",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "x_data",
                    "possible_values": []
                },
                "*arrays_1": {
                    "value": "y_data",
                    "possible_values": []
                },
                "test_size": {
                    "value": "0.3",
                    "possible_values": []
                }
            }
        }
    },
    "examples/simple/classification/image_classification_problem.py": {
        "sklearn": {},
        "tensorflow": {
            "load_data_49": {
                "variable": {
                    "value": "(training_set, testing_set)",
                    "possible_values": []
                },
                "path": {
                    "value": "mnist.npz",
                    "possible_values": []
                }
            }
        }
    },
    "examples/simple/classification/multiclass_prediction.py": {
        "sklearn": {}
    },
    "examples/simple/classification/resample_example.py": {
        "sklearn": {
            "train_test_split_34": {
                "variable": {
                    "value": "(x_train, x_test, y_train, y_test)",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "np.array(features)",
                    "possible_values": []
                },
                "*arrays_1": {
                    "value": "np.array(target)",
                    "possible_values": []
                },
                "test_size": {
                    "value": "0.3",
                    "possible_values": []
                }
            }
        }
    },
    "examples/simple/pipeline_tune.py": {
        "sklearn": {}
    },
    "examples/simple/regression/regression_with_tuning.py": {
        "sklearn": {
            "train_test_split_52": {
                "variable": {
                    "value": "(x_train, x_test, y_train, y_test)",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "x_data",
                    "possible_values": []
                },
                "*arrays_1": {
                    "value": "y_data",
                    "possible_values": []
                },
                "test_size": {
                    "value": "0.3",
                    "possible_values": []
                }
            },
            "mean_absolute_error_98": {
                "variable": {
                    "value": "mae_value",
                    "possible_values": []
                },
                "y_true": {
                    "value": "y_test",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "pipeline_prediction",
                    "possible_values": [
                        [
                            "predicted_values.predict",
                            "Attribute"
                        ]
                    ]
                }
            },
            "mean_absolute_error_112": {
                "variable": {
                    "value": "mae_value",
                    "possible_values": []
                },
                "y_true": {
                    "value": "y_test",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "preds_tuned",
                    "possible_values": [
                        [
                            "predicted_values_tuned.predict",
                            "Attribute"
                        ]
                    ]
                }
            }
        }
    },
    "examples/simple/time_series_forecasting/clstm.py": {
        "sklearn": {
            "mean_squared_error_101": {
                "variable": {
                    "value": "rmse",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "prediction_before_export",
                    "possible_values": [
                        [
                            "pipeline.predict(test_data).predict[0]",
                            "Subscript"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_absolute_error_102": {
                "variable": {
                    "value": "mae",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "prediction_before_export",
                    "possible_values": [
                        [
                            "pipeline.predict(test_data).predict[0]",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "examples/simple/time_series_forecasting/tuning_pipelines.py": {
        "sklearn": {
            "mean_squared_error_60": {
                "variable": {
                    "value": "rmse",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_target",
                    "possible_values": [
                        [
                            "np.ravel(test_data.target)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predict",
                    "possible_values": [
                        [
                            "np.ravel(np.array(prediction.predict))",
                            "Call"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_absolute_error_61": {
                "variable": {
                    "value": "mae",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_target",
                    "possible_values": [
                        [
                            "np.ravel(test_data.target)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predict",
                    "possible_values": [
                        [
                            "np.ravel(np.array(prediction.predict))",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_squared_error_79": {
                "variable": {
                    "value": "rmse",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_target",
                    "possible_values": [
                        [
                            "np.ravel(test_data.target)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predict_after",
                    "possible_values": [
                        [
                            "np.ravel(np.array(prediction_after.predict))",
                            "Call"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_absolute_error_80": {
                "variable": {
                    "value": "mae",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_target",
                    "possible_values": [
                        [
                            "np.ravel(test_data.target)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predict_after",
                    "possible_values": [
                        [
                            "np.ravel(np.array(prediction_after.predict))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "fedot/api/api_utils/metrics.py": {
        "sklearn": {}
    },
    "fedot/core/composer/metrics.py": {
        "sklearn": {
            "mean_squared_error_151": {
                "y_true": {
                    "value": "reference.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "predicted.predict",
                    "possible_values": []
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_squared_error_160": {
                "y_true": {
                    "value": "reference.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "predicted.predict",
                    "possible_values": []
                },
                "squared": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "mean_squared_log_error_169": {
                "y_true": {
                    "value": "reference.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "predicted.predict",
                    "possible_values": []
                }
            },
            "mean_absolute_percentage_error_178": {
                "y_true": {
                    "value": "reference.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "predicted.predict",
                    "possible_values": []
                }
            },
            "f1_score_202": {
                "y_true": {
                    "value": "reference.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "predicted.predict",
                    "possible_values": []
                }
            },
            "mean_absolute_error_211": {
                "y_true": {
                    "value": "reference.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "predicted.predict",
                    "possible_values": []
                }
            },
            "r2_score_219": {
                "y_true": {
                    "value": "reference.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "predicted.predict",
                    "possible_values": []
                }
            },
            "roc_curve_243": {
                "y_true": {
                    "value": "target",
                    "possible_values": []
                },
                "y_score": {
                    "value": "predict",
                    "possible_values": []
                },
                "pos_label": {
                    "value": "pos_label",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "auc_247": {
                "x": {
                    "value": "fpr",
                    "possible_values": []
                },
                "y": {
                    "value": "tpr",
                    "possible_values": []
                }
            },
            "precision_score_256": {
                "y_true": {
                    "value": "reference.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "predicted.predict",
                    "possible_values": []
                }
            },
            "log_loss_264": {
                "y_true": {
                    "value": "reference.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "predicted.predict",
                    "possible_values": []
                }
            },
            "accuracy_score_274": {
                "y_true": {
                    "value": "reference.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "predicted.predict",
                    "possible_values": []
                }
            },
            "silhouette_score_283": {
                "X": {
                    "value": "reference.features",
                    "possible_values": []
                },
                "labels": {
                    "value": "predicted.predict",
                    "possible_values": []
                }
            },
            "roc_auc_score_234": {
                "y_score": {
                    "value": "predicted.predict",
                    "possible_values": []
                },
                "y_true": {
                    "value": "reference.target",
                    "possible_values": []
                }
            }
        }
    },
    "fedot/core/data/data_split.py": {
        "sklearn": {
            "train_test_split_104": {
                "variable": {
                    "value": "(idx_train, idx_test, x_train, x_test, y_train, y_test)",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "idx",
                    "possible_values": []
                },
                "*arrays_1": {
                    "value": "input_features",
                    "possible_values": []
                },
                "*arrays_2": {
                    "value": "input_target",
                    "possible_values": []
                },
                "test_size": {
                    "value": "1.0 - split_ratio",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "with_shuffle",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                },
                "random_state": {
                    "value": "random_state",
                    "possible_values": [
                        [
                            "42",
                            "Constant"
                        ]
                    ]
                }
            }
        }
    },
    "fedot/core/operations/evaluation/clustering.py": {
        "sklearn": {}
    },
    "fedot/core/operations/evaluation/evaluation_interfaces.py": {
        "sklearn": {}
    },
    "fedot/core/operations/evaluation/operation_implementations/data_operations/categorical_encoders.py": {
        "sklearn": {
            "OneHotEncoder_23": {
                "variable": {
                    "value": "self.encoder",
                    "possible_values": []
                },
                "handle_unknown": {
                    "value": "ignore",
                    "possible_values": []
                }
            },
            "OneHotEncoder_25": {
                "variable": {
                    "value": "self.encoder",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "**{**params, **default_params}",
                    "possible_values": []
                }
            },
            "LabelEncoder_174": {
                "variable": {
                    "value": "le",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            }
        }
    },
    "fedot/core/operations/evaluation/operation_implementations/data_operations/decompose.py": {
        "sklearn": {
            "OneHotEncoder_212": {
                "variable": {
                    "value": "binary_enc",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            }
        }
    },
    "fedot/core/operations/evaluation/operation_implementations/data_operations/sklearn_filters.py": {
        "sklearn": {
            "make_pipeline_105": {
                "variable": {
                    "value": "self.inner_model",
                    "possible_values": []
                },
                "*steps": {
                    "value": "StandardScaler(with_mean=False)",
                    "possible_values": []
                },
                "memory": {
                    "value": "LinearRegression()",
                    "possible_values": []
                }
            },
            "DecisionTreeRegressor_124": {
                "variable": {
                    "value": "self.inner_model",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "RANSACRegressor_109": {
                "variable": {
                    "value": "self.operation",
                    "possible_values": []
                },
                "base_estimator": {
                    "value": "self.inner_model",
                    "possible_values": []
                }
            },
            "RANSACRegressor_111": {
                "variable": {
                    "value": "self.operation",
                    "possible_values": []
                },
                "base_estimator": {
                    "value": "self.inner_model",
                    "possible_values": []
                }
            },
            "RANSACRegressor_127": {
                "variable": {
                    "value": "self.operation",
                    "possible_values": []
                },
                "base_estimator": {
                    "value": "self.inner_model",
                    "possible_values": []
                }
            },
            "RANSACRegressor_129": {
                "variable": {
                    "value": "self.operation",
                    "possible_values": []
                },
                "base_estimator": {
                    "value": "self.inner_model",
                    "possible_values": []
                }
            },
            "IsolationForest_146": {
                "variable": {
                    "value": "self.operation",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "IsolationForest_148": {
                "variable": {
                    "value": "self.operation",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "**params",
                    "possible_values": []
                }
            },
            "StandardScaler_105": {
                "with_mean": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "LinearRegression_105": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            }
        }
    },
    "fedot/core/operations/evaluation/operation_implementations/data_operations/sklearn_imbalanced_class.py": {
        "sklearn": {
            "resample_174": {
                "*arrays_0": {
                    "value": "data",
                    "possible_values": []
                },
                "replace": {
                    "value": "self.replace",
                    "possible_values": []
                },
                "n_samples": {
                    "value": "self.n_samples",
                    "possible_values": []
                }
            }
        }
    },
    "fedot/core/operations/evaluation/operation_implementations/data_operations/sklearn_selectors.py": {
        "sklearn": {
            "LinearRegression_123": {
                "variable": {
                    "value": "self.inner_model",
                    "possible_values": []
                },
                "normalize": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "DecisionTreeRegressor_145": {
                "variable": {
                    "value": "self.inner_model",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "LogisticRegression_167": {
                "variable": {
                    "value": "self.inner_model",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "DecisionTreeClassifier_189": {
                "variable": {
                    "value": "self.inner_model",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "RFE_127": {
                "variable": {
                    "value": "self.operation",
                    "possible_values": []
                },
                "estimator": {
                    "value": "self.inner_model",
                    "possible_values": []
                }
            },
            "RFE_132": {
                "variable": {
                    "value": "self.operation",
                    "possible_values": []
                },
                "estimator": {
                    "value": "self.inner_model",
                    "possible_values": []
                }
            },
            "RFE_149": {
                "variable": {
                    "value": "self.operation",
                    "possible_values": []
                },
                "estimator": {
                    "value": "self.inner_model",
                    "possible_values": []
                }
            },
            "RFE_154": {
                "variable": {
                    "value": "self.operation",
                    "possible_values": []
                },
                "estimator": {
                    "value": "self.inner_model",
                    "possible_values": []
                }
            },
            "RFE_171": {
                "variable": {
                    "value": "self.operation",
                    "possible_values": []
                },
                "estimator": {
                    "value": "self.inner_model",
                    "possible_values": []
                }
            },
            "RFE_176": {
                "variable": {
                    "value": "self.operation",
                    "possible_values": []
                },
                "estimator": {
                    "value": "self.inner_model",
                    "possible_values": []
                }
            },
            "RFE_193": {
                "variable": {
                    "value": "self.operation",
                    "possible_values": []
                },
                "estimator": {
                    "value": "self.inner_model",
                    "possible_values": []
                }
            },
            "RFE_198": {
                "variable": {
                    "value": "self.operation",
                    "possible_values": []
                },
                "estimator": {
                    "value": "self.inner_model",
                    "possible_values": []
                }
            }
        }
    },
    "fedot/core/operations/evaluation/operation_implementations/data_operations/sklearn_transformations.py": {
        "sklearn": {
            "PCA_111": {
                "variable": {
                    "value": "self.pca",
                    "possible_values": []
                },
                "svd_solver": {
                    "value": "full",
                    "possible_values": []
                },
                "n_components": {
                    "value": "mle",
                    "possible_values": []
                }
            },
            "PCA_113": {
                "variable": {
                    "value": "self.pca",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "**params",
                    "possible_values": []
                }
            },
            "KernelPCA_128": {
                "variable": {
                    "value": "self.pca",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "KernelPCA_130": {
                "variable": {
                    "value": "self.pca",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "**params",
                    "possible_values": []
                }
            },
            "FastICA_143": {
                "variable": {
                    "value": "self.pca",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "FastICA_145": {
                "variable": {
                    "value": "self.pca",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "**params",
                    "possible_values": []
                }
            },
            "PolynomialFeatures_162": {
                "variable": {
                    "value": "self.operation",
                    "possible_values": []
                },
                "include_bias": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "PolynomialFeatures_167": {
                "variable": {
                    "value": "self.operation",
                    "possible_values": []
                },
                "include_bias": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "StandardScaler_227": {
                "variable": {
                    "value": "self.operation",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "StandardScaler_229": {
                "variable": {
                    "value": "self.operation",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "**params",
                    "possible_values": []
                }
            },
            "MinMaxScaler_248": {
                "variable": {
                    "value": "self.operation",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "MinMaxScaler_250": {
                "variable": {
                    "value": "self.operation",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "**params",
                    "possible_values": []
                }
            },
            "SimpleImputer_274": {
                "variable": {
                    "value": "self.imputer_cat",
                    "possible_values": []
                },
                "strategy": {
                    "value": "most_frequent",
                    "possible_values": []
                }
            },
            "SimpleImputer_275": {
                "variable": {
                    "value": "self.imputer_num",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "SimpleImputer_277": {
                "variable": {
                    "value": "self.imputer_cat",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "**self.params_cat",
                    "possible_values": []
                }
            },
            "SimpleImputer_278": {
                "variable": {
                    "value": "self.imputer_num",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "**self.params_num",
                    "possible_values": []
                }
            }
        }
    },
    "fedot/core/operations/evaluation/operation_implementations/data_operations/ts_transformations.py": {
        "sklearn": {
            "TruncatedSVD_748": {
                "variable": {
                    "value": "svd",
                    "possible_values": []
                },
                "n_components": {
                    "value": "n_components",
                    "possible_values": [
                        [
                            "int(features_columns.shape[1] * n_components_perc)",
                            "Call"
                        ],
                        [
                            "int(features_columns.shape[1] * n_components_perc)",
                            "Call"
                        ],
                        [
                            "features_columns.shape[0] - 1",
                            "BinOp"
                        ]
                    ]
                },
                "n_iter": {
                    "value": "5",
                    "possible_values": []
                },
                "random_state": {
                    "value": "42",
                    "possible_values": []
                }
            }
        }
    },
    "fedot/core/operations/evaluation/operation_implementations/models/discriminant_analysis.py": {
        "sklearn": {
            "LinearDiscriminantAnalysis_65": {
                "variable": {
                    "value": "self.model",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "LinearDiscriminantAnalysis_67": {
                "variable": {
                    "value": "self.model",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "**params",
                    "possible_values": []
                }
            },
            "QuadraticDiscriminantAnalysis_122": {
                "variable": {
                    "value": "self.model",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "QuadraticDiscriminantAnalysis_124": {
                "variable": {
                    "value": "self.model",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "**params",
                    "possible_values": []
                }
            }
        }
    },
    "fedot/core/operations/evaluation/operation_implementations/models/keras.py": {
        "sklearn": {
            "OneHotEncoder_97": {
                "variable": {
                    "value": "le",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "Sequential_35": {
                "variable": {
                    "value": "model",
                    "possible_values": []
                },
                "layers": {
                    "value": "[tf.keras.layers.InputLayer(input_shape=input_shape), tf.keras.layers.Conv2D(32, kernel_size=(3, 3), activation='relu'), tf.keras.layers.MaxPooling2D(pool_size=(2, 2)), tf.keras.layers.Conv2D(64, kernel_size=(3, 3), activation='relu'), tf.keras.layers.MaxPooling2D(pool_size=(2, 2)), tf.keras.layers.Conv2D(128, kernel_size=(3, 3), activation='relu'), tf.keras.layers.MaxPooling2D(pool_size=(2, 2)), tf.keras.layers.Flatten(), tf.keras.layers.Dropout(0.5), tf.keras.layers.Dense(num_classes, activation='softmax')]",
                    "possible_values": []
                }
            },
            "Sequential_54": {
                "variable": {
                    "value": "model",
                    "possible_values": []
                },
                "layers": {
                    "value": "[tf.keras.layers.InputLayer(input_shape=input_shape), tf.keras.layers.Conv2D(32, kernel_size=(3, 3), activation='relu'), tf.keras.layers.MaxPooling2D(pool_size=(2, 2)), tf.keras.layers.Flatten(), tf.keras.layers.Dropout(0.5), tf.keras.layers.Dense(num_classes, activation='softmax')]",
                    "possible_values": []
                }
            },
            "VGG16_70": {
                "variable": {
                    "value": "model",
                    "possible_values": []
                },
                "include_top": {
                    "value": "True",
                    "possible_values": []
                },
                "weights": {
                    "value": "None",
                    "possible_values": []
                },
                "input_shape": {
                    "value": "input_shape",
                    "possible_values": []
                },
                "classes": {
                    "value": "num_classes",
                    "possible_values": []
                },
                "classifier_activation": {
                    "value": "sigmoid",
                    "possible_values": []
                }
            },
            "InputLayer_37": {
                "input_shape": {
                    "value": "input_shape",
                    "possible_values": []
                }
            },
            "Conv2D_38": {
                "filters": {
                    "value": "32",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "possible_values": []
                },
                "activation": {
                    "value": "relu",
                    "possible_values": []
                }
            },
            "MaxPooling2D_39": {
                "pool_size": {
                    "value": "(2, 2)",
                    "possible_values": []
                }
            },
            "Conv2D_40": {
                "filters": {
                    "value": "64",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "possible_values": []
                },
                "activation": {
                    "value": "relu",
                    "possible_values": []
                }
            },
            "MaxPooling2D_41": {
                "pool_size": {
                    "value": "(2, 2)",
                    "possible_values": []
                }
            },
            "Conv2D_42": {
                "filters": {
                    "value": "128",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "possible_values": []
                },
                "activation": {
                    "value": "relu",
                    "possible_values": []
                }
            },
            "MaxPooling2D_43": {
                "pool_size": {
                    "value": "(2, 2)",
                    "possible_values": []
                }
            },
            "Flatten_44": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "Dropout_45": {
                "rate": {
                    "value": "0.5",
                    "possible_values": []
                }
            },
            "Dense_46": {
                "units": {
                    "value": "num_classes",
                    "possible_values": []
                },
                "activation": {
                    "value": "softmax",
                    "possible_values": []
                }
            },
            "InputLayer_56": {
                "input_shape": {
                    "value": "input_shape",
                    "possible_values": []
                }
            },
            "Conv2D_57": {
                "filters": {
                    "value": "32",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "possible_values": []
                },
                "activation": {
                    "value": "relu",
                    "possible_values": []
                }
            },
            "MaxPooling2D_58": {
                "pool_size": {
                    "value": "(2, 2)",
                    "possible_values": []
                }
            },
            "Flatten_59": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "Dropout_60": {
                "rate": {
                    "value": "0.5",
                    "possible_values": []
                }
            },
            "Dense_61": {
                "units": {
                    "value": "num_classes",
                    "possible_values": []
                },
                "activation": {
                    "value": "softmax",
                    "possible_values": []
                }
            }
        }
    },
    "fedot/core/operations/evaluation/operation_implementations/models/knn.py": {
        "sklearn": {
            "KNeighborsClassifier_75": {
                "variable": {
                    "value": "self.model",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "KNeighborsClassifier_78": {
                "variable": {
                    "value": "self.model",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "**params",
                    "possible_values": []
                }
            },
            "KNeighborsRegressor_112": {
                "variable": {
                    "value": "self.model",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "KNeighborsRegressor_115": {
                "variable": {
                    "value": "self.model",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "**params",
                    "possible_values": []
                }
            }
        }
    },
    "fedot/core/operations/evaluation/operation_implementations/models/svc.py": {
        "sklearn": {
            "OneVsRestClassifier_21": {
                "variable": {
                    "value": "self.model",
                    "possible_values": []
                },
                "estimator": {
                    "value": "self.inner_model",
                    "possible_values": []
                }
            },
            "SVC_15": {
                "variable": {
                    "value": "self.inner_model",
                    "possible_values": []
                },
                "kernel": {
                    "value": "linear",
                    "possible_values": []
                },
                "probability": {
                    "value": "True",
                    "possible_values": []
                },
                "class_weight": {
                    "value": "balanced",
                    "possible_values": []
                }
            },
            "SVC_19": {
                "variable": {
                    "value": "self.inner_model",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "**params",
                    "possible_values": []
                }
            }
        }
    },
    "fedot/core/operations/evaluation/operation_implementations/models/ts_implementations/clstm.py": {
        "sklearn": {
            "StandardScaler_62": {
                "variable": {
                    "value": "self.scaler",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            }
        },
        "torch": {
            "Tensor_147": {
                "variable": {
                    "value": "x",
                    "possible_values": []
                }
            },
            "from_numpy_228": {
                "variable": {
                    "value": "x",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "features_columns.copy()",
                    "possible_values": []
                }
            },
            "from_numpy_229": {
                "variable": {
                    "value": "y",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "final_target.copy()",
                    "possible_values": []
                }
            },
            "Sequential_244": {
                "variable": {
                    "value": "self.conv_block1",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Conv1d(in_channels=1, out_channels=cnn1_output_size, kernel_size=cnn1_kernel_size)",
                    "possible_values": []
                }
            },
            "Sequential_248": {
                "variable": {
                    "value": "self.conv_block2",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Conv1d(in_channels=cnn1_output_size, out_channels=cnn2_output_size, kernel_size=cnn2_kernel_size)",
                    "possible_values": []
                }
            },
            "LSTM_252": {
                "variable": {
                    "value": "self.lstm",
                    "possible_values": []
                },
                "*args": {
                    "value": "cnn2_output_size",
                    "possible_values": []
                },
                "dropout": {
                    "value": "0.1",
                    "possible_values": []
                }
            },
            "Linear_254": {
                "variable": {
                    "value": "self.linear",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.hidden_size * 2",
                    "possible_values": []
                },
                "out_features": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "cat_267": {
                "variable": {
                    "value": "hidden_cat",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[self.hidden_cell[0], self.hidden_cell[1]]",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "possible_values": []
                }
            },
            "is_available_207": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "Adam_53": {
                "params": {
                    "value": "self.model.parameters()",
                    "possible_values": []
                },
                "lr": {
                    "value": "self.learning_rate",
                    "possible_values": []
                }
            },
            "SGD_54": {
                "params": {
                    "value": "self.model.parameters()",
                    "possible_values": []
                },
                "lr": {
                    "value": "self.learning_rate",
                    "possible_values": []
                }
            },
            "hstack_98": {
                "variable": {
                    "value": "x",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(x[:, 1:], output)",
                    "possible_values": []
                }
            },
            "hstack_100": {
                "variable": {
                    "value": "x",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(x, y[:, i].unsqueeze(1))",
                    "possible_values": []
                }
            },
            "hstack_103": {
                "variable": {
                    "value": "final_output",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(final_output, output)",
                    "possible_values": []
                }
            },
            "DataLoader_230": {
                "dataset": {
                    "value": "TensorDataset(x, y)",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "self.batch_size",
                    "possible_values": []
                }
            },
            "Conv1d_245": {
                "in_channels": {
                    "value": "1",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "cnn1_output_size",
                    "possible_values": [
                        [
                            "16",
                            "MethodArgument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "cnn1_kernel_size",
                    "possible_values": [
                        [
                            "5",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "ReLU_246": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "Conv1d_249": {
                "in_channels": {
                    "value": "cnn1_output_size",
                    "possible_values": [
                        [
                            "16",
                            "MethodArgument"
                        ]
                    ]
                },
                "out_channels": {
                    "value": "cnn2_output_size",
                    "possible_values": [
                        [
                            "32",
                            "MethodArgument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "cnn2_kernel_size",
                    "possible_values": [
                        [
                            "3",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "ReLU_250": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "zeros_257": {
                "*size": {
                    "value": "1",
                    "possible_values": []
                },
                "out": {
                    "value": "batch_size",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.hidden_size",
                    "possible_values": []
                }
            },
            "zeros_258": {
                "*size": {
                    "value": "1",
                    "possible_values": []
                },
                "out": {
                    "value": "batch_size",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.hidden_size",
                    "possible_values": []
                }
            },
            "no_grad_171": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "TensorDataset_230": {
                "*tensors": {
                    "value": "x",
                    "possible_values": []
                }
            }
        }
    },
    "fedot/core/operations/evaluation/text.py": {
        "sklearn": {}
    },
    "fedot/core/optimisers/objective/data_objective_advisor.py": {
        "sklearn": {}
    },
    "fedot/core/pipelines/tuning/tuner_interface.py": {
        "sklearn": {}
    },
    "fedot/core/utils.py": {
        "sklearn": {
            "train_test_split_49": {
                "variable": {
                    "value": "(train, test)",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "df.iloc[:, :]",
                    "possible_values": []
                },
                "test_size": {
                    "value": "t_size",
                    "possible_values": []
                },
                "random_state": {
                    "value": "42",
                    "possible_values": []
                }
            }
        }
    },
    "fedot/core/validation/split.py": {
        "sklearn": {}
    },
    "fedot/explainability/surrogate_explainer.py": {
        "sklearn": {
            "plot_tree_89": {
                "decision_tree": {
                    "value": "self.surrogate.root_node.fitted_operation",
                    "possible_values": []
                },
                "proportion": {
                    "value": "True",
                    "possible_values": []
                },
                "filled": {
                    "value": "True",
                    "possible_values": []
                },
                "rounded": {
                    "value": "True",
                    "possible_values": []
                },
                "fontsize": {
                    "value": "12",
                    "possible_values": []
                }
            }
        }
    },
    "fedot/preprocessing/categorical.py": {
        "sklearn": {
            "LabelEncoder_103": {
                "variable": {
                    "value": "encoder",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            }
        }
    },
    "fedot/preprocessing/preprocessing.py": {
        "sklearn": {
            "LabelEncoder_408": {
                "variable": {
                    "value": "target_encoder",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            }
        }
    },
    "fedot/sensitivity/operations_hp_sensitivity/one_operation_sensitivity.py": {
        "sklearn": {
            "mean_squared_error_102": {
                "variable": {
                    "value": "mse_metric",
                    "possible_values": []
                },
                "y_true": {
                    "value": "self._test_data.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "prediction.predict",
                    "possible_values": []
                }
            }
        }
    },
    "fedot/utilities/define_metric_by_task.py": {
        "sklearn": {}
    },
    "fedot/utilities/synth_dataset_generator.py": {
        "sklearn": {
            "make_classification_28": {
                "variable": {
                    "value": "(features, target)",
                    "possible_values": []
                },
                "n_samples": {
                    "value": "samples_amount",
                    "possible_values": []
                },
                "n_features": {
                    "value": "features_amount",
                    "possible_values": []
                },
                "n_informative": {
                    "value": "features_options['informative']",
                    "possible_values": []
                },
                "n_redundant": {
                    "value": "features_options['redundant']",
                    "possible_values": []
                },
                "n_repeated": {
                    "value": "features_options['repeated']",
                    "possible_values": []
                },
                "n_classes": {
                    "value": "classes_amount",
                    "possible_values": []
                },
                "n_clusters_per_class": {
                    "value": "features_options['clusters_per_class']",
                    "possible_values": []
                },
                "weights": {
                    "value": "weights",
                    "possible_values": []
                },
                "flip_y": {
                    "value": "noise_fraction",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "full_shuffle",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "make_regression_58": {
                "variable": {
                    "value": "(features, target)",
                    "possible_values": []
                },
                "n_samples": {
                    "value": "samples_amount",
                    "possible_values": []
                },
                "n_features": {
                    "value": "features_amount",
                    "possible_values": []
                },
                "n_informative": {
                    "value": "features_options['informative']",
                    "possible_values": []
                },
                "bias": {
                    "value": "features_options['bias']",
                    "possible_values": []
                },
                "n_targets": {
                    "value": "n_targets",
                    "possible_values": []
                },
                "noise": {
                    "value": "noise",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "shuffle",
                    "possible_values": []
                }
            },
            "make_gaussian_quantiles_88": {
                "variable": {
                    "value": "(features, target)",
                    "possible_values": []
                },
                "n_samples": {
                    "value": "samples_amount",
                    "possible_values": []
                },
                "n_features": {
                    "value": "features_amount",
                    "possible_values": []
                },
                "n_classes": {
                    "value": "classes_amount",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "full_shuffle",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                },
                "mean": {
                    "value": "mean",
                    "possible_values": []
                },
                "cov": {
                    "value": "cov",
                    "possible_values": []
                }
            }
        }
    },
    "test/integration/quality/test_synthetic_tasks.py": {
        "sklearn": {
            "mean_squared_error_42": {
                "variable": {
                    "value": "error",
                    "possible_values": []
                },
                "y_true": {
                    "value": "results.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "results.predict",
                    "possible_values": []
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            }
        }
    },
    "test/integration/real_applications/test_examples.py": {
        "sklearn": {
            "mean_squared_error_44": {
                "variable": {
                    "value": "model_rmse",
                    "possible_values": []
                },
                "y_true": {
                    "value": "true_values",
                    "possible_values": [
                        [
                            "real_data[gap_ids]",
                            "Subscript"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predicted_values",
                    "possible_values": [
                        [
                            "arr_without_gaps[gap_ids]",
                            "Subscript"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            }
        }
    },
    "test/integration/real_applications/test_real_cases.py": {
        "sklearn": {
            "mean_squared_error_60": {
                "variable": {
                    "value": "rmse_ridge",
                    "possible_values": []
                },
                "y_true": {
                    "value": "actual",
                    "possible_values": [
                        [
                            "np.array(dataframe['temperature'])[gap_ids]",
                            "Subscript"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "ridge_predicted",
                    "possible_values": [
                        [
                            "np.array(dataframe['ridge'])[gap_ids]",
                            "Subscript"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_squared_error_61": {
                "variable": {
                    "value": "rmse_composite",
                    "possible_values": []
                },
                "y_true": {
                    "value": "actual",
                    "possible_values": [
                        [
                            "np.array(dataframe['temperature'])[gap_ids]",
                            "Subscript"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "composite_predicted",
                    "possible_values": [
                        [
                            "np.array(dataframe['composite'])[gap_ids]",
                            "Subscript"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            }
        }
    },
    "test/unit/api/test_main_api.py": {
        "sklearn": {
            "train_test_split_54": {
                "variable": {
                    "value": "(x_train, x_test, y_train, y_test)",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "x",
                    "possible_values": []
                },
                "*arrays_1": {
                    "value": "y",
                    "possible_values": []
                },
                "test_size": {
                    "value": "0.15",
                    "possible_values": []
                },
                "random_state": {
                    "value": "24",
                    "possible_values": []
                }
            },
            "load_iris_346": {
                "variable": {
                    "value": "(df_el, y)",
                    "possible_values": []
                },
                "return_X_y": {
                    "value": "True",
                    "possible_values": []
                },
                "as_frame": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "LabelEncoder_347": {
                "variable": {
                    "value": "df_el[target_column]",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            }
        }
    },
    "test/unit/composer/test_composer.py": {
        "sklearn": {}
    },
    "test/unit/composer/test_quality_metrics.py": {
        "sklearn": {
            "load_breast_cancer_24": {
                "variable": {
                    "value": "(predictors, response)",
                    "possible_values": []
                },
                "return_X_y": {
                    "value": "True",
                    "possible_values": []
                }
            }
        }
    },
    "test/unit/data/test_data.py": {
        "sklearn": {
            "load_iris_22": {
                "variable": {
                    "value": "(predictors, response)",
                    "possible_values": []
                },
                "return_X_y": {
                    "value": "True",
                    "possible_values": []
                }
            }
        }
    },
    "test/unit/explainability/test_pipeline_explanation.py": {
        "sklearn": {
            "load_iris_20": {
                "variable": {
                    "value": "(predictors, response)",
                    "possible_values": []
                },
                "return_X_y": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "load_boston_34": {
                "variable": {
                    "value": "(predictors, response)",
                    "possible_values": []
                },
                "return_X_y": {
                    "value": "True",
                    "possible_values": []
                }
            }
        }
    },
    "test/unit/models/test_atomized_model.py": {
        "sklearn": {
            "mean_squared_error_146": {
                "variable": {
                    "value": "bfr_save_mse",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "before_save_predicted.predict",
                    "possible_values": []
                }
            },
            "mean_squared_error_147": {
                "variable": {
                    "value": "aft_load_mse",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "after_save_predicted.predict",
                    "possible_values": []
                }
            },
            "mean_squared_error_168": {
                "variable": {
                    "value": "source_mse",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "predicted_values.predict",
                    "possible_values": []
                }
            },
            "mean_squared_error_169": {
                "variable": {
                    "value": "atomized_mse",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "predicted_atomized_values",
                    "possible_values": [
                        [
                            "predicted_atomized_output.predict",
                            "Attribute"
                        ]
                    ]
                }
            },
            "mean_squared_error_200": {
                "variable": {
                    "value": "aft_tun_mse",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "after_tuning_predicted",
                    "possible_values": [
                        [
                            "after_tuning_output.predict",
                            "Attribute"
                        ]
                    ]
                }
            },
            "mean_squared_error_201": {
                "variable": {
                    "value": "bfr_tun_mse",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "before_tuning_predicted",
                    "possible_values": [
                        [
                            "before_tuning_output.predict",
                            "Attribute"
                        ]
                    ]
                }
            }
        }
    },
    "test/unit/models/test_model.py": {
        "sklearn": {
            "make_classification_109": {
                "variable": {
                    "value": "synthetic_data",
                    "possible_values": []
                },
                "n_samples": {
                    "value": "n_samples",
                    "possible_values": [
                        [
                            "1000",
                            "MethodArgument"
                        ]
                    ]
                },
                "n_features": {
                    "value": "n_features",
                    "possible_values": [
                        [
                            "100",
                            "MethodArgument"
                        ]
                    ]
                },
                "n_informative": {
                    "value": "n_informative",
                    "possible_values": [
                        [
                            "5",
                            "Constant"
                        ],
                        [
                            "5",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "mean_squared_error_176": {
                "variable": {
                    "value": "rmse_value_test",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "test_pred.predict",
                    "possible_values": []
                }
            },
            "mean_absolute_error_201": {
                "variable": {
                    "value": "mae_value_test",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_data.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "test_pred.predict[0]",
                    "possible_values": []
                }
            },
            "MinMaxScaler_100": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            }
        }
    },
    "test/unit/models/test_split_train_test.py": {
        "sklearn": {
            "make_classification_37": {
                "variable": {
                    "value": "synthetic_data",
                    "possible_values": []
                },
                "n_samples": {
                    "value": "n_samples",
                    "possible_values": [
                        [
                            "10000",
                            "MethodArgument"
                        ]
                    ]
                },
                "n_features": {
                    "value": "n_features",
                    "possible_values": [
                        [
                            "10",
                            "MethodArgument"
                        ]
                    ]
                },
                "random_state": {
                    "value": "random_state",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            }
        }
    },
    "test/unit/models/test_strategy.py": {
        "sklearn": {}
    },
    "test/unit/pipelines/test_node.py": {
        "sklearn": {
            "load_iris_17": {
                "variable": {
                    "value": "(predictors, response)",
                    "possible_values": []
                },
                "return_X_y": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "LogisticRegression_49": {
                "variable": {
                    "value": "test_skl_model",
                    "possible_values": []
                },
                "C": {
                    "value": "10.0",
                    "possible_values": []
                },
                "random_state": {
                    "value": "1",
                    "possible_values": []
                },
                "solver": {
                    "value": "liblinear",
                    "possible_values": []
                },
                "max_iter": {
                    "value": "10000",
                    "possible_values": []
                },
                "verbose": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "classification_report_31": {
                "y_true": {
                    "value": "y_true",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "y_pred",
                    "possible_values": []
                }
            },
            "accuracy_score_32": {
                "y_true": {
                    "value": "y_true",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "y_pred",
                    "possible_values": []
                }
            }
        }
    },
    "test/unit/pipelines/test_node_cache.py": {
        "sklearn": {
            "load_breast_cancer_20": {
                "variable": {
                    "value": "(predictors, response)",
                    "possible_values": []
                },
                "return_X_y": {
                    "value": "True",
                    "possible_values": []
                }
            }
        }
    },
    "test/unit/pipelines/test_pipeline.py": {
        "sklearn": {
            "load_iris_34": {
                "variable": {
                    "value": "(predictors, response)",
                    "possible_values": []
                },
                "return_X_y": {
                    "value": "True",
                    "possible_values": []
                }
            }
        }
    },
    "test/unit/pipelines/test_pipeline_ts_wrappers.py": {
        "sklearn": {
            "mean_absolute_percentage_error_148": {
                "variable": {
                    "value": "metric",
                    "possible_values": []
                },
                "y_true": {
                    "value": "full_ts[-multi_length:-1]",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "multi_predicted[:-1]",
                    "possible_values": []
                }
            },
            "mean_absolute_percentage_error_125": {
                "y_true": {
                    "value": "test_data.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "predict",
                    "possible_values": [
                        [
                            "in_sample_ts_forecast(pipeline=pipeline, input_data=full_series, horizon=forecast_length)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "test/unit/pipelines/test_pipeline_tuning.py": {
        "sklearn": {}
    },
    "test/unit/tasks/test_classification.py": {
        "sklearn": {
            "load_iris_60": {
                "variable": {
                    "value": "synthetic_data",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {}
    },
    "test/unit/tasks/test_forecasting.py": {
        "sklearn": {
            "mean_squared_error_139": {
                "variable": {
                    "value": "rmse_test",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_target",
                    "possible_values": [
                        [
                            "np.ravel(np.array(test_data.target))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data.target))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data.target))",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "test_pred",
                    "possible_values": [
                        [
                            "pipeline.predict(input_data=test_data)",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_pred.predict))",
                            "Call"
                        ],
                        [
                            "pipeline.predict(input_data=test_data)",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_pred.predict))",
                            "Call"
                        ],
                        [
                            "pipeline.predict(input_data=test_data)",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_pred.predict))",
                            "Call"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_squared_error_174": {
                "variable": {
                    "value": "rmse_test",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_target",
                    "possible_values": [
                        [
                            "np.ravel(np.array(test_data.target))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data.target))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data.target))",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "test_pred",
                    "possible_values": [
                        [
                            "pipeline.predict(input_data=test_data)",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_pred.predict))",
                            "Call"
                        ],
                        [
                            "pipeline.predict(input_data=test_data)",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_pred.predict))",
                            "Call"
                        ],
                        [
                            "pipeline.predict(input_data=test_data)",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_pred.predict))",
                            "Call"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_squared_error_192": {
                "variable": {
                    "value": "rmse_test",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_target",
                    "possible_values": [
                        [
                            "np.ravel(np.array(test_data.target))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data.target))",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_data.target))",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "test_pred",
                    "possible_values": [
                        [
                            "pipeline.predict(input_data=test_data)",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_pred.predict))",
                            "Call"
                        ],
                        [
                            "pipeline.predict(input_data=test_data)",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_pred.predict))",
                            "Call"
                        ],
                        [
                            "pipeline.predict(input_data=test_data)",
                            "Call"
                        ],
                        [
                            "np.ravel(np.array(test_pred.predict))",
                            "Call"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "mean_absolute_error_235": {
                "variable": {
                    "value": "mae",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_part",
                    "possible_values": [
                        [
                            "time_series[-len_forecast:]",
                            "Subscript"
                        ],
                        [
                            "np.ravel(np.array(test_part))",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "pipeline_forecast",
                    "possible_values": [
                        [
                            "np.ravel(np.array(predicted_values.predict))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "test/unit/tasks/test_gapfilling.py": {
        "sklearn": {
            "mean_squared_error_49": {
                "variable": {
                    "value": "rmse_test",
                    "possible_values": []
                },
                "y_true": {
                    "value": "true_values",
                    "possible_values": [
                        [
                            "real_values[id_gaps]",
                            "Subscript"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "predicted_values",
                    "possible_values": [
                        [
                            "without_gap[id_gaps]",
                            "Subscript"
                        ]
                    ]
                },
                "squared": {
                    "value": "False",
                    "possible_values": []
                }
            }
        }
    },
    "test/unit/tasks/test_regression.py": {
        "sklearn": {
            "make_regression_48": {
                "variable": {
                    "value": "synthetic_data",
                    "possible_values": []
                },
                "n_samples": {
                    "value": "n_samples",
                    "possible_values": [
                        [
                            "1000",
                            "MethodArgument"
                        ]
                    ]
                },
                "n_features": {
                    "value": "n_features",
                    "possible_values": [
                        [
                            "10",
                            "MethodArgument"
                        ]
                    ]
                },
                "random_state": {
                    "value": "random_state",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            }
        }
    },
    "test/unit/utilities/test_pipeline_import_export.py": {
        "sklearn": {
            "mean_absolute_error_430": {
                "variable": {
                    "value": "mae_before",
                    "possible_values": []
                },
                "y_true": {
                    "value": "mixed_input.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "before_output.predict",
                    "possible_values": []
                }
            },
            "mean_absolute_error_438": {
                "variable": {
                    "value": "mae_after",
                    "possible_values": []
                },
                "y_true": {
                    "value": "mixed_input.target",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "after_output.predict",
                    "possible_values": []
                }
            }
        }
    },
    "test/unit/validation/test_table_cv.py": {
        "sklearn": {}
    },
    "test/unit/validation/test_time_series_cv.py": {
        "sklearn": {}
    }
}