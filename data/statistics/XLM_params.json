{
    "xlm/evaluation/glue.py": {
        "sklearn": {
            "f1_score_246": {
                "y_true": {
                    "value": "gold",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.concatenate(gold)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.concatenate(pred)",
                            "Call"
                        ]
                    ]
                },
                "average": {
                    "value": "binary if params.out_features == 2 else micro",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "matthews_corrcoef_247": {
                "y_true": {
                    "value": "gold",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.concatenate(gold)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.concatenate(pred)",
                            "Call"
                        ]
                    ]
                }
            }
        },
        "torch": {
            "Sequential_91": {
                "variable": {
                    "value": "self.proj",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "*[nn.Dropout(params.dropout), nn.Linear(self.embedder.out_dim, params.out_features)]",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "cross_entropy_158": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.proj(self.embedder.get_embeddings(x, lengths, positions=None, langs=None))",
                            "Call"
                        ],
                        [
                            "self.proj(self.embedder.get_embeddings(x, lengths, positions=None, langs=None))",
                            "Call"
                        ]
                    ]
                },
                "target": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.data['train']['y'][idx]",
                            "Subscript"
                        ],
                        [
                            "to_cuda(x, y, lengths)",
                            "Call"
                        ],
                        [
                            "self.data[splt]['y'][idx] if has_labels else None",
                            "IfExp"
                        ],
                        [
                            "to_cuda(x, y, lengths)",
                            "Call"
                        ],
                        [
                            "[float(l) for l in lines]",
                            "ListComp"
                        ],
                        [
                            "[lab2id.get(x, UNK_LABEL) for x in lines]",
                            "ListComp"
                        ],
                        [
                            "[lab2id[x] for x in lines]",
                            "ListComp"
                        ]
                    ]
                },
                "weight": {
                    "value": "self.weights",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "mse_loss_160": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output.squeeze(1)",
                    "type": "Call",
                    "possible_values": []
                },
                "target": {
                    "value": "y.float()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "no_grad_112": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Dropout_92": {
                "p": {
                    "value": "params.dropout",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_93": {
                "in_features": {
                    "value": "self.embedder.out_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "params.out_features",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "translate.py": {
        "torch": {
            "load_65": {
                "variable": {
                    "value": "reloaded",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "params.model_path",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "no_grad_140": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "xlm/data/dataset.py": {
        "torch": {
            "from_numpy_75": {
                "ndarray": {
                    "value": "self.data[a:b].astype(np.int64)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "from_numpy_128": {
                "ndarray": {
                    "value": "s.astype(np.int64)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "xlm/data/dictionary.py": {
        "torch": {
            "load_172": {
                "variable": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "bin_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bin_path",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "save_226": {
                "obj": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.load(bin_path)",
                            "Call"
                        ],
                        [
                            "{'dico': dico, 'positions': positions, 'sentences': sentences, 'unk_words': unk_words}",
                            "Dict"
                        ]
                    ]
                },
                "f": {
                    "value": "bin_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bin_path",
                            "Method Argument"
                        ]
                    ]
                },
                "pickle_protocol": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "xlm/data/loader.py": {
        "torch": {
            "load_68": {
                "variable": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "path.replace('train', 'valid')",
                            "Call"
                        ],
                        [
                            "split_path",
                            "variable"
                        ],
                        [
                            "path",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "xlm/evaluation/evaluator.py": {
        "torch": {
            "from_numpy_206": {
                "variable": {
                    "value": "pred_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "to_predict.astype(np.uint8)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "arange_294": {
                "variable": {
                    "value": "alen",
                    "type": "variable",
                    "possible_values": []
                },
                "start": {
                    "value": "lengths.max()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.long",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "lengths.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "arange_458": {
                "variable": {
                    "value": "alen",
                    "type": "variable",
                    "possible_values": []
                },
                "start": {
                    "value": "len2.max()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.long",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "len2.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "no_grad_226": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "xlm/evaluation/xnli.py": {
        "torch": {
            "Sequential_71": {
                "variable": {
                    "value": "self.proj",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "*[nn.Dropout(params.dropout), nn.Linear(self.embedder.out_dim, 3)]",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "cross_entropy_138": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.proj(self.embedder.get_embeddings(x, lengths, positions, langs))",
                            "Call"
                        ],
                        [
                            "self.proj(self.embedder.get_embeddings(x, lengths, positions, langs))",
                            "Call"
                        ]
                    ]
                },
                "target": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.data['en']['train']['y'][idx]",
                            "Subscript"
                        ],
                        [
                            "to_cuda(x, y, lengths, positions, langs)",
                            "Call"
                        ],
                        [
                            "self.data[lang][splt]['y'][idx]",
                            "Subscript"
                        ],
                        [
                            "to_cuda(x, y, lengths, positions, langs)",
                            "Call"
                        ]
                    ]
                }
            },
            "no_grad_92": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Dropout_72": {
                "p": {
                    "value": "params.dropout",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_73": {
                "in_features": {
                    "value": "self.embedder.out_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "xlm/model/__init__.py": {
        "torch": {
            "no_grad_94": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "load_160": {
                "variable": {
                    "value": "enc_reload",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "enc_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "params.reload_model.split(',')",
                            "Call"
                        ]
                    ]
                },
                "map_location": {
                    "value": "lambda storage, loc: storage.cuda(params.local_rank)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "load_169": {
                "variable": {
                    "value": "dec_reload",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "dec_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "params.reload_model.split(',')",
                            "Call"
                        ]
                    ]
                },
                "map_location": {
                    "value": "lambda storage, loc: storage.cuda(params.local_rank)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "load_122": {
                "f": {
                    "value": "params.reload_model",
                    "type": "Attribute",
                    "possible_values": []
                },
                "map_location": {
                    "value": "lambda storage, loc: storage.cuda(params.local_rank)",
                    "type": "Lambda",
                    "possible_values": []
                }
            }
        }
    },
    "xlm/model/embedder.py": {
        "torch": {
            "load_27": {
                "variable": {
                    "value": "reloaded",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "path",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "xlm/model/memory/memory.py": {
        "torch": {
            "EmbeddingBag_79": {
                "variable": {
                    "value": "self.values",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "self.size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "self.v_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "mode": {
                    "value": "sum",
                    "type": "str",
                    "possible_values": []
                },
                "sparse": {
                    "value": "params.mem_sparse",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_157": {
                "variable": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input.detach()",
                            "Call"
                        ],
                        [
                            "F.dropout(input, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "input",
                            "Method Argument"
                        ]
                    ]
                },
                "p": {
                    "value": "self.input_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_159": {
                "variable": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.query_proj(input)",
                            "Call"
                        ],
                        [
                            "F.dropout(query, p=self.query_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "query / query.norm(2, 1, keepdim=True).expand_as(query)",
                            "BinOp"
                        ],
                        [
                            "query.view(-1, self.heads, self.k_dim)",
                            "Call"
                        ],
                        [
                            "query.view(-1, self.heads, self.k_dim)",
                            "Call"
                        ],
                        [
                            "query",
                            "Method Argument"
                        ],
                        [
                            "query",
                            "Method Argument"
                        ],
                        [
                            "query",
                            "Method Argument"
                        ],
                        [
                            "query",
                            "Method Argument"
                        ],
                        [
                            "query",
                            "Method Argument"
                        ],
                        [
                            "query",
                            "Method Argument"
                        ],
                        [
                            "query",
                            "Method Argument"
                        ]
                    ]
                },
                "p": {
                    "value": "self.query_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_202": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.values(indices, per_sample_weights=scores.to(self.values.weight.data)).to(scores)",
                            "Call"
                        ],
                        [
                            "F.dropout(output, p=self.value_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "output.view(n_images, width, height, self.v_dim)",
                            "Call"
                        ],
                        [
                            "output.transpose(1, 3)",
                            "Call"
                        ],
                        [
                            "output.view(prefix_shape + (self.v_dim,))",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.value_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "linear_491": {
                "variable": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.query_proj(input)",
                            "Call"
                        ],
                        [
                            "F.dropout(query, p=self.query_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "query / query.norm(2, 1, keepdim=True).expand_as(query)",
                            "BinOp"
                        ],
                        [
                            "query.view(-1, self.heads, self.k_dim)",
                            "Call"
                        ],
                        [
                            "query.view(-1, self.heads, self.k_dim)",
                            "Call"
                        ],
                        [
                            "query",
                            "Method Argument"
                        ],
                        [
                            "query",
                            "Method Argument"
                        ],
                        [
                            "query",
                            "Method Argument"
                        ],
                        [
                            "query",
                            "Method Argument"
                        ],
                        [
                            "query",
                            "Method Argument"
                        ],
                        [
                            "query",
                            "Method Argument"
                        ],
                        [
                            "query",
                            "Method Argument"
                        ]
                    ]
                },
                "weight": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.FloatTensor(2 ** self.k_dim, self.k_dim)",
                            "Call"
                        ],
                        [
                            "keys / math.sqrt(self.k_dim)",
                            "BinOp"
                        ],
                        [
                            "torch.from_numpy(np.array([init(self.n_indices, self.k_dim, self.keys_normalized_init, seed=i) for i in range(self.heads)])).view(self.heads, self.n_indices, self.k_dim)",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(init(self.n_indices, self.k_dim, self.keys_normalized_init, seed=0))",
                            "Call"
                        ],
                        [
                            "torch.FloatTensor(2 ** half, half)",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(np.array([init(n_keys, half, self.keys_normalized_init, seed=2 * i + j) for i in range(self.heads) for j in range(2)])).view(self.heads, 2, n_keys, half)",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(init(n_keys, half, self.keys_normalized_init, seed=0))",
                            "Call"
                        ],
                        [
                            "self.create_keys()",
                            "Call"
                        ],
                        [
                            "keys",
                            "Method Argument"
                        ],
                        [
                            "keys",
                            "Method Argument"
                        ]
                    ]
                },
                "bias": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "linear_660": {
                "variable": {
                    "value": "scores1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "q1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "query[:, :half]",
                            "Subscript"
                        ],
                        [
                            "q1 / q1.norm(2, 1, keepdim=True).expand_as(q1)",
                            "BinOp"
                        ],
                        [
                            "query[:, :half]",
                            "Subscript"
                        ],
                        [
                            "q1 / q1.norm(2, 1, keepdim=True).expand_as(q1)",
                            "BinOp"
                        ]
                    ]
                },
                "weight": {
                    "value": "keys1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "keys1",
                            "Method Argument"
                        ],
                        [
                            "keys1",
                            "Method Argument"
                        ]
                    ]
                },
                "bias": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "linear_661": {
                "variable": {
                    "value": "scores2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "q2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "query[:, half:]",
                            "Subscript"
                        ],
                        [
                            "q2 / q2.norm(2, 1, keepdim=True).expand_as(q2)",
                            "BinOp"
                        ],
                        [
                            "query[:, half:]",
                            "Subscript"
                        ],
                        [
                            "q2 / q2.norm(2, 1, keepdim=True).expand_as(q2)",
                            "BinOp"
                        ]
                    ]
                },
                "weight": {
                    "value": "keys2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "keys2",
                            "Method Argument"
                        ],
                        [
                            "keys2",
                            "Method Argument"
                        ]
                    ]
                },
                "bias": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "topk_678": {
                "variable": {
                    "value": "(scores, best_indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "all_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "concat_scores.sum(2)",
                            "Call"
                        ],
                        [
                            "(scores1.view(bs, knn, 1).expand(bs, knn, knn) + scores2.view(bs, 1, knn).expand(bs, knn, knn)).view(bs, -1)",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "knn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "knn",
                            "Method Argument"
                        ],
                        [
                            "knn",
                            "Method Argument"
                        ],
                        [
                            "knn",
                            "Method Argument"
                        ],
                        [
                            "knn",
                            "Method Argument"
                        ],
                        [
                            "knn",
                            "Method Argument"
                        ],
                        [
                            "knn",
                            "Method Argument"
                        ],
                        [
                            "knn",
                            "Method Argument"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "largest": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "sorted": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cat_169": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_indices(query, self.knn)",
                            "Call"
                        ],
                        [
                            "indices.view(bs, self.heads, -1).chunk(self.heads, 1)",
                            "Call"
                        ],
                        [
                            "[p[idx] for (p, idx) in zip(self.head_permutations, indices)]",
                            "ListComp"
                        ],
                        [
                            "torch.cat(indices, 1).view(bs * self.heads, -1)",
                            "Call"
                        ],
                        [
                            "indices % self.modulo_size",
                            "BinOp"
                        ],
                        [
                            "indices.view(bs, self.heads * self.knn)",
                            "Call"
                        ],
                        [
                            "scores.topk(knn, dim=1, largest=True, sorted=True)",
                            "Call"
                        ],
                        [
                            "torch.cat([idx.unsqueeze(1) for (_, idx) in outputs], 1).view(bs, knn)",
                            "Call"
                        ],
                        [
                            "all_indices.gather(1, best_indices)",
                            "Call"
                        ],
                        [
                            "torch.cat([idx.unsqueeze(1) for (_, idx) in outputs], 1).view(bs, knn)",
                            "Call"
                        ],
                        [
                            "all_indices.gather(1, best_indices)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_179": {
                "variable": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "scores.float()",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Parameter_445": {
                "variable": {
                    "value": "self.keys",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.FloatTensor(2 ** self.k_dim, self.k_dim)",
                            "Call"
                        ],
                        [
                            "keys / math.sqrt(self.k_dim)",
                            "BinOp"
                        ],
                        [
                            "torch.from_numpy(np.array([init(self.n_indices, self.k_dim, self.keys_normalized_init, seed=i) for i in range(self.heads)])).view(self.heads, self.n_indices, self.k_dim)",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(init(self.n_indices, self.k_dim, self.keys_normalized_init, seed=0))",
                            "Call"
                        ],
                        [
                            "torch.FloatTensor(2 ** half, half)",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(np.array([init(n_keys, half, self.keys_normalized_init, seed=2 * i + j) for i in range(self.heads) for j in range(2)])).view(self.heads, 2, n_keys, half)",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(init(n_keys, half, self.keys_normalized_init, seed=0))",
                            "Call"
                        ],
                        [
                            "self.create_keys()",
                            "Call"
                        ],
                        [
                            "keys",
                            "Method Argument"
                        ],
                        [
                            "keys",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cat_513": {
                "variable": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[s.unsqueeze(1) for (s, _) in outputs]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_514": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[idx.unsqueeze(1) for (_, idx) in outputs]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Parameter_566": {
                "variable": {
                    "value": "self.keys",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.FloatTensor(2 ** self.k_dim, self.k_dim)",
                            "Call"
                        ],
                        [
                            "keys / math.sqrt(self.k_dim)",
                            "BinOp"
                        ],
                        [
                            "torch.from_numpy(np.array([init(self.n_indices, self.k_dim, self.keys_normalized_init, seed=i) for i in range(self.heads)])).view(self.heads, self.n_indices, self.k_dim)",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(init(self.n_indices, self.k_dim, self.keys_normalized_init, seed=0))",
                            "Call"
                        ],
                        [
                            "torch.FloatTensor(2 ** half, half)",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(np.array([init(n_keys, half, self.keys_normalized_init, seed=2 * i + j) for i in range(self.heads) for j in range(2)])).view(self.heads, 2, n_keys, half)",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(init(n_keys, half, self.keys_normalized_init, seed=0))",
                            "Call"
                        ],
                        [
                            "self.create_keys()",
                            "Call"
                        ],
                        [
                            "keys",
                            "Method Argument"
                        ],
                        [
                            "keys",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "topk_602": {
                "variable": {
                    "value": "(_scores, best_indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "all_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "concat_scores.sum(2)",
                            "Call"
                        ],
                        [
                            "(scores1.view(bs, knn, 1).expand(bs, knn, knn) + scores2.view(bs, 1, knn).expand(bs, knn, knn)).view(bs, -1)",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "knn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "knn",
                            "Method Argument"
                        ],
                        [
                            "knn",
                            "Method Argument"
                        ],
                        [
                            "knn",
                            "Method Argument"
                        ],
                        [
                            "knn",
                            "Method Argument"
                        ],
                        [
                            "knn",
                            "Method Argument"
                        ],
                        [
                            "knn",
                            "Method Argument"
                        ],
                        [
                            "knn",
                            "Method Argument"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "largest": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "sorted": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cat_630": {
                "variable": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[s.unsqueeze(1) for (s, _) in outputs]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_631": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[idx.unsqueeze(1) for (_, idx) in outputs]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "from_numpy_436": {
                "variable": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "np.array([init(self.n_indices, self.k_dim, self.keys_normalized_init, seed=i) for i in range(self.heads)])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "from_numpy_441": {
                "variable": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "init(self.n_indices, self.k_dim, self.keys_normalized_init, seed=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "from_numpy_548": {
                "variable": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "np.array([init(n_keys, half, self.keys_normalized_init, seed=2 * i + j) for i in range(self.heads) for j in range(2)])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "from_numpy_554": {
                "variable": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "init(n_keys, half, self.keys_normalized_init, seed=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "no_grad_589": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "randperm_130": {
                "n": {
                    "value": "self.n_indices",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "unsqueeze_130": {
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_131": {
                "tensors": {
                    "value": "head_permutations",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[torch.randperm(self.n_indices).unsqueeze(0) for i in range(self.heads)]",
                            "ListComp"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "xlm/model/memory/query.py": {
        "torch": {
            "Sequential_25": {
                "*args": {
                    "value": "*layers",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "Sequential_56": {
                "*args": {
                    "value": "*layers",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "Conv1d_70": {
                "variable": {
                    "value": "self.layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "in_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "in_features",
                            "Method Argument"
                        ]
                    ]
                },
                "out_channels": {
                    "value": "out_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "out_features",
                            "Method Argument"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "groups": {
                    "value": "groups",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Conv2d_90": {
                "variable": {
                    "value": "self.conv1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "input_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_channels",
                            "Method Argument"
                        ]
                    ]
                },
                "out_channels": {
                    "value": "hidden_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "min(input_channels, output_channels)",
                            "Call"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kernel_size",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "[k // 2 for k in kernel_size]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "bias": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                },
                "groups": {
                    "value": "groups",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Conv2d_91": {
                "variable": {
                    "value": "self.conv2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "hidden_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "min(input_channels, output_channels)",
                            "Call"
                        ]
                    ]
                },
                "out_channels": {
                    "value": "output_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "output_channels",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kernel_size",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "[k // 2 for k in kernel_size]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "bias": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                },
                "groups": {
                    "value": "groups",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ReLU_92": {
                "variable": {
                    "value": "self.act",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "BatchNorm2d_96": {
                "variable": {
                    "value": "self.bn1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_features": {
                    "value": "hidden_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "min(input_channels, output_channels)",
                            "Call"
                        ]
                    ]
                }
            },
            "BatchNorm2d_97": {
                "variable": {
                    "value": "self.bn2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_features": {
                    "value": "output_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "output_channels",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Sequential_100": {
                "variable": {
                    "value": "self.residual",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Conv2d_102": {
                "variable": {
                    "value": "self.residual",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "input_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_channels",
                            "Method Argument"
                        ]
                    ]
                },
                "out_channels": {
                    "value": "output_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "output_channels",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "(1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "groups": {
                    "value": "groups",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cat_143": {
                "variable": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[input[:, a:b] for head_id in range(self.heads) for (a, b) in self.slices[head_id]]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ModuleList_181": {
                "variable": {
                    "value": "self.query_mlps",
                    "type": "Attribute",
                    "possible_values": []
                },
                "modules": {
                    "value": "[mlp(sizes, bias=bias, batchnorm=batchnorm, groups=1) for _ in range(self.groups)]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "ModuleList_234": {
                "variable": {
                    "value": "self.query_convs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "modules": {
                    "value": "[convs(sizes, kernel_sizes, bias=bias, batchnorm=batchnorm, residual=residual, groups=1) for _ in range(self.groups)]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "Linear_17": {
                "in_features": {
                    "value": "dim_in",
                    "type": "variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "groups * dim_out",
                    "type": "BinOp",
                    "possible_values": []
                },
                "bias": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "BatchNorm1d_21": {
                "num_features": {
                    "value": "groups * dim_out",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ReLU_23": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Conv2d_43": {
                "in_channels": {
                    "value": "_dim_in",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dim_in * in_group",
                            "BinOp"
                        ]
                    ]
                },
                "out_channels": {
                    "value": "_dim_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dim_out * groups",
                            "BinOp"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "ks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(kernel_sizes[i], kernel_sizes[i])",
                            "Tuple"
                        ]
                    ]
                },
                "padding": {
                    "value": "[k // 2 for k in ks]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "bias": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                },
                "groups": {
                    "value": "in_group",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 if i == 0 else groups",
                            "IfExp"
                        ]
                    ]
                }
            },
            "cat_198": {
                "tensors": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[m(input) for m in self.query_mlps]",
                            "ListComp"
                        ],
                        [
                            "[m(input) for m in self.query_convs]",
                            "ListComp"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_248": {
                "tensors": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[m(input) for m in self.query_mlps]",
                            "ListComp"
                        ],
                        [
                            "[m(input) for m in self.query_convs]",
                            "ListComp"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_45": {
                "num_features": {
                    "value": "_dim_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dim_out * groups",
                            "BinOp"
                        ]
                    ]
                }
            },
            "ReLU_47": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Conv2d_54": {
                "in_channels": {
                    "value": "_dim_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dim_out * groups",
                            "BinOp"
                        ]
                    ]
                },
                "out_channels": {
                    "value": "_dim_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dim_out * groups",
                            "BinOp"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "(1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "bias": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "xlm/model/memory/utils.py": {
        "torch": {
            "empty_140": {
                "variable": {
                    "value": "D",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "nq",
                    "type": "variable",
                    "possible_values": [
                        [
                            "xq.size()",
                            "Call"
                        ]
                    ]
                },
                "out": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": [
                        [
                            "k",
                            "Method Argument"
                        ],
                        [
                            "k",
                            "Method Argument"
                        ]
                    ]
                },
                "device": {
                    "value": "xb.device",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "empty_141": {
                "variable": {
                    "value": "I",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "nq",
                    "type": "variable",
                    "possible_values": [
                        [
                            "xq.size()",
                            "Call"
                        ]
                    ]
                },
                "out": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": [
                        [
                            "k",
                            "Method Argument"
                        ],
                        [
                            "k",
                            "Method Argument"
                        ]
                    ]
                },
                "device": {
                    "value": "xb.device",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cat_66": {
                "tensors": {
                    "value": "[a.unsqueeze(-1).repeat(1, 1, d2).unsqueeze(-1), b.repeat(1, d1).view(n2, d1, d2).unsqueeze(-1)]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "no_grad_101": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "xlm/model/pretrain.py": {
        "torch": {
            "from_numpy_63": {
                "variable": {
                    "value": "embeddings",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.concatenate(vectors, 0)",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(embeddings).float()",
                            "Call"
                        ],
                        [
                            "np.concatenate([model.get_word_vector(w)[None] for w in words], 0)",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(embeddings).float()",
                            "Call"
                        ]
                    ]
                }
            },
            "from_numpy_80": {
                "variable": {
                    "value": "embeddings",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.concatenate(vectors, 0)",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(embeddings).float()",
                            "Call"
                        ],
                        [
                            "np.concatenate([model.get_word_vector(w)[None] for w in words], 0)",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(embeddings).float()",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "xlm/model/transformer.py": {
        "torch": {
            "Embedding_45": {
                "variable": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "num_embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_embeddings",
                            "Method Argument"
                        ]
                    ]
                },
                "embedding_dim": {
                    "value": "embedding_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embedding_dim",
                            "Method Argument"
                        ]
                    ]
                },
                "padding_idx": {
                    "value": "padding_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Linear_53": {
                "variable": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": []
                },
                "in_features": {
                    "value": "in_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "in_features",
                            "Method Argument"
                        ]
                    ]
                },
                "out_features": {
                    "value": "out_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "out_features",
                            "Method Argument"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "arange_88": {
                "variable": {
                    "value": "alen",
                    "type": "variable",
                    "possible_values": []
                },
                "start": {
                    "value": "slen",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.size()",
                            "Call"
                        ],
                        [
                            "slen",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "torch.long",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "lengths.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_210": {
                "variable": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "q",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape(self.q_lin(input))",
                            "Call"
                        ],
                        [
                            "q / math.sqrt(dim_per_head)",
                            "BinOp"
                        ]
                    ]
                },
                "other": {
                    "value": "k.transpose(2, 3)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_214": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "scores.float()",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "dropout_215": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.softmax(scores.float(), dim=-1).type_as(scores)",
                            "Call"
                        ],
                        [
                            "F.dropout(weights, p=self.dropout, training=self.training)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_216": {
                "variable": {
                    "value": "context",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.softmax(scores.float(), dim=-1).type_as(scores)",
                            "Call"
                        ],
                        [
                            "F.dropout(weights, p=self.dropout, training=self.training)",
                            "Call"
                        ]
                    ]
                },
                "other": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape(self.v_lin(input))",
                            "Call"
                        ],
                        [
                            "shape(self.v_lin(v))",
                            "Call"
                        ],
                        [
                            "torch.cat([v_, v], dim=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "dropout_235": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.lin1(input)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "self.lin2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "x[:, -_slen:]",
                            "Subscript"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "LayerNorm_282": {
                "variable": {
                    "value": "self.layer_norm_emb",
                    "type": "Attribute",
                    "possible_values": []
                },
                "normalized_shape": {
                    "value": "self.dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "eps": {
                    "value": "1e-12",
                    "type": "float",
                    "possible_values": []
                }
            },
            "ModuleList_285": {
                "variable": {
                    "value": "self.attentions",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ModuleList_286": {
                "variable": {
                    "value": "self.layer_norm1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ModuleList_287": {
                "variable": {
                    "value": "self.ffns",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ModuleList_288": {
                "variable": {
                    "value": "self.layer_norm2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ModuleDict_294": {
                "variable": {
                    "value": "self.memories",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "dropout_388": {
                "variable": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.embeddings(x)",
                            "Call"
                        ],
                        [
                            "tensor + self.position_embeddings(positions).expand_as(tensor)",
                            "BinOp"
                        ],
                        [
                            "tensor + self.lang_embeddings(langs)",
                            "BinOp"
                        ],
                        [
                            "self.layer_norm_emb(tensor)",
                            "Call"
                        ],
                        [
                            "F.dropout(tensor, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "tensor * mask.unsqueeze(-1).to(tensor.dtype)",
                            "BinOp"
                        ],
                        [
                            "tensor + attn",
                            "BinOp"
                        ],
                        [
                            "self.layer_norm1[i](tensor)",
                            "Call"
                        ],
                        [
                            "tensor + attn",
                            "BinOp"
                        ],
                        [
                            "self.layer_norm15[i](tensor)",
                            "Call"
                        ],
                        [
                            "tensor.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "tensor + self.memories['%i_in' % i](tensor)",
                            "BinOp"
                        ],
                        [
                            "tensor + self.ffns[i](tensor)",
                            "BinOp"
                        ],
                        [
                            "self.layer_norm2[i](tensor)",
                            "Call"
                        ],
                        [
                            "tensor + self.memories['%i_after' % i](tensor)",
                            "BinOp"
                        ],
                        [
                            "self.forward('fwd', x=generated[:cur_len], lengths=gen_len, positions=positions[:cur_len], langs=langs[:cur_len], causal=True, src_enc=src_enc, src_len=src_len, cache=cache)",
                            "Call"
                        ],
                        [
                            "tensor.data[-1, :, :].type_as(src_enc)",
                            "Call"
                        ],
                        [
                            "self.forward('fwd', x=generated[:cur_len], lengths=src_len.new(bs * beam_size).fill_(cur_len), positions=positions[:cur_len], langs=langs[:cur_len], causal=True, src_enc=src_enc, src_len=src_len, cache=cache)",
                            "Call"
                        ],
                        [
                            "tensor.data[-1, :, :]",
                            "Subscript"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "arange_471": {
                "variable": {
                    "value": "positions",
                    "type": "variable",
                    "possible_values": []
                },
                "start": {
                    "value": "max_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "200",
                            "Method Argument"
                        ],
                        [
                            "200",
                            "Method Argument"
                        ],
                        [
                            "max_len",
                            "Method Argument"
                        ]
                    ]
                },
                "out": {
                    "value": "positions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.new(slen).long()",
                            "Call"
                        ],
                        [
                            "torch.arange(slen, out=positions).unsqueeze(0)",
                            "Call"
                        ],
                        [
                            "positions.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "positions[:, -_slen:]",
                            "Subscript"
                        ],
                        [
                            "src_len.new(max_len).long()",
                            "Call"
                        ],
                        [
                            "torch.arange(max_len, out=positions).unsqueeze(1).expand(max_len, bs)",
                            "Call"
                        ],
                        [
                            "src_len.new(max_len).long()",
                            "Call"
                        ],
                        [
                            "torch.arange(max_len, out=positions).unsqueeze(1).expand_as(generated)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "unsqueeze_471": {
                "variable": {
                    "value": "positions",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "arange_569": {
                "variable": {
                    "value": "positions",
                    "type": "variable",
                    "possible_values": []
                },
                "start": {
                    "value": "max_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "200",
                            "Method Argument"
                        ],
                        [
                            "200",
                            "Method Argument"
                        ],
                        [
                            "max_len",
                            "Method Argument"
                        ]
                    ]
                },
                "out": {
                    "value": "positions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.new(slen).long()",
                            "Call"
                        ],
                        [
                            "torch.arange(slen, out=positions).unsqueeze(0)",
                            "Call"
                        ],
                        [
                            "positions.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "positions[:, -_slen:]",
                            "Subscript"
                        ],
                        [
                            "src_len.new(max_len).long()",
                            "Call"
                        ],
                        [
                            "torch.arange(max_len, out=positions).unsqueeze(1).expand(max_len, bs)",
                            "Call"
                        ],
                        [
                            "src_len.new(max_len).long()",
                            "Call"
                        ],
                        [
                            "torch.arange(max_len, out=positions).unsqueeze(1).expand_as(generated)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "unsqueeze_569": {
                "variable": {
                    "value": "positions",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "AdaptiveLogSoftmaxWithLoss_118": {
                "variable": {
                    "value": "self.proj",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "params.emb_dim",
                            "Attribute"
                        ],
                        [
                            "input.size()",
                            "Call"
                        ],
                        [
                            "dim",
                            "Method Argument"
                        ],
                        [
                            "dim",
                            "Method Argument"
                        ]
                    ]
                },
                "n_classes": {
                    "value": "params.n_words",
                    "type": "Attribute",
                    "possible_values": []
                },
                "cutoffs": {
                    "value": "params.asm_cutoffs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "div_value": {
                    "value": "params.asm_div_value",
                    "type": "Attribute",
                    "possible_values": []
                },
                "head_bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cross_entropy_134": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.proj(x).view(-1, self.n_words)",
                            "Call"
                        ],
                        [
                            "self.proj.log_prob(x) if get_scores else None",
                            "IfExp"
                        ],
                        [
                            "torch.matmul(q, k.transpose(2, 3))",
                            "Call"
                        ],
                        [
                            "self.pred_layer(masked_tensor, y, get_scores)",
                            "Call"
                        ],
                        [
                            "self.pred_layer.get_scores(tensor)",
                            "Call"
                        ],
                        [
                            "self.pred_layer.get_scores(tensor)",
                            "Call"
                        ],
                        [
                            "F.log_softmax(scores, dim=-1)",
                            "Call"
                        ]
                    ]
                },
                "target": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "y",
                            "Method Argument"
                        ],
                        [
                            "y",
                            "Method Argument"
                        ]
                    ]
                },
                "reduction": {
                    "value": "mean",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ModuleList_290": {
                "variable": {
                    "value": "self.layer_norm15",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ModuleList_291": {
                "variable": {
                    "value": "self.encoder_attn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "arange_362": {
                "variable": {
                    "value": "positions",
                    "type": "variable",
                    "possible_values": []
                },
                "start": {
                    "value": "slen",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.size()",
                            "Call"
                        ],
                        [
                            "slen",
                            "Method Argument"
                        ]
                    ]
                },
                "out": {
                    "value": "positions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.new(slen).long()",
                            "Call"
                        ],
                        [
                            "torch.arange(slen, out=positions).unsqueeze(0)",
                            "Call"
                        ],
                        [
                            "positions.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "positions[:, -_slen:]",
                            "Subscript"
                        ],
                        [
                            "src_len.new(max_len).long()",
                            "Call"
                        ],
                        [
                            "torch.arange(max_len, out=positions).unsqueeze(1).expand(max_len, bs)",
                            "Call"
                        ],
                        [
                            "src_len.new(max_len).long()",
                            "Call"
                        ],
                        [
                            "torch.arange(max_len, out=positions).unsqueeze(1).expand_as(generated)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "unsqueeze_362": {
                "variable": {
                    "value": "positions",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dropout_396": {
                "variable": {
                    "value": "attn",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.attentions[i](tensor, attn_mask, cache=cache)",
                            "Call"
                        ],
                        [
                            "F.dropout(attn, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.encoder_attn[i](tensor, src_mask, kv=src_enc, cache=cache)",
                            "Call"
                        ],
                        [
                            "F.dropout(attn, p=self.dropout, training=self.training)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "log_softmax_605": {
                "variable": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.proj(x).view(-1, self.n_words)",
                            "Call"
                        ],
                        [
                            "self.proj.log_prob(x) if get_scores else None",
                            "IfExp"
                        ],
                        [
                            "torch.matmul(q, k.transpose(2, 3))",
                            "Call"
                        ],
                        [
                            "self.pred_layer(masked_tensor, y, get_scores)",
                            "Call"
                        ],
                        [
                            "self.pred_layer.get_scores(tensor)",
                            "Call"
                        ],
                        [
                            "self.pred_layer.get_scores(tensor)",
                            "Call"
                        ],
                        [
                            "F.log_softmax(scores, dim=-1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "topk_612": {
                "variable": {
                    "value": "(next_scores, next_words)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scores + beam_scores[:, None].expand_as(scores)",
                            "BinOp"
                        ],
                        [
                            "_scores.view(bs, beam_size * n_words)",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "2 * beam_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "largest": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "sorted": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "erf_79": {
                "input": {
                    "value": "x / math.sqrt(2.0)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "dropout_403": {
                "variable": {
                    "value": "attn",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.attentions[i](tensor, attn_mask, cache=cache)",
                            "Call"
                        ],
                        [
                            "F.dropout(attn, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.encoder_attn[i](tensor, src_mask, kv=src_enc, cache=cache)",
                            "Call"
                        ],
                        [
                            "F.dropout(attn, p=self.dropout, training=self.training)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "squeeze_505": {
                "variable": {
                    "value": "next_words",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multinomial_507": {
                "variable": {
                    "value": "next_words",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "F.softmax(scores / sample_temperature, dim=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "num_samples": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_507": {
                "variable": {
                    "value": "next_words",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_203": {
                "variable": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[k_, k]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_204": {
                "variable": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[v_, v]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "LayerNorm_304": {
                "normalized_shape": {
                    "value": "self.dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "eps": {
                    "value": "1e-12",
                    "type": "float",
                    "possible_values": []
                }
            },
            "LayerNorm_312": {
                "normalized_shape": {
                    "value": "self.dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "eps": {
                    "value": "1e-12",
                    "type": "float",
                    "possible_values": []
                }
            },
            "arange_357": {
                "start": {
                    "value": "src_len.max()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.long",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "lengths.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "LayerNorm_306": {
                "normalized_shape": {
                    "value": "self.dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "eps": {
                    "value": "1e-12",
                    "type": "float",
                    "possible_values": []
                }
            },
            "topk_505": {
                "input": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.proj(x).view(-1, self.n_words)",
                            "Call"
                        ],
                        [
                            "self.proj.log_prob(x) if get_scores else None",
                            "IfExp"
                        ],
                        [
                            "torch.matmul(q, k.transpose(2, 3))",
                            "Call"
                        ],
                        [
                            "self.pred_layer(masked_tensor, y, get_scores)",
                            "Call"
                        ],
                        [
                            "self.pred_layer.get_scores(tensor)",
                            "Call"
                        ],
                        [
                            "self.pred_layer.get_scores(tensor)",
                            "Call"
                        ],
                        [
                            "F.log_softmax(scores, dim=-1)",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_507": {
                "input": {
                    "value": "scores / sample_temperature",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "xlm/optim.py": {
        "torch": {
            "zeros_like_39": {
                "variable": {
                    "value": "state[exp_avg]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "p.data",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_40": {
                "variable": {
                    "value": "state[exp_avg_sq]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "p.data",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "xlm/slurm.py": {
        "torch": {
            "set_device_154": {
                "device": {
                    "value": "params.local_rank",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "xlm/trainer.py": {
        "torch": {
            "multinomial_460": {
                "variable": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "params.pred_probs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_samples": {
                    "value": "len(_x_real)",
                    "type": "Call",
                    "possible_values": []
                },
                "replacement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "load_538": {
                "variable": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "checkpoint_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(self.params.dump_path, 'checkpoint.pth')",
                            "Call"
                        ],
                        [
                            "self.params.reload_checkpoint",
                            "Attribute"
                        ]
                    ]
                },
                "map_location": {
                    "value": "cpu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "arange_673": {
                "variable": {
                    "value": "alen",
                    "type": "variable",
                    "possible_values": []
                },
                "start": {
                    "value": "lengths.max()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.long",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "lengths.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "arange_756": {
                "variable": {
                    "value": "idx_pos",
                    "type": "variable",
                    "possible_values": []
                },
                "start": {
                    "value": "bs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.size()",
                            "Call"
                        ],
                        [
                            "len1.size(0)",
                            "Call"
                        ]
                    ]
                }
            },
            "linear_774": {
                "variable": {
                    "value": "pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model('fwd', x=x, lengths=lengths, positions=positions, langs=langs, causal=False)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "weight": {
                    "value": "emb[CLF_ID1].unsqueeze(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "bias": {
                    "value": "emb[CLF_ID2, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "binary_cross_entropy_with_logits_775": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pred.view(-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "target": {
                    "value": "y.to(pred.device).type_as(pred)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "arange_842": {
                "variable": {
                    "value": "alen",
                    "type": "variable",
                    "possible_values": []
                },
                "start": {
                    "value": "len2.max()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.long",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "len2.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "arange_917": {
                "variable": {
                    "value": "alen",
                    "type": "variable",
                    "possible_values": []
                },
                "start": {
                    "value": "len1.max()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.long",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "len1.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "from_numpy_433": {
                "variable": {
                    "value": "pred_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "pred_mask.astype(np.uint8)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_438": {
                "variable": {
                    "value": "pred_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "slen * bs",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.uint8",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "save_524": {
                "obj": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'epoch': self.epoch, 'n_total_iter': self.n_total_iter, 'best_metrics': self.best_metrics, 'best_stopping_criterion': self.best_stopping_criterion}",
                            "Dict"
                        ],
                        [
                            "torch.load(checkpoint_path, map_location='cpu')",
                            "Call"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ]
                    ]
                },
                "f": {
                    "value": "path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(self.params.dump_path, '%s.pth' % name)",
                            "Call"
                        ]
                    ]
                }
            },
            "cat_646": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[x, torch.LongTensor(pad, bs2).fill_(params.pad_index)]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_648": {
                "variable": {
                    "value": "positions",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[positions, torch.arange(pad)[:, None] + positions[-1][None] + 1]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_650": {
                "variable": {
                    "value": "langs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[langs, langs[-1][None].expand(pad, bs2)]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "no_grad_893": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "randperm_632": {
                "n": {
                    "value": "bs1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(lengths)",
                            "Call"
                        ]
                    ]
                }
            },
            "DistributedDataParallel_63": {
                "module": {
                    "value": "getattr(self, name)",
                    "type": "Call",
                    "possible_values": []
                },
                "device_ids": {
                    "value": "[params.local_rank]",
                    "type": "List",
                    "possible_values": []
                },
                "output_device": {
                    "value": "params.local_rank",
                    "type": "Attribute",
                    "possible_values": []
                },
                "broadcast_buffers": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "clip_grad_norm__217": {
                "parameters": {
                    "value": "self.parameters[name]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "max_norm": {
                    "value": "params.clip_grad_norm",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "from_numpy_347": {
                "ndarray": {
                    "value": "permutation",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scores.argsort()",
                            "Call"
                        ]
                    ]
                }
            },
            "clip_grad_norm__231": {
                "parameters": {
                    "value": "apex.amp.master_params(self.optimizers[name])",
                    "type": "Call",
                    "possible_values": []
                },
                "max_norm": {
                    "value": "params.clip_grad_norm",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "nonzero_452": {
                "input": {
                    "value": "pred_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.random.rand(slen, bs) <= params.word_pred",
                            "Compare"
                        ],
                        [
                            "torch.from_numpy(pred_mask.astype(np.uint8))",
                            "Call"
                        ],
                        [
                            "torch.zeros(slen * bs, dtype=torch.uint8)",
                            "Call"
                        ],
                        [
                            "pred_mask.view(slen, bs)",
                            "Call"
                        ],
                        [
                            "pred_mask.view(-1)",
                            "Call"
                        ],
                        [
                            "pred_mask.view(slen, bs)",
                            "Call"
                        ],
                        [
                            "alen[:, None] < lengths[None] - 1",
                            "Compare"
                        ],
                        [
                            "to_cuda(x, lengths, langs, pred_mask, y)",
                            "Call"
                        ],
                        [
                            "self.mask_out(x, lengths)",
                            "Call"
                        ],
                        [
                            "to_cuda(x, y, pred_mask, lengths, positions, langs)",
                            "Call"
                        ],
                        [
                            "alen[:, None] < len2[None] - 1",
                            "Compare"
                        ],
                        [
                            "alen[:, None] < len1[None] - 1",
                            "Compare"
                        ]
                    ]
                }
            },
            "arange_648": {
                "start": {
                    "value": "pad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8 - ml1 % 8",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "xlm/utils.py": {
        "torch": {
            "arange_225": {
                "start": {
                    "value": "slen",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lengths.max().item()",
                            "Call"
                        ]
                    ]
                }
            }
        }
    }
}