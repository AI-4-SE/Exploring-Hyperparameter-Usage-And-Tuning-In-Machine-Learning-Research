{
    "bert_md.py": {
        "tensorflow": {
            "Saver_36": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_max_110": {
                "variable": {
                    "value": "max_sentence_length",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "text_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array([len(s) for s in sentences])",
                            "Call"
                        ],
                        [
                            "text_len[sentence_offset:sentence_offset + max_training_sentences]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "sequence_mask_113": {
                "variable": {
                    "value": "bert_sent_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "bert_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([len(sentences)])",
                            "Call"
                        ],
                        [
                            "bert_len[sentence_offset:sentence_offset + max_training_sentences]",
                            "Subscript"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "self.max_bert_sent_len",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_114": {
                "variable": {
                    "value": "bert_segment",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "bert_sent_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(bert_len, self.max_bert_sent_len, tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sequence_mask_125": {
                "variable": {
                    "value": "text_len_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "text_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array([len(s) for s in sentences])",
                            "Call"
                        ],
                        [
                            "text_len[sentence_offset:sentence_offset + max_training_sentences]",
                            "Subscript"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "max_sentence_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(text_len)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_127": {
                "variable": {
                    "value": "num_words",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "text_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array([len(s) for s in sentences])",
                            "Call"
                        ],
                        [
                            "text_len[sentence_offset:sentence_offset + max_training_sentences]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "tile_130": {
                "variable": {
                    "value": "sentence_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.range(num_sentences), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, max_sentence_length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_133": {
                "variable": {
                    "value": "candidate_starts",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.range(num_words), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, self.max_span_width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_135": {
                "variable": {
                    "value": "candidate_start_sentence_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "flattened_sentence_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.flatten_emb_by_sentence(sentence_indices, text_len_mask)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "candidate_starts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.range(num_words), 1), [1, self.max_span_width])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(tf.reshape(candidate_starts, [-1]), flattened_candidate_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_136": {
                "variable": {
                    "value": "candidate_end_sentence_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "flattened_sentence_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.flatten_emb_by_sentence(sentence_indices, text_len_mask)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.minimum(candidate_ends, num_words - 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_and_137": {
                "variable": {
                    "value": "candidate_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "candidate_ends < num_words",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.equal(candidate_start_sentence_indices, candidate_end_sentence_indices)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_138": {
                "variable": {
                    "value": "flattened_candidate_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "candidate_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(candidate_ends < num_words, tf.equal(candidate_start_sentence_indices, candidate_end_sentence_indices))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "boolean_mask_140": {
                "variable": {
                    "value": "candidate_starts",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.reshape(candidate_starts, [-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "mask": {
                    "value": "flattened_candidate_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(candidate_mask, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_141": {
                "variable": {
                    "value": "candidate_ends",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.reshape(candidate_ends, [-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "mask": {
                    "value": "flattened_candidate_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(candidate_mask, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_146": {
                "variable": {
                    "value": "span_start_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "context_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bert_outputs['sequence_output']",
                            "Subscript"
                        ],
                        [
                            "self.flatten_emb_by_sentence(context_outputs, bert_token_mask)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "candidate_starts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.range(num_words), 1), [1, self.max_span_width])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(tf.reshape(candidate_starts, [-1]), flattened_candidate_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_147": {
                "variable": {
                    "value": "span_end_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "context_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bert_outputs['sequence_output']",
                            "Subscript"
                        ],
                        [
                            "self.flatten_emb_by_sentence(context_outputs, bert_token_mask)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "candidate_ends",
                    "type": "variable",
                    "possible_values": [
                        [
                            "candidate_starts + tf.expand_dims(tf.range(self.max_span_width), 0)",
                            "BinOp"
                        ],
                        [
                            "tf.boolean_mask(tf.reshape(candidate_ends, [-1]), flattened_candidate_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_149": {
                "variable": {
                    "value": "candidate_span_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[span_start_emb, span_end_emb]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_153": {
                "variable": {
                    "value": "candidate_mention_scores",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "candidate_mention_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_mention_scores(candidate_span_emb, self.dropout)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(candidate_mention_scores, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "global_variables_initializer_39": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_44": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "shape_109": {
                "input": {
                    "value": "text_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array([len(s) for s in sentences])",
                            "Call"
                        ],
                        [
                            "text_len[sentence_offset:sentence_offset + max_training_sentences]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "expand_dims_130": {
                "input": {
                    "value": "tf.range(num_sentences)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_133": {
                "input": {
                    "value": "tf.range(num_words)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_134": {
                "input": {
                    "value": "tf.range(self.max_span_width)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "minimum_136": {
                "x": {
                    "value": "candidate_ends",
                    "type": "variable",
                    "possible_values": [
                        [
                            "candidate_starts + tf.expand_dims(tf.range(self.max_span_width), 0)",
                            "BinOp"
                        ],
                        [
                            "tf.boolean_mask(tf.reshape(candidate_ends, [-1]), flattened_candidate_mask)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "num_words - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "equal_137": {
                "x": {
                    "value": "candidate_start_sentence_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(flattened_sentence_indices, candidate_starts)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "candidate_end_sentence_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(flattened_sentence_indices, tf.minimum(candidate_ends, num_words - 1))",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_140": {
                "tensor": {
                    "value": "candidate_starts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.range(num_words), 1), [1, self.max_span_width])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(tf.reshape(candidate_starts, [-1]), flattened_candidate_mask)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_141": {
                "tensor": {
                    "value": "candidate_ends",
                    "type": "variable",
                    "possible_values": [
                        [
                            "candidate_starts + tf.expand_dims(tf.range(self.max_span_width), 0)",
                            "BinOp"
                        ],
                        [
                            "tf.boolean_mask(tf.reshape(candidate_ends, [-1]), flattened_candidate_mask)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Session_47": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "bert_tokenization.py": {
        "tensorflow": {
            "GFile_125": {
                "name": {
                    "value": "vocab_file",
                    "type": "variable",
                    "possible_values": []
                },
                "mode": {
                    "value": "r",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "biaffine_md.py": {
        "tensorflow": {
            "Saver_40": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "vars_to_restore",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[v for v in tf.global_variables() if 'module/' not in v.name]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "reshape_139": {
                "variable": {
                    "value": "flattened_lm_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "lm_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([num_sentences, max((s.shape[0] for s in sentences)), self.lm_size, self.lm_layers])",
                            "Call"
                        ],
                        [
                            "self.load_lm_embeddings(doc_key)",
                            "Call"
                        ],
                        [
                            "lm_emb[sentence_offset:sentence_offset + max_training_sentences, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack([tf.concat([word_emb, word_emb], -1), lm_embeddings['lstm_outputs1'], lm_embeddings['lstm_outputs2']], -1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[num_sentences * max_sentence_length * lm_emb_size, lm_num_layers]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_140": {
                "variable": {
                    "value": "flattened_aggregated_lm_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "flattened_lm_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(lm_emb, [num_sentences * max_sentence_length * lm_emb_size, lm_num_layers])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.expand_dims(self.lm_weights, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_141": {
                "variable": {
                    "value": "aggregated_lm_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "flattened_aggregated_lm_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(flattened_lm_emb, tf.expand_dims(self.lm_weights, 1))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[num_sentences, max_sentence_length, lm_emb_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dropout_147": {
                "variable": {
                    "value": "context_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "context_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "aggregated_lm_emb",
                            "variable"
                        ],
                        [
                            "tf.nn.dropout(context_emb, self.lexical_dropout)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.lexical_dropout",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sequence_mask_149": {
                "variable": {
                    "value": "text_len_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "text_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array([len(s) for s in sentences])",
                            "Call"
                        ],
                        [
                            "text_len[sentence_offset:sentence_offset + max_training_sentences]",
                            "Subscript"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "max_sentence_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "max((len(s) for s in sentences))",
                            "Call"
                        ],
                        [
                            "tf.shape(tokens)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reduce_sum_151": {
                "variable": {
                    "value": "num_words",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "text_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array([len(s) for s in sentences])",
                            "Call"
                        ],
                        [
                            "text_len[sentence_offset:sentence_offset + max_training_sentences]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "tile_152": {
                "variable": {
                    "value": "sentence_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.range(num_sentences), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, max_sentence_length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_156": {
                "variable": {
                    "value": "candidate_starts",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.range(num_words), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, max_sentence_length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_159": {
                "variable": {
                    "value": "candidate_start_sentence_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "flattened_sentence_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.flatten_emb_by_sentence(sentence_indices, text_len_mask)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "candidate_starts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.range(num_words), 1), [1, max_sentence_length])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(tf.reshape(candidate_starts, [-1]), flattened_candidate_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_161": {
                "variable": {
                    "value": "candidate_end_sentence_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "flattened_sentence_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.flatten_emb_by_sentence(sentence_indices, text_len_mask)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.minimum(candidate_ends, num_words - 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_and_163": {
                "variable": {
                    "value": "candidate_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "candidate_ends < num_words",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.equal(candidate_start_sentence_indices, candidate_end_sentence_indices)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_165": {
                "variable": {
                    "value": "flattened_candidate_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "candidate_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(candidate_ends < num_words, tf.equal(candidate_start_sentence_indices, candidate_end_sentence_indices))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "boolean_mask_167": {
                "variable": {
                    "value": "candidate_starts",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.reshape(candidate_starts, [-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "mask": {
                    "value": "flattened_candidate_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(candidate_mask, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_168": {
                "variable": {
                    "value": "candidate_ends",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.reshape(candidate_ends, [-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "mask": {
                    "value": "flattened_candidate_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(candidate_mask, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_and_173": {
                "variable": {
                    "value": "candidate_scores_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.expand_dims(text_len_mask, [1])",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.expand_dims(text_len_mask, [2])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tile_174": {
                "variable": {
                    "value": "sentence_ends_leq_starts",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.logical_not(tf.sequence_mask(tf.range(max_sentence_length), max_sentence_length)), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[num_sentences, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "logical_and_175": {
                "variable": {
                    "value": "candidate_scores_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "candidate_scores_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.expand_dims(text_len_mask, [1]), tf.expand_dims(text_len_mask, [2]))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(candidate_scores_mask, sentence_ends_leq_starts)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "sentence_ends_leq_starts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.logical_not(tf.sequence_mask(tf.range(max_sentence_length), max_sentence_length)), 0), [num_sentences, 1, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_177": {
                "variable": {
                    "value": "flattened_candidate_scores_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "candidate_scores_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.expand_dims(text_len_mask, [1]), tf.expand_dims(text_len_mask, [2]))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(candidate_scores_mask, sentence_ends_leq_starts)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "boolean_mask_189": {
                "variable": {
                    "value": "candidate_mention_scores",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.reshape(candidate_mention_scores, [-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "mask": {
                    "value": "flattened_candidate_scores_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(candidate_scores_mask, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_131": {
                "variable": {
                    "value": "lm_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.concat([word_emb, word_emb], -1), lm_embeddings['lstm_outputs1'], lm_embeddings['lstm_outputs2']]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_137": {
                "variable": {
                    "value": "self.lm_weights",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "tf.get_variable('lm_scores', [lm_num_layers], initializer=tf.constant_initializer(0.0))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_138": {
                "variable": {
                    "value": "self.lm_scaling",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "lm_scaling",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "global_variables_initializer_43": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "shape_122": {
                "input": {
                    "value": "tokens",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[''] * max_sentence_length for _ in sentences]",
                            "ListComp"
                        ],
                        [
                            "np.array(tokens)",
                            "Call"
                        ],
                        [
                            "tokens[sentence_offset:sentence_offset + max_training_sentences, :]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_123": {
                "input": {
                    "value": "tokens",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[''] * max_sentence_length for _ in sentences]",
                            "ListComp"
                        ],
                        [
                            "np.array(tokens)",
                            "Call"
                        ],
                        [
                            "tokens[sentence_offset:sentence_offset + max_training_sentences, :]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "variable_scope_136": {
                "name_or_scope": {
                    "value": "lm_aggregation",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_140": {
                "input": {
                    "value": "self.lm_weights",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_152": {
                "input": {
                    "value": "tf.range(num_sentences)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_156": {
                "input": {
                    "value": "tf.range(num_words)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_158": {
                "input": {
                    "value": "tf.range(max_sentence_length)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "minimum_162": {
                "x": {
                    "value": "candidate_ends",
                    "type": "variable",
                    "possible_values": [
                        [
                            "candidate_starts + tf.expand_dims(tf.range(max_sentence_length), 0)",
                            "BinOp"
                        ],
                        [
                            "tf.boolean_mask(tf.reshape(candidate_ends, [-1]), flattened_candidate_mask)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "num_words - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "equal_163": {
                "x": {
                    "value": "candidate_start_sentence_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(flattened_sentence_indices, candidate_starts)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "candidate_end_sentence_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(flattened_sentence_indices, tf.minimum(candidate_ends, num_words - 1))",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_167": {
                "tensor": {
                    "value": "candidate_starts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.range(num_words), 1), [1, max_sentence_length])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(tf.reshape(candidate_starts, [-1]), flattened_candidate_mask)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_168": {
                "tensor": {
                    "value": "candidate_ends",
                    "type": "variable",
                    "possible_values": [
                        [
                            "candidate_starts + tf.expand_dims(tf.range(max_sentence_length), 0)",
                            "BinOp"
                        ],
                        [
                            "tf.boolean_mask(tf.reshape(candidate_ends, [-1]), flattened_candidate_mask)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_173": {
                "input": {
                    "value": "text_len_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(text_len, maxlen=max_sentence_length)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_174": {
                "input": {
                    "value": "tf.logical_not(tf.sequence_mask(tf.range(max_sentence_length), max_sentence_length))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_183": {
                "name_or_scope": {
                    "value": "candidate_starts_ffnn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_185": {
                "name_or_scope": {
                    "value": "candidate_ends_ffnn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_189": {
                "tensor": {
                    "value": "candidate_mention_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "util.bilinear_classifier(candidate_starts_emb, candidate_ends_emb, self.dropout)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(tf.reshape(candidate_mention_scores, [-1]), flattened_candidate_scores_mask)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "global_variables_39": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_137": {
                "name": {
                    "value": "lm_scores",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[lm_num_layers]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_not_174": {
                "x": {
                    "value": "tf.sequence_mask(tf.range(max_sentence_length), max_sentence_length)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_131": {
                "values": {
                    "value": "[word_emb, word_emb]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "constant_initializer_138": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "sequence_mask_174": {
                "lengths": {
                    "value": "tf.range(max_sentence_length)",
                    "type": "Call",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "max_sentence_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "max((len(s) for s in sentences))",
                            "Call"
                        ],
                        [
                            "tf.shape(tokens)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "constant_initializer_137": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            }
        }
    },
    "cache_elmo.py": {
        "tensorflow": {
            "placeholder_13": {
                "variable": {
                    "value": "token_ph",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_14": {
                "variable": {
                    "value": "len_ph",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_20": {
                "variable": {
                    "value": "lm_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.concat([word_emb, word_emb], -1), lm_embeddings['lstm_outputs1'], lm_embeddings['lstm_outputs2']]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Session_51": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "concat_20": {
                "values": {
                    "value": "[word_emb, word_emb]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "global_variables_initializer_52": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "evaluate.py": {
        "tensorflow": {
            "Session_19": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "lee_md.py": {
        "tensorflow": {
            "Saver_85": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "vars_to_restore",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[v for v in tf.global_variables() if 'module/' not in v.name]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "reshape_160": {
                "variable": {
                    "value": "flattened_lm_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "lm_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.load_lm_embeddings(doc_key)",
                            "Call"
                        ],
                        [
                            "np.zeros([num_sentences, max((s.shape[0] for s in sentences)), self.lm_size, self.lm_layers])",
                            "Call"
                        ],
                        [
                            "lm_emb[sentence_offset:sentence_offset + max_training_sentences, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack([tf.concat([word_emb, word_emb], -1), lm_embeddings['lstm_outputs1'], lm_embeddings['lstm_outputs2']], -1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[num_sentences * max_sentence_length * lm_emb_size, lm_num_layers]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_161": {
                "variable": {
                    "value": "flattened_aggregated_lm_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "flattened_lm_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(lm_emb, [num_sentences * max_sentence_length * lm_emb_size, lm_num_layers])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.expand_dims(self.lm_weights, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_162": {
                "variable": {
                    "value": "aggregated_lm_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "flattened_aggregated_lm_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(flattened_lm_emb, tf.expand_dims(self.lm_weights, 1))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[num_sentences, max_sentence_length, lm_emb_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_166": {
                "variable": {
                    "value": "context_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "context_emb_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[context_word_emb]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_167": {
                "variable": {
                    "value": "head_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "head_emb_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[head_word_emb]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dropout_168": {
                "variable": {
                    "value": "context_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "context_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(context_emb_list, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(context_emb, self.lexical_dropout)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.lexical_dropout",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_169": {
                "variable": {
                    "value": "head_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "head_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(head_emb_list, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(head_emb, self.lexical_dropout)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.lexical_dropout",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sequence_mask_171": {
                "variable": {
                    "value": "text_len_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "text_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array([len(s) for s in sentences])",
                            "Call"
                        ],
                        [
                            "text_len[sentence_offset:sentence_offset + max_training_sentences]",
                            "Subscript"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "max_sentence_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "max((len(s) for s in sentences))",
                            "Call"
                        ],
                        [
                            "tf.shape(context_word_emb)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "tile_177": {
                "variable": {
                    "value": "sentence_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.range(num_sentences), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, max_sentence_length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_181": {
                "variable": {
                    "value": "candidate_starts",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.range(num_words), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, self.max_span_width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_183": {
                "variable": {
                    "value": "candidate_start_sentence_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "flattened_sentence_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.flatten_emb_by_sentence(sentence_indices, text_len_mask)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "candidate_starts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.range(num_words), 1), [1, self.max_span_width])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(tf.reshape(candidate_starts, [-1]), flattened_candidate_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_184": {
                "variable": {
                    "value": "candidate_end_sentence_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "flattened_sentence_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.flatten_emb_by_sentence(sentence_indices, text_len_mask)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.minimum(candidate_ends, num_words - 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_and_185": {
                "variable": {
                    "value": "candidate_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "candidate_ends < num_words",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.equal(candidate_start_sentence_indices, candidate_end_sentence_indices)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_186": {
                "variable": {
                    "value": "flattened_candidate_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "candidate_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(candidate_ends < num_words, tf.equal(candidate_start_sentence_indices, candidate_end_sentence_indices))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "boolean_mask_187": {
                "variable": {
                    "value": "candidate_starts",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.reshape(candidate_starts, [-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "mask": {
                    "value": "flattened_candidate_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(candidate_mask, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_188": {
                "variable": {
                    "value": "candidate_ends",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.reshape(candidate_ends, [-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "mask": {
                    "value": "flattened_candidate_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(candidate_mask, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_196": {
                "variable": {
                    "value": "candidate_mention_scores",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "candidate_mention_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_mention_scores(candidate_span_emb, self.dropout)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(candidate_mention_scores, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_207": {
                "variable": {
                    "value": "span_start_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "context_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.lstm_contextualize(context_emb, text_len, text_len_mask, self.lstm_dropout)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "span_starts",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "gather_210": {
                "variable": {
                    "value": "span_end_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "context_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.lstm_contextualize(context_emb, text_len, text_len_mask, self.lstm_dropout)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "span_ends",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "gather_216": {
                "variable": {
                    "value": "span_width_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.get_variable('span_width_embeddings', [self.config['max_span_width'], self.config['feature_size']])",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "span_width_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "span_width - 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "dropout_217": {
                "variable": {
                    "value": "span_width_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "span_width_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(tf.get_variable('span_width_embeddings', [self.config['max_span_width'], self.config['feature_size']]), span_width_index)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(span_width_emb, self.dropout)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "minimum_221": {
                "variable": {
                    "value": "span_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "util.shape(context_outputs, 0) - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "span_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.range(self.config['max_span_width']), 0) + tf.expand_dims(span_starts, 1)",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(util.shape(context_outputs, 0) - 1, span_indices)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_222": {
                "variable": {
                    "value": "span_text_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "head_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(head_emb_list, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(head_emb, self.lexical_dropout)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "span_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.range(self.config['max_span_width']), 0) + tf.expand_dims(span_starts, 1)",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(util.shape(context_outputs, 0) - 1, span_indices)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_225": {
                "variable": {
                    "value": "span_head_scores",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.head_scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "span_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.range(self.config['max_span_width']), 0) + tf.expand_dims(span_starts, 1)",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(util.shape(context_outputs, 0) - 1, span_indices)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_226": {
                "variable": {
                    "value": "span_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.sequence_mask(span_width, self.config['max_span_width'], dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_228": {
                "variable": {
                    "value": "span_attention",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "span_head_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(self.head_scores, span_indices)",
                            "Call"
                        ],
                        [
                            "span_head_scores + tf.log(span_mask)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_229": {
                "variable": {
                    "value": "span_head_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "span_attention * span_text_emb",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_232": {
                "variable": {
                    "value": "span_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "span_emb_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_138": {
                "variable": {
                    "value": "char_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.get_variable('char_embeddings', [len(self.char_dict), self.config['char_embedding_size']])",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "char_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([len(sentences), max_sentence_length, max_word_length])",
                            "Call"
                        ],
                        [
                            "char_index[sentence_offset:sentence_offset + max_training_sentences, :, :]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reshape_139": {
                "variable": {
                    "value": "flattened_char_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "char_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(tf.get_variable('char_embeddings', [len(self.char_dict), self.config['char_embedding_size']]), char_index)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[num_sentences * max_sentence_length, util.shape(char_emb, 2), util.shape(char_emb, 3)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_141": {
                "variable": {
                    "value": "aggregated_char_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "flattened_aggregated_char_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "util.cnn(flattened_char_emb, self.config['filter_widths'], self.config['filter_size'])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[num_sentences, max_sentence_length, util.shape(flattened_aggregated_char_emb, 1)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_152": {
                "variable": {
                    "value": "lm_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.concat([word_emb, word_emb], -1), lm_embeddings['lstm_outputs1'], lm_embeddings['lstm_outputs2']]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_158": {
                "variable": {
                    "value": "self.lm_weights",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "tf.get_variable('lm_scores', [lm_num_layers], initializer=tf.constant_initializer(0.0))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_159": {
                "variable": {
                    "value": "self.lm_scaling",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "lm_scaling",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_227": {
                "x": {
                    "value": "span_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.sequence_mask(span_width, self.config['max_span_width'], dtype=tf.float32), 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "global_variables_initializer_88": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "shape_131": {
                "input": {
                    "value": "context_word_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([len(sentences), max_sentence_length, self.context_embeddings.size])",
                            "Call"
                        ],
                        [
                            "context_word_emb[sentence_offset:sentence_offset + max_training_sentences, :, :]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_132": {
                "input": {
                    "value": "context_word_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([len(sentences), max_sentence_length, self.context_embeddings.size])",
                            "Call"
                        ],
                        [
                            "context_word_emb[sentence_offset:sentence_offset + max_training_sentences, :, :]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "variable_scope_157": {
                "name_or_scope": {
                    "value": "lm_aggregation",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_161": {
                "input": {
                    "value": "self.lm_weights",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_177": {
                "input": {
                    "value": "tf.range(num_sentences)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_181": {
                "input": {
                    "value": "tf.range(num_words)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_182": {
                "input": {
                    "value": "tf.range(self.max_span_width)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "minimum_184": {
                "x": {
                    "value": "candidate_ends",
                    "type": "variable",
                    "possible_values": [
                        [
                            "candidate_starts + tf.expand_dims(tf.range(self.max_span_width), 0)",
                            "BinOp"
                        ],
                        [
                            "tf.boolean_mask(tf.reshape(candidate_ends, [-1]), flattened_candidate_mask)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "num_words - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "equal_185": {
                "x": {
                    "value": "candidate_start_sentence_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(flattened_sentence_indices, candidate_starts)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "candidate_end_sentence_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(flattened_sentence_indices, tf.minimum(candidate_ends, num_words - 1))",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_187": {
                "tensor": {
                    "value": "candidate_starts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.range(num_words), 1), [1, self.max_span_width])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(tf.reshape(candidate_starts, [-1]), flattened_candidate_mask)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_188": {
                "tensor": {
                    "value": "candidate_ends",
                    "type": "variable",
                    "possible_values": [
                        [
                            "candidate_starts + tf.expand_dims(tf.range(self.max_span_width), 0)",
                            "BinOp"
                        ],
                        [
                            "tf.boolean_mask(tf.reshape(candidate_ends, [-1]), flattened_candidate_mask)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_216": {
                "name": {
                    "value": "span_width_embeddings",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.config['max_span_width'], self.config['feature_size']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_220": {
                "input": {
                    "value": "span_starts",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_223": {
                "name_or_scope": {
                    "value": "head_scores",
                    "type": "str",
                    "possible_values": []
                }
            },
            "sequence_mask_226": {
                "lengths": {
                    "value": "span_width",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 + span_ends - span_starts",
                            "BinOp"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "self.config['max_span_width']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_84": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_138": {
                "name": {
                    "value": "char_embeddings",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[len(self.char_dict), self.config['char_embedding_size']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_158": {
                "name": {
                    "value": "lm_scores",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[lm_num_layers]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_152": {
                "values": {
                    "value": "[word_emb, word_emb]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "constant_initializer_159": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_158": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            }
        }
    },
    "md_ops.py": {
        "tensorflow": {
            "load_op_library_7": {
                "variable": {
                    "value": "md_op_library",
                    "type": "variable",
                    "possible_values": []
                },
                "library_filename": {
                    "value": "./md_kernels.so",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "nn_md.py": {
        "tensorflow": {
            "PaddingFIFOQueue_21": {
                "variable": {
                    "value": "queue",
                    "type": "variable",
                    "possible_values": []
                },
                "capacity": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "dtypes": {
                    "value": "dtypes",
                    "type": "variable",
                    "possible_values": []
                },
                "shapes": {
                    "value": "shapes",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Variable_26": {
                "variable": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "assign_27": {
                "variable": {
                    "value": "self.reset_global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ref": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exponential_decay_28": {
                "variable": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.config['learning_rate']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "global_step": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "decay_steps": {
                    "value": "self.config['decay_frequency']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "decay_rate": {
                    "value": "self.config['decay_rate']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "staircase": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "trainable_variables_31": {
                "variable": {
                    "value": "trainable_params",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "gradients_32": {
                "variable": {
                    "value": "gradients",
                    "type": "variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "self.loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "xs": {
                    "value": "trainable_params",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ]
                    ]
                }
            },
            "clip_by_global_norm_33": {
                "variable": {
                    "value": "(gradients, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "t_list": {
                    "value": "gradients",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gradients(self.loss, trainable_params)",
                            "Call"
                        ]
                    ]
                },
                "clip_norm": {
                    "value": "self.config['max_gradient_norm']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "squeeze_62": {
                "variable": {
                    "value": "top_span_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "top_span_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "md_ops.extract_spans(tf.expand_dims(candidate_mention_scores, 0), tf.expand_dims(candidate_starts, 0), tf.expand_dims(candidate_ends, 0), tf.expand_dims(k, 0), True)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(top_span_indices, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_64": {
                "variable": {
                    "value": "top_span_starts",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "candidate_starts",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "top_span_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "md_ops.extract_spans(tf.expand_dims(candidate_mention_scores, 0), tf.expand_dims(candidate_starts, 0), tf.expand_dims(candidate_ends, 0), tf.expand_dims(k, 0), True)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(top_span_indices, 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_65": {
                "variable": {
                    "value": "top_span_ends",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "candidate_ends",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "top_span_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "md_ops.extract_spans(tf.expand_dims(candidate_mention_scores, 0), tf.expand_dims(candidate_starts, 0), tf.expand_dims(candidate_ends, 0), tf.expand_dims(k, 0), True)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(top_span_indices, 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_66": {
                "variable": {
                    "value": "top_span_mention_scores",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "candidate_mention_scores",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "top_span_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "md_ops.extract_spans(tf.expand_dims(candidate_mention_scores, 0), tf.expand_dims(candidate_starts, 0), tf.expand_dims(candidate_ends, 0), tf.expand_dims(k, 0), True)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(top_span_indices, 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_105": {
                "variable": {
                    "value": "same_start",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.expand_dims(labeled_starts, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.expand_dims(candidate_starts, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_106": {
                "variable": {
                    "value": "same_end",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.expand_dims(labeled_ends, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.expand_dims(candidate_ends, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_and_107": {
                "variable": {
                    "value": "same_span",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "same_start",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.expand_dims(labeled_starts, 1), tf.expand_dims(candidate_starts, 0))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "same_end",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.expand_dims(labeled_ends, 1), tf.expand_dims(candidate_ends, 0))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_any_108": {
                "variable": {
                    "value": "candidate_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "same_span",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(same_start, same_end)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_with_logits_116": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.to_float(span_labels)",
                    "type": "Call",
                    "possible_values": []
                },
                "logits": {
                    "value": "span_scores",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_sum_117": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=tf.to_float(span_labels), logits=span_scores)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss)",
                            "Call"
                        ]
                    ]
                }
            },
            "to_int32_54": {
                "variable": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.floor(tf.to_float(num_words) * self.config['top_span_ratio'])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_69": {
                "variable": {
                    "value": "sigmoid_span_mention_scores",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "top_span_mention_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(candidate_mention_scores, top_span_indices)",
                            "Call"
                        ]
                    ]
                }
            },
            "greater_equal_70": {
                "variable": {
                    "value": "threshold_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "sigmoid_span_mention_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sigmoid(top_span_mention_scores)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.config['mention_selection_threshold']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "boolean_mask_71": {
                "variable": {
                    "value": "top_span_starts",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "top_span_starts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(candidate_starts, top_span_indices)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(top_span_starts, threshold_mask)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "threshold_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater_equal(sigmoid_span_mention_scores, self.config['mention_selection_threshold'])",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_72": {
                "variable": {
                    "value": "top_span_ends",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "top_span_ends",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(candidate_ends, top_span_indices)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(top_span_ends, threshold_mask)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "threshold_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater_equal(sigmoid_span_mention_scores, self.config['mention_selection_threshold'])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_164": {
                "variable": {
                    "value": "flattened_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "emb",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_sentences * max_sentence_length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "boolean_mask_169": {
                "tensor": {
                    "value": "flattened_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(emb, [num_sentences * max_sentence_length])",
                            "Call"
                        ],
                        [
                            "tf.reshape(emb, [num_sentences * max_sentence_length, util.shape(emb, 2)])",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "tf.reshape(text_len_mask, [num_sentences * max_sentence_length])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "placeholder_19": {
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "expand_dims_56": {
                "input": {
                    "value": "candidate_mention_scores",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_57": {
                "input": {
                    "value": "candidate_starts",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_58": {
                "input": {
                    "value": "candidate_ends",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_59": {
                "input": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_words",
                            "variable"
                        ],
                        [
                            "tf.to_int32(tf.floor(tf.to_float(num_words) * self.config['top_span_ratio']))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_105": {
                "input": {
                    "value": "candidate_starts",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_106": {
                "input": {
                    "value": "candidate_ends",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_121": {
                "name_or_scope": {
                    "value": "mention_scores",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_126": {
                "input": {
                    "value": "text_emb",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_136": {
                "variable": {
                    "value": "state_fw",
                    "type": "variable",
                    "possible_values": []
                },
                "c": {
                    "value": "tf.tile(cell_fw.initial_state.c, [num_sentences, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "h": {
                    "value": "tf.tile(cell_fw.initial_state.h, [num_sentences, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_137": {
                "variable": {
                    "value": "state_bw",
                    "type": "variable",
                    "possible_values": []
                },
                "c": {
                    "value": "tf.tile(cell_bw.initial_state.c, [num_sentences, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "h": {
                    "value": "tf.tile(cell_bw.initial_state.h, [num_sentences, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "bidirectional_dynamic_rnn_139": {
                "variable": {
                    "value": "((fw_outputs, bw_outputs), _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell_fw": {
                    "value": "cell_fw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "util.CustomLSTMCell(self.config['contextualization_size'], num_sentences, lstm_dropout)",
                            "Call"
                        ]
                    ]
                },
                "cell_bw": {
                    "value": "cell_bw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "util.CustomLSTMCell(self.config['contextualization_size'], num_sentences, lstm_dropout)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "current_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "text_emb",
                            "variable"
                        ],
                        [
                            "text_outputs",
                            "variable"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "text_len",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_state_fw": {
                    "value": "state_fw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.rnn.LSTMStateTuple(tf.tile(cell_fw.initial_state.c, [num_sentences, 1]), tf.tile(cell_fw.initial_state.h, [num_sentences, 1]))",
                            "Call"
                        ]
                    ]
                },
                "initial_state_bw": {
                    "value": "state_bw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.rnn.LSTMStateTuple(tf.tile(cell_bw.initial_state.c, [num_sentences, 1]), tf.tile(cell_bw.initial_state.h, [num_sentences, 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_147": {
                "variable": {
                    "value": "text_outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[fw_outputs, bw_outputs]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dropout_148": {
                "variable": {
                    "value": "text_outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "text_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([fw_outputs, bw_outputs], 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(text_outputs, lstm_dropout)",
                            "Call"
                        ],
                        [
                            "highway_gates * text_outputs + (1 - highway_gates) * current_inputs",
                            "BinOp"
                        ]
                    ]
                },
                "rate": {
                    "value": "lstm_dropout",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_159": {
                "input": {
                    "value": "emb",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_160": {
                "input": {
                    "value": "emb",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reshape_166": {
                "variable": {
                    "value": "flattened_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "emb",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_sentences * max_sentence_length, util.shape(emb, 2)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_169": {
                "tensor": {
                    "value": "text_len_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_sentences * max_sentence_length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "floor_54": {
                "x": {
                    "value": "tf.to_float(num_words) * self.config['top_span_ratio']",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_112": {
                "x": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "to_float_116": {
                "x": {
                    "value": "span_labels",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "variable_scope_131": {
                "name_or_scope": {
                    "value": "'layer_{}'.format(layer)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_150": {
                "variable": {
                    "value": "highway_gates",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "util.projection(text_outputs, util.shape(text_outputs, 2))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_132": {
                "name_or_scope": {
                    "value": "fw_cell",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_134": {
                "name_or_scope": {
                    "value": "bw_cell",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tile_136": {
                "input": {
                    "value": "cell_fw.initial_state.h",
                    "type": "Attribute",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[num_sentences, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_137": {
                "input": {
                    "value": "cell_bw.initial_state.h",
                    "type": "Attribute",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[num_sentences, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_float_54": {
                "x": {
                    "value": "num_words",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "train.py": {
        "tensorflow": {
            "Saver_20": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FileWriter_23": {
                "variable": {
                    "value": "writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "log_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config['log_dir']",
                            "Subscript"
                        ]
                    ]
                },
                "flush_secs": {
                    "value": "20",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_checkpoint_state_32": {
                "variable": {
                    "value": "ckpt",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "log_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config['log_dir']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "Session_27": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_28": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "util.py": {
        "tensorflow": {
            "get_variable_111": {
                "variable": {
                    "value": "output_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[shape(current_inputs, 1), output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "output_weights_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_112": {
                "variable": {
                    "value": "output_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[output_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "xw_plus_b_113": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "current_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [batch_size * seqlen, emb_size])",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "current_outputs",
                            "variable"
                        ]
                    ]
                },
                "weights": {
                    "value": "output_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('output_weights', [shape(current_inputs, 1), output_size], initializer=output_weights_initializer)",
                            "Call"
                        ]
                    ]
                },
                "biases": {
                    "value": "output_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('output_bias', [output_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "dropout_142": {
                "variable": {
                    "value": "x_bnv",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x_bnv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(x_bnv, keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "noise_shape": {
                    "value": "noise_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[batch_size, 1, input_size]",
                            "List"
                        ]
                    ]
                }
            },
            "dropout_143": {
                "variable": {
                    "value": "y_bnv",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y_bnv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(y_bnv, keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "noise_shape": {
                    "value": "noise_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[batch_size, 1, input_size]",
                            "List"
                        ]
                    ]
                }
            },
            "squeeze_152": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "biaffine",
                    "type": "variable",
                    "possible_values": [
                        [
                            "biaffine_mapping(x_bnv, y_bnv, 1, add_bias_1=add_bias_1, add_bias_2=add_bias_2, initializer=tf.zeros_initializer())",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Summary_48": {
                "value": {
                    "value": "[tf.Summary.Value(tag=k, simple_value=v) for (k, v) in value_dict.items()]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "reshape_98": {
                "variable": {
                    "value": "current_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "f * j + (1 - f) * inputs",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size * seqlen, emb_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_103": {
                "variable": {
                    "value": "hidden_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "'hidden_weights_{}'.format(i)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[shape(current_inputs, 1), hidden_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_104": {
                "variable": {
                    "value": "hidden_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "'hidden_bias_{}'.format(i)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[hidden_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_105": {
                "variable": {
                    "value": "current_outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "tf.nn.xw_plus_b(current_inputs, hidden_weights, hidden_bias)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_116": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.xw_plus_b(current_inputs, output_weights, output_bias)",
                            "Call"
                        ],
                        [
                            "tf.reshape(outputs, [batch_size, seqlen, output_size])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, seqlen, output_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "conv1d_126": {
                "variable": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "f * j + (1 - f) * inputs",
                            "BinOp"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('w', [filter_size, input_size, num_filters])",
                            "Call"
                        ]
                    ]
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_127": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "tf.nn.bias_add(conv, b)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_max_128": {
                "variable": {
                    "value": "pooled",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(tf.nn.bias_add(conv, b))",
                            "Call"
                        ],
                        [
                            "h * self._dropout_mask",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_130": {
                "values": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.xw_plus_b(current_inputs, output_weights, output_bias)",
                            "Call"
                        ],
                        [
                            "tf.reshape(outputs, [batch_size, seqlen, output_size])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_207": {
                "variable": {
                    "value": "bilinear_map",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bilinear_map",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[vector_set_1_size, output_size, vector_set_2_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.orthogonal_initializer()",
                            "Call"
                        ],
                        [
                            "self._orthonormal_initializer()",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_218": {
                "variable": {
                    "value": "vector_set_1",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "vector_set_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([vector_set_1, tf.ones([batch_size, bucket_size, 1])], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.reshape(vector_set_1, [-1, vector_set_1_size])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, vector_set_1_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_221": {
                "variable": {
                    "value": "bilinear_map",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "bilinear_map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('bilinear_map', [vector_set_1_size, output_size, vector_set_2_size], initializer=initializer)",
                            "Call"
                        ],
                        [
                            "tf.reshape(bilinear_map, [vector_set_1_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[vector_set_1_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_224": {
                "variable": {
                    "value": "bilinear_mapping",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "vector_set_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([vector_set_1, tf.ones([batch_size, bucket_size, 1])], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.reshape(vector_set_1, [-1, vector_set_1_size])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "bilinear_map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('bilinear_map', [vector_set_1_size, output_size, vector_set_2_size], initializer=initializer)",
                            "Call"
                        ],
                        [
                            "tf.reshape(bilinear_map, [vector_set_1_size, -1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_227": {
                "variable": {
                    "value": "bilinear_mapping",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "bilinear_mapping",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(vector_set_1, bilinear_map)",
                            "Call"
                        ],
                        [
                            "tf.reshape(bilinear_mapping, [batch_size, bucket_size * output_size, vector_set_2_size])",
                            "Call"
                        ],
                        [
                            "tf.matmul(bilinear_mapping, vector_set_2, adjoint_b=True)",
                            "Call"
                        ],
                        [
                            "tf.reshape(bilinear_mapping, [batch_size, bucket_size, output_size, bucket_size])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, bucket_size * output_size, vector_set_2_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_232": {
                "variable": {
                    "value": "bilinear_mapping",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "bilinear_mapping",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(vector_set_1, bilinear_map)",
                            "Call"
                        ],
                        [
                            "tf.reshape(bilinear_mapping, [batch_size, bucket_size * output_size, vector_set_2_size])",
                            "Call"
                        ],
                        [
                            "tf.matmul(bilinear_mapping, vector_set_2, adjoint_b=True)",
                            "Call"
                        ],
                        [
                            "tf.reshape(bilinear_mapping, [batch_size, bucket_size, output_size, bucket_size])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "vector_set_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([vector_set_2, tf.ones([batch_size, bucket_size, 1])], axis=2)",
                            "Call"
                        ]
                    ]
                },
                "adjoint_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reshape_235": {
                "variable": {
                    "value": "bilinear_mapping",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "bilinear_mapping",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(vector_set_1, bilinear_map)",
                            "Call"
                        ],
                        [
                            "tf.reshape(bilinear_mapping, [batch_size, bucket_size * output_size, vector_set_2_size])",
                            "Call"
                        ],
                        [
                            "tf.matmul(bilinear_mapping, vector_set_2, adjoint_b=True)",
                            "Call"
                        ],
                        [
                            "tf.reshape(bilinear_mapping, [batch_size, bucket_size, output_size, bucket_size])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, bucket_size, output_size, bucket_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dropout_289": {
                "variable": {
                    "value": "self._dropout_mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones([batch_size, self.output_size])",
                    "type": "Call",
                    "possible_values": []
                },
                "rate": {
                    "value": "dropout",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "get_variable_291": {
                "variable": {
                    "value": "initial_cell_state",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "lstm_initial_cell_state",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, self.output_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_292": {
                "variable": {
                    "value": "initial_hidden_state",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "lstm_initial_hidden_state",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, self.output_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_293": {
                "variable": {
                    "value": "self._initial_state",
                    "type": "Attribute",
                    "possible_values": []
                },
                "c": {
                    "value": "initial_cell_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('lstm_initial_cell_state', [1, self.output_size])",
                            "Call"
                        ]
                    ]
                },
                "h": {
                    "value": "initial_hidden_state",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "split_79": {
                "variable": {
                    "value": "(j, f)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "projection(inputs, 2 * shape(inputs, -1))",
                    "type": "Call",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "sigmoid_80": {
                "variable": {
                    "value": "f",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "f",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(f)",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_81": {
                "variable": {
                    "value": "j",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "j",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(j)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(j, dropout)",
                            "Call"
                        ]
                    ]
                }
            },
            "dropout_108": {
                "variable": {
                    "value": "current_outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "current_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(tf.nn.xw_plus_b(current_inputs, hidden_weights, hidden_bias))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(current_outputs, dropout)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "dropout",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "get_variable_124": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[filter_size, input_size, num_filters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_125": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "b",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_filters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_140": {
                "input": {
                    "value": "x_bnv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(x_bnv, keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_187": {
                "name_or_scope": {
                    "value": "Bilinear",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_193": {
                "variable": {
                    "value": "vector_set_1",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[vector_set_1, tf.ones([batch_size, bucket_size, 1])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_196": {
                "variable": {
                    "value": "vector_set_2",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[vector_set_2, tf.ones([batch_size, bucket_size, 1])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_297": {
                "c": {
                    "value": "self.output_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "h": {
                    "value": "self.output_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_313": {
                "variable": {
                    "value": "(i, j, o)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "concat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "projection(tf.concat([inputs, h], 1), 3 * self.output_size, initializer=self._initializer)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_314": {
                "variable": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(num_layers)",
                            "Call"
                        ],
                        [
                            "range(num_hidden_layers)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(i)",
                            "Call"
                        ]
                    ]
                }
            },
            "LSTMStateTuple_317": {
                "variable": {
                    "value": "new_state",
                    "type": "variable",
                    "possible_values": []
                },
                "c": {
                    "value": "new_c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(1 - i) * c + i * tf.tanh(j)",
                            "BinOp"
                        ]
                    ]
                },
                "h": {
                    "value": "new_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tanh(new_c) * tf.sigmoid(o)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "variable_scope_78": {
                "name_or_scope": {
                    "value": "'highway_{}'.format(i)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dropout_83": {
                "variable": {
                    "value": "j",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "j",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(j)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(j, dropout)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "dropout",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_88": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "xw_plus_b_105": {
                "x": {
                    "value": "current_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [batch_size * seqlen, emb_size])",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "current_outputs",
                            "variable"
                        ]
                    ]
                },
                "weights": {
                    "value": "hidden_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('hidden_weights_{}'.format(i), [shape(current_inputs, 1), hidden_size])",
                            "Call"
                        ]
                    ]
                },
                "biases": {
                    "value": "hidden_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('hidden_bias_{}'.format(i), [hidden_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_123": {
                "name_or_scope": {
                    "value": "'conv_{}'.format(i)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "bias_add_127": {
                "value": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(inputs, w, stride=1, padding='VALID')",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('b', [num_filters])",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_initializer_151": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "shape_189": {
                "input": {
                    "value": "vector_set_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([vector_set_1, tf.ones([batch_size, bucket_size, 1])], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.reshape(vector_set_1, [-1, vector_set_1_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_190": {
                "input": {
                    "value": "vector_set_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([vector_set_1, tf.ones([batch_size, bucket_size, 1])], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.reshape(vector_set_1, [-1, vector_set_1_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_289": {
                "shape": {
                    "value": "[batch_size, self.output_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_309": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "concat_312": {
                "values": {
                    "value": "[inputs, h]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tanh_316": {
                "x": {
                    "value": "new_c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(1 - i) * c + i * tf.tanh(j)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "sigmoid_316": {
                "x": {
                    "value": "o",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ones_194": {
                "shape": {
                    "value": "[batch_size, bucket_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_197": {
                "shape": {
                    "value": "[batch_size, bucket_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tanh_315": {
                "x": {
                    "value": "j",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(j)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(j, dropout)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    }
}