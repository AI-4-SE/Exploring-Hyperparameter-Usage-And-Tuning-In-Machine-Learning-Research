{
    "GAN.py": {
        "tensorflow": {
            "get_collection_22": {
                "variable": {
                    "value": "self.g_vars",
                    "type": "Attribute",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "g_scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'gen'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_collection_24": {
                "variable": {
                    "value": "self.d_vars",
                    "type": "Attribute",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "d_scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'discrim'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sigmoid_37": {
                "variable": {
                    "value": "score_real",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits_real",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sigmoid_38": {
                "variable": {
                    "value": "score_fake",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits_fake",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "name_scope_36": {
                "name": {
                    "value": "GAN_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "histogram_39": {
                "name": {
                    "value": "score-real",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "score_real",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(logits_real)",
                            "Call"
                        ]
                    ]
                }
            },
            "histogram_40": {
                "name": {
                    "value": "score-fake",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "score_fake",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(logits_fake)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_43": {
                "variable": {
                    "value": "d_loss_pos",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.nn.sigmoid_cross_entropy_with_logits(logits=logits_real, labels=tf.ones_like(logits_real))",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "loss_real",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_45": {
                "variable": {
                    "value": "d_loss_neg",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.nn.sigmoid_cross_entropy_with_logits(logits=logits_fake, labels=tf.zeros_like(logits_fake))",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "loss_fake",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_48": {
                "variable": {
                    "value": "d_pos_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(score_real > 0.5, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "accuracy_real",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_49": {
                "variable": {
                    "value": "d_neg_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(score_fake < 0.5, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "accuracy_fake",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_51": {
                "variable": {
                    "value": "d_accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "0.5 * d_pos_acc",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0.5 * d_neg_acc",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "accuracy",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_52": {
                "variable": {
                    "value": "self.d_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "0.5 * d_loss_pos",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0.5 * d_loss_neg",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_55": {
                "variable": {
                    "value": "self.g_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.nn.sigmoid_cross_entropy_with_logits(logits=logits_fake, labels=tf.ones_like(logits_fake))",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_57": {
                "variable": {
                    "value": "g_accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(score_fake > 0.5, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "accuracy",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_111": {
                "name": {
                    "value": "optimize",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_133": {
                "name": {
                    "value": "optimize",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_181": {
                "name": {
                    "value": "optimize",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_42": {
                "name": {
                    "value": "discrim",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_54": {
                "name": {
                    "value": "gen",
                    "type": "str",
                    "possible_values": []
                }
            },
            "control_dependencies_113": {
                "control_inputs": {
                    "value": "[g_min]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_n_134": {
                "inputs": {
                    "value": "[x[0] for x in cost_list]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "add_n_135": {
                "inputs": {
                    "value": "[x[1] for x in cost_list]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "control_dependencies_141": {
                "control_inputs": {
                    "value": "[g_min]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_with_logits_43": {
                "logits": {
                    "value": "logits_real",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.ones_like(logits_real)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_with_logits_45": {
                "logits": {
                    "value": "logits_fake",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.zeros_like(logits_fake)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_48": {
                "x": {
                    "value": "score_real > 0.5",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_49": {
                "x": {
                    "value": "score_fake < 0.5",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_with_logits_55": {
                "logits": {
                    "value": "logits_fake",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.ones_like(logits_fake)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_57": {
                "x": {
                    "value": "score_fake > 0.5",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_like_44": {
                "input": {
                    "value": "logits_real",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "zeros_like_46": {
                "input": {
                    "value": "logits_fake",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ones_like_56": {
                "input": {
                    "value": "logits_fake",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "GAN_bicycle.py": {
        "tensorflow": {
            "get_collection_23": {
                "variable": {
                    "value": "self.g_vars",
                    "type": "Attribute",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "g_scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'gen'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_collection_30": {
                "variable": {
                    "value": "self.d_vars",
                    "type": "Attribute",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "d_scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'discrim'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sigmoid_43": {
                "variable": {
                    "value": "score_real",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits_real",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sigmoid_44": {
                "variable": {
                    "value": "score_fake",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits_fake",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "name_scope_42": {
                "name": {
                    "value": "GAN_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "histogram_45": {
                "name": {
                    "value": "score-real",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "score_real",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(logits_real)",
                            "Call"
                        ]
                    ]
                }
            },
            "histogram_46": {
                "name": {
                    "value": "score-fake",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "score_fake",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(logits_fake)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_49": {
                "variable": {
                    "value": "d_loss_pos",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.nn.sigmoid_cross_entropy_with_logits(logits=logits_real, labels=tf.ones_like(logits_real))",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "loss_real",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_51": {
                "variable": {
                    "value": "d_loss_neg",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.nn.sigmoid_cross_entropy_with_logits(logits=logits_fake, labels=tf.zeros_like(logits_fake))",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "loss_fake",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_54": {
                "variable": {
                    "value": "d_pos_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(score_real > 0.5, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "accuracy_real",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_55": {
                "variable": {
                    "value": "d_neg_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(score_fake < 0.5, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "accuracy_fake",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_57": {
                "variable": {
                    "value": "d_accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "0.5 * d_pos_acc",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0.5 * d_neg_acc",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "accuracy",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_58": {
                "variable": {
                    "value": "self.d_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "0.5 * d_loss_pos",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0.5 * d_loss_neg",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_61": {
                "variable": {
                    "value": "self.g_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.nn.sigmoid_cross_entropy_with_logits(logits=logits_fake, labels=tf.ones_like(logits_fake))",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_63": {
                "variable": {
                    "value": "g_accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(score_fake > 0.5, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "accuracy",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_117": {
                "name": {
                    "value": "optimize",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_141": {
                "name": {
                    "value": "optimize",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_193": {
                "name": {
                    "value": "optimize",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_48": {
                "name": {
                    "value": "discrim",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_60": {
                "name": {
                    "value": "gen",
                    "type": "str",
                    "possible_values": []
                }
            },
            "control_dependencies_119": {
                "control_inputs": {
                    "value": "[g_min]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "control_dependencies_121": {
                "control_inputs": {
                    "value": "[g_min_e]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_n_142": {
                "inputs": {
                    "value": "[x[0] for x in cost_list]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "add_n_143": {
                "inputs": {
                    "value": "[x[1] for x in cost_list]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "add_n_144": {
                "inputs": {
                    "value": "[x[2] for x in cost_list]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "control_dependencies_150": {
                "control_inputs": {
                    "value": "[g_min]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "control_dependencies_153": {
                "control_inputs": {
                    "value": "[g_min_e]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_with_logits_49": {
                "logits": {
                    "value": "logits_real",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.ones_like(logits_real)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_with_logits_51": {
                "logits": {
                    "value": "logits_fake",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.zeros_like(logits_fake)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_54": {
                "x": {
                    "value": "score_real > 0.5",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_55": {
                "x": {
                    "value": "score_fake < 0.5",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_with_logits_61": {
                "logits": {
                    "value": "logits_fake",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.ones_like(logits_fake)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_63": {
                "x": {
                    "value": "score_fake > 0.5",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_like_50": {
                "input": {
                    "value": "logits_real",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "zeros_like_52": {
                "input": {
                    "value": "logits_fake",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ones_like_62": {
                "input": {
                    "value": "logits_fake",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "Inference_Instance_generation_grid.py": {
        "tensorflow": {
            "GraphDef_30": {
                "variable": {
                    "value": "graph_def",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "GraphDef_44": {
                "variable": {
                    "value": "graph_def",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "GFile_29": {
                "name": {
                    "value": "args.mask_model",
                    "type": "Attribute",
                    "possible_values": []
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Graph_32": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "import_graph_def_33": {
                "graph_def": {
                    "value": "graph_def",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.GraphDef()",
                            "Call"
                        ],
                        [
                            "tf.GraphDef()",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_43": {
                "name": {
                    "value": "args.rgb_model",
                    "type": "Attribute",
                    "possible_values": []
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Graph_46": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "import_graph_def_47": {
                "graph_def": {
                    "value": "graph_def",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.GraphDef()",
                            "Call"
                        ],
                        [
                            "tf.GraphDef()",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Session_68": {
                "graph": {
                    "value": "graph_mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Session_87": {
                "graph": {
                    "value": "graph_rgb",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "mask_gen.py": {
        "tensorflow": {
            "reduce_mean_156": {
                "variable": {
                    "value": "gap",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "pad_85": {
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [pad, pad], [pad, pad], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "mode": {
                    "value": "mode",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'CONSTANT'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "add_94": {
                "x": {
                    "value": "gamma * x",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('beta', [1, 1, 1, C], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "0.0",
                            "Method Argument"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "AdaIn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_98": {
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "leaky_relu_102": {
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "moments_108": {
                "variable": {
                    "value": "(mean, var)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_109": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "scale",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[x.get_shape()[-1]]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.truncated_normal_initializer(mean=1.0, stddev=0.02)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_113": {
                "variable": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "offset",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[x.get_shape()[-1]]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_122": {
                "x": {
                    "value": "gamma * LayerNorm('lnorm', x)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('beta', [1, 1, 1, C], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "0.0",
                            "Method Argument"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "AdaLN",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_129": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, H, W, G, C // G]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "moments_130": {
                "variable": {
                    "value": "(mean, var)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[1, 2, 4]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_133": {
                "variable": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "gamma",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, 1, C]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_134": {
                "variable": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "beta",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, 1, C]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "leaky_relu_142": {
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "leaky_relu_146": {
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "resize_nearest_neighbor_151": {
                "images": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "new_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[h * scale_factor, w * scale_factor]",
                            "List"
                        ]
                    ]
                },
                "align_corners": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "trainable_variables_165": {
                "variable": {
                    "value": "vars",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "group_167": {
                "variable": {
                    "value": "self._check_op",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*ops",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "add_n_567": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "name": {
                    "value": "feature_match_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_677": {
                "variable": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "learning_rate",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "0.0002",
                    "type": "float",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_106": {
                "name_or_scope": {
                    "value": "instance_norm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_125": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "default_name": {
                    "value": "GroupNorm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "conv2d_203": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "chan",
                    "type": "variable",
                    "possible_values": [
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "chan * 2",
                            "BinOp"
                        ],
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "activation": {
                    "value": "activ",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lambda y: tf.add(mu * GroupNorm(y), sigma, name='gnorm')",
                            "Lambda"
                        ]
                    ]
                },
                "name": {
                    "value": "conv0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "leaky_relu_204": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_206": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "chan",
                    "type": "variable",
                    "possible_values": [
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "chan * 2",
                            "BinOp"
                        ],
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "activation": {
                    "value": "activ",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lambda y: tf.add(mu * GroupNorm(y), sigma, name='gnorm')",
                            "Lambda"
                        ]
                    ]
                },
                "name": {
                    "value": "conv1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_236": {
                "variable": {
                    "value": "res_in",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[c, s]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "conv2d_256": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "chan",
                    "type": "variable",
                    "possible_values": [
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "chan * 2",
                            "BinOp"
                        ],
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "7",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "conv_0",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.leaky_relu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "conv2d_269": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "STYLE_DIM_z2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8",
                            "int"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "name": {
                    "value": "SE_logit",
                    "type": "str",
                    "possible_values": []
                }
            },
            "conv2d_280": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "chan",
                    "type": "variable",
                    "possible_values": [
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "chan * 2",
                            "BinOp"
                        ],
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "7",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "conv_0",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.leaky_relu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "flatten_301": {
                "variable": {
                    "value": "style",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "style",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.flatten(style)",
                            "Call"
                        ]
                    ]
                }
            },
            "dense_302": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "style",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.flatten(style)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "channel * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.leaky_relu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "linear_0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dense_303": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "channel * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.leaky_relu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "linear_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dense_304": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "channel * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.leaky_relu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "linear_2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tile_306": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x[:, np.newaxis]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, nb_upsampling, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_450": {
                "variable": {
                    "value": "musigma",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "musigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(musigma, [-1, 2, chan])",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(musigma)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 2, chan]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_452": {
                "variable": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "musigma[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(mu, [-1, 1, 1, chan])",
                            "Call"
                        ],
                        [
                            "musigmai[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(mu, [-1, 1, 1, chs])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1, 1, chan]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_454": {
                "variable": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "musigma[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chan])",
                            "Call"
                        ],
                        [
                            "musigmai[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chs])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1, 1, chan]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_458": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mu * InstanceNorm('in_0', x, use_affine=False)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "musigma[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chan])",
                            "Call"
                        ],
                        [
                            "musigmai[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chs])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "adain_0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_461": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mu * InstanceNorm('in_1', x, use_affine=False)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "musigma[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chan])",
                            "Call"
                        ],
                        [
                            "musigmai[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chs])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "adain_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "flatten_501": {
                "variable": {
                    "value": "musigma",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "musigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(musigma, [-1, 2, chan])",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(musigma)",
                            "Call"
                        ]
                    ]
                }
            },
            "dense_502": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "musigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(musigma, [-1, 2, chan])",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(musigma)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "dimz",
                    "type": "variable",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.leaky_relu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "linear_0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dense_503": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "dimz",
                    "type": "variable",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.leaky_relu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "linear_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_504": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1, 1, dimz]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "flatten_520": {
                "variable": {
                    "value": "l2",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "l2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Conv2D('conv1', l1, NF * 2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', l1, NF * 4, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(l2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', l1, 1, strides=1, activation=tf.identity, use_bias=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "dense_521": {
                "variable": {
                    "value": "l3",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "l2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Conv2D('conv1', l1, NF * 2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', l1, NF * 4, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(l2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', l1, 1, strides=1, activation=tf.identity, use_bias=True)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.identity",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "imisreal",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_557": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.squared_difference(fm_loss_real, tf.reduce_mean(fake, 0))",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "'mse_feat_' + real.op.name",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "multiply_574": {
                "variable": {
                    "value": "img_crop",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": [
                        [
                            "img / 128.0 - 1.0",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "1 - box",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_647": {
                "variable": {
                    "value": "d_real",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "-tf.minimum(0.0, tf.subtract(real, 1.0))",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "name": {
                    "value": "d_real",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_648": {
                "variable": {
                    "value": "d_fake",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "-tf.minimum(0.0, tf.add(-fake, -1.0))",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "name": {
                    "value": "d_fake",
                    "type": "str",
                    "possible_values": []
                }
            },
            "multiply_649": {
                "variable": {
                    "value": "d_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "d_real + d_fake",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                },
                "name": {
                    "value": "d_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_651": {
                "variable": {
                    "value": "g_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "-fake",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "name": {
                    "value": "g_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "AdamOptimizer_678": {
                "learning_rate": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('learning_rate', initializer=0.0002, trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "beta1": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Exists_66": {
                "filename": {
                    "value": "obj",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(obj)",
                            "Call"
                        ],
                        [
                            "np.load(filename, encoding='latin1').item()",
                            "Call"
                        ],
                        [
                            "dict(np.load(filename))",
                            "Call"
                        ]
                    ]
                }
            },
            "rsqrt_131": {
                "x": {
                    "value": "var + epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "placeholder_175": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, SHAPE, SHAPE, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_176": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, SHAPE, SHAPE, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "template",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_177": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, SHAPE, SHAPE, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "mask",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_178": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, 1, 1, 4)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "bbx",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_179": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, 1, 1, STYLE_DIM)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "z1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_180": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, 1, 1, STYLE_DIM_z2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "z2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_185": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_197": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_213": {
                "name_or_scope": {
                    "value": "igen",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_229": {
                "name_or_scope": {
                    "value": "dec",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_251": {
                "name_or_scope": {
                    "value": "senc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "conv2d_261": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "chan * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "'conv_%d' % (i + 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "conv2d_266": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "chan",
                    "type": "variable",
                    "possible_values": [
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "chan * 2",
                            "BinOp"
                        ],
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "'dconv_%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_276": {
                "name_or_scope": {
                    "value": "cenc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "conv2d_285": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "chan * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "'conv_%d' % (i + 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_297": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_321": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_367": {
                "name_or_scope": {
                    "value": "menc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_447": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_481": {
                "variable": {
                    "value": "musigmai",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "musigmai",
                    "type": "variable",
                    "possible_values": [
                        [
                            "musigma[:, i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(musigmai, [-1, 2, chs])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 2, chs]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_483": {
                "variable": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "musigma[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(mu, [-1, 1, 1, chan])",
                            "Call"
                        ],
                        [
                            "musigmai[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(mu, [-1, 1, 1, chs])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1, 1, chs]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_485": {
                "variable": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "musigma[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chan])",
                            "Call"
                        ],
                        [
                            "musigmai[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chs])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1, 1, chs]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_486": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mu * InstanceNorm('in_%i' % i, x, use_affine=False)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "musigma[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chan])",
                            "Call"
                        ],
                        [
                            "musigmai[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chs])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "'adain%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_498": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_547": {
                "variable": {
                    "value": "fm_loss_real",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "'fm_real_%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "real.shape[1:]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "add_to_collection_564": {
                "name": {
                    "value": "tf.GraphKeys.UPDATE_OPS",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "ema_real_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "moving_averages.assign_moving_average(fm_loss_real, tf.reduce_mean(real, 0), 0.99, zero_debias=False, name='EMA_fm_real_%d' % i)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_573": {
                "name": {
                    "value": "preprocess",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_581": {
                "name": {
                    "value": "styleIn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_587": {
                "variable": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "grayscale_to_rgb_588": {
                "variable": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.layers.UpSampling2D(2, data_format=None)(m)",
                            "Call"
                        ],
                        [
                            "tf.concat(a, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.image.grayscale_to_rgb(m)",
                            "Call"
                        ],
                        [
                            "(m + 1.0) * 128",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(m, 0, 255)",
                            "Call"
                        ],
                        [
                            "tf.cast(m, tf.uint8, name='viz')",
                            "Call"
                        ]
                    ]
                }
            },
            "clip_by_value_590": {
                "variable": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.layers.UpSampling2D(2, data_format=None)(m)",
                            "Call"
                        ],
                        [
                            "tf.concat(a, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.image.grayscale_to_rgb(m)",
                            "Call"
                        ],
                        [
                            "(m + 1.0) * 128",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(m, 0, 255)",
                            "Call"
                        ],
                        [
                            "tf.cast(m, tf.uint8, name='viz')",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "255",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_591": {
                "variable": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.layers.UpSampling2D(2, data_format=None)(m)",
                            "Call"
                        ],
                        [
                            "tf.concat(a, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.image.grayscale_to_rgb(m)",
                            "Call"
                        ],
                        [
                            "(m + 1.0) * 128",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(m, 0, 255)",
                            "Call"
                        ],
                        [
                            "tf.cast(m, tf.uint8, name='viz')",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.uint8",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "viz",
                    "type": "str",
                    "possible_values": []
                }
            },
            "image_592": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                },
                "data": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.layers.UpSampling2D(2, data_format=None)(m)",
                            "Call"
                        ],
                        [
                            "tf.concat(a, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.image.grayscale_to_rgb(m)",
                            "Call"
                        ],
                        [
                            "(m + 1.0) * 128",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(m, 0, 255)",
                            "Call"
                        ],
                        [
                            "tf.cast(m, tf.uint8, name='viz')",
                            "Call"
                        ]
                    ]
                },
                "max_outputs": {
                    "value": "50",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_598": {
                "variable": {
                    "value": "mlp_in",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[z, bbx]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "name_scope_655": {
                "name": {
                    "value": "losses",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Glob_73": {
                "filename": {
                    "value": "obj + '*'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "truncated_normal_initializer_110": {
                "mean": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "0.02",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_115": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "div_117": {
                "x": {
                    "value": "x - mean",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.sqrt(var + epsilon)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_initializer_133": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_134": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reshape_137": {
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "LinearWrap(x).tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', chan, 3, padding='VALID').tf.pad([[0, 0], [1, 1], [1, 1], [0, 0]], mode='SYMMETRIC').Conv2D('conv1', chan, 3, padding='VALID', activation=tf.identity)()",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, name='dconv_%d' % i)",
                            "Call"
                        ],
                        [
                            "adaptive_avg_pooling(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, STYLE_DIM_z2, kernel_size=1, strides=1, activation=None, name='SE_logit')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, H, W, C]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "check_numerics_166": {
                "tensor": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "message": {
                    "value": "\"CheckNumerics['{}']\".format(v.op.name)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_200": {
                "x": {
                    "value": "mu * GroupNorm(y)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "musigma[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chan])",
                            "Call"
                        ],
                        [
                            "musigmai[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chs])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "gnorm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "UpSampling2D_438": {
                "size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "data_format": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "variable_scope_546": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "squared_difference_557": {
                "x": {
                    "value": "fm_loss_real",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('fm_real_%d' % i, real.shape[1:], dtype=tf.float32, trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.reduce_mean(fake, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_586": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_597": {
                "name_or_scope": {
                    "value": "gen",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_612": {
                "name_or_scope": {
                    "value": "discrim",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tile_619": {
                "variable": {
                    "value": "bbx_tile",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "bbx",
                    "type": "variable",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, SHAPE, SHAPE, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_620": {
                "variable": {
                    "value": "D_input_real",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[mask, bbx_tile]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_621": {
                "variable": {
                    "value": "D_input_fake",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[gen_mask, bbx_tile]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "name_scope_656": {
                "name": {
                    "value": "mask_losses",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_n_660": {
                "variable": {
                    "value": "G_loss_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "G_loss_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n(G_loss_mask, name='mask_lsgan_loss')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "mask_lsgan_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_n_661": {
                "variable": {
                    "value": "D_loss_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "D_loss_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n(D_loss_mask, name='mask_Disc_loss')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "mask_Disc_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_665": {
                "variable": {
                    "value": "z_recon_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.abs(z - z_recon)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "z_recon_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "sqrt_117": {
                "x": {
                    "value": "var + epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_554": {
                "input_tensor": {
                    "value": "real",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_559": {
                "input_tensor": {
                    "value": "fake",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_582": {
                "input": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask / 128.0 - 1.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "variable_scope_599": {
                "name_or_scope": {
                    "value": "mlpz",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_601": {
                "name_or_scope": {
                    "value": "genmask",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_603": {
                "name_or_scope": {
                    "value": "recon_z",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_613": {
                "name_or_scope": {
                    "value": "discrim_mask",
                    "type": "str",
                    "possible_values": []
                }
            },
            "minimum_647": {
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.subtract(real, 1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "minimum_648": {
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.add(-fake, -1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_657": {
                "name": {
                    "value": "GAN_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_662": {
                "name": {
                    "value": "FM_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_664": {
                "name": {
                    "value": "z_recon_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_604": {
                "input_tensor": {
                    "value": "mu_sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.MLP(mlp_in, chs, nb_blocks)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "average_pooling2d_615": {
                "inputs": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": [
                        [
                            "img / 128.0 - 1.0",
                            "BinOp"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "subtract_647": {
                "x": {
                    "value": "real",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "add_648": {
                "x": {
                    "value": "-fake",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "y": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "abs_665": {
                "x": {
                    "value": "z - z_recon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_625": {
                "name_or_scope": {
                    "value": "'s%d' % s",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_631": {
                "name_or_scope": {
                    "value": "Ax",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_635": {
                "name_or_scope": {
                    "value": "Ah",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "rgb_gen.py": {
        "tensorflow": {
            "reduce_mean_188": {
                "variable": {
                    "value": "gap",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "average_pooling2d_40": {
                "inputs": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": [
                        [
                            "img / 128.0 - 1.0",
                            "BinOp"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "average_pooling2d_90": {
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "scale_factor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "2",
                            "Method Argument"
                        ],
                        [
                            "2",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pad_104": {
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [pad, pad], [pad, pad], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "mode": {
                    "value": "mode",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'CONSTANT'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "add_113": {
                "x": {
                    "value": "gamma * x",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('beta', [1, 1, 1, C], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "0.0",
                            "Method Argument"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "AdaIn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_117": {
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "leaky_relu_121": {
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "moments_127": {
                "variable": {
                    "value": "(mean, var)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_128": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "scale",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[x.get_shape()[-1]]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.truncated_normal_initializer(mean=1.0, stddev=0.02)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_132": {
                "variable": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "offset",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[x.get_shape()[-1]]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_141": {
                "x": {
                    "value": "gamma * LayerNorm('lnorm', x)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('beta', [1, 1, 1, C], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "0.0",
                            "Method Argument"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "AdaLN",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_148": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, H, W, G, C // G]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "moments_149": {
                "variable": {
                    "value": "(mean, var)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[1, 2, 4]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_152": {
                "variable": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "gamma",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, 1, C]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_153": {
                "variable": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "beta",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, 1, C]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "split_163": {
                "variable": {
                    "value": "(f_1, f_2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "f",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fs",
                            "variable"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_n_166": {
                "inputs": {
                    "value": "flist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "name": {
                    "value": "ploss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "leaky_relu_170": {
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "leaky_relu_174": {
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "leaky_relu_179": {
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "resize_nearest_neighbor_183": {
                "images": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "new_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[h * scale_factor, w * scale_factor]",
                            "List"
                        ]
                    ]
                },
                "align_corners": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "trainable_variables_197": {
                "variable": {
                    "value": "vars",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "group_199": {
                "variable": {
                    "value": "self._check_op",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*ops",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "add_n_677": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "name": {
                    "value": "feature_match_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_805": {
                "variable": {
                    "value": "numelmask",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "bin_gen_mask_gt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.round((mask + 1) * 0.5)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "where_807": {
                "variable": {
                    "value": "numelmask",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.equal(numelmask, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "numelall",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones_like(numelmask) * SHAPE * SHAPE",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "numelmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(bin_gen_mask_gt, axis=[1, 2, 3])",
                            "Call"
                        ],
                        [
                            "tf.where(tf.equal(numelmask, 0), numelall, numelmask)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_855": {
                "variable": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "learning_rate",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "0.0002",
                    "type": "float",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_93": {
                "input": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(x, STYLE_DIM_z2, name='fcmean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(mean, [-1, 1, 1, STYLE_DIM_z2])",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_99": {
                "input_tensor": {
                    "value": "tf.square(mean) + tf.exp(logvar) - 1 - logvar",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_125": {
                "name_or_scope": {
                    "value": "instance_norm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_144": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'vgg_16'",
                            "Method Argument"
                        ]
                    ]
                },
                "default_name": {
                    "value": "GroupNorm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GaussianNoise_177": {
                "stddev": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "conv2d_231": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "chan",
                    "type": "variable",
                    "possible_values": [
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "chan * 2",
                            "BinOp"
                        ],
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "activation": {
                    "value": "activ",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lambda y: tf.add(mu * GroupNorm(y), sigma, name='gnorm')",
                            "Lambda"
                        ]
                    ]
                },
                "name": {
                    "value": "conv0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "leaky_relu_232": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_234": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "chan",
                    "type": "variable",
                    "possible_values": [
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "chan * 2",
                            "BinOp"
                        ],
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "activation": {
                    "value": "activ",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lambda y: tf.add(mu * GroupNorm(y), sigma, name='gnorm')",
                            "Lambda"
                        ]
                    ]
                },
                "name": {
                    "value": "conv1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_335": {
                "variable": {
                    "value": "res_in",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[c, s]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "conv2d_353": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "chan",
                    "type": "variable",
                    "possible_values": [
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "chan * 2",
                            "BinOp"
                        ],
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "INLReLU",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "conv_0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "conv2d_360": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "chan",
                    "type": "variable",
                    "possible_values": [
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "chan * 2",
                            "BinOp"
                        ],
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "INLReLU",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "'conv_%d' % (i + 2)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "conv2d_361": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "chan",
                    "type": "variable",
                    "possible_values": [
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "chan * 2",
                            "BinOp"
                        ],
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "INLReLU",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "'conv_%d' % (i + 3)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "flatten_363": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                }
            },
            "dense_364": {
                "variable": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "STYLE_DIM_z2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8",
                            "int"
                        ]
                    ]
                },
                "name": {
                    "value": "fcmean",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_365": {
                "variable": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(x, STYLE_DIM_z2, name='fcmean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(mean, [-1, 1, 1, STYLE_DIM_z2])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1, 1, STYLE_DIM_z2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dense_366": {
                "variable": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "STYLE_DIM_z2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8",
                            "int"
                        ]
                    ]
                },
                "name": {
                    "value": "fcvar",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_367": {
                "variable": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(x, STYLE_DIM_z2, name='fcvar')",
                            "Call"
                        ],
                        [
                            "tf.reshape(var, [-1, 1, 1, STYLE_DIM_z2])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1, 1, STYLE_DIM_z2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "conv2d_377": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "chan",
                    "type": "variable",
                    "possible_values": [
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "chan * 2",
                            "BinOp"
                        ],
                        [
                            "NF",
                            "variable"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "7",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "conv_0",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.leaky_relu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "flatten_398": {
                "variable": {
                    "value": "style",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "style",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.flatten(style)",
                            "Call"
                        ]
                    ]
                }
            },
            "dense_399": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "style",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.flatten(style)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "channel * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.leaky_relu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "linear_0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dense_400": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "channel * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.leaky_relu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "linear_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dense_401": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "channel * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.leaky_relu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "linear_2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tile_403": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x[:, np.newaxis]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, nb_upsampling, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_496": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[img, z]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "pad_497": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [3, 3], [3, 3], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "mode": {
                    "value": "SYMMETRIC",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_499": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x, z]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_501": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x, down_sample_avg(z, 2)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_503": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x, down_sample_avg(z, 4)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_505": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x, down_sample_avg(z, 8)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "pad_516": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [3, 3], [3, 3], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "mode": {
                    "value": "SYMMETRIC",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_559": {
                "variable": {
                    "value": "musigma",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "musigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(musigma, [-1, 2, chan])",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(musigma)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 2, chan]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_561": {
                "variable": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "musigma[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(mu, [-1, 1, 1, chan])",
                            "Call"
                        ],
                        [
                            "musigmai[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(mu, [-1, 1, 1, chs])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1, 1, chan]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_563": {
                "variable": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "musigma[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chan])",
                            "Call"
                        ],
                        [
                            "musigmai[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chs])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1, 1, chan]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_567": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mu * InstanceNorm('in_0', x, use_affine=False)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "musigma[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chan])",
                            "Call"
                        ],
                        [
                            "musigmai[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chs])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "adain_0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_570": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mu * InstanceNorm('in_1', x, use_affine=False)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "musigma[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chan])",
                            "Call"
                        ],
                        [
                            "musigmai[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chs])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "adain_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "flatten_610": {
                "variable": {
                    "value": "musigma",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "musigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(musigma, [-1, 2, chan])",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(musigma)",
                            "Call"
                        ]
                    ]
                }
            },
            "dense_611": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "musigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(musigma, [-1, 2, chan])",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(musigma)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "dimz",
                    "type": "variable",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.leaky_relu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "linear_0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dense_612": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "dimz",
                    "type": "variable",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.leaky_relu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "linear_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_613": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1, 1, dimz]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "flatten_629": {
                "variable": {
                    "value": "l2",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "l2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Conv2D('conv1', l1, NF * 2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', l1, NF * 4, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(l2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', l1, 1, strides=1, activation=tf.identity, use_bias=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "dense_630": {
                "variable": {
                    "value": "l3",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "l2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Conv2D('conv1', l1, NF * 2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', l1, NF * 4, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(l2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', l1, 1, strides=1, activation=tf.identity, use_bias=True)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.identity",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "imisreal",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_667": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.squared_difference(fm_loss_real, tf.reduce_mean(fake, 0))",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "'mse_feat_' + real.op.name",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "multiply_684": {
                "variable": {
                    "value": "img_crop",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": [
                        [
                            "img / 128.0 - 1.0",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "1 - box",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_797": {
                "variable": {
                    "value": "d_real",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "-tf.minimum(0.0, tf.subtract(real, 1.0))",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "name": {
                    "value": "d_real",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_798": {
                "variable": {
                    "value": "d_fake",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "-tf.minimum(0.0, tf.add(-fake, -1.0))",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "name": {
                    "value": "d_fake",
                    "type": "str",
                    "possible_values": []
                }
            },
            "multiply_799": {
                "variable": {
                    "value": "d_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "d_real + d_fake",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                },
                "name": {
                    "value": "d_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_801": {
                "variable": {
                    "value": "g_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "-fake",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "name": {
                    "value": "g_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "histogram_848": {
                "name": {
                    "value": "z_var",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "zgt_var",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "histogram_849": {
                "name": {
                    "value": "z_mean",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "zgt_mean",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "AdamOptimizer_856": {
                "learning_rate": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('learning_rate', initializer=0.0002, trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "beta1": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Exists_71": {
                "filename": {
                    "value": "obj",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(obj)",
                            "Call"
                        ],
                        [
                            "np.load(filename, encoding='latin1').item()",
                            "Call"
                        ],
                        [
                            "dict(np.load(filename))",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_95": {
                "x": {
                    "value": "logvar * 0.5",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "rsqrt_150": {
                "x": {
                    "value": "var + epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "placeholder_207": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, SHAPE, SHAPE, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_208": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, SHAPE, SHAPE, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "template",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_209": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, SHAPE, SHAPE, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "mask",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_210": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, 1, 1, 4)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "bbx",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_211": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, 1, 1, STYLE_DIM)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "z1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_212": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, 1, 1, STYLE_DIM_z2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "z2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_217": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_225": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_241": {
                "name_or_scope": {
                    "value": "igen",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_294": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'vgg_16'",
                            "Method Argument"
                        ]
                    ]
                },
                "default_name": {
                    "value": "vgg_16",
                    "type": "str",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_328": {
                "name_or_scope": {
                    "value": "dec",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_350": {
                "name_or_scope": {
                    "value": "senc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "conv2d_357": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "chan * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "INLReLU",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "'conv_%d' % (i + 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_373": {
                "name_or_scope": {
                    "value": "cenc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "conv2d_382": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "chan * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "'conv_%d' % (i + 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_394": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_418": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_464": {
                "name_or_scope": {
                    "value": "menc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_556": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_590": {
                "variable": {
                    "value": "musigmai",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "musigmai",
                    "type": "variable",
                    "possible_values": [
                        [
                            "musigma[:, i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(musigmai, [-1, 2, chs])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 2, chs]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_592": {
                "variable": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "musigma[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(mu, [-1, 1, 1, chan])",
                            "Call"
                        ],
                        [
                            "musigmai[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(mu, [-1, 1, 1, chs])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1, 1, chs]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_594": {
                "variable": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "musigma[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chan])",
                            "Call"
                        ],
                        [
                            "musigmai[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chs])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1, 1, chs]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_595": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mu * InstanceNorm('in_%i' % i, x, use_affine=False)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "musigma[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chan])",
                            "Call"
                        ],
                        [
                            "musigmai[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chs])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "'adain%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_607": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_657": {
                "variable": {
                    "value": "fm_loss_real",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "'fm_real_%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "real.shape[1:]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "add_to_collection_674": {
                "name": {
                    "value": "tf.GraphKeys.UPDATE_OPS",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "ema_real_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "moving_averages.assign_moving_average(fm_loss_real, tf.reduce_mean(real, 0), 0.99, zero_debias=False, name='EMA_fm_real_%d' % i)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_683": {
                "name": {
                    "value": "preprocess",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_690": {
                "name": {
                    "value": "styleIn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_696": {
                "variable": {
                    "value": "im",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "clip_by_value_698": {
                "variable": {
                    "value": "im",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "im",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(a, axis=2)",
                            "Call"
                        ],
                        [
                            "(im + 1.0) * 128",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(im, 0, 255)",
                            "Call"
                        ],
                        [
                            "tf.cast(im, tf.uint8, name='viz')",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "255",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_699": {
                "variable": {
                    "value": "im",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "im",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(a, axis=2)",
                            "Call"
                        ],
                        [
                            "(im + 1.0) * 128",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(im, 0, 255)",
                            "Call"
                        ],
                        [
                            "tf.cast(im, tf.uint8, name='viz')",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.uint8",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "viz",
                    "type": "str",
                    "possible_values": []
                }
            },
            "image_700": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                },
                "data": {
                    "value": "im",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(a, axis=2)",
                            "Call"
                        ],
                        [
                            "(im + 1.0) * 128",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(im, 0, 255)",
                            "Call"
                        ],
                        [
                            "tf.cast(im, tf.uint8, name='viz')",
                            "Call"
                        ]
                    ]
                },
                "max_outputs": {
                    "value": "50",
                    "type": "int",
                    "possible_values": []
                }
            },
            "round_707": {
                "variable": {
                    "value": "bin_gen_mask_gt",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "(mask + 1) * 0.5",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "tile_714": {
                "variable": {
                    "value": "zmat",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "zgt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "z_sample(zgt_mean, zgt_var)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, in_gen_gt.shape[1], in_gen_gt.shape[2], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_715": {
                "variable": {
                    "value": "z2mat",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "z2",
                    "type": "variable",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, in_gen_gt.shape[1], in_gen_gt.shape[2], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_716": {
                "variable": {
                    "value": "z3mat",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "z3",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_normal(style_shape_z2, mean=0.0, stddev=1.0, dtype=tf.float32, name='z3')",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, in_gen_gt.shape[1], in_gen_gt.shape[2], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "equal_807": {
                "x": {
                    "value": "numelmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(bin_gen_mask_gt, axis=[1, 2, 3])",
                            "Call"
                        ],
                        [
                            "tf.where(tf.equal(numelmask, 0), numelall, numelmask)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "name_scope_809": {
                "name": {
                    "value": "losses",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Glob_78": {
                "filename": {
                    "value": "obj + '*'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "truncated_normal_initializer_129": {
                "mean": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "0.02",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_134": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "div_136": {
                "x": {
                    "value": "x - mean",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.sqrt(var + epsilon)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_initializer_152": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_153": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reshape_156": {
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "InstanceNorm('inorm', x, use_affine=False)",
                            "Call"
                        ],
                        [
                            "AdaIN(x, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "LayerNorm('lnorm', x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, G, C // G])",
                            "Call"
                        ],
                        [
                            "(x - mean) * tf.rsqrt(var + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [-1, H, W, C]) * gamma + beta",
                            "BinOp"
                        ],
                        [
                            "GroupNorm(x)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.GaussianNoise(1)(x, training=True)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in', x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=noisyINLReLU, strides=1)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv0')",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, activation=activ, name='conv1')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_0')",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 2))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=3, strides=2, activation=INLReLU, name='conv_%d' % (i + 3))",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ],
                        [
                            "tpad(x, pad=3, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan, kernel_size=7, strides=1, name='conv_0', activation=tf.nn.leaky_relu)",
                            "Call"
                        ],
                        [
                            "tpad(x, 1, mode='reflect')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, chan * 2, kernel_size=4, strides=2, name='conv_%d' % (i + 1))",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res%d' % i, chan, first=i == 0)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(style, channel * 2, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, channel * 2, activation=tf.nn.leaky_relu, name='linear_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(x[:, np.newaxis], [1, nb_upsampling, 1])",
                            "Call"
                        ],
                        [
                            "LinearWrap(box).tf.pad([[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC').Conv2D('conv0', reshape[-1], 7, strides=1, padding='VALID').Conv2D('conv1', reshape[-1], 3, strides=2).Conv2D('conv2', reshape[-1], 3, strides=2).Conv2D('conv3', reshape[-1], 3, strides=2).Conv2D('conv4', reshape[-1], 3, strides=2).Conv2D('conv5', reshape[-1], 3, strides=2)()",
                            "Call"
                        ],
                        [
                            "tf.concat([img, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, NF, 7, activation=tf.nn.leaky_relu, padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.concat([x, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, NF * 2, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 2)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv2', x, NF * 4, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 4)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv3', x, NF * 8, 3, strides=2, activation=INLReLU)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, down_sample_avg(z, 8)], axis=-1)",
                            "Call"
                        ],
                        [
                            "Model.build_res_block(x, 'res{}'.format(k), NF * 8 + STYLE_DIM_z2, first=k == 0)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv4', x, NF * 4, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv5', x, NF * 2, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling2D(2)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv6', x, NF, 3, strides=1, activation=noisyINLReLU)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [3, 3], [3, 3], [0, 0]], mode='SYMMETRIC')",
                            "Call"
                        ],
                        [
                            "Conv2D('convlast', x, chan, 7, strides=1, padding='VALID', activation=tf.tanh, use_bias=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv0', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_0', x, use_affine=False), sigma, name='adain_0')",
                            "Call"
                        ],
                        [
                            "Conv2D('conv1', x, chan, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_1', x, use_affine=False), sigma, name='adain_1')",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconvInit', z, chs, 1, activation=tf.nn.leaky_relu, strides=4)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.add(mu * InstanceNorm('in_%i' % i, x, use_affine=False), sigma, name='adain%d' % i)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose('deconv%d' % i, x, chs, 3, activation=tf.nn.leaky_relu, strides=2)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 1), x, NF * 4, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 1), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 2), x, NF * 2, 3, activation=tf.nn.leaky_relu, strides=1)",
                            "Call"
                        ],
                        [
                            "InstanceNorm('in_%i' % (i + 2), x, use_affine=True)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv%d' % (i + 3), x, 1, 3, activation=tf.nn.tanh, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(musigma, dimz, activation=tf.nn.leaky_relu, name='linear_0')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, dimz, activation=tf.nn.leaky_relu, name='linear_1')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, 1, 1, dimz])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, H, W, C]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_164": {
                "input_tensor": {
                    "value": "tf.abs(f_1 - f_2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "check_numerics_198": {
                "tensor": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "message": {
                    "value": "\"CheckNumerics['{}']\".format(v.op.name)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_228": {
                "x": {
                    "value": "mu * GroupNorm(y)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "musigma[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chan])",
                            "Call"
                        ],
                        [
                            "musigmai[:, 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(sigma, [-1, 1, 1, chs])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "gnorm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "UpSampling2D_510": {
                "size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "UpSampling2D_512": {
                "size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "UpSampling2D_514": {
                "size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "UpSampling2D_547": {
                "size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "data_format": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "variable_scope_656": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "squared_difference_667": {
                "x": {
                    "value": "fm_loss_real",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('fm_real_%d' % i, real.shape[1:], dtype=tf.float32, trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.reduce_mean(fake, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_695": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'MLP'",
                            "Method Argument"
                        ],
                        [
                            "'zdec'",
                            "Method Argument"
                        ],
                        [
                            "'z_reconstructer'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_705": {
                "name_or_scope": {
                    "value": "gen",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_730": {
                "values": {
                    "value": "[(img + 1) * 0.5, (gen_im_gt + 1) * 0.5]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_743": {
                "name_or_scope": {
                    "value": "discrim",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_747": {
                "variable": {
                    "value": "D_input_real",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[img, mask]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_748": {
                "variable": {
                    "value": "D_input_fake",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[gen_im_gt, mask]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_772": {
                "variable": {
                    "value": "D_input_real",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[img, mask]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_773": {
                "variable": {
                    "value": "D_input_fake",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[gen_im_z3, mask]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "ones_like_806": {
                "input": {
                    "value": "numelmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(bin_gen_mask_gt, axis=[1, 2, 3])",
                            "Call"
                        ],
                        [
                            "tf.where(tf.equal(numelmask, 0), numelall, numelmask)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_810": {
                "name": {
                    "value": "RGB_losses",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_n_814": {
                "variable": {
                    "value": "G_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "G_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n(G_loss, name='lsgan_loss')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "lsgan_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_n_815": {
                "variable": {
                    "value": "D_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "D_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n(D_loss, name='Disc_loss')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "Disc_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_n_819": {
                "variable": {
                    "value": "G_loss_z3",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "G_loss_z3",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n(G_loss_z3, name='lsgan_loss')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "lsgan_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_n_820": {
                "variable": {
                    "value": "D_loss_z3",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "D_loss_z3",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n(D_loss_z3, name='Disc_loss')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "Disc_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_822": {
                "variable": {
                    "value": "z3_recon_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.abs(z3 - z3_recon)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "z3_recon_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_827": {
                "input_tensor": {
                    "value": "tf.abs(img - gen_im_gt)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "[1, 2, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "split_831": {
                "variable": {
                    "value": "(f3_1, f3_2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "f3",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sqrt_136": {
                "x": {
                    "value": "var + epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_164": {
                "x": {
                    "value": "f_1 - f_2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_664": {
                "input_tensor": {
                    "value": "real",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_669": {
                "input_tensor": {
                    "value": "fake",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_691": {
                "input": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask / 128.0 - 1.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "variable_scope_710": {
                "name_or_scope": {
                    "value": "senc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_717": {
                "name_or_scope": {
                    "value": "genRGB",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_727": {
                "name_or_scope": {
                    "value": "senc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_745": {
                "name_or_scope": {
                    "value": "discrim_im",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_770": {
                "name_or_scope": {
                    "value": "discrim_im",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "minimum_797": {
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.subtract(real, 1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "minimum_798": {
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.add(-fake, -1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_811": {
                "name": {
                    "value": "GAN_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_816": {
                "name": {
                    "value": "GAN_loss_z3",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_821": {
                "name": {
                    "value": "z_recon_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_823": {
                "name": {
                    "value": "FM_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_826": {
                "name": {
                    "value": "im_recon_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_828": {
                "name": {
                    "value": "kl_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_830": {
                "name": {
                    "value": "perceptualLoss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "square_99": {
                "x": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(x, STYLE_DIM_z2, name='fcmean')",
                            "Call"
                        ],
                        [
                            "tf.reshape(mean, [-1, 1, 1, STYLE_DIM_z2])",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_99": {
                "x": {
                    "value": "logvar",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "subtract_797": {
                "x": {
                    "value": "real",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "add_798": {
                "x": {
                    "value": "-fake",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "y": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "abs_822": {
                "x": {
                    "value": "z3 - z3_recon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_824": {
                "input_tensor": {
                    "value": "tf.abs(j - k)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_n_825": {
                "inputs": {
                    "value": "FM_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.reduce_mean(tf.abs(j - k)) for (j, k) in zip(discrim_fm_real, discrim_fm_fake)]",
                            "ListComp"
                        ],
                        [
                            "tf.add_n(FM_loss) / len(FM_loss)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "l2_loss_833": {
                "t": {
                    "value": "f3_1 - f3_2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_833": {
                "x": {
                    "value": "tf.size(f3_1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_752": {
                "name_or_scope": {
                    "value": "'s%d' % s",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_777": {
                "name_or_scope": {
                    "value": "'s%d' % s",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_824": {
                "x": {
                    "value": "j - k",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "size_833": {
                "input": {
                    "value": "f3_1",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "variable_scope_758": {
                "name_or_scope": {
                    "value": "Ax",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_762": {
                "name_or_scope": {
                    "value": "Ah",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_783": {
                "name_or_scope": {
                    "value": "Ax",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_787": {
                "name_or_scope": {
                    "value": "Ah",
                    "type": "str",
                    "possible_values": []
                }
            },
            "abs_827": {
                "x": {
                    "value": "img - gen_im_gt",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    }
}