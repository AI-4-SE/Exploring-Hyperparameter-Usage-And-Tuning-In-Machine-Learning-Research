{
    "dmn_plus_main.py": {
        "tensorflow": {
            "RunConfig_25": {
                "variable": {
                    "value": "run_config",
                    "type": "variable",
                    "possible_values": []
                },
                "log_step_count_steps": {
                    "value": "Config.train.log_step_count_steps",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tf_random_seed": {
                    "value": "Config.train.tf_random_seed",
                    "type": "Attribute",
                    "possible_values": []
                },
                "model_dir": {
                    "value": "model_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'trained_models/{}'.format(Config.train.model_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "reset_default_graph_12": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "argmax_104": {
                "variable": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "model.output",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Estimator_146": {
                "variable": {
                    "value": "estimator",
                    "type": "variable",
                    "possible_values": []
                },
                "model_fn": {
                    "value": "model_fn",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "hparams",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "run_config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.estimator.RunConfig(log_step_count_steps=Config.train.log_step_count_steps, tf_random_seed=Config.train.tf_random_seed, model_dir=model_dir)",
                            "Call"
                        ],
                        [
                            "tf.estimator.RunConfig(log_step_count_steps=Config.train.log_step_count_steps, tf_random_seed=Config.train.tf_random_seed, model_dir=model_dir, session_config=tf.ConfigProto(allow_soft_placement=True, log_device_placement=True))",
                            "Call"
                        ]
                    ]
                }
            },
            "RunConfig_187": {
                "variable": {
                    "value": "run_config",
                    "type": "variable",
                    "possible_values": []
                },
                "log_step_count_steps": {
                    "value": "Config.train.log_step_count_steps",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tf_random_seed": {
                    "value": "Config.train.tf_random_seed",
                    "type": "Attribute",
                    "possible_values": []
                },
                "model_dir": {
                    "value": "model_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'trained_models/{}'.format(Config.train.model_dir)",
                            "Call"
                        ]
                    ]
                },
                "session_config": {
                    "value": "tf.ConfigProto(allow_soft_placement=True, log_device_placement=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TrainSpec_193": {
                "variable": {
                    "value": "train_spec",
                    "type": "variable",
                    "possible_values": []
                },
                "input_fn": {
                    "value": "lambda : input_fn(data, mode=tf.estimator.ModeKeys.TRAIN, num_epochs=Config.train.n_epochs, batch_size=Config.model.batch_size)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "max_steps": {
                    "value": "total_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "int(int(len(data['train'][0]) / Config.model.batch_size) * Config.train.n_epochs)",
                            "Call"
                        ]
                    ]
                },
                "hooks": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "EvalSpec_201": {
                "variable": {
                    "value": "eval_spec",
                    "type": "variable",
                    "possible_values": []
                },
                "input_fn": {
                    "value": "lambda : input_fn(data, mode=tf.estimator.ModeKeys.EVAL, batch_size=Config.model.batch_size)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "exporters": {
                    "value": "[tf.estimator.LatestExporter(name='predict', serving_input_receiver_fn=serving_input_fn, exports_to_keep=1, as_text=True)]",
                    "type": "List",
                    "possible_values": []
                },
                "steps": {
                    "value": "test_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "int(len(data['test'][0]) / Config.model.batch_size)",
                            "Call"
                        ]
                    ]
                },
                "throttle_secs": {
                    "value": "EVAL_AFTER_SEC",
                    "type": "variable",
                    "possible_values": [
                        [
                            "60",
                            "int"
                        ]
                    ]
                }
            },
            "sparse_softmax_cross_entropy_117": {
                "variable": {
                    "value": "cross_entropy",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "train_answer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "labels",
                            "variable"
                        ]
                    ]
                },
                "logits": {
                    "value": "model.output",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "cross-entropy",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_121": {
                "variable": {
                    "value": "reg_term",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.get_collection(tf.GraphKeys.REGULARIZATION_LOSSES)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_123": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "cross_entropy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.losses.sparse_softmax_cross_entropy(train_answer, model.output, scope='cross-entropy')",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "reg_term",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.get_collection(tf.GraphKeys.REGULARIZATION_LOSSES))",
                            "Call"
                        ]
                    ]
                }
            },
            "ServingInputReceiver_168": {
                "features": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{key: tensor for (key, tensor) in receiver_tensor.items()}",
                            "DictComp"
                        ]
                    ]
                },
                "receiver_tensors": {
                    "value": "receiver_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'input_data': tf.placeholder(tf.float32, [None, data_loader.max_facts_seq_len, Config.model.embed_dim]), 'question_data': tf.placeholder(tf.float32, [None, data_loader.max_question_seq_len, Config.model.embed_dim]), 'input_data_mask': tf.placeholder(tf.int32, [None, data_loader.max_input_mask_len])}",
                            "Dict"
                        ]
                    ]
                }
            },
            "train_and_evaluate_219": {
                "estimator": {
                    "value": "estimator",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_estimator(run_config, params)",
                            "Call"
                        ],
                        [
                            "tf.estimator.Estimator(model_fn=model_fn, params=hparams, config=run_config)",
                            "Call"
                        ]
                    ]
                },
                "train_spec": {
                    "value": "train_spec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.estimator.TrainSpec(input_fn=lambda : input_fn(data, mode=tf.estimator.ModeKeys.TRAIN, num_epochs=Config.train.n_epochs, batch_size=Config.model.batch_size), max_steps=total_steps, hooks=None)",
                            "Call"
                        ]
                    ]
                },
                "eval_spec": {
                    "value": "eval_spec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.estimator.EvalSpec(input_fn=lambda : input_fn(data, mode=tf.estimator.ModeKeys.EVAL, batch_size=Config.model.batch_size), exporters=[tf.estimator.LatestExporter(name='predict', serving_input_receiver_fn=serving_input_fn, exports_to_keep=1, as_text=True)], steps=test_steps, throttle_secs=EVAL_AFTER_SEC)",
                            "Call"
                        ]
                    ]
                }
            },
            "EstimatorSpec_113": {
                "mode": {
                    "value": "mode",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.estimator.ModeKeys.EVAL",
                            "Method Argument"
                        ]
                    ]
                },
                "predictions": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(model.output, axis=1)",
                            "Call"
                        ],
                        [
                            "{'predictions': predictions}",
                            "Dict"
                        ]
                    ]
                },
                "export_outputs": {
                    "value": "export_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'prediction': tf.estimator.export.PredictOutput(predictions)}",
                            "Dict"
                        ]
                    ]
                }
            },
            "variable_scope_116": {
                "name_or_scope": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "EstimatorSpec_132": {
                "mode": {
                    "value": "mode",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.estimator.ModeKeys.EVAL",
                            "Method Argument"
                        ]
                    ]
                },
                "loss": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add(cross_entropy, reg_term)",
                            "Call"
                        ]
                    ]
                },
                "train_op": {
                    "value": "train_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.layers.optimize_loss(loss, tf.train.get_global_step(), optimizer=Config.train.get('optimizer', 'Adam'), learning_rate=Config.train.learning_rate, summaries=['loss', 'gradients', 'learning_rate'], name='train_op')",
                            "Call"
                        ]
                    ]
                }
            },
            "EstimatorSpec_139": {
                "mode": {
                    "value": "mode",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.estimator.ModeKeys.EVAL",
                            "Method Argument"
                        ]
                    ]
                },
                "loss": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add(cross_entropy, reg_term)",
                            "Call"
                        ]
                    ]
                },
                "eval_metric_ops": {
                    "value": "eval_metrics",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'accuracy': tf.metrics.accuracy(train_answer, predictions)}",
                            "Dict"
                        ]
                    ]
                }
            },
            "placeholder_158": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, data_loader.max_facts_seq_len, Config.model.embed_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_159": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, data_loader.max_question_seq_len, Config.model.embed_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_160": {
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, data_loader.max_input_mask_len]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "PredictOutput_111": {
                "outputs": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(model.output, axis=1)",
                            "Call"
                        ],
                        [
                            "{'predictions': predictions}",
                            "Dict"
                        ]
                    ]
                }
            },
            "get_collection_121": {
                "key": {
                    "value": "tf.GraphKeys.REGULARIZATION_LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_global_step_126": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "accuracy_137": {
                "labels": {
                    "value": "train_answer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "labels",
                            "variable"
                        ]
                    ]
                },
                "predictions": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(model.output, axis=1)",
                            "Call"
                        ],
                        [
                            "{'predictions': predictions}",
                            "Dict"
                        ]
                    ]
                }
            },
            "ConfigProto_190": {
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "log_device_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "LatestExporter_205": {
                "name": {
                    "value": "predict",
                    "type": "str",
                    "possible_values": []
                },
                "serving_input_receiver_fn": {
                    "value": "serving_input_fn",
                    "type": "variable",
                    "possible_values": []
                },
                "exports_to_keep": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "as_text": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "model/dmn_plus.py": {
        "tensorflow": {
            "softmax_49": {
                "variable": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(tf.concat([rnn_output, q_vec], 1), self.vocab_size, activation=None)",
                            "Call"
                        ],
                        [
                            "prev_memory",
                            "variable"
                        ],
                        [
                            "self.add_answer_module(output, q_vec)",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_50": {
                "variable": {
                    "value": "pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(output)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_54": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=output, labels=labels)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "AdamOptimizer_63": {
                "variable": {
                    "value": "opt",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.params.train.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_74": {
                "variable": {
                    "value": "question_length",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.to_int32(tf.not_equal(tf.reduce_max(self.embedding_question, axis=2), self.params.data.PAD_ID))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_80": {
                "variable": {
                    "value": "self.input_length",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.input_mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_138": {
                "variable": {
                    "value": "attentions",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.stack(attentions)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_140": {
                "variable": {
                    "value": "attentions",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "attentions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.squeeze(self.get_attention(q_vec, memory, fv, bool(hop_index) or bool(i)), axis=1) for (i, fv) in enumerate(fact_vecs)]",
                            "ListComp"
                        ],
                        [
                            "tf.transpose(tf.stack(attentions))",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(attentions)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(attentions, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_141": {
                "variable": {
                    "value": "attentions",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attentions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.squeeze(self.get_attention(q_vec, memory, fv, bool(hop_index) or bool(i)), axis=1) for (i, fv) in enumerate(fact_vecs)]",
                            "ListComp"
                        ],
                        [
                            "tf.transpose(tf.stack(attentions))",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(attentions)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(attentions, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "transpose_146": {
                "variable": {
                    "value": "tmp",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.stack(fact_vecs)",
                    "type": "Call",
                    "possible_values": []
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_147": {
                "variable": {
                    "value": "gru_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tmp, attentions]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dense_163": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "tf.concat([rnn_output, q_vec], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "units": {
                    "value": "self.vocab_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "variable_scope_17": {
                "name_or_scope": {
                    "value": "gradient_noise",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_19": {
                "x": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "gn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_normal(tf.shape(t), stddev=stddev)",
                            "Call"
                        ]
                    ]
                }
            },
            "trainable_variables_56": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_59": {
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.nn.sparse_softmax_cross_entropy_with_logits(logits=output, labels=labels))",
                            "Call"
                        ],
                        [
                            "loss + self.params.train.learning_rate",
                            "BinOp"
                        ]
                    ]
                }
            },
            "map_fn_100": {
                "variable": {
                    "value": "facts_stacked",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "get_encoded_fact",
                    "type": "variable",
                    "possible_values": []
                },
                "elems": {
                    "value": "tf.range(start=0, limit=batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "unstack_102": {
                "variable": {
                    "value": "facts",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.transpose(facts_stacked, [1, 0, 2])",
                    "type": "Call",
                    "possible_values": []
                },
                "num": {
                    "value": "self.max_mask_length",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_117": {
                "variable": {
                    "value": "feature_vec",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[fact_vec * q_vec, fact_vec * prev_memory, tf.abs(fact_vec - q_vec), tf.abs(fact_vec - prev_memory)]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dynamic_rnn_150": {
                "variable": {
                    "value": "(_, episode)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell": {
                    "value": "AttentionGRUCell(self.params.model.num_units)",
                    "type": "Call",
                    "possible_values": []
                },
                "inputs": {
                    "value": "gru_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tmp, attentions], 2)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "np.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "self.input_length",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_161": {
                "variable": {
                    "value": "rnn_output",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "rnn_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(rnn_output, self.params.model.dropout)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.params.model.dropout",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_18": {
                "input": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_55": {
                "logits": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(tf.concat([rnn_output, q_vec], 1), self.vocab_size, activation=None)",
                            "Call"
                        ],
                        [
                            "prev_memory",
                            "variable"
                        ],
                        [
                            "self.add_answer_module(output, q_vec)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "to_int32_74": {
                "x": {
                    "value": "tf.not_equal(tf.reduce_max(self.embedding_question, axis=2), self.params.data.PAD_ID)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_83": {
                "name_or_scope": {
                    "value": "facts",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_92": {
                "variable": {
                    "value": "mask_lengths",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.to_int32(tf.not_equal(input_mask[i], self.params.data.PAD_ID))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "boolean_mask_94": {
                "variable": {
                    "value": "input_mask_temp",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_mask[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "mask": {
                    "value": "tf.sequence_mask(mask_lengths, max_mask_length)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_nd_96": {
                "variable": {
                    "value": "encoded_facts",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "input_encoder_outputs[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.reshape(input_mask_temp, [-1, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_97": {
                "variable": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.stack([max_mask_length - mask_lengths, self.params.model.num_units])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_111": {
                "name_or_scope": {
                    "value": "attention",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True if hop_index > 0 else False",
                            "IfExp"
                        ]
                    ]
                }
            },
            "squeeze_134": {
                "input": {
                    "value": "self.get_attention(q_vec, memory, fv, bool(hop_index) or bool(i))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_138": {
                "values": {
                    "value": "attentions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.squeeze(self.get_attention(q_vec, memory, fv, bool(hop_index) or bool(i)), axis=1) for (i, fv) in enumerate(fact_vecs)]",
                            "ListComp"
                        ],
                        [
                            "tf.transpose(tf.stack(attentions))",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(attentions)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(attentions, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_146": {
                "values": {
                    "value": "fact_vecs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_input_representation()",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_149": {
                "name_or_scope": {
                    "value": "attention_gru",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True if hop_index > 0 else False",
                            "IfExp"
                        ]
                    ]
                }
            },
            "concat_163": {
                "values": {
                    "value": "[rnn_output, q_vec]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_173": {
                "name_or_scope": {
                    "value": "input",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.contrib.layers.xavier_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_177": {
                "name_or_scope": {
                    "value": "question",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.contrib.layers.xavier_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_186": {
                "name_or_scope": {
                    "value": "memory",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.contrib.layers.xavier_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_206": {
                "name_or_scope": {
                    "value": "answer",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.contrib.layers.xavier_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "not_equal_75": {
                "x": {
                    "value": "tf.reduce_max(self.embedding_question, axis=2)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.params.data.PAD_ID",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_85": {
                "input": {
                    "value": "self.input_mask",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_86": {
                "input": {
                    "value": "self.input_mask",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_98": {
                "values": {
                    "value": "[encoded_facts, padding]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "range_100": {
                "start": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "limit": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(self.input_mask)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "transpose_102": {
                "a": {
                    "value": "facts_stacked",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(get_encoded_fact, tf.range(start=0, limit=batch_size), dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "abs_114": {
                "x": {
                    "value": "fact_vec - q_vec",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_115": {
                "x": {
                    "value": "fact_vec - prev_memory",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "dense_199": {
                "variable": {
                    "value": "prev_memory",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "tf.concat([prev_memory, episode, q_vec], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "units": {
                    "value": "self.params.model.num_units",
                    "type": "Attribute",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.relu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "clip_by_norm_67": {
                "t": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": []
                },
                "clip_norm": {
                    "value": "self.params.model.max_grad_val",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_max_75": {
                "input_tensor": {
                    "value": "self.embedding_question",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_92": {
                "x": {
                    "value": "tf.not_equal(input_mask[i], self.params.data.PAD_ID)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sequence_mask_94": {
                "lengths": {
                    "value": "mask_lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.to_int32(tf.not_equal(input_mask[i], self.params.data.PAD_ID)), axis=0)",
                            "Call"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "max_mask_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(self.input_mask)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reshape_96": {
                "tensor": {
                    "value": "input_mask_temp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(input_mask[i], tf.sequence_mask(mask_lengths, max_mask_length))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_97": {
                "values": {
                    "value": "[max_mask_length - mask_lengths, self.params.model.num_units]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_198": {
                "name_or_scope": {
                    "value": "'hop_%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "not_equal_92": {
                "x": {
                    "value": "input_mask[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "self.params.data.PAD_ID",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_199": {
                "values": {
                    "value": "[prev_memory, episode, q_vec]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "model/encoder.py": {
        "tensorflow": {
            "concat_52": {
                "variable": {
                    "value": "encoder_final_state",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(output_state_fw[-1], output_state_bw[-1])",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dynamic_rnn_35": {
                "cell": {
                    "value": "self.cells",
                    "type": "Attribute",
                    "possible_values": []
                },
                "inputs": {
                    "value": "input_vector",
                    "type": "variable",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "time_major": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "swap_memory": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "GRUCell_70": {
                "variable": {
                    "value": "single_cell",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "self.num_units",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.get_variable_scope().reuse",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "DropoutWrapper_89": {
                "variable": {
                    "value": "single_cell",
                    "type": "variable",
                    "possible_values": []
                },
                "cell": {
                    "value": "single_cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._rnn_single_cell()",
                            "Call"
                        ],
                        [
                            "tf.contrib.rnn.GRUCell(self.num_units, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "tf.contrib.rnn.BasicLSTMCell(self.num_units, forget_bias=1.0, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "tf.contrib.rnn.DropoutWrapper(cell=single_cell, input_keep_prob=1.0 - self.dropout)",
                            "Call"
                        ],
                        [
                            "tf.contrib.rnn.LayerNormBasicLSTMCell(self.num_units, forget_bias=1.0, layer_norm=True, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "tf.contrib.rnn.LayerNormBasicLSTMCell(self.num_units)",
                            "Call"
                        ]
                    ]
                },
                "input_keep_prob": {
                    "value": "1.0 - self.dropout",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "MultiRNNCell_63": {
                "cells": {
                    "value": "stacked_rnn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "state_is_tuple": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "BasicLSTMCell_73": {
                "variable": {
                    "value": "single_cell",
                    "type": "variable",
                    "possible_values": []
                },
                "num_units": {
                    "value": "self.num_units",
                    "type": "Attribute",
                    "possible_values": []
                },
                "forget_bias": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.get_variable_scope().reuse",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_scope_71": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_75": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_81": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "utils/attention_gru_cell.py": {
        "tensorflow": {
            "get_variable_scope_104": {
                "variable": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_106": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[total_arg_size, output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[a.dtype for a in args][0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "variable_scope_105": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "vs.get_variable_scope()",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_109": {
                "variable": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "args[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "vs.get_variable('weights', [total_arg_size, output_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_111": {
                "variable": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "array_ops.concat(args, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "vs.get_variable('weights', [total_arg_size, output_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_116": {
                "variable": {
                    "value": "biases",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "biases",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[a.dtype for a in args][0]",
                            "Subscript"
                        ]
                    ]
                },
                "initializer": {
                    "value": "init_ops.constant_initializer(bias_start, dtype=dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "bias_add_120": {
                "value": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": [
                        [
                            "math_ops.matmul(args[0], weights)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(array_ops.concat(args, 1), weights)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "vs.get_variable('biases', [output_size], dtype=dtype, initializer=init_ops.constant_initializer(bias_start, dtype=dtype))",
                            "Call"
                        ]
                    ]
                }
            },
            "warn_36": {
                "msg": {
                    "value": "%s: The input_size parameter is deprecated.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "variable_scope_51": {
                "name_or_scope": {
                    "value": "scope or 'attention_gru_cell'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "split_57": {
                "variable": {
                    "value": "(inputs, g)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[self._num_units, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_61": {
                "variable": {
                    "value": "r",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "r",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_linear([inputs, state], self._num_units, True)",
                            "Call"
                        ],
                        [
                            "sigmoid(r)",
                            "Call"
                        ],
                        [
                            "r * _linear(state, self._num_units, False)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "variable_scope_114": {
                "name_or_scope": {
                    "value": "outer_scope",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "variable_scope_52": {
                "name_or_scope": {
                    "value": "gates",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_62": {
                "name_or_scope": {
                    "value": "candidate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_64": {
                "name_or_scope": {
                    "value": "input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_111": {
                "values": {
                    "value": "args",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[args]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_initializer_119": {
                "value": {
                    "value": "bias_start",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[a.dtype for a in args][0]",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "utils/data_loader.py": {
        "tensorflow": {
            "placeholder_239": {
                "variable": {
                    "value": "input_placeholder",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, Config.data.max_facts_seq_len, Config.model.embed_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_241": {
                "variable": {
                    "value": "input_mask_placeholder",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, Config.data.max_input_mask_length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_243": {
                "variable": {
                    "value": "question_placeholder",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, Config.data.max_question_seq_len, Config.model.embed_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_245": {
                "variable": {
                    "value": "answer_placeholder",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "name_scope_234": {
                "name": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'train'",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    }
}