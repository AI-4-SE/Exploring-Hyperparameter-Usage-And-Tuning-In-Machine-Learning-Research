{
    "src/block.py": {
        "tensorflow": {
            "concatenate_19": {
                "variable": {
                    "value": "concat",
                    "possible_values": []
                },
                "arys": {
                    "value": "[conv, pool]",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "possible_values": []
                },
                "name": {
                    "value": "initial_concat_layer",
                    "possible_values": []
                }
            },
            "add_85": {
                "variable": {
                    "value": "merged",
                    "possible_values": []
                },
                "x": {
                    "value": "[branch_1, branch_2]",
                    "possible_values": []
                }
            },
            "add_137": {
                "variable": {
                    "value": "decoder",
                    "possible_values": []
                },
                "x": {
                    "value": "[branch_1, branch_2]",
                    "possible_values": []
                }
            },
            "Conv2D_17": {
                "filters": {
                    "value": "filters - 3",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 2)",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "possible_values": []
                },
                "name": {
                    "value": "initial_conv_layer",
                    "possible_values": []
                }
            },
            "MaxPooling2D_18": {
                "name": {
                    "value": "initial_max_pooling_layer",
                    "possible_values": []
                }
            },
            "Conv2D_59": {
                "filters": {
                    "value": "n_filters",
                    "possible_values": [
                        [
                            "output_channels // scale",
                            "BinOp"
                        ],
                        [
                            "output_channels // scale",
                            "BinOp"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "(stride, stride)",
                    "possible_values": []
                },
                "strides": {
                    "value": "(stride, stride)",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "BatchNormalization_65": {
                "momentum": {
                    "value": "0.1",
                    "possible_values": []
                }
            },
            "PReLU_66": {
                "shared_axes": {
                    "value": "[1, 2]",
                    "possible_values": []
                }
            },
            "BatchNormalization_76": {
                "momentum": {
                    "value": "0.1",
                    "possible_values": []
                }
            },
            "PReLU_77": {
                "shared_axes": {
                    "value": "[1, 2]",
                    "possible_values": []
                }
            },
            "Conv2D_80": {
                "filters": {
                    "value": "output_channels",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(1, 1)",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "BatchNormalization_81": {
                "momentum": {
                    "value": "0.1",
                    "possible_values": []
                }
            },
            "SpatialDropout2D_82": {
                "rate": {
                    "value": "dropout",
                    "possible_values": [
                        [
                            "0.1",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "PReLU_86": {
                "shared_axes": {
                    "value": "[1, 2]",
                    "possible_values": []
                }
            },
            "Conv2D_108": {
                "filters": {
                    "value": "n_filters",
                    "possible_values": [
                        [
                            "output_channels // scale",
                            "BinOp"
                        ],
                        [
                            "output_channels // scale",
                            "BinOp"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "(1, 1)",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "BatchNormalization_109": {
                "momentum": {
                    "value": "0.1",
                    "possible_values": []
                }
            },
            "Activation_110": {
                "activation": {
                    "value": "relu",
                    "possible_values": []
                }
            },
            "BatchNormalization_117": {
                "momentum": {
                    "value": "0.1",
                    "possible_values": []
                }
            },
            "Activation_118": {
                "activation": {
                    "value": "relu",
                    "possible_values": []
                }
            },
            "Conv2D_121": {
                "filters": {
                    "value": "output_channels",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(1, 1)",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "MaxPooling2D_41": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "Permute_43": {
                "dims": {
                    "value": "(1, 3, 2)",
                    "possible_values": []
                }
            },
            "ZeroPadding2D_48": {
                "padding": {
                    "value": "(vertical_padding, horizontal_padding)",
                    "possible_values": []
                }
            },
            "Permute_50": {
                "dims": {
                    "value": "(1, 3, 2)",
                    "possible_values": []
                }
            },
            "Conv2D_70": {
                "filters": {
                    "value": "n_filters",
                    "possible_values": [
                        [
                            "output_channels // scale",
                            "BinOp"
                        ],
                        [
                            "output_channels // scale",
                            "BinOp"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "possible_values": []
                }
            },
            "Conv2DTranspose_114": {
                "filters": {
                    "value": "n_filters",
                    "possible_values": [
                        [
                            "output_channels // scale",
                            "BinOp"
                        ],
                        [
                            "output_channels // scale",
                            "BinOp"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 2)",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "possible_values": []
                }
            },
            "Conv2D_116": {
                "filters": {
                    "value": "n_filters",
                    "possible_values": [
                        [
                            "output_channels // scale",
                            "BinOp"
                        ],
                        [
                            "output_channels // scale",
                            "BinOp"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "Conv2D_127": {
                "filters": {
                    "value": "output_channels",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(1, 1)",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "BatchNormalization_128": {
                "momentum": {
                    "value": "0.1",
                    "possible_values": []
                }
            },
            "BatchNormalization_136": {
                "momentum": {
                    "value": "0.1",
                    "possible_values": []
                }
            },
            "Activation_138": {
                "activation": {
                    "value": "relu",
                    "possible_values": []
                }
            },
            "Conv2D_72": {
                "filters": {
                    "value": "n_filters",
                    "possible_values": [
                        [
                            "output_channels // scale",
                            "BinOp"
                        ],
                        [
                            "output_channels // scale",
                            "BinOp"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "(1, assymetric)",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "Conv2D_73": {
                "filters": {
                    "value": "n_filters",
                    "possible_values": [
                        [
                            "output_channels // scale",
                            "BinOp"
                        ],
                        [
                            "output_channels // scale",
                            "BinOp"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "(assymetric, 1)",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "possible_values": []
                }
            },
            "UpSampling2D_130": {
                "size": {
                    "value": "(2, 2)",
                    "possible_values": []
                }
            },
            "Conv2D_75": {
                "filters": {
                    "value": "n_filters",
                    "possible_values": [
                        [
                            "output_channels // scale",
                            "BinOp"
                        ],
                        [
                            "output_channels // scale",
                            "BinOp"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "possible_values": []
                },
                "dilation_rate": {
                    "value": "(dilated, dilated)",
                    "possible_values": []
                }
            }
        }
    },
    "src/dataset.py": {
        "tensorflow": {
            "read_file_13": {
                "variable": {
                    "value": "image",
                    "possible_values": []
                },
                "filename": {
                    "value": "image_path",
                    "possible_values": []
                }
            },
            "decode_png_14": {
                "variable": {
                    "value": "image",
                    "possible_values": []
                },
                "contents": {
                    "value": "image",
                    "possible_values": [
                        [
                            "tf.io.read_file(image_path)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_png(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, 0.1, seed=None)",
                            "Call"
                        ],
                        [
                            "tf.cast(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(images=image, size=[IMAGE_SIZE, IMAGE_SIZE])",
                            "Call"
                        ],
                        [
                            "(image - 127.5) / 127.5",
                            "BinOp"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "possible_values": []
                }
            },
            "random_hue_15": {
                "variable": {
                    "value": "image",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "possible_values": [
                        [
                            "tf.io.read_file(image_path)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_png(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, 0.1, seed=None)",
                            "Call"
                        ],
                        [
                            "tf.cast(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(images=image, size=[IMAGE_SIZE, IMAGE_SIZE])",
                            "Call"
                        ],
                        [
                            "(image - 127.5) / 127.5",
                            "BinOp"
                        ]
                    ]
                },
                "max_delta": {
                    "value": "0.1",
                    "possible_values": []
                },
                "seed": {
                    "value": "None",
                    "possible_values": []
                }
            },
            "cast_16": {
                "variable": {
                    "value": "image",
                    "possible_values": []
                },
                "x": {
                    "value": "image",
                    "possible_values": [
                        [
                            "tf.io.read_file(image_path)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_png(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, 0.1, seed=None)",
                            "Call"
                        ],
                        [
                            "tf.cast(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(images=image, size=[IMAGE_SIZE, IMAGE_SIZE])",
                            "Call"
                        ],
                        [
                            "(image - 127.5) / 127.5",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "resize_17": {
                "variable": {
                    "value": "image",
                    "possible_values": []
                },
                "images": {
                    "value": "image",
                    "possible_values": [
                        [
                            "tf.io.read_file(image_path)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_png(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, 0.1, seed=None)",
                            "Call"
                        ],
                        [
                            "tf.cast(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(images=image, size=[IMAGE_SIZE, IMAGE_SIZE])",
                            "Call"
                        ],
                        [
                            "(image - 127.5) / 127.5",
                            "BinOp"
                        ]
                    ]
                },
                "size": {
                    "value": "[IMAGE_SIZE, IMAGE_SIZE]",
                    "possible_values": []
                }
            },
            "read_file_20": {
                "variable": {
                    "value": "mask",
                    "possible_values": []
                },
                "filename": {
                    "value": "mask_path",
                    "possible_values": []
                }
            },
            "decode_png_21": {
                "variable": {
                    "value": "mask",
                    "possible_values": []
                },
                "contents": {
                    "value": "mask",
                    "possible_values": [
                        [
                            "tf.io.read_file(mask_path)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_png(mask, channels=1)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(images=mask, size=[IMAGE_SIZE, IMAGE_SIZE])",
                            "Call"
                        ],
                        [
                            "tf.cast(mask, dtype=tf.uint8)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.squeeze(mask), depth=NUM_CLASSES)",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "resize_22": {
                "variable": {
                    "value": "mask",
                    "possible_values": []
                },
                "images": {
                    "value": "mask",
                    "possible_values": [
                        [
                            "tf.io.read_file(mask_path)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_png(mask, channels=1)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(images=mask, size=[IMAGE_SIZE, IMAGE_SIZE])",
                            "Call"
                        ],
                        [
                            "tf.cast(mask, dtype=tf.uint8)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.squeeze(mask), depth=NUM_CLASSES)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "[IMAGE_SIZE, IMAGE_SIZE]",
                    "possible_values": []
                }
            },
            "cast_23": {
                "variable": {
                    "value": "mask",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "possible_values": [
                        [
                            "tf.io.read_file(mask_path)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_png(mask, channels=1)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(images=mask, size=[IMAGE_SIZE, IMAGE_SIZE])",
                            "Call"
                        ],
                        [
                            "tf.cast(mask, dtype=tf.uint8)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.squeeze(mask), depth=NUM_CLASSES)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.uint8",
                    "possible_values": []
                }
            },
            "one_hot_24": {
                "variable": {
                    "value": "mask",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.squeeze(mask)",
                    "possible_values": []
                },
                "depth": {
                    "value": "NUM_CLASSES",
                    "possible_values": []
                }
            },
            "squeeze_24": {
                "input": {
                    "value": "mask",
                    "possible_values": [
                        [
                            "tf.io.read_file(mask_path)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_png(mask, channels=1)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(images=mask, size=[IMAGE_SIZE, IMAGE_SIZE])",
                            "Call"
                        ],
                        [
                            "tf.cast(mask, dtype=tf.uint8)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.squeeze(mask), depth=NUM_CLASSES)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "src/metrics.py": {
        "tensorflow": {
            "weighted_cross_entropy_with_logits_15": {
                "variable": {
                    "value": "loss",
                    "possible_values": []
                },
                "logits": {
                    "value": "y_pred",
                    "possible_values": [
                        [
                            "convert_to_logits(y_pred)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_pred, K.epsilon(), 1 - K.epsilon())",
                            "Call"
                        ],
                        [
                            "convert_to_logits(y_pred)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_pred, K.epsilon(), 1 - K.epsilon())",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_pred, K.epsilon(), 1 - K.epsilon())",
                            "Call"
                        ]
                    ]
                },
                "targets": {
                    "value": "y_true",
                    "possible_values": []
                },
                "pos_weight": {
                    "value": "beta",
                    "possible_values": [
                        [
                            "LOSS_HYPERPARAMETERS['weighted_cross_entropy_beta']",
                            "Subscript"
                        ],
                        [
                            "LOSS_HYPERPARAMETERS['balanced_cross_entropy_beta']",
                            "Subscript"
                        ],
                        [
                            "beta / (1 - beta)",
                            "BinOp"
                        ],
                        [
                            "LOSS_HYPERPARAMETERS['tversky_loss_beta']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "weighted_cross_entropy_with_logits_32": {
                "variable": {
                    "value": "loss",
                    "possible_values": []
                },
                "logits": {
                    "value": "y_pred",
                    "possible_values": [
                        [
                            "convert_to_logits(y_pred)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_pred, K.epsilon(), 1 - K.epsilon())",
                            "Call"
                        ],
                        [
                            "convert_to_logits(y_pred)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_pred, K.epsilon(), 1 - K.epsilon())",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_pred, K.epsilon(), 1 - K.epsilon())",
                            "Call"
                        ]
                    ]
                },
                "targets": {
                    "value": "y_true",
                    "possible_values": []
                },
                "pos_weight": {
                    "value": "pos_weight",
                    "possible_values": []
                }
            },
            "clip_by_value_47": {
                "variable": {
                    "value": "y_pred",
                    "possible_values": []
                },
                "t": {
                    "value": "y_pred",
                    "possible_values": [
                        [
                            "convert_to_logits(y_pred)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_pred, K.epsilon(), 1 - K.epsilon())",
                            "Call"
                        ],
                        [
                            "convert_to_logits(y_pred)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_pred, K.epsilon(), 1 - K.epsilon())",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_pred, K.epsilon(), 1 - K.epsilon())",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "K.epsilon()",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1 - K.epsilon()",
                    "possible_values": []
                }
            },
            "log_48": {
                "variable": {
                    "value": "logits",
                    "possible_values": []
                },
                "x": {
                    "value": "y_pred / (1 - y_pred)",
                    "possible_values": []
                }
            },
            "reduce_sum_60": {
                "variable": {
                    "value": "denominator",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "y_true + y_pred",
                    "possible_values": []
                },
                "axis": {
                    "value": "(1, 2, 3)",
                    "possible_values": []
                }
            },
            "reduce_sum_65": {
                "variable": {
                    "value": "numerator",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "y_true * y_pred",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "reshape_119": {
                "variable": {
                    "value": "dice_loss",
                    "possible_values": []
                },
                "tensor": {
                    "value": "dice_loss(y_true, y_pred)",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, 1, 1)",
                    "possible_values": []
                }
            },
            "clip_by_value_10": {
                "variable": {
                    "value": "y_pred",
                    "possible_values": []
                },
                "t": {
                    "value": "y_pred",
                    "possible_values": [
                        [
                            "convert_to_logits(y_pred)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_pred, K.epsilon(), 1 - K.epsilon())",
                            "Call"
                        ],
                        [
                            "convert_to_logits(y_pred)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_pred, K.epsilon(), 1 - K.epsilon())",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_pred, K.epsilon(), 1 - K.epsilon())",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "K.epsilon()",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1 - K.epsilon()",
                    "possible_values": []
                }
            },
            "reduce_mean_20": {
                "input_tensor": {
                    "value": "loss",
                    "possible_values": [
                        [
                            "tf.nn.weighted_cross_entropy_with_logits(logits=y_pred, targets=y_true, pos_weight=beta)",
                            "Call"
                        ],
                        [
                            "tf.nn.weighted_cross_entropy_with_logits(logits=y_pred, targets=y_true, pos_weight=pos_weight)",
                            "Call"
                        ],
                        [
                            "focal_loss_with_logits(logits=logits, targets=y_true, alpha=alpha, gamma=gamma, y_pred=y_pred)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(tf.shape(logits)[0], 0), lambda : tf.reduce_sum(logits) * 0.0, compute_loss, strict=True, name='loss')",
                            "Call"
                        ],
                        [
                            "tf.tensordot(tf.nn.relu(errors_sorted), tf.stop_gradient(grad), 1, name='loss_non_void')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(losses)",
                            "Call"
                        ],
                        [
                            "lovasz_hinge_flat(*flatten_binary_scores(logits, labels, ignore))",
                            "Call"
                        ],
                        [
                            "binary_crossentropy(y_true, y_pred) + dice_loss",
                            "BinOp"
                        ]
                    ]
                }
            },
            "clip_by_value_26": {
                "variable": {
                    "value": "y_pred",
                    "possible_values": []
                },
                "t": {
                    "value": "y_pred",
                    "possible_values": [
                        [
                            "convert_to_logits(y_pred)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_pred, K.epsilon(), 1 - K.epsilon())",
                            "Call"
                        ],
                        [
                            "convert_to_logits(y_pred)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_pred, K.epsilon(), 1 - K.epsilon())",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_pred, K.epsilon(), 1 - K.epsilon())",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "K.epsilon()",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1 - K.epsilon()",
                    "possible_values": []
                }
            },
            "reduce_mean_37": {
                "input_tensor": {
                    "value": "loss * (1 - beta)",
                    "possible_values": []
                }
            },
            "reduce_mean_55": {
                "input_tensor": {
                    "value": "loss",
                    "possible_values": [
                        [
                            "tf.nn.weighted_cross_entropy_with_logits(logits=y_pred, targets=y_true, pos_weight=beta)",
                            "Call"
                        ],
                        [
                            "tf.nn.weighted_cross_entropy_with_logits(logits=y_pred, targets=y_true, pos_weight=pos_weight)",
                            "Call"
                        ],
                        [
                            "focal_loss_with_logits(logits=logits, targets=y_true, alpha=alpha, gamma=gamma, y_pred=y_pred)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(tf.shape(logits)[0], 0), lambda : tf.reduce_sum(logits) * 0.0, compute_loss, strict=True, name='loss')",
                            "Call"
                        ],
                        [
                            "tf.tensordot(tf.nn.relu(errors_sorted), tf.stop_gradient(grad), 1, name='loss_non_void')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(losses)",
                            "Call"
                        ],
                        [
                            "lovasz_hinge_flat(*flatten_binary_scores(logits, labels, ignore))",
                            "Call"
                        ],
                        [
                            "binary_crossentropy(y_true, y_pred) + dice_loss",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_75": {
                "variable": {
                    "value": "gts",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "gt_sorted",
                    "possible_values": [
                        [
                            "tf.gather(labelsf, perm)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_79": {
                "variable": {
                    "value": "jaccard",
                    "possible_values": []
                },
                "values": {
                    "value": "(jaccard[0:1], jaccard[1:] - jaccard[:-1])",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "cond_94": {
                "variable": {
                    "value": "loss",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.equal(tf.shape(logits)[0], 0)",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.reduce_sum(logits) * 0.0",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "compute_loss",
                    "possible_values": []
                },
                "strict": {
                    "value": "True",
                    "possible_values": []
                },
                "name": {
                    "value": "loss",
                    "possible_values": []
                }
            },
            "log_11": {
                "x": {
                    "value": "y_pred / (1 - y_pred)",
                    "possible_values": []
                }
            },
            "log_27": {
                "x": {
                    "value": "y_pred / (1 - y_pred)",
                    "possible_values": []
                }
            },
            "epsilon_47": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "reduce_sum_59": {
                "input_tensor": {
                    "value": "y_true * y_pred",
                    "possible_values": []
                },
                "axis": {
                    "value": "(1, 2, 3)",
                    "possible_values": []
                }
            },
            "cast_85": {
                "variable": {
                    "value": "labelsf",
                    "possible_values": []
                },
                "x": {
                    "value": "labels",
                    "possible_values": []
                },
                "dtype": {
                    "value": "logits.dtype",
                    "possible_values": []
                }
            },
            "top_k_88": {
                "variable": {
                    "value": "(errors_sorted, perm)",
                    "possible_values": []
                },
                "input": {
                    "value": "errors",
                    "possible_values": [
                        [
                            "1.0 - logits * tf.stop_gradient(signs)",
                            "BinOp"
                        ]
                    ]
                },
                "k": {
                    "value": "tf.shape(errors)[0]",
                    "possible_values": []
                },
                "name": {
                    "value": "descending_sort",
                    "possible_values": []
                }
            },
            "gather_89": {
                "variable": {
                    "value": "gt_sorted",
                    "possible_values": []
                },
                "params": {
                    "value": "labelsf",
                    "possible_values": [
                        [
                            "tf.cast(labels, logits.dtype)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "perm",
                    "possible_values": []
                }
            },
            "tensordot_91": {
                "variable": {
                    "value": "loss",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.nn.relu(errors_sorted)",
                    "possible_values": []
                },
                "b": {
                    "value": "tf.stop_gradient(grad)",
                    "possible_values": []
                },
                "axes": {
                    "value": "1",
                    "possible_values": []
                },
                "name": {
                    "value": "loss_non_void",
                    "possible_values": []
                }
            },
            "map_fn_109": {
                "variable": {
                    "value": "losses",
                    "possible_values": []
                },
                "fn": {
                    "value": "treat_image",
                    "possible_values": []
                },
                "elems": {
                    "value": "(logits, labels)",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "reduce_mean_110": {
                "variable": {
                    "value": "loss",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "possible_values": [
                        [
                            "tf.map_fn(treat_image, (logits, labels), dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "binary_crossentropy_120": {
                "y_true": {
                    "value": "y_true",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "y_pred",
                    "possible_values": [
                        [
                            "convert_to_logits(y_pred)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_pred, K.epsilon(), 1 - K.epsilon())",
                            "Call"
                        ],
                        [
                            "convert_to_logits(y_pred)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_pred, K.epsilon(), 1 - K.epsilon())",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(y_pred, K.epsilon(), 1 - K.epsilon())",
                            "Call"
                        ]
                    ]
                }
            },
            "epsilon_10": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "epsilon_26": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "cumsum_76": {
                "x": {
                    "value": "gt_sorted",
                    "possible_values": [
                        [
                            "tf.gather(labelsf, perm)",
                            "Call"
                        ]
                    ]
                }
            },
            "cumsum_77": {
                "x": {
                    "value": "1.0 - gt_sorted",
                    "possible_values": []
                }
            },
            "equal_95": {
                "x": {
                    "value": "tf.shape(logits)[0]",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "reduce_sum_68": {
                "input_tensor": {
                    "value": "denominator",
                    "possible_values": [
                        [
                            "tf.reduce_sum(y_true + y_pred, axis=(1, 2, 3))",
                            "Call"
                        ],
                        [
                            "y_true * y_pred + beta * (1 - y_true) * y_pred + (1 - beta) * y_true * (1 - y_pred)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "possible_values": []
                }
            },
            "relu_91": {
                "features": {
                    "value": "errors_sorted",
                    "possible_values": []
                }
            },
            "stop_gradient_91": {
                "input": {
                    "value": "grad",
                    "possible_values": [
                        [
                            "lovasz_grad(gt_sorted)",
                            "Call"
                        ]
                    ]
                }
            },
            "log1p_45": {
                "x": {
                    "value": "tf.exp(-tf.abs(logits))",
                    "possible_values": []
                }
            },
            "relu_45": {
                "features": {
                    "value": "-logits",
                    "possible_values": []
                }
            },
            "stop_gradient_87": {
                "input": {
                    "value": "signs",
                    "possible_values": [
                        [
                            "2.0 * labelsf - 1.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_95": {
                "input": {
                    "value": "logits",
                    "possible_values": [
                        [
                            "tf.log(y_pred / (1 - y_pred))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_96": {
                "input_tensor": {
                    "value": "logits",
                    "possible_values": [
                        [
                            "tf.log(y_pred / (1 - y_pred))",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_106": {
                "input": {
                    "value": "lab",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "exp_45": {
                "x": {
                    "value": "-tf.abs(logits)",
                    "possible_values": []
                }
            },
            "shape_88": {
                "input": {
                    "value": "errors",
                    "possible_values": [
                        [
                            "1.0 - logits * tf.stop_gradient(signs)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "abs_45": {
                "x": {
                    "value": "logits",
                    "possible_values": [
                        [
                            "tf.log(y_pred / (1 - y_pred))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "src/model.py": {
        "tensorflow": {
            "Input_13": {
                "variable": {
                    "value": "input_tensor",
                    "possible_values": []
                },
                "shape": {
                    "value": "input_shape",
                    "possible_values": [
                        [
                            "(512",
                            "MethodArgument"
                        ]
                    ]
                },
                "name": {
                    "value": "Input_Layer",
                    "possible_values": []
                }
            },
            "Model_26": {
                "variable": {
                    "value": "model",
                    "possible_values": []
                },
                "*args": {
                    "value": "input_tensor",
                    "possible_values": [
                        [
                            "Input(shape=input_shape, name='Input_Layer')",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "output_tennsor",
                    "possible_values": [
                        [
                            "Conv2DTranspose(filters=output_channels, kernel_size=(2, 2), strides=(2, 2), padding='same', activation='softmax')(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "Conv2DTranspose_21": {
                "filters": {
                    "value": "output_channels",
                    "possible_values": [
                        [
                            "3",
                            "MethodArgument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "(2, 2)",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 2)",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "possible_values": []
                },
                "activation": {
                    "value": "softmax",
                    "possible_values": []
                }
            }
        }
    },
    "src/utils.py": {
        "tensorflow": {
            "disable_eager_execution_13": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            }
        }
    }
}