{
    "Experiment_Component/AModelSuit.py": {
        "tensorflow": {
            "Saver_79": {
                "variable": {
                    "value": "self._saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_checkpoint_state_87": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "self._model_dir + '/checkpoints/'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reset_default_graph_138": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "trainable_variables_146": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "latest_checkpoint_85": {
                "checkpoint_dir": {
                    "value": "self._model_dir + '/checkpoints/'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "global_variables_initializer_98": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "Experiment_Component/Experiments/csnnExperimentFunctions.py": {
        "tensorflow": {
            "Session_55": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "Experiment_Component/ModelSuits/AGeneratorModelSuit.py": {
        "tensorflow": {
            "Session_51": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_59": {
                "variable": {
                    "value": "self._placeholder_x",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "x_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "placeholder_60": {
                "variable": {
                    "value": "self._placeholder_y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "y_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "merge_all_72": {
                "variable": {
                    "value": "self._eval_summary_op",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "merge_all_73": {
                "variable": {
                    "value": "self._train_summary_op",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Summary_277": {
                "variable": {
                    "value": "summary",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_187": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "split_199": {
                "variable": {
                    "value": "input_data_split",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self._placeholder_x",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "self._num_gpus",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_200": {
                "variable": {
                    "value": "labels_split",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self._placeholder_y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "self._num_gpus",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_scope_187": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "RunOptions_108": {
                "variable": {
                    "value": "run_options",
                    "type": "variable",
                    "possible_values": []
                },
                "trace_level": {
                    "value": "tf.RunOptions.FULL_TRACE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "RunMetadata_109": {
                "variable": {
                    "value": "run_metadata",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "name_scope_193": {
                "name": {
                    "value": "Infer",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_202": {
                "name": {
                    "value": "'InferGPU%d' % gpu",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "device_202": {
                "device_name": {
                    "value": "'/gpu:%d' % gpu",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "Experiment_Component/ModelSuits/ATfRecordModelSuit.py": {
        "tensorflow": {
            "Session_39": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "Experiment_Component/ModelSuits/GeneratorModelSuits/CsnnGeneratorModelSuit.py": {
        "tensorflow": {
            "RunOptions_74": {
                "variable": {
                    "value": "run_options",
                    "type": "variable",
                    "possible_values": []
                },
                "trace_level": {
                    "value": "tf.RunOptions.FULL_TRACE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "RunMetadata_75": {
                "variable": {
                    "value": "run_metadata",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "Experiment_Component/ModelSuits/GeneratorModelSuits/HybridGeneratorModelSuit.py": {
        "tensorflow": {
            "Summary_233": {
                "variable": {
                    "value": "summary",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "RunOptions_76": {
                "variable": {
                    "value": "run_options",
                    "type": "variable",
                    "possible_values": []
                },
                "trace_level": {
                    "value": "tf.RunOptions.FULL_TRACE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "RunMetadata_77": {
                "variable": {
                    "value": "run_metadata",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "Experiment_Component/ModelSuits/ReconstructEncodingModelSuit.py": {
        "tensorflow": {
            "Session_45": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_49": {
                "variable": {
                    "value": "self._placeholder_x",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "x_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "placeholder_50": {
                "variable": {
                    "value": "self._placeholder_y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "y_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "merge_all_65": {
                "variable": {
                    "value": "self.__train_summary_op",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Summary_231": {
                "variable": {
                    "value": "summary",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_64": {
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "self._training_ops[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "Experiment_Component/ModelSuits/TfRecordModelSuit/FsModelSuit.py": {
        "tensorflow": {
            "Session_43": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_56": {
                "variable": {
                    "value": "self._data_placeholder_train",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self._dataset_provider.getEntryDatatyp('data')",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, np.prod(self.__shape_data_train))",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_58": {
                "variable": {
                    "value": "self._label_placeholder_train",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self._dataset_provider.getEntryDatatyp('label')",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, self.__shape_label_train[0])",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "merge_all_80": {
                "variable": {
                    "value": "self.__train_summary_op",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_78": {
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "self._training_ops[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "scalar_79": {
                "name": {
                    "value": "acc",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "self._training_ops[2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "Summary_230": {
                "variable": {
                    "value": "summary",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_256": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_scope_256": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "Experiment_Component/ModelSuits/TfRecordModelSuit/StandardTfRecordModelSuit.py": {
        "tensorflow": {
            "merge_all_42": {
                "variable": {
                    "value": "self.__train_summary_op",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_40": {
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "self._training_ops[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "scalar_41": {
                "name": {
                    "value": "acc",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "self._training_ops[2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "Summary_177": {
                "variable": {
                    "value": "summary",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_203": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_scope_203": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "Experiment_Component/Models/Cifar10Reconstruction.py": {
        "tensorflow": {
            "reduce_mean_64": {
                "variable": {
                    "value": "train_loss_op",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.losses.mean_squared_error(labels=train_labels, predictions=train_logits_op)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_82": {
                "variable": {
                    "value": "val_loss_op",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.losses.mean_squared_error(labels=val_labels, predictions=val_logits_op)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "AdamOptimizer_114": {
                "variable": {
                    "value": "optimizer_op",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.__model_config['learningRate']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "conv2d_29": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "512",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "batch_normalization_30": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(input_batch, 512, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(8, 8), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 256, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(16, 16), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 128, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(32, 32), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 64, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 3, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_31": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(input_batch, 512, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(8, 8), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 256, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(16, 16), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 128, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(32, 32), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 64, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 3, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_34": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(input_batch, 512, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(8, 8), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 256, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(16, 16), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 128, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(32, 32), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 64, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 3, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "256",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "batch_normalization_35": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(input_batch, 512, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(8, 8), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 256, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(16, 16), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 128, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(32, 32), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 64, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 3, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_36": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(input_batch, 512, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(8, 8), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 256, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(16, 16), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 128, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(32, 32), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 64, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 3, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_39": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(input_batch, 512, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(8, 8), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 256, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(16, 16), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 128, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(32, 32), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 64, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 3, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "batch_normalization_40": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(input_batch, 512, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(8, 8), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 256, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(16, 16), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 128, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(32, 32), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 64, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 3, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_41": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(input_batch, 512, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(8, 8), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 256, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(16, 16), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 128, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(32, 32), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 64, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 3, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_44": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(input_batch, 512, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(8, 8), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 256, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(16, 16), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 128, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(32, 32), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 64, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 3, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "batch_normalization_45": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(input_batch, 512, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(8, 8), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 256, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(16, 16), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 128, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(32, 32), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 64, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 3, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_46": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(input_batch, 512, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(8, 8), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 256, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(16, 16), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 128, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(32, 32), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 64, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 3, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_48": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(input_batch, 512, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(8, 8), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 256, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(16, 16), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 128, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(32, 32), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 64, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 3, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "batch_normalization_49": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(input_batch, 512, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(8, 8), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 256, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(16, 16), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 128, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(32, 32), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 64, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 3, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_50": {
                "variable": {
                    "value": "rec",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(input_batch, 512, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(8, 8), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 256, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(16, 16), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 128, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x, size=(32, 32), method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 64, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, 3, 3, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_27": {
                "name_or_scope": {
                    "value": "cnn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "mean_squared_error_64": {
                "labels": {
                    "value": "train_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "predictions": {
                    "value": "train_logits_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.__cnnNetFn(train_batch, is_training=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "image_67": {
                "name": {
                    "value": "train_rec",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "train_logits_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.__cnnNetFn(train_batch, is_training=True)",
                            "Call"
                        ]
                    ]
                },
                "max_outputs": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_68": {
                "name": {
                    "value": "train_label",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "train_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "max_outputs": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                }
            },
            "mean_squared_error_82": {
                "labels": {
                    "value": "val_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "predictions": {
                    "value": "val_logits_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.__cnnNetFn(val_batch, is_training=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "image_85": {
                "name": {
                    "value": "val_rec",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "val_logits_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.__cnnNetFn(val_batch, is_training=False)",
                            "Call"
                        ]
                    ]
                },
                "max_outputs": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_86": {
                "name": {
                    "value": "val_label",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "val_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "max_outputs": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "Experiment_Component/Models/Csnn.py": {
        "tensorflow": {
            "variable_scope_72": {
                "name_or_scope": {
                    "value": "Csnn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "histogram_179": {
                "name": {
                    "value": "Layer + str(layer_num) + Distances",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add(distances_block_batch, skip_out)",
                            "Call"
                        ],
                        [
                            "layers.chooseNormalization(distances_block_batch, self.__layers[i]['bmuMetricsValueInvert'], self.__layers[i]['bmuMetricsNormalization'])",
                            "Call"
                        ],
                        [
                            "layers.choosePoolingLayer(distances_block_batch, self.__layers[i])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(distances_block_batch, rate=self.__layers[i]['dropout'], training=is_training)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_211": {
                "variable": {
                    "value": "d_img",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "distances_block_batch",
                            "variable"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, layer_config['somGrid'][2], layer_config['somGrid'][0], layer_config['somGrid'][1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "image_178": {
                "name": {
                    "value": "InputImage",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "input_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "distances_block_batch",
                            "variable"
                        ]
                    ]
                },
                "max_outputs": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_213": {
                "name": {
                    "value": "Encoding",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.transpose(d_img, [0, 2, 3, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "max_outputs": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_91": {
                "name_or_scope": {
                    "value": "'Layer' + str(i)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "add_132": {
                "variable": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add(distances_block_batch, skip_out)",
                            "Call"
                        ],
                        [
                            "layers.chooseNormalization(distances_block_batch, self.__layers[i]['bmuMetricsValueInvert'], self.__layers[i]['bmuMetricsNormalization'])",
                            "Call"
                        ],
                        [
                            "layers.choosePoolingLayer(distances_block_batch, self.__layers[i])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(distances_block_batch, rate=self.__layers[i]['dropout'], training=is_training)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "skip_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "distances_block_batch",
                            "variable"
                        ]
                    ]
                }
            },
            "dropout_144": {
                "variable": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add(distances_block_batch, skip_out)",
                            "Call"
                        ],
                        [
                            "layers.chooseNormalization(distances_block_batch, self.__layers[i]['bmuMetricsValueInvert'], self.__layers[i]['bmuMetricsNormalization'])",
                            "Call"
                        ],
                        [
                            "layers.choosePoolingLayer(distances_block_batch, self.__layers[i])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(distances_block_batch, rate=self.__layers[i]['dropout'], training=is_training)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.__layers[i]['dropout']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "training": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "transpose_213": {
                "a": {
                    "value": "d_img",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_batch, [-1, layer_config['somGrid'][2], layer_config['somGrid'][0], layer_config['somGrid'][1]])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 3, 1]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "Experiment_Component/Models/CsnnCnnHybrid.py": {
        "tensorflow": {
            "reduce_mean_100": {
                "variable": {
                    "value": "loss_op",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.nn.softmax_cross_entropy_with_logits_v2(logits=logits_train, labels=tf.cast(train_labels, dtype=tf.int32))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_115": {
                "variable": {
                    "value": "loss_op",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.nn.softmax_cross_entropy_with_logits_v2(logits=logits_eval, labels=tf.cast(eval_labels, dtype=tf.int32))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_126": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(flat, self.__num_classes)",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [-1, self.__num_classes])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, self.__num_classes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "equal_127": {
                "variable": {
                    "value": "correct_prediction",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(logits, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.argmax(labels, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_128": {
                "variable": {
                    "value": "acc_op",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(correct_prediction, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "AdamOptimizer_138": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.__learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "conv2d_43": {
                "variable": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "elu",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "tf.contrib.layers.l2_regularizer(self.__weight_decay)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "batch_normalization_45": {
                "variable": {
                    "value": "conv1_bn",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(input, 32, 3, activation='elu', padding='SAME', kernel_regularizer=tf.contrib.layers.l2_regularizer(self.__weight_decay))",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_46": {
                "variable": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv1_bn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(conv1)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "elu",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "tf.contrib.layers.l2_regularizer(self.__weight_decay)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "batch_normalization_48": {
                "variable": {
                    "value": "conv2_bn",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(conv1_bn, 32, 3, activation='elu', padding='SAME', kernel_regularizer=tf.contrib.layers.l2_regularizer(self.__weight_decay))",
                            "Call"
                        ]
                    ]
                }
            },
            "max_pooling2d_49": {
                "variable": {
                    "value": "conv2_pool",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "conv2_bn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(conv2)",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dropout_50": {
                "variable": {
                    "value": "conv2_drop",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "conv2_pool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.max_pooling2d(conv2_bn, 2, 2, padding='SAME')",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "0.2",
                    "type": "float",
                    "possible_values": []
                },
                "training": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "conv2d_52": {
                "variable": {
                    "value": "conv3",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv2_drop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dropout(conv2_pool, rate=0.2, training=is_training)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "elu",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "tf.contrib.layers.l2_regularizer(self.__weight_decay)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "batch_normalization_54": {
                "variable": {
                    "value": "conv3_bn",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "conv3",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(conv2_drop, 64, 3, activation='elu', padding='SAME', kernel_regularizer=tf.contrib.layers.l2_regularizer(self.__weight_decay))",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_55": {
                "variable": {
                    "value": "conv4",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv3_bn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(conv3)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "elu",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "tf.contrib.layers.l2_regularizer(self.__weight_decay)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "batch_normalization_57": {
                "variable": {
                    "value": "conv4_bn",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "conv4",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(conv3_bn, 64, 3, activation='elu', padding='SAME', kernel_regularizer=tf.contrib.layers.l2_regularizer(self.__weight_decay))",
                            "Call"
                        ]
                    ]
                }
            },
            "max_pooling2d_58": {
                "variable": {
                    "value": "conv4_pool",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "conv4_bn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(conv4)",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dropout_59": {
                "variable": {
                    "value": "conv4_drop",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "conv4_pool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.max_pooling2d(conv4_bn, 2, 2, padding='SAME')",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "0.3",
                    "type": "float",
                    "possible_values": []
                },
                "training": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "conv2d_61": {
                "variable": {
                    "value": "conv5",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv4_drop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dropout(conv4_pool, rate=0.3, training=is_training)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "elu",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "tf.contrib.layers.l2_regularizer(self.__weight_decay)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "batch_normalization_63": {
                "variable": {
                    "value": "conv5_bn",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "conv5",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(conv4_drop, 128, 3, activation='elu', padding='SAME', kernel_regularizer=tf.contrib.layers.l2_regularizer(self.__weight_decay))",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_64": {
                "variable": {
                    "value": "conv6",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv5_bn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(conv5)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "elu",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "tf.contrib.layers.l2_regularizer(self.__weight_decay)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "max_pooling2d_66": {
                "variable": {
                    "value": "conv6_pool",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "conv6",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(conv5_bn, 128, 3, activation='elu', padding='SAME', kernel_regularizer=tf.contrib.layers.l2_regularizer(self.__weight_decay))",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "stop_gradient_68": {
                "variable": {
                    "value": "csnn_features",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.__csnn.getTrainOp(input)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "identity_69": {
                "variable": {
                    "value": "csnn_features",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "csnn_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(self.__csnn.getTrainOp(input))",
                            "Call"
                        ],
                        [
                            "tf.identity(csnn_features)",
                            "Call"
                        ]
                    ]
                }
            },
            "batch_normalization_75": {
                "variable": {
                    "value": "conv6_bn",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "joint_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat((conv6_pool, csnn_features), axis=3)",
                            "Call"
                        ],
                        [
                            "conv6_pool",
                            "variable"
                        ]
                    ]
                }
            },
            "conv2d_77": {
                "variable": {
                    "value": "conv7",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv6_bn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(joint_features)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "256",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "elu",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "tf.contrib.layers.l2_regularizer(self.__weight_decay)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "batch_normalization_79": {
                "variable": {
                    "value": "conv7_bn",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "conv7",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(conv6_bn, 256, 3, activation='elu', padding='SAME', kernel_regularizer=tf.contrib.layers.l2_regularizer(self.__weight_decay))",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_80": {
                "variable": {
                    "value": "conv8",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv7_bn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(conv7)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "256",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "elu",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "tf.contrib.layers.l2_regularizer(self.__weight_decay)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "batch_normalization_82": {
                "variable": {
                    "value": "conv8_bn",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "conv8",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(conv7_bn, 256, 3, activation='elu', padding='SAME', kernel_regularizer=tf.contrib.layers.l2_regularizer(self.__weight_decay))",
                            "Call"
                        ]
                    ]
                }
            },
            "max_pooling2d_83": {
                "variable": {
                    "value": "conv8_pool",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "conv8_bn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(conv8)",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dropout_84": {
                "variable": {
                    "value": "conv8_drop",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "conv8_pool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.max_pooling2d(conv8_bn, 2, 2, padding='SAME')",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "0.4",
                    "type": "float",
                    "possible_values": []
                },
                "training": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "flatten_86": {
                "variable": {
                    "value": "flat",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "conv8_drop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dropout(conv8_pool, rate=0.4, training=is_training)",
                            "Call"
                        ]
                    ]
                }
            },
            "dense_87": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.layers.flatten(conv8_drop)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "self.__num_classes",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_42": {
                "name_or_scope": {
                    "value": "CNN",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_71": {
                "variable": {
                    "value": "joint_features",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(conv6_pool, csnn_features)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_v2_100": {
                "logits": {
                    "value": "logits_train",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.cast(train_labels, dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_v2_115": {
                "logits": {
                    "value": "logits_eval",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.cast(eval_labels, dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "argmax_127": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_128": {
                "x": {
                    "value": "correct_prediction",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.argmax(logits, 1), tf.argmax(labels, 1))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_101": {
                "x": {
                    "value": "train_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_116": {
                "x": {
                    "value": "eval_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "Experiment_Component/Models/Mlp.py": {
        "tensorflow": {
            "reduce_mean_52": {
                "variable": {
                    "value": "train_loss_op",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.nn.softmax_cross_entropy_with_logits_v2(logits=train_logits_op, labels=tf.cast(train_labels, dtype=tf.int32))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_67": {
                "variable": {
                    "value": "val_loss_op",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.nn.softmax_cross_entropy_with_logits_v2(logits=val_logits_op, labels=tf.cast(val_labels, dtype=tf.int32))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_79": {
                "variable": {
                    "value": "eval_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "eval_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(eval_logits, [-1, self.__model_config['numClasses']])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, self.__model_config['numClasses']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "equal_80": {
                "variable": {
                    "value": "correct_prediction",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(eval_logits, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.argmax(eval_labels, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_81": {
                "variable": {
                    "value": "eval_acc_op",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(correct_prediction, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "AdamOptimizer_100": {
                "variable": {
                    "value": "optimizer_op",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.__model_config['learningRate']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "flatten_33": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "input_batch",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "dense_39": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.flatten(input_batch)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, layer['neurons'], activation=layer['activation'])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(x, rate=layer['dropoutRate'], training=is_training)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "self.__model_config['numClasses']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "variable_scope_32": {
                "name_or_scope": {
                    "value": "Mlp",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dense_35": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.flatten(input_batch)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, layer['neurons'], activation=layer['activation'])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(x, rate=layer['dropoutRate'], training=is_training)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "layer['neurons']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "activation": {
                    "value": "layer['activation']",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "self.__model_config['layers']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "dropout_36": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.flatten(input_batch)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, layer['neurons'], activation=layer['activation'])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(x, rate=layer['dropoutRate'], training=is_training)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "layer['dropoutRate']",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "self.__model_config['layers']",
                            "Subscript"
                        ]
                    ]
                },
                "training": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_v2_52": {
                "logits": {
                    "value": "train_logits_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.__mlpNetFn(train_batch, is_training=True)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.cast(train_labels, dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_v2_67": {
                "logits": {
                    "value": "val_logits_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.__mlpNetFn(val_batch, is_training=False)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.cast(val_labels, dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "argmax_80": {
                "input": {
                    "value": "eval_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_81": {
                "x": {
                    "value": "correct_prediction",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.argmax(eval_logits, 1), tf.argmax(eval_labels, 1))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_53": {
                "x": {
                    "value": "train_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_68": {
                "x": {
                    "value": "val_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "Experiment_Component/Trainer/MultiGpuBackprobTrainer.py": {
        "tensorflow": {
            "split_38": {
                "variable": {
                    "value": "input_data_split",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "input_data",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "self.__num_gpus",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_39": {
                "variable": {
                    "value": "labels_split",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "self.__num_gpus",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_74": {
                "variable": {
                    "value": "input_data_split",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "input_data",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "self.__num_gpus",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_75": {
                "variable": {
                    "value": "labels_split",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "self.__num_gpus",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_77": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_54": {
                "variable": {
                    "value": "avg_loss_op",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "reduce_mean_102": {
                "variable": {
                    "value": "avg_loss_op",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "reduce_mean_119": {
                "variable": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "grads",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[g for (g, _) in grad_and_vars]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_43": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_53": {
                "name": {
                    "value": "valLossAcc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "device_53": {
                "device_name": {
                    "value": "self.__controller",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_81": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_97": {
                "name": {
                    "value": "applyGradients",
                    "type": "str",
                    "possible_values": []
                }
            },
            "device_97": {
                "device_name": {
                    "value": "self.__controller",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_scope_43": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_77": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_scope_81": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "name_scope_46": {
                "name": {
                    "value": "'ValidationGPU%d' % gpu",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "device_46": {
                "device_name": {
                    "value": "'/gpu:%d' % gpu",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "name_scope_83": {
                "name": {
                    "value": "'TrainingGPU%d' % gpu",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "device_83": {
                "device_name": {
                    "value": "'/gpu:%d' % gpu",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "name_scope_86": {
                "name": {
                    "value": "computeGradients",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "Experiment_Component/Trainer/MultiGpuCsnnTrainer.py": {
        "tensorflow": {
            "split_42": {
                "variable": {
                    "value": "input_data_split",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "input_data",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_66": {
                "variable": {
                    "value": "input_data_split",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "input_data",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "self.__num_gpus",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_or_create_global_step_81": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_45": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_69": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_80": {
                "name": {
                    "value": "applyLearningWeights",
                    "type": "str",
                    "possible_values": []
                }
            },
            "device_80": {
                "device_name": {
                    "value": "self.__controller",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_82": {
                "name": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.get_or_create_global_step()",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_scope_45": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_69": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "name_scope_49": {
                "name": {
                    "value": "'ValidationGPU%d' % gpu",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "device_49": {
                "device_name": {
                    "value": "'/gpu:%d' % gpu",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "name_scope_71": {
                "name": {
                    "value": "'TrainingGPU%d' % gpu",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "device_71": {
                "device_name": {
                    "value": "'/gpu:%d' % gpu",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "name_scope_73": {
                "name": {
                    "value": "computeLearningWeights",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "Experiment_Component/Trainer/MultiGpuHybridTrainer.py": {
        "tensorflow": {
            "split_39": {
                "variable": {
                    "value": "input_data_split",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "input_data",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "self.__num_gpus",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_40": {
                "variable": {
                    "value": "labels_split",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "self.__num_gpus",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_77": {
                "variable": {
                    "value": "input_data_split",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "input_data",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "self.__num_gpus",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_78": {
                "variable": {
                    "value": "labels_split",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "self.__num_gpus",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_56": {
                "variable": {
                    "value": "avg_loss_op",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "get_or_create_global_step_82": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_mean_105": {
                "variable": {
                    "value": "avg_loss_op",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "reduce_mean_125": {
                "variable": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "grads",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[g for (g, _) in grad_and_vars]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_44": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_55": {
                "name": {
                    "value": "valLossAcc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "device_55": {
                "device_name": {
                    "value": "self.__controller",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_81": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_100": {
                "name": {
                    "value": "applyGradientsAndCsnnUpdates",
                    "type": "str",
                    "possible_values": []
                }
            },
            "device_100": {
                "device_name": {
                    "value": "self.__controller",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_scope_44": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_81": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "name_scope_47": {
                "name": {
                    "value": "'ValidationGPU%d' % gpu",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "device_47": {
                "device_name": {
                    "value": "'/gpu:%d' % gpu",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "name_scope_84": {
                "name": {
                    "value": "'TrainingGPU%d' % gpu",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "device_84": {
                "device_name": {
                    "value": "'/gpu:%d' % gpu",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "name_scope_87": {
                "name": {
                    "value": "computeGradients",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "Experiment_Component/Trainer/SingleGpuBackprobTrainer.py": {
        "tensorflow": {
            "variable_scope_18": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_36": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_40": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_scope_18": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "name_scope_19": {
                "name": {
                    "value": "Validation",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_scope_36": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "name_scope_37": {
                "name": {
                    "value": "Training",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_initializer_40": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "Experiment_Component/Trainer/SingleGpuCsnnTrainer.py": {
        "tensorflow": {
            "variable_scope_22": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_39": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_or_create_global_step_42": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_22": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "name_scope_23": {
                "name": {
                    "value": "Validation",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_scope_39": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "name_scope_40": {
                "name": {
                    "value": "Training",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "Input_Component/ADataProvider.py": {
        "tensorflow": {
            "name_scope_118": {
                "name": {
                    "value": "str(self.__dataset_name) + 'Data_' + mode",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "device_118": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "Input_Component/DataProviders/EncodingProvider.py": {
        "tensorflow": {}
    },
    "Input_Component/TfRecord/TfRecordProvider.py": {
        "tensorflow": {
            "parse_single_example_175": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "serialized": {
                    "value": "tfrecord",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "{'data': tf.FixedLenFeature([], tf.string), 'dataShape': tf.FixedLenFeature([self.__tfrecord_shape_lens['data']], tf.int64), 'label': tf.FixedLenFeature([], tf.string), 'labelShape': tf.FixedLenFeature([self.__tfrecord_shape_lens['label']], tf.int64)}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "decode_raw_181": {
                "variable": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": []
                },
                "input_bytes": {
                    "value": "features['data']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_type": {
                    "value": "self.__tf_record_datatypes['data']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reshape_182": {
                "variable": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.decode_raw(features['data'], self.__tf_record_datatypes['data'])",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, features['dataShape'])",
                            "Call"
                        ],
                        [
                            "tf.cast(data, self.__tf_datatyps_after_parse['data'])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "features['dataShape']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cast_184": {
                "variable": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.decode_raw(features['data'], self.__tf_record_datatypes['data'])",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, features['dataShape'])",
                            "Call"
                        ],
                        [
                            "tf.cast(data, self.__tf_datatyps_after_parse['data'])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.__tf_datatyps_after_parse['data']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "decode_raw_186": {
                "variable": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": []
                },
                "input_bytes": {
                    "value": "features['label']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_type": {
                    "value": "self.__tf_record_datatypes['label']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reshape_187": {
                "variable": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.decode_raw(features['label'], self.__tf_record_datatypes['label'])",
                            "Call"
                        ],
                        [
                            "tf.reshape(label, features['labelShape'])",
                            "Call"
                        ],
                        [
                            "tf.cast(label, self.__tf_datatyps_after_parse['label'])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "features['labelShape']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cast_189": {
                "variable": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.decode_raw(features['label'], self.__tf_record_datatypes['label'])",
                            "Call"
                        ],
                        [
                            "tf.reshape(label, features['labelShape'])",
                            "Call"
                        ],
                        [
                            "tf.cast(label, self.__tf_datatyps_after_parse['label'])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.__tf_datatyps_after_parse['label']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "placeholder_82": {
                "variable": {
                    "value": "self.__tfrecord_files_placeholder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TFRecordDataset_83": {
                "variable": {
                    "value": "self.__tfrecord_dataset",
                    "type": "Attribute",
                    "possible_values": []
                },
                "filenames": {
                    "value": "self.__tfrecord_files_placeholder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "compression_type": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "buffer_size": {
                    "value": "self.__input_pipeline_config['bufferMB'] << 20",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "name_scope_61": {
                "name": {
                    "value": "dataset",
                    "type": "str",
                    "possible_values": []
                }
            },
            "device_61": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shuffle_and_repeat_139": {
                "buffer_size": {
                    "value": "((self.__input_pipeline_config['shuffleMB'] << 20) - 1) // bytes_per_item + 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "seed": {
                    "value": "42",
                    "type": "int",
                    "possible_values": []
                }
            },
            "FixedLenFeature_176": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_177": {
                "shape": {
                    "value": "[self.__tfrecord_shape_lens['data']]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_178": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_179": {
                "shape": {
                    "value": "[self.__tfrecord_shape_lens['label']]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "Output_Component/Summary/TensorboardSummaryWriter.py": {
        "tensorflow": {
            "FileWriter_18": {
                "variable": {
                    "value": "self.__summary_train_writer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logdir": {
                    "value": "modelDir + '/logs/train/'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "graph": {
                    "value": "graph",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "FileWriter_19": {
                "variable": {
                    "value": "self.__summary_eval_writer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logdir": {
                    "value": "modelDir + '/logs/eval/'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "graph": {
                    "value": "graph",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "FileWriter_20": {
                "variable": {
                    "value": "self.__summary_test_writer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logdir": {
                    "value": "modelDir + '/logs/test/'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "graph": {
                    "value": "graph",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "Output_Component/Summary/TxtFunctionTimeStopper.py": {
        "tensorflow": {}
    },
    "Output_Component/TfRecord/TfRecordExporter.py": {
        "tensorflow": {
            "TFRecordOptions_37": {
                "variable": {
                    "value": "tf_record_writer_options",
                    "type": "variable",
                    "possible_values": []
                },
                "compression_type": {
                    "value": "tf.python_io.TFRecordCompressionType.NONE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TFRecordWriter_38": {
                "variable": {
                    "value": "self.__tf_record_writer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "path": {
                    "value": "tfrecord_savepath + '.tfrecords'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "options": {
                    "value": "tf_record_writer_options",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.python_io.TFRecordOptions(tf.python_io.TFRecordCompressionType.NONE)",
                            "Call"
                        ]
                    ]
                }
            },
            "Example_54": {
                "variable": {
                    "value": "example",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "tf.train.Features(feature=feature)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_49": {
                "variable": {
                    "value": "feature[entry_part_name]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[entry_part_value.tostring()])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_51": {
                "variable": {
                    "value": "feature[entry_part_name + Shape]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "int64_list": {
                    "value": "tf.train.Int64List(value=entry_part_value.shape)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Features_54": {
                "feature": {
                    "value": "feature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{}",
                            "Dict"
                        ]
                    ]
                }
            },
            "BytesList_49": {
                "value": {
                    "value": "[entry_part_value.tostring()]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Int64List_51": {
                "value": {
                    "value": "entry_part_value.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "Preprocessing_Component/Preprocessing/MaxDivNormalizer.py": {
        "tensorflow": {
            "name_scope_26": {
                "name": {
                    "value": "'NormalizeTrough' + str(self.__max_value)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "truediv_27": {
                "x": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "float(self.__max_value)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "Preprocessing_Component/Preprocessing/ZeroMeanUnitVarianceNormalizer.py": {
        "tensorflow": {
            "subtract_49": {
                "variable": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.subtract(input, np.expand_dims(np.expand_dims(np.expand_dims(self.__dataset_mean, axis=0), axis=2), axis=3).astype(np.float32))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "np.expand_dims(np.expand_dims(np.expand_dims(self.__dataset_mean, axis=0), axis=2), axis=3).astype(np.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_47": {
                "name": {
                    "value": "ZeroMeanUnitVariance",
                    "type": "str",
                    "possible_values": []
                }
            },
            "truediv_53": {
                "x": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.subtract(input, np.expand_dims(np.expand_dims(np.expand_dims(self.__dataset_mean, axis=0), axis=2), axis=3).astype(np.float32))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "np.expand_dims(np.expand_dims(np.expand_dims(self.__dataset_std, axis=0), axis=2), axis=3).astype(np.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "csnnLib/bmuMetrics.py": {
        "tensorflow": {
            "subtract_29": {
                "variable": {
                    "value": "distance_vectors_per_map_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "input_batch",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "norm_34": {
                "variable": {
                    "value": "manhattan_distances_per_map_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "distance_vectors_per_map_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.subtract(weights, input_batch)",
                            "Call"
                        ],
                        [
                            "tf.subtract(weights, input_batch)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "ord": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmin_39": {
                "variable": {
                    "value": "bmus_per_map_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "manhattan_distances_per_map_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(distance_vectors_per_map_batch, axis=3, ord=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "subtract_72": {
                "variable": {
                    "value": "distance_vectors_per_map_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "input_batch",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "norm_77": {
                "variable": {
                    "value": "euclidean_distances_per_map_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "distance_vectors_per_map_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.subtract(weights, input_batch)",
                            "Call"
                        ],
                        [
                            "tf.subtract(weights, input_batch)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmin_82": {
                "variable": {
                    "value": "bmus_per_map_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "euclidean_distances_per_map_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(distance_vectors_per_map_batch, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_145": {
                "variable": {
                    "value": "bmus_per_map_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "person_r_per_map_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div_no_nan(cov, tf.multiply(tf.sqrt(var_input), tf.sqrt(var_weights)))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_179": {
                "variable": {
                    "value": "convolution_distance_per_map_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.multiply(weights, input_batch)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_184": {
                "variable": {
                    "value": "bmus_per_map_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "convolution_distance_per_map_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.multiply(weights, input_batch), axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_24": {
                "name_or_scope": {
                    "value": "manhattanDistance",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_min_44": {
                "variable": {
                    "value": "min_distances_per_map",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "manhattan_distances_per_map_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(distance_vectors_per_map_batch, axis=3, ord=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_45": {
                "variable": {
                    "value": "min_distance_sum",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "min_distances_per_map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_min(manhattan_distances_per_map_batch, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(euclidean_distances_per_map_batch, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_67": {
                "name_or_scope": {
                    "value": "euclideanDistance",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_min_87": {
                "variable": {
                    "value": "min_distances_per_map",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "euclidean_distances_per_map_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(distance_vectors_per_map_batch, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_88": {
                "variable": {
                    "value": "min_distance_sum",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "min_distances_per_map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_min(manhattan_distances_per_map_batch, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(euclidean_distances_per_map_batch, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_110": {
                "name_or_scope": {
                    "value": "pearsonCorrelation",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_122": {
                "variable": {
                    "value": "x_mean",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_mean_123": {
                "variable": {
                    "value": "y_mean",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_max_150": {
                "variable": {
                    "value": "max_distances_per_map",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "person_r_per_map_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div_no_nan(cov, tf.multiply(tf.sqrt(var_input), tf.sqrt(var_weights)))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_151": {
                "variable": {
                    "value": "max_distance_sum",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "max_distances_per_map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(person_r_per_map_batch, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(convolution_distance_per_map_batch, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_173": {
                "name_or_scope": {
                    "value": "convolutionDistance",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_max_189": {
                "variable": {
                    "value": "max_distances_per_map",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "convolution_distance_per_map_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.multiply(weights, input_batch), axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_190": {
                "variable": {
                    "value": "max_distance_sum",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "max_distances_per_map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(person_r_per_map_batch, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(convolution_distance_per_map_batch, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collections_46": {
                "names": {
                    "value": "sum_distance_measure",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "min_distance_sum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(min_distances_per_map)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(min_distances_per_map)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collections_89": {
                "names": {
                    "value": "sum_distance_measure",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "min_distance_sum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(min_distances_per_map)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(min_distances_per_map)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_124": {
                "input_tensor": {
                    "value": "tf.multiply(tf.subtract(x, x_mean), tf.subtract(y, y_mean))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multiply_140": {
                "x": {
                    "value": "tf.sqrt(var_input)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.sqrt(var_weights)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_to_collections_152": {
                "names": {
                    "value": "sum_distance_measure",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "max_distance_sum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(max_distances_per_map)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(max_distances_per_map)",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_179": {
                "x": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "input_batch",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "add_to_collections_191": {
                "names": {
                    "value": "sum_distance_measure",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "max_distance_sum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(max_distances_per_map)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(max_distances_per_map)",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_124": {
                "x": {
                    "value": "tf.subtract(x, x_mean)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.subtract(y, y_mean)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_140": {
                "x": {
                    "value": "var_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "covariance(weights, weights)",
                            "Call"
                        ]
                    ]
                }
            },
            "subtract_124": {
                "x": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "y_mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(y, axis=3, keepdims=True)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "csnnLib/decayFunctions.py": {
        "tensorflow": {
            "multiply_15": {
                "x": {
                    "value": "coeff",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.exp(tf.negative(tf.multiply(tf.multiply(2.0, coeff), tf.truediv(global_step, max_steps))))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "multiply_27": {
                "x": {
                    "value": "float(coeff_start)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.pow(float(coeff_end) / float(coeff_start), tf.truediv(global_step, float(max_steps)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exp_15": {
                "x": {
                    "value": "tf.negative(tf.multiply(tf.multiply(2.0, coeff), tf.truediv(global_step, max_steps)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "pow_27": {
                "x": {
                    "value": "float(coeff_end) / float(coeff_start)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.truediv(global_step, float(max_steps))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "negative_16": {
                "x": {
                    "value": "tf.multiply(tf.multiply(2.0, coeff), tf.truediv(global_step, max_steps))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "truediv_28": {
                "x": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "float(max_steps)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "multiply_16": {
                "x": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "coeff",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "truediv_16": {
                "x": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "max_steps",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "csnnLib/evaluation.py": {
        "tensorflow": {
            "gather_20": {
                "variable": {
                    "value": "bmu_cords_per_map_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "neuron_cords",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.expand_dims(neuron_cords, axis=0), axis=0)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "bmu_batch",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "expand_dims_24": {
                "variable": {
                    "value": "bmu_cords_per_map_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "bmu_cords_per_map_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(neuron_cords, bmu_batch)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(bmu_cords_per_map_batch, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_28": {
                "input": {
                    "value": "neuron_cords",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.expand_dims(neuron_cords, axis=0), axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_34": {
                "variable": {
                    "value": "comp",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "bmu_cords_per_map_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(neuron_cords, bmu_batch)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(bmu_cords_per_map_batch, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "neuron_cords",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.expand_dims(neuron_cords, axis=0), axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_max_40": {
                "variable": {
                    "value": "unique",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.reduce_min(tf.to_int32(comp), axis=3)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "count_nonzero_45": {
                "variable": {
                    "value": "non_zeros",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "unique",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(tf.reduce_min(tf.to_int32(comp), axis=3), axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "truediv_51": {
                "variable": {
                    "value": "neuron_utilization",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.to_float(non_zeros)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.to_float(num_maps.value * nr_neurons.value)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_15": {
                "name_or_scope": {
                    "value": "'neuronUtilization' + str(name)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_min_40": {
                "input_tensor": {
                    "value": "tf.to_int32(comp)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_float_51": {
                "x": {
                    "value": "num_maps.value * nr_neurons.value",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_int32_40": {
                "x": {
                    "value": "comp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(bmu_cords_per_map_batch, neuron_cords)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "csnnLib/layers.py": {
        "tensorflow": {
            "argmax_239": {
                "variable": {
                    "value": "max_map_index_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reduce_max(distances_batch, axis=2)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_244": {
                "variable": {
                    "value": "mask_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "max_map_index_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(tf.reduce_max(distances_batch, axis=2), axis=1)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "maps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "neighborhood_coeff_batch.get_shape()[1].value",
                            "Attribute"
                        ]
                    ]
                }
            },
            "expand_dims_248": {
                "variable": {
                    "value": "mask_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mask_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(max_map_index_batch, maps)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(mask_batch, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multiply_253": {
                "variable": {
                    "value": "neighborhood_coeff_batch_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "neighborhood_coeff_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "getattr(neighborhoodFunctions, neighborhood_function)(neuron_cords, bmus_batch, train_interval[1] - train_interval[0], **neighborhoodFunction_args)",
                            "Call"
                        ],
                        [
                            "__onlyBestBmuUpdate(distances_batch, neighborhood_coeff_batch)",
                            "Call"
                        ],
                        [
                            "tf.zeros([b, m.value, n.value, 1])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "mask_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(max_map_index_batch, maps)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(mask_batch, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_384": {
                "variable": {
                    "value": "delta_local_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "som_net_weights.get_shape()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_387": {
                "variable": {
                    "value": "delta_som_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "som_net_weights.get_shape()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_390": {
                "variable": {
                    "value": "neighborhood_coeff_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[b, m.value, n.value, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_485": {
                "variable": {
                    "value": "som_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "name + 'Weights'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_maps, num_som_neurons_per_map, patch_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_uniform_initializer(-1.0, 1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_490": {
                "variable": {
                    "value": "som_weights_metric",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "som_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name + 'Weights', [num_maps, num_som_neurons_per_map, patch_size], initializer=tf.random_uniform_initializer(-1.0, 1.0))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_501": {
                "variable": {
                    "value": "neuron_cords",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.array(list(__neuronCords(som_grid_height, som_grid_width)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_or_create_global_step_520": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cond_521": {
                "variable": {
                    "value": "(delta_som_weights, delta_local_weights, neighborhood_coeff_batch)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.logical_and(tf.greater_equal(tf.cast(global_step, tf.int32), tf.cast(train_interval[0], tf.int32)), tf.less(tf.cast(global_step, tf.int32), tf.cast(train_interval[1], tf.int32)))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "train",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "infer",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reshape_537": {
                "variable": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "distances_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, num_conv_patches_h, num_conv_patches_w, num_maps * num_som_neurons_per_map]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_539": {
                "variable": {
                    "value": "neighborhood_coeff_block_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "neighborhood_coeff_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "getattr(neighborhoodFunctions, neighborhood_function)(neuron_cords, bmus_batch, train_interval[1] - train_interval[0], **neighborhoodFunction_args)",
                            "Call"
                        ],
                        [
                            "__onlyBestBmuUpdate(distances_batch, neighborhood_coeff_batch)",
                            "Call"
                        ],
                        [
                            "tf.zeros([b, m.value, n.value, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, num_conv_patches_h, num_conv_patches_w, num_maps * num_som_neurons_per_map]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_626": {
                "variable": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(distances_batch, [-1, num_conv_patches_h, num_conv_patches_w, num_maps * num_som_neurons_per_map])",
                            "Call"
                        ],
                        [
                            "tf.add(-distances_block_batch, tf.reduce_max(distances_block_batch, axis=3, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.div(distances_block_batch, tf.reduce_max(distances_block_batch, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value * w.value * som_grid[2], som_grid[0], som_grid[1]])",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value, w.value, som_grid[2] * pooled_h.value * pooled_w.value])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(distances_block_batch, [1, 1, 1, 2], [1, 1, 1, 2], 'valid')",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "featurePooling(distances_block_batch, layer_config['somGrid'], layer_config['featurePooling'][0], layer_config['featurePooling'][1], pooling_type=layer_config['featurePooling'][2])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, h.value * w.value * som_grid[2], som_grid[0], som_grid[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_641": {
                "variable": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(distances_batch, [-1, num_conv_patches_h, num_conv_patches_w, num_maps * num_som_neurons_per_map])",
                            "Call"
                        ],
                        [
                            "tf.add(-distances_block_batch, tf.reduce_max(distances_block_batch, axis=3, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.div(distances_block_batch, tf.reduce_max(distances_block_batch, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value * w.value * som_grid[2], som_grid[0], som_grid[1]])",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value, w.value, som_grid[2] * pooled_h.value * pooled_w.value])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(distances_block_batch, [1, 1, 1, 2], [1, 1, 1, 2], 'valid')",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "featurePooling(distances_block_batch, layer_config['somGrid'], layer_config['featurePooling'][0], layer_config['featurePooling'][1], pooling_type=layer_config['featurePooling'][2])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, h.value, w.value, som_grid[2] * pooled_h.value * pooled_w.value]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_33": {
                "variable": {
                    "value": "local_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "name + 'Weights'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_maps, num_som_neurons_per_map, num_som_neurons_prev_layer]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_uniform_initializer(-1.0, 1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_38": {
                "variable": {
                    "value": "input_local_update_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, patch_size // num_som_neurons_prev_layer, num_som_neurons_prev_layer]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_42": {
                "input": {
                    "value": "input_local_update_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_batch, [-1, patch_size // num_som_neurons_prev_layer, num_som_neurons_prev_layer])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(input_local_update_batch, 2), 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(input_batch, 1), 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multiply_46": {
                "variable": {
                    "value": "output_local_update_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "input_local_update_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_batch, [-1, patch_size // num_som_neurons_prev_layer, num_som_neurons_prev_layer])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(input_local_update_batch, 2), 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(input_batch, 1), 1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.expand_dims(tf.expand_dims(local_weights, axis=0), axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "transpose_51": {
                "variable": {
                    "value": "output_batch_re",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "output_local_update_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(input_local_update_batch, tf.expand_dims(tf.expand_dims(local_weights, axis=0), axis=0))",
                            "Call"
                        ],
                        [
                            "tf.multiply(input_local_update_batch, tf.expand_dims(local_weights, axis=0))",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 3, 4, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_55": {
                "variable": {
                    "value": "output_batch_re",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output_batch_re",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(output_local_update_batch, [0, 2, 3, 4, 1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output_batch_re, [-1, num_maps, num_som_neurons_per_map, patch_size])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, num_maps, num_som_neurons_per_map, patch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_85": {
                "variable": {
                    "value": "local_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "name + 'Weights'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_maps, num_som_neurons_per_map, patch_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_uniform_initializer(-1.0, 1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_90": {
                "input": {
                    "value": "input_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multiply_93": {
                "variable": {
                    "value": "output_local_update_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "input_local_update_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_batch, [-1, patch_size // num_som_neurons_prev_layer, num_som_neurons_prev_layer])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(input_local_update_batch, 2), 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(input_batch, 1), 1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.expand_dims(local_weights, axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "extract_image_patches_197": {
                "variable": {
                    "value": "input_patches_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "input_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "ksizes": {
                    "value": "k_sizes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, som_kernel[0], som_kernel[1], 1]",
                            "List"
                        ]
                    ]
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, strides[0], strides[1], 1]",
                            "List"
                        ]
                    ]
                },
                "rates": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_211": {
                "variable": {
                    "value": "input_patches_batch_re",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_patches_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.extract_image_patches(images=input_batch, ksizes=k_sizes, strides=strides, rates=[1, 1, 1, 1], padding=padding)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, patch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_343": {
                "variable": {
                    "value": "delta_local_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "som_weights.get_shape()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_386": {
                "variable": {
                    "value": "delta_local_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "local_weights.get_shape()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_to_collections_545": {
                "names": {
                    "value": "deltaSomWeights",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "delta_som_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "getattr(learningRules, som_learning_rule)(som_learning_rate, neighborhood_coeff_batch, tf.expand_dims(tf.expand_dims(input_patches_batch_re, axis=1), axis=1), som_weights)",
                            "Call"
                        ],
                        [
                            "tf.zeros(som_net_weights.get_shape())",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collections_546": {
                "names": {
                    "value": "oldSomWeights",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "som_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name + 'Weights', [num_maps, num_som_neurons_per_map, patch_size], initializer=tf.random_uniform_initializer(-1.0, 1.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collections_557": {
                "names": {
                    "value": "neuronUtilization",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "neuron_utilization",
                    "type": "variable",
                    "possible_values": [
                        [
                            "evaluation.neuronUtilization(neuron_cords, bmus_batch, name)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_583": {
                "variable": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "-distances_block_batch",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_max(distances_block_batch, axis=3, keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "max_pooling2d_632": {
                "variable": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(distances_batch, [-1, num_conv_patches_h, num_conv_patches_w, num_maps * num_som_neurons_per_map])",
                            "Call"
                        ],
                        [
                            "tf.add(-distances_block_batch, tf.reduce_max(distances_block_batch, axis=3, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.div(distances_block_batch, tf.reduce_max(distances_block_batch, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value * w.value * som_grid[2], som_grid[0], som_grid[1]])",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value, w.value, som_grid[2] * pooled_h.value * pooled_w.value])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(distances_block_batch, [1, 1, 1, 2], [1, 1, 1, 2], 'valid')",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "featurePooling(distances_block_batch, layer_config['somGrid'], layer_config['featurePooling'][0], layer_config['featurePooling'][1], pooling_type=layer_config['featurePooling'][2])",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "pool_ksize",
                    "type": "variable",
                    "possible_values": []
                },
                "strides": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": []
                },
                "data_format": {
                    "value": "channels_first",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_662": {
                "variable": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(distances_batch, [-1, num_conv_patches_h, num_conv_patches_w, num_maps * num_som_neurons_per_map])",
                            "Call"
                        ],
                        [
                            "tf.add(-distances_block_batch, tf.reduce_max(distances_block_batch, axis=3, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.div(distances_block_batch, tf.reduce_max(distances_block_batch, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value * w.value * som_grid[2], som_grid[0], som_grid[1]])",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value, w.value, som_grid[2] * pooled_h.value * pooled_w.value])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(distances_block_batch, [1, 1, 1, 2], [1, 1, 1, 2], 'valid')",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "featurePooling(distances_block_batch, layer_config['somGrid'], layer_config['featurePooling'][0], layer_config['featurePooling'][1], pooling_type=layer_config['featurePooling'][2])",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 1, 1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1, 1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "valid",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_30": {
                "name_or_scope": {
                    "value": "'localWeights' + str(name)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_82": {
                "name_or_scope": {
                    "value": "'localInputWeights' + str(name)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_149": {
                "input": {
                    "value": "input_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_183": {
                "name_or_scope": {
                    "value": "'createAndShapePatches' + str(name)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_214": {
                "variable": {
                    "value": "input_patches_vis_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_patches_batch_re",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_patches_batch, [-1, patch_size])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, som_kernel[0], som_kernel[1], som_kernel_depth]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_max_239": {
                "input_tensor": {
                    "value": "distances_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_354": {
                "input": {
                    "value": "input_patches_batch_re",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_patches_batch, [-1, patch_size])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_389": {
                "input": {
                    "value": "distances_batch",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "logical_and_522": {
                "x": {
                    "value": "tf.greater_equal(tf.cast(global_step, tf.int32), tf.cast(train_interval[0], tf.int32))",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.less(tf.cast(global_step, tf.int32), tf.cast(train_interval[1], tf.int32))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_to_collections_552": {
                "names": {
                    "value": "deltaLocalWeights",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "delta_local_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "getattr(learningRules, local_learning_rule)(local_weights, input_local_update_batch, neighborhood_coeff_local_batch, output_local_update_batch, local_learning_rate, reduce_sum_axis, reduce_mean_axis)",
                            "Call"
                        ],
                        [
                            "tf.zeros(som_weights.get_shape())",
                            "Call"
                        ],
                        [
                            "tf.zeros(som_net_weights.get_shape())",
                            "Call"
                        ],
                        [
                            "tf.zeros(local_weights.get_shape())",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collections_553": {
                "names": {
                    "value": "oldLocalWeights",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "local_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name + 'Weights', [num_maps, num_som_neurons_per_map, num_som_neurons_prev_layer], initializer=tf.random_uniform_initializer(-1.0, 1.0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name + 'Weights', [num_maps, num_som_neurons_per_map, patch_size], initializer=tf.random_uniform_initializer(-1.0, 1.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "div_586": {
                "x": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(distances_batch, [-1, num_conv_patches_h, num_conv_patches_w, num_maps * num_som_neurons_per_map])",
                            "Call"
                        ],
                        [
                            "tf.add(-distances_block_batch, tf.reduce_max(distances_block_batch, axis=3, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.div(distances_block_batch, tf.reduce_max(distances_block_batch, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value * w.value * som_grid[2], som_grid[0], som_grid[1]])",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value, w.value, som_grid[2] * pooled_h.value * pooled_w.value])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(distances_block_batch, [1, 1, 1, 2], [1, 1, 1, 2], 'valid')",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "featurePooling(distances_block_batch, layer_config['somGrid'], layer_config['featurePooling'][0], layer_config['featurePooling'][1], pooling_type=layer_config['featurePooling'][2])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.reduce_max(tf.abs(distances_block_batch), keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "average_pooling2d_635": {
                "variable": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(distances_batch, [-1, num_conv_patches_h, num_conv_patches_w, num_maps * num_som_neurons_per_map])",
                            "Call"
                        ],
                        [
                            "tf.add(-distances_block_batch, tf.reduce_max(distances_block_batch, axis=3, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.div(distances_block_batch, tf.reduce_max(distances_block_batch, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value * w.value * som_grid[2], som_grid[0], som_grid[1]])",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value, w.value, som_grid[2] * pooled_h.value * pooled_w.value])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(distances_block_batch, [1, 1, 1, 2], [1, 1, 1, 2], 'valid')",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "featurePooling(distances_block_batch, layer_config['somGrid'], layer_config['featurePooling'][0], layer_config['featurePooling'][1], pooling_type=layer_config['featurePooling'][2])",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "pool_ksize",
                    "type": "variable",
                    "possible_values": []
                },
                "strides": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": []
                },
                "data_format": {
                    "value": "channels_first",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pooling2d_655": {
                "variable": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(distances_batch, [-1, num_conv_patches_h, num_conv_patches_w, num_maps * num_som_neurons_per_map])",
                            "Call"
                        ],
                        [
                            "tf.add(-distances_block_batch, tf.reduce_max(distances_block_batch, axis=3, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.div(distances_block_batch, tf.reduce_max(distances_block_batch, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value * w.value * som_grid[2], som_grid[0], som_grid[1]])",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value, w.value, som_grid[2] * pooled_h.value * pooled_w.value])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(distances_block_batch, [1, 1, 1, 2], [1, 1, 1, 2], 'valid')",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "featurePooling(distances_block_batch, layer_config['somGrid'], layer_config['featurePooling'][0], layer_config['featurePooling'][1], pooling_type=layer_config['featurePooling'][2])",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "layer_config['pooling'][0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "strides": {
                    "value": "layer_config['pooling'][1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_46": {
                "input": {
                    "value": "local_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name + 'Weights', [num_maps, num_som_neurons_per_map, num_som_neurons_prev_layer], initializer=tf.random_uniform_initializer(-1.0, 1.0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name + 'Weights', [num_maps, num_som_neurons_per_map, patch_size], initializer=tf.random_uniform_initializer(-1.0, 1.0))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_93": {
                "input": {
                    "value": "local_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name + 'Weights', [num_maps, num_som_neurons_per_map, num_som_neurons_prev_layer], initializer=tf.random_uniform_initializer(-1.0, 1.0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name + 'Weights', [num_maps, num_som_neurons_per_map, patch_size], initializer=tf.random_uniform_initializer(-1.0, 1.0))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_216": {
                "name": {
                    "value": "Patches",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "input_patches_vis_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_patches_batch_re, [-1, som_kernel[0], som_kernel[1], som_kernel_depth])",
                            "Call"
                        ]
                    ]
                },
                "max_outputs": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                }
            },
            "random_uniform_initializer_486": {
                "minval": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "greater_equal_522": {
                "x": {
                    "value": "tf.cast(global_step, tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(train_interval[0], tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "less_523": {
                "x": {
                    "value": "tf.cast(global_step, tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(train_interval[1], tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_max_583": {
                "input_tensor": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(distances_batch, [-1, num_conv_patches_h, num_conv_patches_w, num_maps * num_som_neurons_per_map])",
                            "Call"
                        ],
                        [
                            "tf.add(-distances_block_batch, tf.reduce_max(distances_block_batch, axis=3, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.div(distances_block_batch, tf.reduce_max(distances_block_batch, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value * w.value * som_grid[2], som_grid[0], som_grid[1]])",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value, w.value, som_grid[2] * pooled_h.value * pooled_w.value])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(distances_block_batch, [1, 1, 1, 2], [1, 1, 1, 2], 'valid')",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "featurePooling(distances_block_batch, layer_config['somGrid'], layer_config['featurePooling'][0], layer_config['featurePooling'][1], pooling_type=layer_config['featurePooling'][2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_max_586": {
                "input_tensor": {
                    "value": "tf.abs(distances_block_batch)",
                    "type": "Call",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "div_589": {
                "x": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(distances_batch, [-1, num_conv_patches_h, num_conv_patches_w, num_maps * num_som_neurons_per_map])",
                            "Call"
                        ],
                        [
                            "tf.add(-distances_block_batch, tf.reduce_max(distances_block_batch, axis=3, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.div(distances_block_batch, tf.reduce_max(distances_block_batch, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value * w.value * som_grid[2], som_grid[0], som_grid[1]])",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value, w.value, som_grid[2] * pooled_h.value * pooled_w.value])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(distances_block_batch, [1, 1, 1, 2], [1, 1, 1, 2], 'valid')",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "featurePooling(distances_block_batch, layer_config['somGrid'], layer_config['featurePooling'][0], layer_config['featurePooling'][1], pooling_type=layer_config['featurePooling'][2])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.reduce_max(distances_block_batch, axis=3, keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "div_592": {
                "variable": {
                    "value": "distances",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(distances_batch, [-1, num_conv_patches_h, num_conv_patches_w, num_maps * num_som_neurons_per_map])",
                            "Call"
                        ],
                        [
                            "tf.add(-distances_block_batch, tf.reduce_max(distances_block_batch, axis=3, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.div(distances_block_batch, tf.reduce_max(distances_block_batch, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value * w.value * som_grid[2], som_grid[0], som_grid[1]])",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value, w.value, som_grid[2] * pooled_h.value * pooled_w.value])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(distances_block_batch, [1, 1, 1, 2], [1, 1, 1, 2], 'valid')",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "featurePooling(distances_block_batch, layer_config['somGrid'], layer_config['featurePooling'][0], layer_config['featurePooling'][1], pooling_type=layer_config['featurePooling'][2])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.reduce_max(distances_block_batch, axis=3, keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "average_pooling2d_658": {
                "variable": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(distances_batch, [-1, num_conv_patches_h, num_conv_patches_w, num_maps * num_som_neurons_per_map])",
                            "Call"
                        ],
                        [
                            "tf.add(-distances_block_batch, tf.reduce_max(distances_block_batch, axis=3, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.div(distances_block_batch, tf.reduce_max(distances_block_batch, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value * w.value * som_grid[2], som_grid[0], som_grid[1]])",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value, w.value, som_grid[2] * pooled_h.value * pooled_w.value])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(distances_block_batch, [1, 1, 1, 2], [1, 1, 1, 2], 'valid')",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "featurePooling(distances_block_batch, layer_config['somGrid'], layer_config['featurePooling'][0], layer_config['featurePooling'][1], pooling_type=layer_config['featurePooling'][2])",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "layer_config['pooling'][0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "strides": {
                    "value": "layer_config['pooling'][1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "random_uniform_initializer_35": {
                "minval": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "random_uniform_initializer_87": {
                "minval": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "cast_522": {
                "x": {
                    "value": "train_interval[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_523": {
                "x": {
                    "value": "train_interval[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "abs_586": {
                "x": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(distances_batch, [-1, num_conv_patches_h, num_conv_patches_w, num_maps * num_som_neurons_per_map])",
                            "Call"
                        ],
                        [
                            "tf.add(-distances_block_batch, tf.reduce_max(distances_block_batch, axis=3, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.div(distances_block_batch, tf.reduce_max(distances_block_batch, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value * w.value * som_grid[2], som_grid[0], som_grid[1]])",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value, w.value, som_grid[2] * pooled_h.value * pooled_w.value])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(distances_block_batch, [1, 1, 1, 2], [1, 1, 1, 2], 'valid')",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "featurePooling(distances_block_batch, layer_config['somGrid'], layer_config['featurePooling'][0], layer_config['featurePooling'][1], pooling_type=layer_config['featurePooling'][2])",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_max_589": {
                "input_tensor": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(distances_batch, [-1, num_conv_patches_h, num_conv_patches_w, num_maps * num_som_neurons_per_map])",
                            "Call"
                        ],
                        [
                            "tf.add(-distances_block_batch, tf.reduce_max(distances_block_batch, axis=3, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.div(distances_block_batch, tf.reduce_max(distances_block_batch, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value * w.value * som_grid[2], som_grid[0], som_grid[1]])",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value, w.value, som_grid[2] * pooled_h.value * pooled_w.value])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(distances_block_batch, [1, 1, 1, 2], [1, 1, 1, 2], 'valid')",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "featurePooling(distances_block_batch, layer_config['somGrid'], layer_config['featurePooling'][0], layer_config['featurePooling'][1], pooling_type=layer_config['featurePooling'][2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "batch_normalization_593": {
                "x": {
                    "value": "distances",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(distances_block_batch, tf.reduce_max(distances_block_batch, axis=3, keepdims=True))",
                            "Call"
                        ]
                    ]
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_max_592": {
                "input_tensor": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(distances_batch, [-1, num_conv_patches_h, num_conv_patches_w, num_maps * num_som_neurons_per_map])",
                            "Call"
                        ],
                        [
                            "tf.add(-distances_block_batch, tf.reduce_max(distances_block_batch, axis=3, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.div(distances_block_batch, tf.reduce_max(distances_block_batch, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value * w.value * som_grid[2], som_grid[0], som_grid[1]])",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value, w.value, som_grid[2] * pooled_h.value * pooled_w.value])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(distances_block_batch, [1, 1, 1, 2], [1, 1, 1, 2], 'valid')",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "featurePooling(distances_block_batch, layer_config['somGrid'], layer_config['featurePooling'][0], layer_config['featurePooling'][1], pooling_type=layer_config['featurePooling'][2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "batch_normalization_596": {
                "x": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(distances_batch, [-1, num_conv_patches_h, num_conv_patches_w, num_maps * num_som_neurons_per_map])",
                            "Call"
                        ],
                        [
                            "tf.add(-distances_block_batch, tf.reduce_max(distances_block_batch, axis=3, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.div(distances_block_batch, tf.reduce_max(distances_block_batch, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value * w.value * som_grid[2], som_grid[0], som_grid[1]])",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value, w.value, som_grid[2] * pooled_h.value * pooled_w.value])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(distances_block_batch, [1, 1, 1, 2], [1, 1, 1, 2], 'valid')",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "featurePooling(distances_block_batch, layer_config['somGrid'], layer_config['featurePooling'][0], layer_config['featurePooling'][1], pooling_type=layer_config['featurePooling'][2])",
                            "Call"
                        ]
                    ]
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "div_599": {
                "variable": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(distances_batch, [-1, num_conv_patches_h, num_conv_patches_w, num_maps * num_som_neurons_per_map])",
                            "Call"
                        ],
                        [
                            "tf.add(-distances_block_batch, tf.reduce_max(distances_block_batch, axis=3, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.div(distances_block_batch, tf.reduce_max(distances_block_batch, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value * w.value * som_grid[2], som_grid[0], som_grid[1]])",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value, w.value, som_grid[2] * pooled_h.value * pooled_w.value])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(distances_block_batch, [1, 1, 1, 2], [1, 1, 1, 2], 'valid')",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "featurePooling(distances_block_batch, layer_config['somGrid'], layer_config['featurePooling'][0], layer_config['featurePooling'][1], pooling_type=layer_config['featurePooling'][2])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.reduce_max(distances_block_batch, keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "batch_normalization_600": {
                "x": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(distances_batch, [-1, num_conv_patches_h, num_conv_patches_w, num_maps * num_som_neurons_per_map])",
                            "Call"
                        ],
                        [
                            "tf.add(-distances_block_batch, tf.reduce_max(distances_block_batch, axis=3, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.div(distances_block_batch, tf.reduce_max(distances_block_batch, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value * w.value * som_grid[2], som_grid[0], som_grid[1]])",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value, w.value, som_grid[2] * pooled_h.value * pooled_w.value])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(distances_block_batch, [1, 1, 1, 2], [1, 1, 1, 2], 'valid')",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "featurePooling(distances_block_batch, layer_config['somGrid'], layer_config['featurePooling'][0], layer_config['featurePooling'][1], pooling_type=layer_config['featurePooling'][2])",
                            "Call"
                        ]
                    ]
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_max_599": {
                "input_tensor": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(distances_batch, [-1, num_conv_patches_h, num_conv_patches_w, num_maps * num_som_neurons_per_map])",
                            "Call"
                        ],
                        [
                            "tf.add(-distances_block_batch, tf.reduce_max(distances_block_batch, axis=3, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.div(distances_block_batch, tf.reduce_max(distances_block_batch, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value * w.value * som_grid[2], som_grid[0], som_grid[1]])",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value, w.value, som_grid[2] * pooled_h.value * pooled_w.value])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(distances_block_batch, [1, 1, 1, 2], [1, 1, 1, 2], 'valid')",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "featurePooling(distances_block_batch, layer_config['somGrid'], layer_config['featurePooling'][0], layer_config['featurePooling'][1], pooling_type=layer_config['featurePooling'][2])",
                            "Call"
                        ]
                    ]
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "batch_normalization_603": {
                "x": {
                    "value": "distances_block_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(distances_batch, [-1, num_conv_patches_h, num_conv_patches_w, num_maps * num_som_neurons_per_map])",
                            "Call"
                        ],
                        [
                            "tf.add(-distances_block_batch, tf.reduce_max(distances_block_batch, axis=3, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.div(distances_block_batch, tf.reduce_max(distances_block_batch, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value * w.value * som_grid[2], som_grid[0], som_grid[1]])",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.reshape(distances_block_batch, [-1, h.value, w.value, som_grid[2] * pooled_h.value * pooled_w.value])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, pool_ksize, stride, data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(distances_block_batch, [1, 1, 1, 2], [1, 1, 1, 2], 'valid')",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(distances_block_batch, layer_config['pooling'][0], layer_config['pooling'][1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "featurePooling(distances_block_batch, layer_config['somGrid'], layer_config['featurePooling'][0], layer_config['featurePooling'][1], pooling_type=layer_config['featurePooling'][2])",
                            "Call"
                        ]
                    ]
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "csnnLib/learningRules.py": {
        "tensorflow": {
            "expand_dims_39": {
                "variable": {
                    "value": "neighborhood_coeff_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "neighborhood_coeff_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.greater_equal(neighborhood_coeff_batch, 1.0))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multiply_50": {
                "variable": {
                    "value": "delta_new_batch_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "neighborhood_coeff_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.greater_equal(neighborhood_coeff_batch, 1.0))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.subtract(input_batch, tf.expand_dims(som_net_weights, axis=0))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_56": {
                "variable": {
                    "value": "delta_new_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "delta_new_batch_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(neighborhood_coeff_batch, tf.subtract(input_batch, tf.expand_dims(som_net_weights, axis=0)))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multiply_62": {
                "variable": {
                    "value": "delta_new_weights_op",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "delta_new_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(delta_new_batch_weights, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(delta_new_batch_weights_batch, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "expand_dims_86": {
                "variable": {
                    "value": "neighborhood_coeff_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "neighborhood_coeff_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.greater_equal(neighborhood_coeff_batch, 1.0))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multiply_93": {
                "variable": {
                    "value": "delta_new_batch_weights_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "neighborhood_coeff_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.greater_equal(neighborhood_coeff_batch, 1.0))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "input_batch",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_mean_99": {
                "variable": {
                    "value": "delta_new_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "delta_new_batch_weights_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(neighborhood_coeff_batch, input_batch)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multiply_105": {
                "variable": {
                    "value": "delta_new_weights_op",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "delta_new_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(delta_new_batch_weights, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(delta_new_batch_weights_batch, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "zeros_127": {
                "variable": {
                    "value": "delta_new_weights_op",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[m.value, n.value, d.value]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_170": {
                "variable": {
                    "value": "neighborhood_coeff_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "neighborhood_coeff_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.greater_equal(neighborhood_coeff_batch, 1.0))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multiply_211": {
                "x": {
                    "value": "output_local_update_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.subtract(input_local_update_batch, tf.multiply(output_local_update_batch, local_weights))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_218": {
                "variable": {
                    "value": "delta_local_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "delta_weights_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(neighborhood_coeff_batch, tf.multiply(output_local_update_batch, tf.subtract(input_local_update_batch, tf.multiply(output_local_update_batch, local_weights))))",
                            "Call"
                        ],
                        [
                            "tf.multiply(neighborhood_coeff_batch, tf.multiply(output_local_update_batch, input_local_update_batch))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "reduce_mean_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "''",
                            "str"
                        ],
                        [
                            "[0, 1]",
                            "List"
                        ],
                        [
                            "[0]",
                            "List"
                        ]
                    ]
                }
            },
            "multiply_223": {
                "variable": {
                    "value": "delta_local_weights_op",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "delta_local_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(delta_weights_batch, axis=reduce_mean_axis)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(delta_weights_batch, axis=reduce_mean_axis)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "local_learning_rate",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "multiply_260": {
                "x": {
                    "value": "output_local_update_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "input_local_update_batch",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_mean_266": {
                "variable": {
                    "value": "delta_local_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "delta_weights_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(neighborhood_coeff_batch, tf.multiply(output_local_update_batch, tf.subtract(input_local_update_batch, tf.multiply(output_local_update_batch, local_weights))))",
                            "Call"
                        ],
                        [
                            "tf.multiply(neighborhood_coeff_batch, tf.multiply(output_local_update_batch, input_local_update_batch))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "reduce_mean_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "''",
                            "str"
                        ],
                        [
                            "[0, 1]",
                            "List"
                        ],
                        [
                            "[0]",
                            "List"
                        ]
                    ]
                }
            },
            "multiply_271": {
                "variable": {
                    "value": "delta_local_weights_op",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "delta_local_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(delta_weights_batch, axis=reduce_mean_axis)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(delta_weights_batch, axis=reduce_mean_axis)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "local_learning_rate",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "subtract_312": {
                "variable": {
                    "value": "modified_input_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "input_local_update_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.multiply(input_modification_coeff, tf.reduce_sum(tf.multiply(output_local_update_batch, local_weights), axis=reduce_sum_axis, keepdims=True))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "subtract_368": {
                "variable": {
                    "value": "modified_input_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "input_local_update_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.multiply(input_modification_coeff, tf.reduce_sum(tf.multiply(output_local_update_batch, local_weights), axis=reduce_sum_axis, keepdims=True))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "subtract_424": {
                "variable": {
                    "value": "modified_input_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "input_local_update_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.multiply(input_modification_coeff, tf.cumsum(tf.multiply(output_local_update_batch, local_weights), axis=reduce_sum_axis, exclusive=True))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "subtract_479": {
                "variable": {
                    "value": "modified_input_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "input_local_update_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.multiply(input_modification_coeff, tf.cumsum(output_local_update_batch, axis=reduce_sum_axis, exclusive=True))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_555": {
                "variable": {
                    "value": "delta_local_weights_op",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[m.value, n.value, d.value]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_35": {
                "name_or_scope": {
                    "value": "standardSomLearning",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_82": {
                "name_or_scope": {
                    "value": "convSomLearning",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_124": {
                "name_or_scope": {
                    "value": "statics",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_162": {
                "variable": {
                    "value": "neighborhood_coeff_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "neighborhood_coeff_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.greater_equal(neighborhood_coeff_batch, 1.0))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_float_164": {
                "variable": {
                    "value": "neighborhood_coeff_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.greater_equal(neighborhood_coeff_batch, 1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_165": {
                "variable": {
                    "value": "neighborhood_coeff_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "neighborhood_coeff_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.greater_equal(neighborhood_coeff_batch, 1.0))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_201": {
                "name_or_scope": {
                    "value": "Oja",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_252": {
                "name_or_scope": {
                    "value": "hebb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_301": {
                "name_or_scope": {
                    "value": "proposedLocalLearningHebb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_357": {
                "name_or_scope": {
                    "value": "proposedLocalLearningOja",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_413": {
                "name_or_scope": {
                    "value": "generalizedHebbianElemMul",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_468": {
                "name_or_scope": {
                    "value": "generalizedHebbianElemMulNoWeight",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_519": {
                "name_or_scope": {
                    "value": "noise",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_551": {
                "name_or_scope": {
                    "value": "static",
                    "type": "str",
                    "possible_values": []
                }
            },
            "subtract_51": {
                "x": {
                    "value": "input_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.expand_dims(som_net_weights, axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "multiply_312": {
                "x": {
                    "value": "input_modification_coeff",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.reduce_sum(tf.multiply(output_local_update_batch, local_weights), axis=reduce_sum_axis, keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "multiply_368": {
                "x": {
                    "value": "input_modification_coeff",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.reduce_sum(tf.multiply(output_local_update_batch, local_weights), axis=reduce_sum_axis, keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "multiply_424": {
                "x": {
                    "value": "input_modification_coeff",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.cumsum(tf.multiply(output_local_update_batch, local_weights), axis=reduce_sum_axis, exclusive=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "multiply_479": {
                "x": {
                    "value": "input_modification_coeff",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.cumsum(output_local_update_batch, axis=reduce_sum_axis, exclusive=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_51": {
                "input": {
                    "value": "som_net_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "greater_equal_164": {
                "x": {
                    "value": "neighborhood_coeff_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.greater_equal(neighborhood_coeff_batch, 1.0))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(neighborhood_coeff_batch, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "subtract_212": {
                "x": {
                    "value": "input_local_update_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.multiply(output_local_update_batch, local_weights)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_313": {
                "input_tensor": {
                    "value": "tf.multiply(output_local_update_batch, local_weights)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "reduce_sum_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "''",
                            "str"
                        ],
                        [
                            "3",
                            "int"
                        ],
                        [
                            "2",
                            "int"
                        ]
                    ]
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_369": {
                "input_tensor": {
                    "value": "tf.multiply(output_local_update_batch, local_weights)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "reduce_sum_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "''",
                            "str"
                        ],
                        [
                            "3",
                            "int"
                        ],
                        [
                            "2",
                            "int"
                        ]
                    ]
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cumsum_425": {
                "x": {
                    "value": "tf.multiply(output_local_update_batch, local_weights)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "reduce_sum_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "''",
                            "str"
                        ],
                        [
                            "3",
                            "int"
                        ],
                        [
                            "2",
                            "int"
                        ]
                    ]
                },
                "exclusive": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cumsum_480": {
                "x": {
                    "value": "output_local_update_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "reduce_sum_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "''",
                            "str"
                        ],
                        [
                            "3",
                            "int"
                        ],
                        [
                            "2",
                            "int"
                        ]
                    ]
                },
                "exclusive": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "multiply_212": {
                "x": {
                    "value": "output_local_update_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "local_weights",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "multiply_313": {
                "x": {
                    "value": "output_local_update_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "local_weights",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "multiply_369": {
                "x": {
                    "value": "output_local_update_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "local_weights",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "multiply_425": {
                "x": {
                    "value": "output_local_update_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "local_weights",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "csnnLib/neighborhoodFunctions.py": {
        "tensorflow": {
            "gather_29": {
                "variable": {
                    "value": "bmu_cords_per_map_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "neuron_cords",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.expand_dims(neuron_cords, axis=0), axis=1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "bmu_batch",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "expand_dims_33": {
                "variable": {
                    "value": "bmu_cords_per_map_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "bmu_cords_per_map_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(neuron_cords, bmu_batch)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(bmu_cords_per_map_batch, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_37": {
                "input": {
                    "value": "neuron_cords",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.expand_dims(neuron_cords, axis=0), axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_float_42": {
                "variable": {
                    "value": "bmu_distances_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.subtract(neuron_cords, bmu_cords_per_map_batch)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "norm_46": {
                "variable": {
                    "value": "euclidean_distances_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "bmu_distances_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.subtract(neuron_cords, bmu_cords_per_map_batch))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "negative_47": {
                "variable": {
                    "value": "neg_squard_euclidean_distances_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.square(euclidean_distances_batch)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exp_59": {
                "variable": {
                    "value": "neighborhood_coeff_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.div(neg_squard_euclidean_distances_batch, tf.multiply(2.0, tf.square(std_coeff)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_24": {
                "name_or_scope": {
                    "value": "gaussian",
                    "type": "str",
                    "possible_values": []
                }
            },
            "to_float_51": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.train.get_or_create_global_step()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "subtract_42": {
                "x": {
                    "value": "neuron_cords",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.expand_dims(neuron_cords, axis=0), axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "bmu_cords_per_map_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(neuron_cords, bmu_batch)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(bmu_cords_per_map_batch, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "square_47": {
                "x": {
                    "value": "euclidean_distances_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(bmu_distances_batch, axis=3)",
                            "Call"
                        ]
                    ]
                }
            },
            "div_59": {
                "x": {
                    "value": "neg_squard_euclidean_distances_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.negative(tf.square(euclidean_distances_batch))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.multiply(2.0, tf.square(std_coeff))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_or_create_global_step_51": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "multiply_60": {
                "x": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.square(std_coeff)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "square_60": {
                "x": {
                    "value": "std_coeff",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decayFunctions.decreaseCoeff(std_coeff, 1.0, global_step, training_steps)",
                            "Call"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "csnnLib/optimization.py": {
        "tensorflow": {
            "assign_25": {
                "variable": {
                    "value": "inc_global_step_op",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.get_or_create_global_step()",
                            "Call"
                        ],
                        [
                            "tf.train.get_or_create_global_step()",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "global_step + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "get_collection_52": {
                "variable": {
                    "value": "delta_som_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "deltaSomWeights",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_53": {
                "variable": {
                    "value": "old_som_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "oldSomWeights",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_118": {
                "variable": {
                    "value": "delta_local_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "deltaLocalWeights",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_119": {
                "variable": {
                    "value": "old_local_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "oldLocalWeights",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_170": {
                "variable": {
                    "value": "delta_new_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "delta_new_batch_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_173": {
                "variable": {
                    "value": "new_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "som_net_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "delta_new_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(delta_new_batch_weights, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(delta_new_local_weights, axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "assign_179": {
                "variable": {
                    "value": "apply_weights_op",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "som_net_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "new_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add(som_net_weights, delta_new_weights)",
                            "Call"
                        ],
                        [
                            "tf.div_no_nan(new_weights, tf.norm(new_weights, axis=2, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.add(local_weights, delta_new_weights)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_197": {
                "variable": {
                    "value": "delta_new_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "delta_new_local_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_200": {
                "variable": {
                    "value": "new_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "local_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "delta_new_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(delta_new_batch_weights, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(delta_new_local_weights, axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "assign_203": {
                "variable": {
                    "value": "apply_local_weights_op",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "local_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "new_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add(som_net_weights, delta_new_weights)",
                            "Call"
                        ],
                        [
                            "tf.div_no_nan(new_weights, tf.norm(new_weights, axis=2, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.add(local_weights, delta_new_weights)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_20": {
                "name_or_scope": {
                    "value": "OptimizeCsnn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_28": {
                "key": {
                    "value": "deltaLocalWeights",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_45": {
                "name_or_scope": {
                    "value": "OptimizeSomWeights",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_48": {
                "variable": {
                    "value": "distance_measures",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "sum_distance_measure",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_49": {
                "variable": {
                    "value": "neuron_utilization",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "neuronUtilization",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_or_create_global_step_94": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cond_95": {
                "variable": {
                    "value": "operation",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.logical_and(tf.greater_equal(tf.cast(global_step, tf.int32), tf.cast(layer_train_intervals[i][0], tf.int32)), tf.less(tf.cast(global_step, tf.int32), tf.cast(layer_train_intervals[i][1], tf.int32)))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "train",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "infer",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "variable_scope_116": {
                "name_or_scope": {
                    "value": "OptimizeLocalWeights",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_or_create_global_step_145": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cond_146": {
                "variable": {
                    "value": "operation",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.logical_and(tf.greater_equal(tf.cast(global_step, tf.int32), tf.cast(layer_train_intervals[i][0], tf.int32)), tf.less(tf.cast(global_step, tf.int32), tf.cast(layer_train_intervals[i][1], tf.int32)))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "train",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "infer",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "variable_scope_166": {
                "name_or_scope": {
                    "value": "applyStandardSomLearning",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_193": {
                "name_or_scope": {
                    "value": "applyLocalLearning",
                    "type": "str",
                    "possible_values": []
                }
            },
            "norm_176": {
                "tensor": {
                    "value": "new_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add(som_net_weights, delta_new_weights)",
                            "Call"
                        ],
                        [
                            "tf.div_no_nan(new_weights, tf.norm(new_weights, axis=2, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.add(local_weights, delta_new_weights)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "scalar_77": {
                "name": {
                    "value": "'MeanWeightChangeLayer' + str(i)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_mean(gpu_delta_weights)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "histogram_78": {
                "name": {
                    "value": "'SomWeightsLayer' + str(i)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "old_som_weights[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "logical_and_96": {
                "x": {
                    "value": "tf.greater_equal(tf.cast(global_step, tf.int32), tf.cast(layer_train_intervals[i][0], tf.int32))",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.less(tf.cast(global_step, tf.int32), tf.cast(layer_train_intervals[i][1], tf.int32))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_134": {
                "name": {
                    "value": "'MeanLocalWeightChangeLayer' + str(i)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_mean(gpu_delta_local_weights)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "histogram_135": {
                "name": {
                    "value": "'LocalWeightsLayer' + str(i)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "old_local_weights[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "logical_and_147": {
                "x": {
                    "value": "tf.greater_equal(tf.cast(global_step, tf.int32), tf.cast(layer_train_intervals[i][0], tf.int32))",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.less(tf.cast(global_step, tf.int32), tf.cast(layer_train_intervals[i][1], tf.int32))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_77": {
                "input_tensor": {
                    "value": "gpu_delta_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "scalar_81": {
                "name": {
                    "value": "'DistanceMeasure' + str(i)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_mean(gpu_distance_measures)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_83": {
                "name": {
                    "value": "'NeuronUtilization' + str(i)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_mean(gpu_neuron_utilization)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "greater_equal_97": {
                "x": {
                    "value": "tf.cast(global_step, tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(layer_train_intervals[i][0], tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "less_98": {
                "x": {
                    "value": "tf.cast(global_step, tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(layer_train_intervals[i][1], tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_134": {
                "input_tensor": {
                    "value": "gpu_delta_local_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "greater_equal_147": {
                "x": {
                    "value": "tf.cast(global_step, tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(layer_train_intervals[i][0], tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "less_148": {
                "x": {
                    "value": "tf.cast(global_step, tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(layer_train_intervals[i][1], tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_81": {
                "input_tensor": {
                    "value": "gpu_distance_measures",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "reduce_mean_83": {
                "input_tensor": {
                    "value": "gpu_neuron_utilization",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "cast_97": {
                "x": {
                    "value": "layer_train_intervals[i][0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_98": {
                "x": {
                    "value": "layer_train_intervals[i][1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_147": {
                "x": {
                    "value": "layer_train_intervals[i][0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_148": {
                "x": {
                    "value": "layer_train_intervals[i][1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "csnnLib/visualisation.py": {
        "tensorflow": {
            "reshape_107": {
                "variable": {
                    "value": "weight_patches",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[som_grid_height, som_grid_width, kernel_height, kernel_width, input_depth]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_113": {
                "variable": {
                    "value": "weight_patches",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "weight_patches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(weights, [som_grid_height, som_grid_width, kernel_height, kernel_width, input_depth])",
                            "Call"
                        ],
                        [
                            "tf.transpose(weight_patches, [0, 2, 1, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(weight_patches, [1, som_grid_height * kernel_height, som_grid_width * kernel_width, input_depth])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1, 3, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_119": {
                "variable": {
                    "value": "weight_patches",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "weight_patches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(weights, [som_grid_height, som_grid_width, kernel_height, kernel_width, input_depth])",
                            "Call"
                        ],
                        [
                            "tf.transpose(weight_patches, [0, 2, 1, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(weight_patches, [1, som_grid_height * kernel_height, som_grid_width * kernel_width, input_depth])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, som_grid_height * kernel_height, som_grid_width * kernel_width, input_depth]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_185": {
                "variable": {
                    "value": "weigths_for_bmus",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.reshape(bmus, [-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_186": {
                "variable": {
                    "value": "weigths_for_bmus",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "weigths_for_bmus",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(weights, tf.reshape(bmus, [-1]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.transpose(weigths_for_bmus, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.reshape(weigths_for_bmus, [-1, num_conv_patches_h, num_conv_patches_w, grid[2], som_kernel[0], som_kernel[1], som_vec_size.value // (som_kernel[0] * som_kernel[1])])",
                            "Call"
                        ],
                        [
                            "tf.transpose(weigths_for_bmus, [0, 3, 1, 4, 2, 5, 6])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_194": {
                "variable": {
                    "value": "weigths_for_bmus",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "weigths_for_bmus",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(weights, tf.reshape(bmus, [-1]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.transpose(weigths_for_bmus, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.reshape(weigths_for_bmus, [-1, num_conv_patches_h, num_conv_patches_w, grid[2], som_kernel[0], som_kernel[1], som_vec_size.value // (som_kernel[0] * som_kernel[1])])",
                            "Call"
                        ],
                        [
                            "tf.transpose(weigths_for_bmus, [0, 3, 1, 4, 2, 5, 6])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, num_conv_patches_h, num_conv_patches_w, grid[2], som_kernel[0], som_kernel[1], som_vec_size.value // (som_kernel[0] * som_kernel[1])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_202": {
                "variable": {
                    "value": "weigths_for_bmus",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "weigths_for_bmus",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(weights, tf.reshape(bmus, [-1]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.transpose(weigths_for_bmus, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.reshape(weigths_for_bmus, [-1, num_conv_patches_h, num_conv_patches_w, grid[2], som_kernel[0], som_kernel[1], som_vec_size.value // (som_kernel[0] * som_kernel[1])])",
                            "Call"
                        ],
                        [
                            "tf.transpose(weigths_for_bmus, [0, 3, 1, 4, 2, 5, 6])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 3, 1, 4, 2, 5, 6]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_209": {
                "variable": {
                    "value": "weigths_block",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "weigths_for_bmus",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(weights, tf.reshape(bmus, [-1]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.transpose(weigths_for_bmus, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.reshape(weigths_for_bmus, [-1, num_conv_patches_h, num_conv_patches_w, grid[2], som_kernel[0], som_kernel[1], som_vec_size.value // (som_kernel[0] * som_kernel[1])])",
                            "Call"
                        ],
                        [
                            "tf.transpose(weigths_for_bmus, [0, 3, 1, 4, 2, 5, 6])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, grid[2], num_conv_patches_h * som_kernel[0], num_conv_patches_w * som_kernel[1], som_vec_size.value // (som_kernel[0] * som_kernel[1])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_257": {
                "variable": {
                    "value": "map",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "local_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "indices[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_263": {
                "variable": {
                    "value": "neuron",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(maps, map_index, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(map, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.gather(local_weights, indices[0], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(neuron, map_index, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_268": {
                "variable": {
                    "value": "neuron",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "neuron",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(map, indices[1], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(neuron, [prev_grid[2], prev_grid[0], prev_grid[1], -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[prev_grid[2], prev_grid[0], prev_grid[1], -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_28": {
                "variable": {
                    "value": "channel",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "block",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "indices",
                            "variable"
                        ],
                        [
                            "__expandIndexForRgbVis(index)",
                            "Call"
                        ],
                        [
                            "[index]",
                            "List"
                        ],
                        [
                            "indices",
                            "variable"
                        ],
                        [
                            "input_channel_indices",
                            "variable"
                        ],
                        [
                            "__expandIndexForRgbVis(index)",
                            "Call"
                        ],
                        [
                            "[index]",
                            "List"
                        ],
                        [
                            "input_channel_indices",
                            "variable"
                        ],
                        [
                            "__expandIndexForRgbVis(index)",
                            "Call"
                        ],
                        [
                            "[index]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_50": {
                "variable": {
                    "value": "maps",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "block",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "index[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_56": {
                "variable": {
                    "value": "maps",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "maps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(block, index[0], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.gather(maps, index[1], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(maps, [-1, grid[2], grid[0], grid[1]])",
                            "Call"
                        ],
                        [
                            "neighborhood_coeff_batch.get_shape()[1].value",
                            "Attribute"
                        ]
                    ]
                },
                "indices": {
                    "value": "index[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_61": {
                "variable": {
                    "value": "maps",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "maps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(block, index[0], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.gather(maps, index[1], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(maps, [-1, grid[2], grid[0], grid[1]])",
                            "Call"
                        ],
                        [
                            "neighborhood_coeff_batch.get_shape()[1].value",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, grid[2], grid[0], grid[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_135": {
                "variable": {
                    "value": "weight_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "weight_patches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(weights, [som_grid_height, som_grid_width, kernel_height, kernel_width, input_depth])",
                            "Call"
                        ],
                        [
                            "tf.transpose(weight_patches, [0, 2, 1, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(weight_patches, [1, som_grid_height * kernel_height, som_grid_width * kernel_width, input_depth])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "indices",
                            "variable"
                        ],
                        [
                            "__expandIndexForRgbVis(index)",
                            "Call"
                        ],
                        [
                            "[index]",
                            "List"
                        ],
                        [
                            "indices",
                            "variable"
                        ],
                        [
                            "input_channel_indices",
                            "variable"
                        ],
                        [
                            "__expandIndexForRgbVis(index)",
                            "Call"
                        ],
                        [
                            "[index]",
                            "List"
                        ],
                        [
                            "input_channel_indices",
                            "variable"
                        ],
                        [
                            "__expandIndexForRgbVis(index)",
                            "Call"
                        ],
                        [
                            "[index]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_169": {
                "variable": {
                    "value": "max_map_index_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reduce_max(distances_batch, axis=2)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_174": {
                "variable": {
                    "value": "mask_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "max_map_index_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(tf.reduce_max(distances_batch, axis=2), axis=1)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "maps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(block, index[0], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.gather(maps, index[1], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(maps, [-1, grid[2], grid[0], grid[1]])",
                            "Call"
                        ],
                        [
                            "neighborhood_coeff_batch.get_shape()[1].value",
                            "Attribute"
                        ]
                    ]
                }
            },
            "multiply_179": {
                "variable": {
                    "value": "bmus",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "bmus",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(bmus, mask_batch)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "mask_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(max_map_index_batch, maps)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_214": {
                "variable": {
                    "value": "weigths_map_block",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "weigths_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(weigths_for_bmus, [-1, grid[2], num_conv_patches_h * som_kernel[0], num_conv_patches_w * som_kernel[1], som_vec_size.value // (som_kernel[0] * som_kernel[1])])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_221": {
                "variable": {
                    "value": "weigths_map_block",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "weigths_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(weigths_for_bmus, [-1, grid[2], num_conv_patches_h * som_kernel[0], num_conv_patches_w * som_kernel[1], som_vec_size.value // (som_kernel[0] * som_kernel[1])])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "map_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(grid[2])",
                            "Call"
                        ],
                        [
                            "range(prev_grid[2])",
                            "Call"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_236": {
                "variable": {
                    "value": "weight_img_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "weigths_map_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(weigths_block, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.gather(weigths_block, map_index, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "indices",
                            "variable"
                        ],
                        [
                            "__expandIndexForRgbVis(index)",
                            "Call"
                        ],
                        [
                            "[index]",
                            "List"
                        ],
                        [
                            "indices",
                            "variable"
                        ],
                        [
                            "input_channel_indices",
                            "variable"
                        ],
                        [
                            "__expandIndexForRgbVis(index)",
                            "Call"
                        ],
                        [
                            "[index]",
                            "List"
                        ],
                        [
                            "input_channel_indices",
                            "variable"
                        ],
                        [
                            "__expandIndexForRgbVis(index)",
                            "Call"
                        ],
                        [
                            "[index]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_276": {
                "variable": {
                    "value": "map",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "neuron",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(map, indices[1], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(neuron, [prev_grid[2], prev_grid[0], prev_grid[1], -1])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "map_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(grid[2])",
                            "Call"
                        ],
                        [
                            "range(prev_grid[2])",
                            "Call"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_31": {
                "name": {
                    "value": "str(name_prefix) + 'Channel' + str(index)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "channel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(block, index, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "max_outputs": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_69": {
                "variable": {
                    "value": "map",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "maps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(block, index[0], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.gather(maps, index[1], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(maps, [-1, grid[2], grid[0], grid[1]])",
                            "Call"
                        ],
                        [
                            "neighborhood_coeff_batch.get_shape()[1].value",
                            "Attribute"
                        ]
                    ]
                },
                "indices": {
                    "value": "map_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(grid[2])",
                            "Call"
                        ],
                        [
                            "range(prev_grid[2])",
                            "Call"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_74": {
                "variable": {
                    "value": "map",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(maps, map_index, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(map, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.gather(local_weights, indices[0], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(neuron, map_index, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_138": {
                "name": {
                    "value": "'WeightGridForChannel' + str(index)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "weight_channel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(weight_patches, index, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "max_outputs": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_185": {
                "tensor": {
                    "value": "bmus",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(bmus, mask_batch)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "image_239": {
                "name": {
                    "value": "'WeightImgForMap' + str(map_index) + 'Channel' + str(index)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "weight_img_channel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(weigths_map_block, index, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "max_outputs": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_77": {
                "name": {
                    "value": "str(name_prefix) + 'Act' + str(index) + 'Map' + str(map_index)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(maps, map_index, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(map, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.gather(local_weights, indices[0], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(neuron, map_index, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "max_outputs": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_169": {
                "input_tensor": {
                    "value": "distances_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_279": {
                "name": {
                    "value": "str(name_prefix) + 'Map' + str(indices[0]) + 'Neuron' + str(indices[1]) + 'PrevMap' + str(map_index)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.expand_dims(map, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "max_outputs": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_288": {
                "variable": {
                    "value": "map_part",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(maps, map_index, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(map, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.gather(local_weights, indices[0], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(neuron, map_index, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "map_part_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(kernel_depth.value)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_293": {
                "input": {
                    "value": "map_part",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(map, map_part_index, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(map_part, axis=0), axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_280": {
                "input": {
                    "value": "map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(maps, map_index, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(map, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.gather(local_weights, indices[0], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(neuron, map_index, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_296": {
                "name": {
                    "value": "str(name_prefix) + 'Map' + str(indices[0]) + 'Neuron' + str(indices[1]) + 'PrevMap' + str(map_index)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "map_part",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(map, map_part_index, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(map_part, axis=0), axis=3)",
                            "Call"
                        ]
                    ]
                },
                "max_outputs": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    }
}