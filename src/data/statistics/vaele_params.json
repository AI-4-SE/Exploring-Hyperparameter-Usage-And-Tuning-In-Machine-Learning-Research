{
    "utils/inducing_points.py": {
        "sklearn": {
            "KMeans_41": {
                "variable": {
                    "value": "km",
                    "type": "variable",
                    "possible_values": []
                },
                "n_clusters": {
                    "value": "nb_pseudo_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "init": {
                    "value": "random",
                    "type": "str",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {}
    },
    "utils/mutual_information.py": {
        "sklearn": {
            "mutual_info_score_20": {
                "variable": {
                    "value": "mi",
                    "type": "variable",
                    "possible_values": []
                },
                "labels_true": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "labels_pred": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "contingency": {
                    "value": "c_xy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.histogram2d(x, y, nbins)[0]",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "utils/plot_utils.py": {
        "sklearn": {},
        "tensorflow": {
            "exp_386": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "log_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "log_weights[:, 0, :]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reshape_402": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "samples[0, 0, ...]",
                            "Subscript"
                        ],
                        [
                            "samples[0]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1, samples.shape[-1])",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_404": {
                "variable": {
                    "value": "predicted_mean",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x + fx",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "samples.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_405": {
                "variable": {
                    "value": "fxs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "fx",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "samples.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_406": {
                "variable": {
                    "value": "predicted_scale",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.sqrt(var_fx)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "samples.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "transpose_389": {
                "a": {
                    "value": "ss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoded_scales[0, ...]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "transpose_390": {
                "a": {
                    "value": "particles",
                    "type": "variable",
                    "possible_values": [
                        [
                            "particles[:, 0, ...]",
                            "Subscript"
                        ]
                    ]
                },
                "perm": {
                    "value": "[2, 0, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sqrt_406": {
                "x": {
                    "value": "var_fx",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_min_304": {
                "input_tensor": {
                    "value": "synthetic_samples",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_max_304": {
                "input_tensor": {
                    "value": "synthetic_samples",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "MessagePassingAlgorithm.py": {
        "tensorflow": {
            "stack_48": {
                "variable": {
                    "value": "Kmms",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[k.K(iv_values) for k in self.sde.kernel.kernels]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "map_fn_52": {
                "variable": {
                    "value": "inv_Kmms",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "tf.linalg.inv",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "Kmms",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([k.K(iv_values) for k in self.sde.kernel.kernels], axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "map_fn_53": {
                "variable": {
                    "value": "chol_Kmms",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "tf.linalg.cholesky",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "Kmms",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([k.K(iv_values) for k in self.sde.kernel.kernels], axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_55": {
                "variable": {
                    "value": "variances",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[rbf_kernel.variance for rbf_kernel in self.sde.kernel.kernels]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "stack_57": {
                "variable": {
                    "value": "Lambdas",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.linalg.diag(tf.reshape(rbf_kernel.lengthscales ** 2, (-1,))) for rbf_kernel in self.sde.kernel.kernels]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "stack_61": {
                "variable": {
                    "value": "inv_Lambdas",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.linalg.diag(1 / tf.reshape(rbf_kernel.lengthscales ** 2, (-1,))) for rbf_kernel in self.sde.kernel.kernels]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "gather_nd_75": {
                "variable": {
                    "value": "Q_aij",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "Q_abij",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._compute_filtering_Q(mean_tm1, cov_tm1, sqe_terms)",
                            "Call"
                        ],
                        [
                            "tf.exp(n2_abij) / sqrt_det_R_ab",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "[[i, i] for i in range(Q_abij.shape[0])]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "map_fn_88": {
                "variable": {
                    "value": "det_term",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda x: 1 / tf.sqrt(tf.linalg.det(x))",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "tf.einsum('ij,ajk->aik', cov_tm1, sqe_terms.inv_Lambdas) + tf.expand_dims(tf.eye(self.sde.dimension, dtype=tf_floatx()), 0)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_95": {
                "variable": {
                    "value": "det_term",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "det_term",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(lambda x: 1 / tf.sqrt(tf.linalg.det(x)), tf.einsum('ij,ajk->aik', cov_tm1, sqe_terms.inv_Lambdas) + tf.expand_dims(tf.eye(self.sde.dimension, dtype=tf_floatx()), 0))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(det_term, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_97": {
                "variable": {
                    "value": "exp_term",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "-0.5 * tf.reduce_sum(tf.tensordot(zeta, tf.linalg.inv(cov_tm1 + sqe_terms.Lambdas), [[1], [1]]) * tf.expand_dims(zeta, 1), axis=2)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "map_fn_111": {
                "variable": {
                    "value": "det_R_ab",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda x: tf.map_fn(tf.linalg.det, x)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "R_ab",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('ij,abjk->abik', cov_tm1, tf.expand_dims(sqe_terms.inv_Lambdas, 0) + tf.expand_dims(sqe_terms.inv_Lambdas, 1)) + tf.expand_dims(tf.expand_dims(tf.eye(self.sde.dimension, dtype=tf_floatx()), 0), 0)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "map_fn_115": {
                "variable": {
                    "value": "inv_R_ab",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda x: tf.map_fn(tf.linalg.inv, x)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "R_ab",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('ij,abjk->abik', cov_tm1, tf.expand_dims(sqe_terms.inv_Lambdas, 0) + tf.expand_dims(sqe_terms.inv_Lambdas, 1)) + tf.expand_dims(tf.expand_dims(tf.eye(self.sde.dimension, dtype=tf_floatx()), 0), 0)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "einsum_120": {
                "variable": {
                    "value": "zeta_lambda",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "axy,iy->aix",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "sqe_terms.inv_Lambdas",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "zeta_i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sde.iv_values() - mean_tm1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "transpose_125": {
                "variable": {
                    "value": "n_tmp",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.reduce_sum(tf.tensordot(zeta_i, sqe_terms.inv_Lambdas, [[1], [1]]) * tf.expand_dims(zeta_i, 1), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_131": {
                "variable": {
                    "value": "log_variances",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "sqe_terms.variances",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "diag_154": {
                "variable": {
                    "value": "diag_terms",
                    "type": "variable",
                    "possible_values": []
                },
                "diagonal": {
                    "value": "self.sde.diffusion.expected_diffusion()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "einsum_185": {
                "variable": {
                    "value": "trace_term",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "aij,aji->a",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "matrix_term",
                    "type": "variable",
                    "possible_values": [
                        [
                            "filtering_terms.inv_Kmms - tf.einsum('aij,akj->aik', aux_term, aux_term)",
                            "BinOp"
                        ],
                        [
                            "tf.einsum('aij,ajk->aik', expanded_cov_tm1, tf.map_fn(tf.linalg.inv, filtering_terms.Lambdas + expanded_cov_tm1), name='compute_cov_mf_x_given_tm1_einsum')",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "filtering_terms.Q_aij",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "E_cov_fa_fa_einsum",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tile_189": {
                "variable": {
                    "value": "expanded_cov_tm1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "cov_tm1[tf.newaxis, ...]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[self.sde.dimension, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "einsum_190": {
                "variable": {
                    "value": "matrix_term",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "aij,ajk->aik",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "expanded_cov_tm1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(cov_tm1[tf.newaxis, ...], [self.sde.dimension, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "tf.map_fn(tf.linalg.inv, filtering_terms.Lambdas + expanded_cov_tm1)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "compute_cov_mf_x_given_tm1_einsum",
                    "type": "str",
                    "possible_values": []
                }
            },
            "map_fn_226": {
                "variable": {
                    "value": "(means_t_given_tm1, covs_t_t_given_tm1, precs_t_t_given_tm1, covs_t_tm1_given_tm1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda x: self.predict_xt_given_tm1(mean_tm1=x[0], cov_tm1=x[1])",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "(expanded_means_tm1, covs_tm1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "(tf_floatx(), tf_floatx(), tf_floatx(), tf_floatx())",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "forward_predict_map",
                    "type": "str",
                    "possible_values": []
                }
            },
            "squeeze_238": {
                "variable": {
                    "value": "means_t_given_tm1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "means_t_given_tm1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(means_t_given_tm1, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "map_fn_254": {
                "variable": {
                    "value": "encoding_precs",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "tf.linalg.inv",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "encoding_covs",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "encoding_precisions",
                    "type": "str",
                    "possible_values": []
                }
            },
            "transpose_261": {
                "variable": {
                    "value": "temporal_encoding_means",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "encoding_means",
                    "type": "variable",
                    "possible_values": []
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_262": {
                "variable": {
                    "value": "temporal_encoding_precs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "encoding_precs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(tf.linalg.inv, encoding_covs, name='encoding_precisions')",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "scan_264": {
                "variable": {
                    "value": "(filtered_distributions, predicted_distributions, conditional_covs)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "fn": {
                    "value": "self._forward_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "[temporal_encoding_means[1:, ...], temporal_encoding_precs[1:, ...]]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "((messages_mean_t0, messages_cov_t0, messages_prec_t0), (tf.zeros_like(messages_mean_t0), tf.zeros_like(messages_cov_t0), tf.zeros_like(messages_prec_t0)), tf.zeros_like(messages_cov_t0))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "forwards_messages_scan",
                    "type": "str",
                    "possible_values": []
                }
            },
            "repeat_302": {
                "variable": {
                    "value": "last_sampling_mean",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "filtered_means[-1:, ...]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "repeats": {
                    "value": "self.nb_samples",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "scan_371": {
                "variable": {
                    "value": "(samples, acc_entropies, sampling_means, sampling_covs)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "fn": {
                    "value": "backwards_step",
                    "type": "variable",
                    "possible_values": []
                },
                "elems": {
                    "value": "(filtered_means[:-1, ...], filtered_covs[:-1, ...], predicted_means, predicted_precs, conditional_covs)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "(last_samples, last_entropy, last_sampling_mean, last_sampling_cov)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "reverse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "transpose_386": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.concat([samples, last_samples[tf.newaxis, ...]], axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "perm": {
                    "value": "[1, 2, 0, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_387": {
                "variable": {
                    "value": "sampling_means",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.concat([sampling_means, last_sampling_mean[tf.newaxis, ...]], axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "perm": {
                    "value": "[1, 2, 0, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_389": {
                "variable": {
                    "value": "sampling_covs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.concat([sampling_covs, last_sampling_cov[tf.newaxis, ...]], axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "perm": {
                    "value": "[1, 0, 2, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "triangular_solve_67": {
                "variable": {
                    "value": "betas",
                    "type": "variable",
                    "possible_values": []
                },
                "matrix": {
                    "value": "tf.linalg.adjoint(chol_Kmms)",
                    "type": "Call",
                    "possible_values": []
                },
                "rhs": {
                    "value": "tf.transpose(self.sde.drift_svgp.q_mu)[..., tf.newaxis]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "lower": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "squeeze_70": {
                "variable": {
                    "value": "betas",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "betas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linalg.triangular_solve(tf.linalg.adjoint(chol_Kmms), tf.transpose(self.sde.drift_svgp.q_mu)[..., tf.newaxis], lower=False)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(betas, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.einsum('aij,ja->ai', inv_Kmms, self.sde.drift_svgp.q_mu)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "einsum_72": {
                "variable": {
                    "value": "betas",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "aij,ja->ai",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "inv_Kmms",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(tf.linalg.inv, Kmms)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "self.sde.drift_svgp.q_mu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_148": {
                "input_tensor": {
                    "value": "filtering_terms.betas * filtering_terms.gammas",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "triangular_solve_171": {
                "variable": {
                    "value": "aux_term",
                    "type": "variable",
                    "possible_values": []
                },
                "matrix": {
                    "value": "tf.linalg.adjoint(filtering_terms.chol_Kmms)",
                    "type": "Call",
                    "possible_values": []
                },
                "rhs": {
                    "value": "self.sde.drift_svgp.q_sqrt",
                    "type": "Attribute",
                    "possible_values": []
                },
                "lower": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "triangular_solve_177": {
                "variable": {
                    "value": "aux_term",
                    "type": "variable",
                    "possible_values": []
                },
                "matrix": {
                    "value": "tf.linalg.adjoint(filtering_terms.chol_Kmms)",
                    "type": "Call",
                    "possible_values": []
                },
                "rhs": {
                    "value": "tf.linalg.triangular_solve(filtering_terms.chol_Kmms, self.sde.drift_svgp.q_sqrt, lower=True)",
                    "type": "Call",
                    "possible_values": []
                },
                "lower": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_195": {
                "input_tensor": {
                    "value": "filtering_terms.betas[..., tf.newaxis] * filtering_terms.gammas[..., tf.newaxis] * tf.einsum('axy,iy->aix', matrix_term, self.sde.iv_values() - mean_tm1)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "einsum_203": {
                "equation": {
                    "value": "ai,abi->ab",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "filtering_terms.betas",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "tf.einsum('abij,bj->abi', filtering_terms.Q_abij, filtering_terms.betas)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "einsum_325": {
                "variable": {
                    "value": "J_t",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "bij,bjk->bik",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "predicted_prec_tp1",
                    "type": "variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "conditional_tp1_t_gt",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "name_scope_33": {
                "name": {
                    "value": "predict/aux/",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_36": {
                "name": {
                    "value": "predit/stats",
                    "type": "str",
                    "possible_values": []
                }
            },
            "inv_43": {
                "input": {
                    "value": "cov_t_t_given_tm1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cov_tm1 + cov_mf_mf + cov_mf_x + tf.transpose(cov_mf_x) + diag_terms",
                            "BinOp"
                        ]
                    ]
                }
            },
            "transpose_102": {
                "a": {
                    "value": "exp_term",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(-0.5 * tf.reduce_sum(tf.tensordot(zeta, tf.linalg.inv(cov_tm1 + sqe_terms.Lambdas), [[1], [1]]) * tf.expand_dims(zeta, 1), axis=2))",
                            "Call"
                        ]
                    ]
                }
            },
            "einsum_107": {
                "equation": {
                    "value": "ij,abjk->abik",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "cov_tm1",
                    "type": "variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "tf.expand_dims(sqe_terms.inv_Lambdas, 0) + tf.expand_dims(sqe_terms.inv_Lambdas, 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_109": {
                "input": {
                    "value": "tf.eye(self.sde.dimension, dtype=tf_floatx())",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_122": {
                "input": {
                    "value": "zeta_lambda",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('axy,iy->aix', sqe_terms.inv_Lambdas, zeta_i)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_123": {
                "input": {
                    "value": "zeta_lambda",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('axy,iy->aix', sqe_terms.inv_Lambdas, zeta_i)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_126": {
                "input_tensor": {
                    "value": "tf.tensordot(zeta_i, sqe_terms.inv_Lambdas, [[1], [1]]) * tf.expand_dims(zeta_i, 1)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_133": {
                "input": {
                    "value": "log_variances + tf.transpose(log_variances)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "sqrt_143": {
                "x": {
                    "value": "det_R_ab",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(lambda x: tf.map_fn(tf.linalg.det, x), R_ab)",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_144": {
                "x": {
                    "value": "n2_abij",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.expand_dims(log_variances + tf.transpose(log_variances), -1), -1) + -0.5 * (tf.expand_dims(tf.expand_dims(n_tmp, 1), 3) + tf.expand_dims(tf.expand_dims(n_tmp, 0), 2) - tf.reduce_sum(tf.einsum('abxy,yabij->abijx', inv_R_ab, tf.tensordot(cov_tm1, z_abij, [[-1], [-1]]), name='Q_einsum') * z_abij, axis=-1))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "einsum_165": {
                "equation": {
                    "value": "i,j->ij",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "E_mf_given_tm1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._compute_E_mf_given_tm1(filtering_terms)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "E_mf_given_tm1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._compute_E_mf_given_tm1(filtering_terms)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "cov_mf_mf_einsum",
                    "type": "str",
                    "possible_values": []
                }
            },
            "einsum_184": {
                "equation": {
                    "value": "aij,akj->aik",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "aux_term",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linalg.triangular_solve(tf.linalg.adjoint(filtering_terms.chol_Kmms), self.sde.drift_svgp.q_sqrt, lower=False)",
                            "Call"
                        ],
                        [
                            "tf.linalg.triangular_solve(tf.linalg.adjoint(filtering_terms.chol_Kmms), tf.linalg.triangular_solve(filtering_terms.chol_Kmms, self.sde.drift_svgp.q_sqrt, lower=True), lower=False)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "aux_term",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linalg.triangular_solve(tf.linalg.adjoint(filtering_terms.chol_Kmms), self.sde.drift_svgp.q_sqrt, lower=False)",
                            "Call"
                        ],
                        [
                            "tf.linalg.triangular_solve(tf.linalg.adjoint(filtering_terms.chol_Kmms), tf.linalg.triangular_solve(filtering_terms.chol_Kmms, self.sde.drift_svgp.q_sqrt, lower=True), lower=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_186": {
                "tensor": {
                    "value": "filtering_terms.variances",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "map_fn_191": {
                "fn": {
                    "value": "tf.linalg.inv",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "filtering_terms.Lambdas + expanded_cov_tm1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "einsum_206": {
                "equation": {
                    "value": "abij,bj->abi",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "filtering_terms.Q_abij",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "filtering_terms.betas",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_386": {
                "values": {
                    "value": "[samples, last_samples[tf.newaxis, ...]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_387": {
                "values": {
                    "value": "[sampling_means, last_sampling_mean[tf.newaxis, ...]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_389": {
                "values": {
                    "value": "[sampling_covs, last_sampling_cov[tf.newaxis, ...]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "diag_59": {
                "diagonal": {
                    "value": "tf.reshape(rbf_kernel.lengthscales ** 2, (-1,))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "diag_61": {
                "diagonal": {
                    "value": "1 / tf.reshape(rbf_kernel.lengthscales ** 2, (-1,))",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "adjoint_67": {
                "matrix": {
                    "value": "chol_Kmms",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(tf.linalg.cholesky, Kmms)",
                            "Call"
                        ]
                    ]
                }
            },
            "einsum_91": {
                "equation": {
                    "value": "ij,ajk->aik",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "cov_tm1",
                    "type": "variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "sqe_terms.inv_Lambdas",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_92": {
                "input": {
                    "value": "tf.eye(self.sde.dimension, dtype=tf_floatx())",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_97": {
                "input_tensor": {
                    "value": "tf.tensordot(zeta, tf.linalg.inv(cov_tm1 + sqe_terms.Lambdas), [[1], [1]]) * tf.expand_dims(zeta, 1)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "map_fn_112": {
                "fn": {
                    "value": "tf.linalg.det",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "map_fn_116": {
                "fn": {
                    "value": "tf.linalg.inv",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "transpose_158": {
                "a": {
                    "value": "cov_mf_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._compute_cov_mf_x_given_tm1(mean_tm1, cov_tm1, filtering_terms)",
                            "Call"
                        ]
                    ]
                }
            },
            "adjoint_172": {
                "matrix": {
                    "value": "filtering_terms.chol_Kmms",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "adjoint_178": {
                "matrix": {
                    "value": "filtering_terms.chol_Kmms",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "triangular_solve_179": {
                "matrix": {
                    "value": "filtering_terms.chol_Kmms",
                    "type": "Attribute",
                    "possible_values": []
                },
                "rhs": {
                    "value": "self.sde.drift_svgp.q_sqrt",
                    "type": "Attribute",
                    "possible_values": []
                },
                "lower": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "einsum_198": {
                "equation": {
                    "value": "axy,iy->aix",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "matrix_term",
                    "type": "variable",
                    "possible_values": [
                        [
                            "filtering_terms.inv_Kmms - tf.einsum('aij,akj->aik', aux_term, aux_term)",
                            "BinOp"
                        ],
                        [
                            "tf.einsum('aij,ajk->aik', expanded_cov_tm1, tf.map_fn(tf.linalg.inv, filtering_terms.Lambdas + expanded_cov_tm1), name='compute_cov_mf_x_given_tm1_einsum')",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "self.sde.iv_values() - mean_tm1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_282": {
                "values": {
                    "value": "[tf.expand_dims(messages_mean_t0, 0), filtered_distributions[0]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_283": {
                "values": {
                    "value": "[tf.expand_dims(messages_cov_t0, 0), filtered_distributions[1]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_284": {
                "values": {
                    "value": "[tf.expand_dims(messages_prec_t0, 0), filtered_distributions[2]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "einsum_329": {
                "equation": {
                    "value": "sbi,bij->sbj",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "samples_tp1 - predicted_mean_tp1[tf.newaxis, ...]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "J_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('bij,bjk->bik', predicted_prec_tp1, conditional_tp1_t_gt)",
                            "Call"
                        ]
                    ]
                }
            },
            "einsum_331": {
                "equation": {
                    "value": "bji,bjk->bik",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "J_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('bij,bjk->bik', predicted_prec_tp1, conditional_tp1_t_gt)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "conditional_tp1_t_gt",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reshape_59": {
                "tensor": {
                    "value": "rbf_kernel.lengthscales ** 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "transpose_68": {
                "a": {
                    "value": "self.sde.drift_svgp.q_mu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sqrt_89": {
                "x": {
                    "value": "tf.linalg.det(x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "eye_92": {
                "num_rows": {
                    "value": "self.sde.dimension",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_108": {
                "input": {
                    "value": "sqe_terms.inv_Lambdas",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "eye_109": {
                "num_rows": {
                    "value": "self.sde.dimension",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tensordot_127": {
                "a": {
                    "value": "zeta_i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sde.iv_values() - mean_tm1",
                            "BinOp"
                        ]
                    ]
                },
                "b": {
                    "value": "sqe_terms.inv_Lambdas",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axes": {
                    "value": "[[1], [1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_127": {
                "input": {
                    "value": "zeta_i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sde.iv_values() - mean_tm1",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_136": {
                "input_tensor": {
                    "value": "tf.einsum('abxy,yabij->abijx', inv_R_ab, tf.tensordot(cov_tm1, z_abij, [[-1], [-1]]), name='Q_einsum') * z_abij",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_like_274": {
                "input": {
                    "value": "messages_cov_t0",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reshape_61": {
                "tensor": {
                    "value": "rbf_kernel.lengthscales ** 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "det_89": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "tensordot_98": {
                "a": {
                    "value": "zeta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mean_tm1 - self.sde.iv_values()",
                            "BinOp"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.linalg.inv(cov_tm1 + sqe_terms.Lambdas)",
                    "type": "Call",
                    "possible_values": []
                },
                "axes": {
                    "value": "[[1], [1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_99": {
                "input": {
                    "value": "zeta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mean_tm1 - self.sde.iv_values()",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_133": {
                "a": {
                    "value": "log_variances",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.log(sqe_terms.variances)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_135": {
                "input": {
                    "value": "n_tmp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(tf.reduce_sum(tf.tensordot(zeta_i, sqe_terms.inv_Lambdas, [[1], [1]]) * tf.expand_dims(zeta_i, 1), axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_like_273": {
                "input": {
                    "value": "messages_prec_t0",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "expand_dims_282": {
                "input": {
                    "value": "messages_mean_t0",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_283": {
                "input": {
                    "value": "messages_cov_t0",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_284": {
                "input": {
                    "value": "messages_prec_t0",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "inv_98": {
                "input": {
                    "value": "cov_tm1 + sqe_terms.Lambdas",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "einsum_137": {
                "equation": {
                    "value": "abxy,yabij->abijx",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "inv_R_ab",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(lambda x: tf.map_fn(tf.linalg.inv, x), R_ab)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "tf.tensordot(cov_tm1, z_abij, [[-1], [-1]])",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "Q_einsum",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tensordot_138": {
                "a": {
                    "value": "cov_tm1",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "z_abij",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.expand_dims(zeta_lambda, 1), 3) + tf.expand_dims(tf.expand_dims(zeta_lambda, 0), 2)",
                            "BinOp"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[-1], [-1]]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "ParticleFilter.py": {
        "tensorflow": {
            "squeeze_23": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tfd.Categorical(logits=log_weights).sample(1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "map_fn_24": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda x: tf.gather(x[0], x[1])",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "(particles, tf.transpose(indices))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "transpose_29": {
                "a": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(lambda x: tf.gather(x[0], x[1]), elems=(particles, tf.transpose(indices)), dtype=tf_floatx())",
                            "Call"
                        ],
                        [
                            "backward_sample(forward_particles, log_weights)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_41": {
                "variable": {
                    "value": "self.alpha",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "0.99",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scan_116": {
                "variable": {
                    "value": "(particles, log_weights)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda a, x: forward_step(a[0], a[1], x)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "(tf.transpose(encoding_potentials[0], [1, 0, 2]), tf.transpose(encoding_potentials[1], [1, 0, 2]))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "(particles, log_weights)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "repeat_128": {
                "variable": {
                    "value": "last_log_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "log_weights[-1][tf.newaxis, ...]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "repeats": {
                    "value": "self.nb_samples",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_132": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "log_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.weight_fn(log_weights, particles, encoding_potential)",
                            "Call"
                        ],
                        [
                            "log_weights - tf.math.reduce_logsumexp(log_weights, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "log_weights[tf.newaxis, ...] + self.dynamics_fn(forward_particles, backward_particles)",
                            "BinOp"
                        ],
                        [
                            "log_weights - tf.reduce_logsumexp(log_weights, axis=-1, keepdims=True)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_133": {
                "variable": {
                    "value": "final_mean",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "particles[-1] * weights[-1, ..., tf.newaxis]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "map_fn_137": {
                "variable": {
                    "value": "final_prec",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "tf.linalg.diag",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "1 / final_var",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scan_157": {
                "variable": {
                    "value": "(bparticles, blog_weights)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda a, x: backward_step(a, *x)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "(particles_1_Tm1, weights_1_Tm1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "(last_sample, tf.zeros_like(last_log_weights, dtype=tf_floatx()))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "reverse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "concat_170": {
                "variable": {
                    "value": "bparticles",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[bparticles, last_sample[tf.newaxis, ...]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_173": {
                "variable": {
                    "value": "covs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "covs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfp.stats.covariance(tf.reshape(bparticles, [s[0] * s[-1], s[1], s[2]]), sample_axis=1, event_axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(covs, [2, 0, 1])",
                            "Call"
                        ],
                        [
                            "covs + 1e-08 * tf.eye(covs.shape[1], batch_shape=[covs.shape[0]], dtype=tf_floatx())",
                            "BinOp"
                        ]
                    ]
                },
                "perm": {
                    "value": "[2, 0, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "log_15": {
                "x": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_logsumexp_18": {
                "input_tensor": {
                    "value": "new_log_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "log_weights - log_sampling_weights",
                            "BinOp"
                        ],
                        [
                            "new_log_weights - tf.reduce_logsumexp(new_log_weights)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "gather_19": {
                "params": {
                    "value": "particles",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.proposal_builder(particles, encoding_potential).sample()",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfd.Categorical(logits=log_sampling_weights).sample(len(log_weights))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tfd.Categorical(logits=log_weights).sample(1), axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_100": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "log_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.weight_fn(log_weights, particles, encoding_potential)",
                            "Call"
                        ],
                        [
                            "log_weights - tf.math.reduce_logsumexp(log_weights, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "log_weights[tf.newaxis, ...] + self.dynamics_fn(forward_particles, backward_particles)",
                            "BinOp"
                        ],
                        [
                            "log_weights - tf.reduce_logsumexp(log_weights, axis=-1, keepdims=True)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "map_fn_103": {
                "variable": {
                    "value": "(particles, log_weights)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda x: tf.cond(x[0] < self.n_eff_threshold, lambda : forward_resampling(x[1], x[2], self.alpha), lambda : (x[1], x[2]))",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "(n_eff, particles, log_weights)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "(tf_floatx(), tf_floatx())",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_190": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "particles",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.proposal_builder(particles, encoding_potential).sample()",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1, particles.shape[-1])",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_193": {
                "variable": {
                    "value": "mean_x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x + fx",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "particles.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "square_196": {
                "variable": {
                    "value": "var_y",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "scale_y",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reshape_205": {
                "variable": {
                    "value": "fx",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "fx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(fx, particles.shape)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "particles.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sqrt_215": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.square(encoding_scale) + sde_model.diffusion.expected_diffusion()",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "gather_25": {
                "params": {
                    "value": "x[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "indices": {
                    "value": "x[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "transpose_62": {
                "a": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(lambda x: tf.gather(x[0], x[1]), elems=(particles, tf.transpose(indices)), dtype=tf_floatx())",
                            "Call"
                        ],
                        [
                            "backward_sample(forward_particles, log_weights)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 2, 0, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_83": {
                "a": {
                    "value": "distro.sample(self.n_particles)",
                    "type": "Call",
                    "possible_values": []
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_135": {
                "input_tensor": {
                    "value": "particles[-1] ** 2 * weights[-1, ..., tf.newaxis]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_172": {
                "tensor": {
                    "value": "bparticles",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([bparticles, last_sample[tf.newaxis, ...]], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[s[0] * s[-1], s[1], s[2]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_181": {
                "values": {
                    "value": "[blog_weights, last_log_weights[tf.newaxis, ...]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_26": {
                "a": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfd.Categorical(logits=log_sampling_weights).sample(len(log_weights))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tfd.Categorical(logits=log_weights).sample(1), axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_84": {
                "shape": {
                    "value": "(batch_size, self.n_particles)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_logsumexp_97": {
                "input_tensor": {
                    "value": "log_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.weight_fn(log_weights, particles, encoding_potential)",
                            "Call"
                        ],
                        [
                            "log_weights - tf.math.reduce_logsumexp(log_weights, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "log_weights[tf.newaxis, ...] + self.dynamics_fn(forward_particles, backward_particles)",
                            "BinOp"
                        ],
                        [
                            "log_weights - tf.reduce_logsumexp(log_weights, axis=-1, keepdims=True)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_101": {
                "input_tensor": {
                    "value": "tf.square(weights)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_logsumexp_149": {
                "input_tensor": {
                    "value": "log_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.weight_fn(log_weights, particles, encoding_potential)",
                            "Call"
                        ],
                        [
                            "log_weights - tf.math.reduce_logsumexp(log_weights, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "log_weights[tf.newaxis, ...] + self.dynamics_fn(forward_particles, backward_particles)",
                            "BinOp"
                        ],
                        [
                            "log_weights - tf.reduce_logsumexp(log_weights, axis=-1, keepdims=True)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "eye_175": {
                "num_rows": {
                    "value": "covs.shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "batch_shape": {
                    "value": "[covs.shape[0]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logdet_177": {
                "matrix": {
                    "value": "covs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfp.stats.covariance(tf.reshape(bparticles, [s[0] * s[-1], s[1], s[2]]), sample_axis=1, event_axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(covs, [2, 0, 1])",
                            "Call"
                        ],
                        [
                            "covs + 1e-08 * tf.eye(covs.shape[1], batch_shape=[covs.shape[0]], dtype=tf_floatx())",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reshape_204": {
                "tensor": {
                    "value": "particles",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.proposal_builder(particles, encoding_potential).sample()",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1, particles.shape[-1])",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_212": {
                "tensor": {
                    "value": "particles",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.proposal_builder(particles, encoding_potential).sample()",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1, particles.shape[-1])",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_213": {
                "tensor": {
                    "value": "fx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(fx, particles.shape)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "particles.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "square_101": {
                "x": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(log_weights)",
                            "Call"
                        ],
                        [
                            "tf.exp(log_weights)",
                            "Call"
                        ]
                    ]
                }
            },
            "cond_104": {
                "pred": {
                    "value": "x[0] < self.n_eff_threshold",
                    "type": "Compare",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : forward_resampling(x[1], x[2], self.alpha)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (x[1], x[2])",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "transpose_119": {
                "a": {
                    "value": "encoding_potentials[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_like_160": {
                "input": {
                    "value": "last_log_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.repeat(log_weights[-1][tf.newaxis, ...], self.nb_samples, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_177": {
                "x": {
                    "value": "2 * tf.constant(np.pi, dtype=tf_floatx())",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sqrt_199": {
                "x": {
                    "value": "var_xy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 / (1 / var_x + 1 / var_y)[:, tf.newaxis, :]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "square_215": {
                "x": {
                    "value": "encoding_scale",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "constant_177": {
                "value": {
                    "value": "np.pi",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_208": {
                "x": {
                    "value": "sde_model.diffusion.expected_diffusion()",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "SdeModel.py": {
        "tensorflow": {
            "stack_131": {
                "variable": {
                    "value": "Kmms",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[k.K(iv_values) for k in self.kernel.kernels]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "map_fn_135": {
                "variable": {
                    "value": "chol_Kmm",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "tf.linalg.cholesky",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "Kmms",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([k.K(iv_values) for k in self.kernel.kernels], axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "cholesky_212": {
                "variable": {
                    "value": "var_sqrt_inv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "-2 * theta_3",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "matmul_214": {
                "variable": {
                    "value": "Q",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "var_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inverse_lower_triangular(var_sqrt_inv)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "var_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inverse_lower_triangular(var_sqrt_inv)",
                            "Call"
                        ]
                    ]
                },
                "transpose_a": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "einsum_218": {
                "variable": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "aij,ja->ia",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "Q",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linalg.matmul(var_sqrt, var_sqrt, transpose_a=True)",
                            "Call"
                        ],
                        [
                            "eta_3 - tf.einsum('ji,ki->ijk', aux, aux)",
                            "BinOp"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "theta_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('aij,ja->ia', precision, mu)",
                            "Call"
                        ]
                    ]
                }
            },
            "cholesky_219": {
                "variable": {
                    "value": "q_sqrt",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "Q",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linalg.matmul(var_sqrt, var_sqrt, transpose_a=True)",
                            "Call"
                        ],
                        [
                            "eta_3 - tf.einsum('ji,ki->ijk', aux, aux)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "matmul_227": {
                "variable": {
                    "value": "precision",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inverse_q_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inverse_lower_triangular(q_sqrt)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "inverse_q_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inverse_lower_triangular(q_sqrt)",
                            "Call"
                        ]
                    ]
                },
                "transpose_a": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "einsum_233": {
                "variable": {
                    "value": "theta_2",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "aij,ja->ia",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "precision",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linalg.matmul(inverse_q_sqrt, inverse_q_sqrt, transpose_a=True)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('aij,ja->ia', Q, theta_2)",
                            "Call"
                        ],
                        [
                            "eta_2 / eta_1[tf.newaxis, ...]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "cholesky_265": {
                "variable": {
                    "value": "q_sqrt",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "Q",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linalg.matmul(var_sqrt, var_sqrt, transpose_a=True)",
                            "Call"
                        ],
                        [
                            "eta_3 - tf.einsum('ji,ki->ijk', aux, aux)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "scan_305": {
                "variable": {
                    "value": "trajectories",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda x_tm1, noise_term: x_tm1 + self.drift_svgp.predict_f(x_tm1)[0] + noise_term",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "diffusions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfp.distributions.MultivariateNormalDiag(tf.zeros(initial_points.shape, dtype=tf_floatx()), tf.sqrt(self.diffusion.expected_diffusion())).sample(sim_steps, dtype=tf_floatx())",
                            "Call"
                        ]
                    ]
                },
                "initializer": {
                    "value": "initial_points",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "sde_sim",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_173": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_174": {
                "input_tensor": {
                    "value": "self.kullback_leibler_by_dimension(free_bits)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_178": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "transpose_193": {
                "variable": {
                    "value": "kl_mu",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.sqrt(self.diffusion.expected_precision())[tf.newaxis, ...] * self.drift_svgp.q_mu",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "maximum_205": {
                "variable": {
                    "value": "kl",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "free_bits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(0",
                            "Method Argument"
                        ],
                        [
                            "tf.convert_to_tensor(0",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "kl",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gaussian_kl + tfd.Gamma(self.diffusion.alphas(), self.diffusion.betas()).kl_divergence(self.diffusion.prior_distribution)",
                            "BinOp"
                        ],
                        [
                            "tfd.MultivariateNormalTriL(kl_mu, q_sqrt).kl_divergence(self.drift_svgp.prior_distribution) + tfd.Gamma(self.diffusion.alphas(), self.diffusion.betas()).kl_divergence(self.diffusion.prior_distribution)",
                            "BinOp"
                        ],
                        [
                            "tf.math.maximum(free_bits, kl)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_312": {
                "values": {
                    "value": "[initial_points[:, tf.newaxis, :], tf.transpose(trajectories, [1, 0, 2])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_to_tensor_322": {
                "value": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "default_float()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_323": {
                "value": {
                    "value": "np.array([[1, 1], [2, 2]])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "default_float()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_326": {
                "value": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "np_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_327": {
                "value": {
                    "value": "[2, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "np_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_like_41": {
                "input": {
                    "value": "alphas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "diff_parameters.alphas",
                            "Attribute"
                        ],
                        [
                            "theta_0 + 0.5",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_like_47": {
                "input": {
                    "value": "betas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "diff_parameters.betas",
                            "Attribute"
                        ],
                        [
                            "-theta_1 - 0.5 * tf.einsum('ia,aij,ja->a', theta_2, Q, theta_2)",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "digamma_66": {
                "x": {
                    "value": "self.alphas()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_66": {
                "x": {
                    "value": "self.betas()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_263": {
                "x": {
                    "value": "eta_1[tf.newaxis, ...]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "einsum_264": {
                "equation": {
                    "value": "ji,ki->ijk",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "aux",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sqrt(alphas / betas)[tf.newaxis, ...] * q_mu",
                            "BinOp"
                        ],
                        [
                            "eta_2 / tf.sqrt(eta_1[tf.newaxis, ...])",
                            "BinOp"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "aux",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sqrt(alphas / betas)[tf.newaxis, ...] * q_mu",
                            "BinOp"
                        ],
                        [
                            "eta_2 / tf.sqrt(eta_1[tf.newaxis, ...])",
                            "BinOp"
                        ]
                    ]
                }
            },
            "Variable_75": {
                "initial_value": {
                    "value": "inducing_points",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "inducing_points.py",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_like_88": {
                "input": {
                    "value": "tf.transpose(self.q_mu)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "repeat_89": {
                "input": {
                    "value": "tf.convert_to_tensor(prior_scale, dtype=tf_floatx())[..., tf.newaxis]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "repeats": {
                    "value": "self.q_mu.shape[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "ones_like_116": {
                "input": {
                    "value": "tf.sqrt(diff_parameters.alphas / diff_parameters.betas)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_149": {
                "tensor": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, samples.shape[-1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_183": {
                "input_tensor": {
                    "value": "tf.math.log(tf.linalg.diag_part(q_sqrt))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "einsum_217": {
                "equation": {
                    "value": "ia,aij,ja->a",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "theta_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('aij,ja->ia', precision, mu)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "Q",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linalg.matmul(var_sqrt, var_sqrt, transpose_a=True)",
                            "Call"
                        ],
                        [
                            "eta_3 - tf.einsum('ji,ki->ijk', aux, aux)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "einsum_232": {
                "equation": {
                    "value": "ia,aij,ja->a",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('aij,ja->ia', Q, theta_2)",
                            "Call"
                        ],
                        [
                            "eta_2 / eta_1[tf.newaxis, ...]",
                            "BinOp"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "precision",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linalg.matmul(inverse_q_sqrt, inverse_q_sqrt, transpose_a=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_241": {
                "x": {
                    "value": "alphas / betas",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "digamma_243": {
                "x": {
                    "value": "alphas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "diff_parameters.alphas",
                            "Attribute"
                        ],
                        [
                            "theta_0 + 0.5",
                            "BinOp"
                        ]
                    ]
                }
            },
            "log_243": {
                "x": {
                    "value": "betas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "diff_parameters.betas",
                            "Attribute"
                        ],
                        [
                            "-theta_1 - 0.5 * tf.einsum('ia,aij,ja->a', theta_2, Q, theta_2)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "einsum_247": {
                "equation": {
                    "value": "ia,ja->aij",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "aux",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sqrt(alphas / betas)[tf.newaxis, ...] * q_mu",
                            "BinOp"
                        ],
                        [
                            "eta_2 / tf.sqrt(eta_1[tf.newaxis, ...])",
                            "BinOp"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "aux",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sqrt(alphas / betas)[tf.newaxis, ...] * q_mu",
                            "BinOp"
                        ],
                        [
                            "eta_2 / tf.sqrt(eta_1[tf.newaxis, ...])",
                            "BinOp"
                        ]
                    ]
                }
            },
            "matmul_248": {
                "a": {
                    "value": "q_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.drift_svgp.q_sqrt",
                            "Attribute"
                        ],
                        [
                            "self.drift_svgp.q_sqrt",
                            "Attribute"
                        ],
                        [
                            "tf.linalg.cholesky(Q)",
                            "Call"
                        ],
                        [
                            "tf.linalg.cholesky(Q)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "q_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.drift_svgp.q_sqrt",
                            "Attribute"
                        ],
                        [
                            "self.drift_svgp.q_sqrt",
                            "Attribute"
                        ],
                        [
                            "tf.linalg.cholesky(Q)",
                            "Call"
                        ],
                        [
                            "tf.linalg.cholesky(Q)",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "transpose_314": {
                "a": {
                    "value": "trajectories",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.scan(lambda x_tm1, noise_term: x_tm1 + self.drift_svgp.predict_f(x_tm1)[0] + noise_term, elems=diffusions, initializer=initial_points, name='sde_sim')",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_88": {
                "a": {
                    "value": "self.q_mu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sqrt_116": {
                "x": {
                    "value": "diff_parameters.alphas / diff_parameters.betas",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ones_like_159": {
                "input": {
                    "value": "kernel.lengthscales",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "log_183": {
                "x": {
                    "value": "tf.linalg.diag_part(q_sqrt)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_257": {
                "x": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "search_results.estimated_root",
                            "Attribute"
                        ]
                    ]
                }
            },
            "log_258": {
                "x": {
                    "value": "eta_1",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "zeros_302": {
                "shape": {
                    "value": "initial_points.shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_303": {
                "x": {
                    "value": "self.diffusion.expected_diffusion()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_90": {
                "value": {
                    "value": "prior_scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "diag_part_183": {
                "input": {
                    "value": "q_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.drift_svgp.q_sqrt",
                            "Attribute"
                        ],
                        [
                            "self.drift_svgp.q_sqrt",
                            "Attribute"
                        ],
                        [
                            "tf.linalg.cholesky(Q)",
                            "Call"
                        ],
                        [
                            "tf.linalg.cholesky(Q)",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_194": {
                "x": {
                    "value": "self.diffusion.expected_precision()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "digamma_257": {
                "x": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "search_results.estimated_root",
                            "Attribute"
                        ]
                    ]
                }
            }
        }
    },
    "VAE.py": {
        "tensorflow": {
            "convert_to_tensor_37": {
                "variable": {
                    "value": "self.minimum_nats",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "-np.Inf",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_72": {
                "variable": {
                    "value": "fx",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "fx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(fx, x_1Tm1.shape)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "x_1Tm1.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_73": {
                "variable": {
                    "value": "var_fx",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "var_fx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(var_fx, x_1Tm1.shape)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "x_1Tm1.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_fn_158": {
                "variable": {
                    "value": "(decoded_means, decoded_scales_diag)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda x_: self.decoder(x_, training=training)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "(tf_floatx(), tf_floatx())",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reduce_sum_232": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "breaked_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._breaked_loss(y_input, y_target, samples, entropies, encoded_dist, decoded_dist, initial_state, effective_nb_timesteps, kl_weight)",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_293": {
                "variable": {
                    "value": "q_sqrt_T",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "q_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sde_model.drift_svgp.q_sqrt",
                            "Attribute"
                        ],
                        [
                            "self.sde_model.drift_svgp.q_sqrt",
                            "Attribute"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "einsum_294": {
                "variable": {
                    "value": "Q",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "aij,ajk->aik",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "q_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sde_model.drift_svgp.q_sqrt",
                            "Attribute"
                        ],
                        [
                            "self.sde_model.drift_svgp.q_sqrt",
                            "Attribute"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "q_sqrt_T",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(q_sqrt, [0, 2, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "map_fn_295": {
                "variable": {
                    "value": "prec",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "tf.linalg.inv",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "Q",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('aij,ajk->aik', q_sqrt, q_sqrt_T)",
                            "Call"
                        ]
                    ]
                }
            },
            "einsum_303": {
                "variable": {
                    "value": "prec_mu",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "aij,ja->ai",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "prec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(tf.linalg.inv, Q)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "q_mu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sde_model.drift_svgp.q_mu",
                            "Attribute"
                        ],
                        [
                            "self.sde_model.drift_svgp.q_mu",
                            "Attribute"
                        ]
                    ]
                }
            },
            "einsum_304": {
                "variable": {
                    "value": "mu_prec_mu",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ia,ai->a",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "q_mu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sde_model.drift_svgp.q_mu",
                            "Attribute"
                        ],
                        [
                            "self.sde_model.drift_svgp.q_mu",
                            "Attribute"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "prec_mu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('aij,ja->ai', prec, q_mu)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_50": {
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_61": {
                "input_tensor": {
                    "value": "time_and_batch_reduced",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._reduce_batch(time_reduced, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_to_tensor_98": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_128": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "map_fn_174": {
                "variable": {
                    "value": "initial_dynamic_scale",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda x: tf.sqrt(1 / tf.linalg.diag_part(x))",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "initial_dynamic_prec",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "convert_to_tensor_188": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stack_206": {
                "values": {
                    "value": "[-ly, -kl_weight * lx, -kl_weight * mpenalty, -kl_weight * alphaterm, -kl_weight * reduced_entropy, kl_weight * kl]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "convert_to_tensor_215": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_216": {
                "input_tensor": {
                    "value": "self._breaked_loss(y_input, y_target, samples, entropies, encoded_dist, decoded_dist, initial_state, effective_nb_timesteps, kl_weight)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_225": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_239": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_264": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_33": {
                "value": {
                    "value": "pseudo_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_58": {
                "input_tensor": {
                    "value": "xs",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_71": {
                "tensor": {
                    "value": "x_1Tm1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x[:, :, :-1, :]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1, x_1Tm1.shape[-1])",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reduce_mean_196": {
                "input_tensor": {
                    "value": "entropies",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "GradientTape_248": {
                "persistent": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "watch_accessed_variables": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "where_300": {
                "condition": {
                    "value": "kl > self.minimum_nats",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "nat_mnat_0",
                    "type": "variable",
                    "possible_values": [
                        [
                            "alphas - 0.5 - theta_0_prior",
                            "BinOp"
                        ],
                        [
                            "kl_weight * tf.where(kl > self.minimum_nats, nat_mnat_0, tf.zeros_like(nat_mnat_0))",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(nat_mnat_0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_307": {
                "condition": {
                    "value": "kl > self.minimum_nats",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "nat_mnat_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-betas - 0.5 * mu_prec_mu - theta_1_prior",
                            "BinOp"
                        ],
                        [
                            "kl_weight * tf.where(kl > self.minimum_nats, nat_mnat_1, tf.zeros_like(nat_mnat_1))",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(nat_mnat_1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_326": {
                "condition": {
                    "value": "(kl > self.minimum_nats)[tf.newaxis, ...]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "x": {
                    "value": "theta_2",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.zeros_like(theta_2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_333": {
                "condition": {
                    "value": "tf.reshape(kl > self.minimum_nats, [-1, 1, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "nat_mnat_3",
                    "type": "variable",
                    "possible_values": [
                        [
                            "theta_3 - theta_3_prior",
                            "BinOp"
                        ],
                        [
                            "kl_weight * tf.where(tf.reshape(kl > self.minimum_nats, [-1, 1, 1]), nat_mnat_3, tf.zeros_like(nat_mnat_3))",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(nat_mnat_3)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_43": {
                "shape": {
                    "value": "self.phase_space_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_85": {
                "input_tensor": {
                    "value": "lx0",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfd.MultivariateNormalDiag(x0_mean, x0_scale).log_prob(x[:, :, 0, :])",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_87": {
                "input_tensor": {
                    "value": "tf.math.digamma(alphas) - tf.math.log(alphas)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "convert_to_tensor_112": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_289": {
                "input": {
                    "value": "theta_3",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "map_fn_291": {
                "fn": {
                    "value": "tf.linalg.inv",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "self.sde_model.drift_svgp.prior_distribution.covariance()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_300": {
                "input": {
                    "value": "nat_mnat_0",
                    "type": "variable",
                    "possible_values": [
                        [
                            "alphas - 0.5 - theta_0_prior",
                            "BinOp"
                        ],
                        [
                            "kl_weight * tf.where(kl > self.minimum_nats, nat_mnat_0, tf.zeros_like(nat_mnat_0))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "zeros_like_307": {
                "input": {
                    "value": "nat_mnat_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-betas - 0.5 * mu_prec_mu - theta_1_prior",
                            "BinOp"
                        ],
                        [
                            "kl_weight * tf.where(kl > self.minimum_nats, nat_mnat_1, tf.zeros_like(nat_mnat_1))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_mean_310": {
                "input_tensor": {
                    "value": "tf.reduce_sum(tf.square(dsamples), axis=2)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "[0, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "einsum_320": {
                "equation": {
                    "value": "abt,ta->ba",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "B",
                    "type": "variable",
                    "possible_values": [
                        [
                            "triangular_solve(chol_Kmm, Kmn)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "dsamples[ii, jj, :]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "einsum_321": {
                "equation": {
                    "value": "ait,ajt->aij",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "B",
                    "type": "variable",
                    "possible_values": [
                        [
                            "triangular_solve(chol_Kmm, Kmn)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "B",
                    "type": "variable",
                    "possible_values": [
                        [
                            "triangular_solve(chol_Kmm, Kmn)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_327": {
                "input": {
                    "value": "theta_2",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reshape_333": {
                "tensor": {
                    "value": "kl > self.minimum_nats",
                    "type": "Compare",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_like_334": {
                "input": {
                    "value": "nat_mnat_3",
                    "type": "variable",
                    "possible_values": [
                        [
                            "theta_3 - theta_3_prior",
                            "BinOp"
                        ],
                        [
                            "kl_weight * tf.where(tf.reshape(kl > self.minimum_nats, [-1, 1, 1]), nat_mnat_3, tf.zeros_like(nat_mnat_3))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_86": {
                "input_tensor": {
                    "value": "var_fx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(var_fx, x_1Tm1.shape)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "sqrt_174": {
                "x": {
                    "value": "1 / tf.linalg.diag_part(x)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_310": {
                "input_tensor": {
                    "value": "tf.square(dsamples)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sqrt_76": {
                "x": {
                    "value": "self.sde_model.diffusion.expected_diffusion()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "digamma_87": {
                "x": {
                    "value": "alphas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sde_model.diffusion.alphas()",
                            "Call"
                        ],
                        [
                            "self.sde_model.diffusion._alphas",
                            "Attribute"
                        ],
                        [
                            "self.sde_model.diffusion._alphas",
                            "Attribute"
                        ]
                    ]
                }
            },
            "log_87": {
                "x": {
                    "value": "alphas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sde_model.diffusion.alphas()",
                            "Call"
                        ],
                        [
                            "self.sde_model.diffusion._alphas",
                            "Attribute"
                        ],
                        [
                            "self.sde_model.diffusion._alphas",
                            "Attribute"
                        ]
                    ]
                }
            },
            "square_310": {
                "x": {
                    "value": "dsamples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "samples[:, :, 1:, :] - samples[:, :, :-1, :]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "diag_part_174": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "callbacks.py": {
        "tensorflow": {}
    },
    "experiments/Experiment.py": {
        "tensorflow": {
            "convert_to_tensor_58": {
                "variable": {
                    "value": "self.effective_len",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self.effective_len",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TFRecordDataset_93": {
                "variable": {
                    "value": "tfdata",
                    "type": "variable",
                    "possible_values": []
                },
                "filenames": {
                    "value": "files",
                    "type": "variable",
                    "possible_values": [
                        [
                            "glob.glob(os.path.join(folder, '*.tfrecords'))",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_138": {
                "variable": {
                    "value": "examples",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "examples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(examples, axis=0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(examples, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_156": {
                "variable": {
                    "value": "examples",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "examples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(examples, axis=0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(examples, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "parse_single_example_96": {
                "serialized": {
                    "value": "proto",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "{'signal': tf.io.FixedLenFeature([self.example_timesteps], tf.float32, default_value=np.zeros(self.example_timesteps))}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "cast_110": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "FixedLenFeature_97": {
                "shape": {
                    "value": "[self.example_timesteps]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "default_value": {
                    "value": "np.zeros(self.example_timesteps)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "nnets/models.py": {
        "tensorflow": {
            "convert_to_tensor_474": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.random.rand(1, 10, 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TimeDistributed_35": {
                "variable": {
                    "value": "self.mean_output_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "layer": {
                    "value": "Mlp([128], output_dim)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TimeDistributed_38": {
                "variable": {
                    "value": "self.scale_diag_output_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "layer": {
                    "value": "Mlp([128], output_dim, activation='softplus')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Dense_76": {
                "variable": {
                    "value": "self.output_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "output_dim",
                    "type": "variable",
                    "possible_values": []
                },
                "activation": {
                    "value": "activation",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None if i == len(conv_units_list) - 1 else 'relu'",
                            "IfExp"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.keras.layers.LeakyReLU()",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Dense_95": {
                "variable": {
                    "value": "self.output_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "output_dim",
                    "type": "variable",
                    "possible_values": []
                },
                "activation": {
                    "value": "activation",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None if i == len(conv_units_list) - 1 else 'relu'",
                            "IfExp"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.keras.layers.LeakyReLU()",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "split_403": {
                "variable": {
                    "value": "(mean, scale)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(np.random.rand(1, 10, 2))",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "dense_layer(x)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "dense_layer(x)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "conv_layer(x)",
                            "Call"
                        ],
                        [
                            "bn_layer(x, training=training)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "bn(conv_layer(x), training=training)",
                            "Call"
                        ],
                        [
                            "activation(x)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "bn(conv_layer(x), training=training)",
                            "Call"
                        ],
                        [
                            "activation(x)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "convert_to_tensor_10": {
                "value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_19": {
                "variable": {
                    "value": "mask_0",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.concat([[True], tf.repeat(False, means.shape[-2] - 1)], axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, -1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "logical_or_20": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask_0",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.concat([[True], tf.repeat(False, means.shape[-2] - 1)], axis=0), (1, -1, 1))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(means[..., :1], rate=self.rate) == 0.0",
                            "Compare"
                        ],
                        [
                            "tf.math.logical_or(mask_0, mask)",
                            "Call"
                        ],
                        [
                            "tf.repeat(mask, means.shape[-1], axis=-1)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "repeat_21": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(means[..., :1], rate=self.rate) == 0.0",
                            "Compare"
                        ],
                        [
                            "tf.math.logical_or(mask_0, mask)",
                            "Call"
                        ],
                        [
                            "tf.repeat(mask, means.shape[-1], axis=-1)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "repeats": {
                    "value": "means.shape[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "TimeDistributed_297": {
                "variable": {
                    "value": "self.output_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "layer": {
                    "value": "Mlp([2 * units_list[-1]], output_dim, dropout=0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TimeDistributed_327": {
                "variable": {
                    "value": "self.mean_output_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "layer": {
                    "value": "Mlp([128], output_dim, dropout=0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TimeDistributed_383": {
                "variable": {
                    "value": "self.mean_output_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "layer": {
                    "value": "tf.keras.layers.Dense(units=output_dim, activation=None, name='mean_output')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TimeDistributed_389": {
                "variable": {
                    "value": "self.scale_output_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "layer": {
                    "value": "tf.keras.layers.Dense(units=output_dim, activation=_POSITIVE_TRANSFORMATION, name='scale_output')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "GRU_438": {
                "variable": {
                    "value": "base",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "units",
                    "type": "variable",
                    "possible_values": []
                },
                "dropout": {
                    "value": "DROPOUT",
                    "type": "variable",
                    "possible_values": []
                },
                "recurrent_dropout": {
                    "value": "REC_DROPOUT",
                    "type": "variable",
                    "possible_values": []
                },
                "return_sequences": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "return_state": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "stateful": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "name_scope_296": {
                "name": {
                    "value": "output",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_326": {
                "name": {
                    "value": "output",
                    "type": "str",
                    "possible_values": []
                }
            },
            "TimeDistributed_332": {
                "variable": {
                    "value": "self.scale_output_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "layer": {
                    "value": "Mlp([128], 1 if tie_scale else output_dim, dropout=0.0, activation='softplus')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "repeat_347": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.scale_output_layer(x)",
                            "Call"
                        ],
                        [
                            "tf.repeat(scale, self.output_dim, -1)",
                            "Call"
                        ],
                        [
                            "tf.repeat(self.scale, self.output_dim, -1)",
                            "Call"
                        ],
                        [
                            "self.scale",
                            "Attribute"
                        ],
                        [
                            "tf.zeros_like(tf.stop_gradient(mean)) + scale + 1e-05",
                            "BinOp"
                        ],
                        [
                            "0 * self.scale_output_layer(scale) + 0.0001",
                            "BinOp"
                        ]
                    ]
                },
                "repeats": {
                    "value": "self.output_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "repeat_350": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.scale",
                    "type": "Attribute",
                    "possible_values": []
                },
                "repeats": {
                    "value": "self.output_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "LeakyReLU_372": {
                "variable": {
                    "value": "activation",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "name_scope_380": {
                "name": {
                    "value": "output",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dropout_18": {
                "x": {
                    "value": "means[..., :1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "rate": {
                    "value": "self.rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_19": {
                "values": {
                    "value": "[[True], tf.repeat(False, means.shape[-2] - 1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_25": {
                "condition": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(means[..., :1], rate=self.rate) == 0.0",
                            "Compare"
                        ],
                        [
                            "tf.math.logical_or(mask_0, mask)",
                            "Call"
                        ],
                        [
                            "tf.repeat(mask, means.shape[-1], axis=-1)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "x": {
                    "value": "self.dropped_scale * tf.ones_like(scales)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "scales",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Dense_75": {
                "units": {
                    "value": "units",
                    "type": "variable",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "name": {
                    "value": "f'hidden_layer_{i}'",
                    "type": "JoinedStr",
                    "possible_values": []
                }
            },
            "Dense_94": {
                "units": {
                    "value": "units",
                    "type": "variable",
                    "possible_values": []
                },
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "f'hidden_layer_{i}'",
                    "type": "JoinedStr",
                    "possible_values": []
                }
            },
            "Dense_384": {
                "units": {
                    "value": "output_dim",
                    "type": "variable",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "name": {
                    "value": "mean_output",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Dense_390": {
                "units": {
                    "value": "output_dim",
                    "type": "variable",
                    "possible_values": []
                },
                "activation": {
                    "value": "_POSITIVE_TRANSFORMATION",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'softplus'",
                            "str"
                        ]
                    ]
                },
                "name": {
                    "value": "scale_output",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_442": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'hidden_rnn_' + str(i) if i != last_layer_idx else 'output_rnn'",
                            "IfExp"
                        ]
                    ]
                }
            },
            "Conv1D_290": {
                "filters": {
                    "value": "units",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "activation",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None if i == len(conv_units_list) - 1 else 'relu'",
                            "IfExp"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.keras.layers.LeakyReLU()",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "dilation_rate": {
                    "value": "2 ** i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "BatchNormalization_292": {
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_like_353": {
                "input": {
                    "value": "tf.stop_gradient(mean)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Conv1D_375": {
                "filters": {
                    "value": "units",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'valid'",
                            "str"
                        ],
                        [
                            "'same'",
                            "str"
                        ]
                    ]
                },
                "dilation_rate": {
                    "value": "dilation_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "BatchNormalization_376": {
                "momentum": {
                    "value": "0.8",
                    "type": "float",
                    "possible_values": []
                }
            },
            "repeat_19": {
                "input": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "repeats": {
                    "value": "means.shape[-2] - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ones_like_25": {
                "input": {
                    "value": "scales",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ones_337": {
                "shape": {
                    "value": "1 if tie_scale else output_dim",
                    "type": "IfExp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stop_gradient_353": {
                "input": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.mean_output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.mean_output_layer(mean)",
                            "Call"
                        ]
                    ]
                }
            },
            "Bidirectional_444": {
                "layer": {
                    "value": "base",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.layers.GRU(units=units, dropout=DROPOUT, recurrent_dropout=REC_DROPOUT, return_sequences=True, return_state=True, stateful=False)",
                            "Call"
                        ]
                    ]
                },
                "merge_mode": {
                    "value": "concat",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "run_experiment.py": {
        "tensorflow": {
            "Adam_21": {
                "variable": {
                    "value": "hoptimizers",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "set_seed_7": {
                "seed": {
                    "value": "25",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_like_19": {
                "input": {
                    "value": "k.lengthscales",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "utils/Trainer.py": {
        "tensorflow": {
            "Mean_157": {
                "variable": {
                    "value": "avg_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "MeanTensor_158": {
                "variable": {
                    "value": "avg_breaked_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "breaked_loss",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Mean_251": {
                "variable": {
                    "value": "avg_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_74": {
                "variable": {
                    "value": "fx",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "fx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(fx, samples.shape)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "samples.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Checkpoint_138": {
                "variable": {
                    "value": "ckpt",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "tf.Variable(1)",
                    "type": "Call",
                    "possible_values": []
                },
                "graphicalModel": {
                    "value": "self.model",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "CheckpointManager_139": {
                "variable": {
                    "value": "manager",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint": {
                    "value": "ckpt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(None,)",
                            "Tuple"
                        ],
                        [
                            "tf.train.Checkpoint(step=tf.Variable(1), graphicalModel=self.model)",
                            "Call"
                        ]
                    ]
                },
                "directory": {
                    "value": "self.experiment.checkpoint_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "100",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Adam_143": {
                "learning_rate": {
                    "value": "0.0003",
                    "type": "float",
                    "possible_values": []
                }
            },
            "range_180": {
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_75": {
                "input_tensor": {
                    "value": "tf.square(samples[..., 1:, :] - samples[..., :-1, :] - fx[..., :-1, :])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_73": {
                "tensor": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, samples.shape[-1])",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "square_75": {
                "x": {
                    "value": "samples[..., 1:, :] - samples[..., :-1, :] - fx[..., :-1, :]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_77": {
                "input_tensor": {
                    "value": "self.model.sde_model.diffusion.expected_diffusion()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Variable_138": {
                "initial_value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "utils/VaeFactory.py": {
        "tensorflow": {
            "convert_to_tensor_35": {
                "value": {
                    "value": "np.repeat(amplitude_dy, phase_space_dim).astype(np_floatx())",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_36": {
                "value": {
                    "value": "length_scale * np.ones((phase_space_dim, phase_space_dim)).astype(np_floatx())",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "convert_to_tensor_43": {
                "value": {
                    "value": "np.repeat(alpha, phase_space_dim).astype(np_floatx())",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_44": {
                "value": {
                    "value": "np.repeat(beta, phase_space_dim).astype(np_floatx())",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "utils/data.py": {
        "tensorflow": {
            "Example_46": {
                "variable": {
                    "value": "example",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "TFRecordWriter_45": {
                "path": {
                    "value": "destination",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(tfrecords_folder, os.path.basename(filename).split('.')[0] + '.tfrecords')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "utils/math.py": {
        "tensorflow": {
            "eye_9": {
                "variable": {
                    "value": "I",
                    "type": "variable",
                    "possible_values": []
                },
                "num_rows": {
                    "value": "M.shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "batch_shape": {
                    "value": "[M.shape[0]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "map_fn_23": {
                "variable": {
                    "value": "covariances",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "tf.linalg.inv",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "precisions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "precisions_a + precisions_b",
                            "BinOp"
                        ]
                    ]
                }
            },
            "einsum_26": {
                "variable": {
                    "value": "mus",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "aij,aj->ai",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "covariances",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(tf.linalg.inv, precisions)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "tf.einsum('aij,aj->ai', precisions_a, means_a) + tf.einsum('aij,aj->ai', precisions_b, means_b)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "maximum_87": {
                "variable": {
                    "value": "pairwise_distances_squared",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pairwise_distances_squared",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.add(tf.math.reduce_sum(tf.math.square(feature), axis=[1], keepdims=True), tf.math.reduce_sum(tf.math.square(tf.transpose(feature)), axis=[0], keepdims=True)) - 2.0 * tf.matmul(feature, tf.transpose(feature))",
                            "BinOp"
                        ],
                        [
                            "tf.math.maximum(pairwise_distances_squared, 0.0)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "less_equal_89": {
                "variable": {
                    "value": "error_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pairwise_distances_squared",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.add(tf.math.reduce_sum(tf.math.square(feature), axis=[1], keepdims=True), tf.math.reduce_sum(tf.math.square(tf.transpose(feature)), axis=[0], keepdims=True)) - 2.0 * tf.matmul(feature, tf.transpose(feature))",
                            "BinOp"
                        ],
                        [
                            "tf.math.maximum(pairwise_distances_squared, 0.0)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "multiply_101": {
                "variable": {
                    "value": "pairwise_distances",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pairwise_distances",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pairwise_distances_squared",
                            "variable"
                        ],
                        [
                            "tf.math.sqrt(pairwise_distances_squared + tf.cast(error_mask, dtype=tf.dtypes.float32) * 1e-16)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(pairwise_distances, tf.cast(tf.math.logical_not(error_mask), dtype=tf_floatx()))",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(pairwise_distances, mask_offdiagonals)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.cast(tf.math.logical_not(error_mask), dtype=tf_floatx())",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "multiply_111": {
                "variable": {
                    "value": "pairwise_distances",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pairwise_distances",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pairwise_distances_squared",
                            "variable"
                        ],
                        [
                            "tf.math.sqrt(pairwise_distances_squared + tf.cast(error_mask, dtype=tf.dtypes.float32) * 1e-16)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(pairwise_distances, tf.cast(tf.math.logical_not(error_mask), dtype=tf_floatx()))",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(pairwise_distances, mask_offdiagonals)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "mask_offdiagonals",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones_like(pairwise_distances) - tf.linalg.diag(tf.ones([num_data], dtype=tf_floatx()))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "triangular_solve_10": {
                "matrix": {
                    "value": "M",
                    "type": "variable",
                    "possible_values": []
                },
                "rhs": {
                    "value": "I",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.eye(M.shape[1], batch_shape=[M.shape[0]], dtype=tf_floatx())",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_95": {
                "variable": {
                    "value": "pairwise_distances",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pairwise_distances_squared + tf.cast(error_mask, dtype=tf.dtypes.float32) * 1e-16",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "convert_to_tensor_42": {
                "value": {
                    "value": "takens",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros((ys.shape[0], numelem, dim))",
                            "Call"
                        ],
                        [
                            "np.zeros((ys.shape[0], last_index - first_index, dim))",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_66": {
                "value": {
                    "value": "takens",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros((ys.shape[0], numelem, dim))",
                            "Call"
                        ],
                        [
                            "np.zeros((ys.shape[0], last_index - first_index, dim))",
                            "Call"
                        ]
                    ]
                }
            },
            "add_79": {
                "x": {
                    "value": "tf.math.reduce_sum(tf.math.square(feature), axis=[1], keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.math.reduce_sum(tf.math.square(tf.transpose(feature)), axis=[0], keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_103": {
                "x": {
                    "value": "tf.math.logical_not(error_mask)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_106": {
                "input": {
                    "value": "feature",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ones_like_108": {
                "input": {
                    "value": "pairwise_distances",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pairwise_distances_squared",
                            "variable"
                        ],
                        [
                            "tf.math.sqrt(pairwise_distances_squared + tf.cast(error_mask, dtype=tf.dtypes.float32) * 1e-16)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(pairwise_distances, tf.cast(tf.math.logical_not(error_mask), dtype=tf_floatx()))",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(pairwise_distances, mask_offdiagonals)",
                            "Call"
                        ]
                    ]
                }
            },
            "diag_108": {
                "diagonal": {
                    "value": "tf.ones([num_data], dtype=tf_floatx())",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "einsum_29": {
                "equation": {
                    "value": "aij,aj->ai",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "precisions_b",
                    "type": "variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "means_b",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_sum_80": {
                "input_tensor": {
                    "value": "tf.math.square(feature)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_81": {
                "input_tensor": {
                    "value": "tf.math.square(tf.transpose(feature))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "[0]",
                    "type": "List",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_84": {
                "a": {
                    "value": "feature",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "tf.transpose(feature)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_not_103": {
                "x": {
                    "value": "error_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.less_equal(pairwise_distances_squared, 0.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_109": {
                "shape": {
                    "value": "[num_data]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "square_80": {
                "x": {
                    "value": "feature",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "square_82": {
                "x": {
                    "value": "tf.transpose(feature)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "transpose_84": {
                "a": {
                    "value": "feature",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "transpose_82": {
                "a": {
                    "value": "feature",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cast_97": {
                "x": {
                    "value": "error_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.less_equal(pairwise_distances_squared, 0.0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.dtypes.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "utils/schedulers.py": {
        "tensorflow": {
            "convert_to_tensor_17": {
                "variable": {
                    "value": "self.initial_learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "initial_learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_18": {
                "variable": {
                    "value": "self.maximum_learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "maximum_learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_19": {
                "variable": {
                    "value": "self.growth_steps",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "growth_steps",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_22": {
                "variable": {
                    "value": "self._log_initial_learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.initial_learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "log_23": {
                "variable": {
                    "value": "self._log_maximum_learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.maximum_learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_48": {
                "variable": {
                    "value": "self.initial_learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "initial_learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_49": {
                "variable": {
                    "value": "self.maximum_learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "maximum_learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_51": {
                "variable": {
                    "value": "self.growth_steps",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "growth_steps",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_52": {
                "variable": {
                    "value": "self.midpoint",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "midpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_73": {
                "variable": {
                    "value": "self.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_26": {
                "name": {
                    "value": "self.name or 'NatGradSchedule'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "minimum_28": {
                "x": {
                    "value": "tf.exp(self._log_initial_learning_rate + (self._log_maximum_learning_rate - self._log_initial_learning_rate) * p)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.maximum_learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "name_scope_56": {
                "name": {
                    "value": "self.name or 'SigmoidScheduler'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "name_scope_77": {
                "name": {
                    "value": "self.name or 'ConstantSchedule'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "exp_29": {
                "x": {
                    "value": "self._log_initial_learning_rate + (self._log_maximum_learning_rate - self._log_initial_learning_rate) * p",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sigmoid_57": {
                "x": {
                    "value": "(step - self.midpoint) / self.growth_steps",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "utils/tf_utils.py": {
        "tensorflow": {
            "stack_67": {
                "values": {
                    "value": "[tf.gradients(y[i], x)[0] for i in range(n)]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "map_fn_79": {
                "fn": {
                    "value": "lambda vector: tf.scatter_nd(indices=indices, updates=vector, shape=[dimension, dimension])",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "vectors",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "to_float_12": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "name_scope_90": {
                "name": {
                    "value": "summaries",
                    "type": "str",
                    "possible_values": []
                }
            },
            "histogram_98": {
                "name": {
                    "value": "histogram",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "to_double_14": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "scatter_nd_80": {
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array(list(zip(*np.tril_indices(dimension))), dtype=np.int32)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "vector",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[dimension, dimension]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gradients_67": {
                "ys": {
                    "value": "y[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "xs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "utils/train.py": {
        "tensorflow": {
            "convert_to_tensor_72": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_87": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "bloss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gm._breaked_loss(y_input, y_target, samples, entropies, encoded_dist, decoded_dist, initial_state, effective_nb_timesteps, kl_weight)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_116": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_128": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "breaked_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gm._breaked_loss(y_input, y_target, samples, entropies, encoded_dist, decoded_dist, initial_state, effective_nb_timesteps, kl_weight)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_139": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_169": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_19": {
                "tensor": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "distro.sample(vae.mpa.nb_samples)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(*samples.shape[:2], -1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "convert_to_tensor_35": {
                "value": {
                    "value": "noise",
                    "type": "variable",
                    "possible_values": [
                        [
                            "min_noise + np.random.normal(0, noise_std, size=events.shape) * events",
                            "BinOp"
                        ]
                    ]
                }
            },
            "GradientTape_78": {
                "persistent": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "watch_accessed_variables": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "GradientTape_122": {
                "persistent": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "watch_accessed_variables": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "eye_21": {
                "num_rows": {
                    "value": "covs.shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "batch_shape": {
                    "value": "[covs.shape[0]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logdet_23": {
                "matrix": {
                    "value": "covs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfp.stats.covariance(tf.reshape(samples, (*samples.shape[:2], -1)), sample_axis=0)",
                            "Call"
                        ],
                        [
                            "covs + 1e-08 * tf.eye(covs.shape[1], batch_shape=[covs.shape[0]], dtype=tf_floatx())",
                            "BinOp"
                        ]
                    ]
                }
            },
            "clip_by_value_147": {
                "t": {
                    "value": "nat_grad",
                    "type": "variable",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "-clip_value",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "clip_value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100.0",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "log_23": {
                "x": {
                    "value": "2 * tf.constant(np.pi, dtype=tf_floatx())",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "normal_65": {
                "shape": {
                    "value": "inputs.shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "stddev": {
                    "value": "noise_std",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_23": {
                "value": {
                    "value": "np.pi",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "vaele_config.py": {
        "tensorflow": {
            "list_physical_devices_30": {
                "variable": {
                    "value": "gpus",
                    "type": "variable",
                    "possible_values": []
                },
                "device_type": {
                    "value": "GPU",
                    "type": "str",
                    "possible_values": []
                }
            },
            "set_floatx_25": {
                "value": {
                    "value": "_VAELE_DEFAULT_FLOAT_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'float64'",
                            "str"
                        ]
                    ]
                }
            },
            "floatx_41": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "as_dtype_49": {
                "type_value": {
                    "value": "np_floatx()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "set_memory_growth_35": {
                "device": {
                    "value": "gpu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gpus",
                            "variable"
                        ]
                    ]
                },
                "enable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    }
}