{
    "Drug/utils/experiment.py": {
        "sklearn": {}
    },
    "Pose/main.py": {
        "tensorflow": {
            "Sequential_188": {
                "variable": {
                    "value": "encoder_w",
                    "type": "Variable",
                    "possible_values": []
                },
                "layers": {
                    "value": "[tf.keras.layers.Conv2D(filters=32, kernel_size=3, strides=(2, 2), activation='relu', padding='SAME'), tf.keras.layers.Conv2D(filters=48, kernel_size=3, strides=(2, 2), activation='relu', padding='SAME'), tf.keras.layers.MaxPooling2D(pool_size=(2, 2)), tf.keras.layers.Conv2D(filters=64, kernel_size=3, strides=(2, 2), activation='relu', padding='SAME'), tf.keras.layers.Flatten(), tf.keras.layers.Dense(FLAGS.dim_w)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_199": {
                "variable": {
                    "value": "xa",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "xa",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(xa, [-1, 128, 128, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 128, 128, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_200": {
                "variable": {
                    "value": "xb",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "xb",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(xb, [-1, 128, 128, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 128, 128, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_203": {
                "variable": {
                    "value": "inputa",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputa",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "encoder_w(xa)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputa, [-1, FLAGS.update_batch_size * FLAGS.num_classes, FLAGS.dim_w])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, FLAGS.update_batch_size * FLAGS.num_classes, FLAGS.dim_w]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_206": {
                "variable": {
                    "value": "inputb",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputb",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "encoder_w(xb)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputb, [-1, FLAGS.update_batch_size * FLAGS.num_classes, FLAGS.dim_w])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, FLAGS.update_batch_size * FLAGS.num_classes, FLAGS.dim_w]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_215": {
                "variable": {
                    "value": "xa_val",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "xa_val",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(xa_val, [-1, 128, 128, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 128, 128, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_216": {
                "variable": {
                    "value": "xb_val",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "xb_val",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(xb_val, [-1, 128, 128, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 128, 128, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_219": {
                "variable": {
                    "value": "inputa_val",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputa_val",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "encoder_w(xa_val)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputa_val, [-1, FLAGS.update_batch_size * FLAGS.num_classes, FLAGS.dim_w])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, FLAGS.update_batch_size * FLAGS.num_classes, FLAGS.dim_w]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_224": {
                "variable": {
                    "value": "inputb_val",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputb_val",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "encoder_w(xb_val)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputb_val, [-1, FLAGS.update_batch_size * FLAGS.num_classes, FLAGS.dim_w])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, FLAGS.update_batch_size * FLAGS.num_classes, FLAGS.dim_w]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "merge_all_241": {
                "variable": {
                    "value": "model.summ_op",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "InteractiveSession_242": {
                "variable": {
                    "value": "sess",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_246": {
                "variable": {
                    "value": "saver",
                    "type": "Variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES)",
                    "type": "Call",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "60",
                    "type": "int",
                    "possible_values": []
                }
            },
            "global_variables_initializer_87": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_87": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_244": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_244": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_201": {
                "name_or_scope": {
                    "value": "encoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_246": {
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TensorShape_167": {
                "dims": {
                    "value": "[None, FLAGS.update_batch_size * FLAGS.num_classes, dim_input]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_169": {
                "dims": {
                    "value": "[None, FLAGS.update_batch_size * FLAGS.num_classes, dim_output]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_171": {
                "dims": {
                    "value": "[None, FLAGS.update_batch_size * FLAGS.num_classes, dim_input]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_173": {
                "dims": {
                    "value": "[None, FLAGS.update_batch_size * FLAGS.num_classes, dim_output]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_179": {
                "dims": {
                    "value": "[None, FLAGS.update_batch_size * FLAGS.num_classes, dim_input]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_181": {
                "dims": {
                    "value": "[None, FLAGS.update_batch_size * FLAGS.num_classes, dim_output]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_183": {
                "dims": {
                    "value": "[None, FLAGS.update_batch_size * FLAGS.num_classes, dim_input]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_185": {
                "dims": {
                    "value": "[None, FLAGS.update_batch_size * FLAGS.num_classes, dim_output]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Conv2D_189": {
                "filters": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Conv2D_191": {
                "filters": {
                    "value": "48",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MaxPooling2D_192": {
                "pool_size": {
                    "value": "(2, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Conv2D_193": {
                "filters": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Flatten_194": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Dense_195": {
                "units": {
                    "value": "FLAGS.dim_w",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "Pose/maml.py": {
        "tensorflow": {
            "range_27": {
                "variable": {
                    "value": "index",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "shuffle_28": {
                "variable": {
                    "value": "shuffled_index",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "index",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.range(FLAGS.update_batch_size)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_35": {
                "variable": {
                    "value": "pred",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "pred",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(pred, [-1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_36": {
                "variable": {
                    "value": "label",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "label",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(label, [-1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_37": {
                "input_tensor": {
                    "value": "tf.square(pred - label)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "placeholder_with_default_45": {
                "variable": {
                    "value": "self.meta_lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "FLAGS.meta_lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "get_variable_230": {
                "variable": {
                    "value": "weights[conv1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "conv1",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[k, k, self.channels, self.dim_hidden]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "conv_initializer",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "contrib_layers.xavier_initializer_conv2d(dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                }
            },
            "Variable_234": {
                "variable": {
                    "value": "weights[b1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.zeros([self.dim_hidden])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_235": {
                "variable": {
                    "value": "weights[conv2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "conv2",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[k, k, self.dim_hidden, self.dim_hidden]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "conv_initializer",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "contrib_layers.xavier_initializer_conv2d(dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                }
            },
            "Variable_239": {
                "variable": {
                    "value": "weights[b2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.zeros([self.dim_hidden])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_240": {
                "variable": {
                    "value": "weights[conv3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "conv3",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[k, k, self.dim_hidden, self.dim_hidden]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "conv_initializer",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "contrib_layers.xavier_initializer_conv2d(dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                }
            },
            "Variable_244": {
                "variable": {
                    "value": "weights[b3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.zeros([self.dim_hidden])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_245": {
                "variable": {
                    "value": "weights[conv4]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "conv4",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[k, k, self.dim_hidden, self.dim_hidden]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "conv_initializer",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "contrib_layers.xavier_initializer_conv2d(dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Attribute"
                        ]
                    ]
                }
            },
            "Variable_249": {
                "variable": {
                    "value": "weights[b4]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.zeros([self.dim_hidden])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Variable_251": {
                "variable": {
                    "value": "weights[w5]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.random_normal([self.dim_hidden, self.dim_output])",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "w5",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Variable_253": {
                "variable": {
                    "value": "weights[b5]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.zeros([self.dim_output])",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "b5",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_258": {
                "variable": {
                    "value": "inp",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inp",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(inp, [-1, self.img_size, self.img_size, channels])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, self.img_size, self.img_size, channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_269": {
                "variable": {
                    "value": "hidden4",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "hidden4",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "conv_block(hidden3, weights['conv4'], weights['b4'], reuse, scope + '3')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(hidden4, [1, 2])",
                            "Call"
                        ],
                        [
                            "conv_block(hidden3_query, weights['conv4'], weights['b4'], reuse, scope + '3')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(hidden4, [1, 2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "uniform_274": {
                "variable": {
                    "value": "sel_layer",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_278": {
                "variable": {
                    "value": "(mixed_inp, reweighted_target)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.equal(sel_layer, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : mixup_data(inp_support, label_support, inp_query, label_query)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (mixed_inp, reweighted_target)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "reshape_283": {
                "variable": {
                    "value": "mixed_inp",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "mixed_inp",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inp_query",
                            "Name"
                        ],
                        [
                            "tf.reshape(mixed_inp, [-1, self.img_size, self.img_size, channels])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, self.img_size, self.img_size, channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_285": {
                "variable": {
                    "value": "inp_support",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inp_support",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(inp_support, [-1, self.img_size, self.img_size, channels])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, self.img_size, self.img_size, channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cond_292": {
                "variable": {
                    "value": "(hidden1_query, reweighted_target)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.equal(sel_layer, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : mixup_data(hidden1_support, label_support, hidden1_query, label_query)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (hidden1_query, reweighted_target)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_302": {
                "variable": {
                    "value": "(hidden2_query, reweighted_target)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.equal(sel_layer, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : mixup_data(hidden2_support, label_support, hidden2_query, label_query)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (hidden2_query, reweighted_target)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_312": {
                "variable": {
                    "value": "(hidden3_query, reweighted_target)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.equal(sel_layer, 3)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : mixup_data(hidden3_support, label_support, hidden3_query, label_query)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (hidden3_query, reweighted_target)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "reduce_mean_320": {
                "variable": {
                    "value": "hidden4",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "hidden4",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "conv_block(hidden3, weights['conv4'], weights['b4'], reuse, scope + '3')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(hidden4, [1, 2])",
                            "Call"
                        ],
                        [
                            "conv_block(hidden3_query, weights['conv4'], weights['b4'], reuse, scope + '3')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(hidden4, [1, 2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "conv2d_16": {
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, weight, [1, 1, 1, 1], 'SAME') + bias",
                            "BinOp"
                        ],
                        [
                            "tf_layers.batch_norm(x, activation_fn=tf.nn.relu, reuse=reuse, scope=scope)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "weight",
                    "type": "Variable",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "square_37": {
                "x": {
                    "value": "pred - label",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "map_fn_154": {
                "variable": {
                    "value": "result",
                    "type": "Variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "task_metalearn",
                    "type": "Variable",
                    "possible_values": []
                },
                "elems": {
                    "value": "(self.inputa, self.inputb, self.labela, self.labelb)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "out_dtype",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[tf.float32, [tf.float32] * 2, [tf.float32] * 2, [tf.float32] * 2, [tf.float32] * 2]",
                            "List"
                        ]
                    ]
                },
                "parallel_iterations": {
                    "value": "FLAGS.meta_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_218": {
                "name": {
                    "value": "prefix + 'Pre-mse'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "total_losses2[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "scalar_219": {
                "name": {
                    "value": "prefix + 'Post-mse_' + str(num_updates)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "total_losses2[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "gather_29": {
                "params": {
                    "value": "x_support",
                    "type": "Variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "shuffled_index",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.random.shuffle(index)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_30": {
                "params": {
                    "value": "y_support",
                    "type": "Variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "shuffled_index",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.random.shuffle(index)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_67": {
                "name_or_scope": {
                    "value": "model",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "gradients_87": {
                "variable": {
                    "value": "grads",
                    "type": "Variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "task_lossa",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.loss_func(task_outputa, labela)",
                            "Call"
                        ]
                    ]
                },
                "xs": {
                    "value": "list(weights.values())",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "AdamOptimizer_178": {
                "variable": {
                    "value": "optimizer",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.meta_lr",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_collection_179": {
                "variable": {
                    "value": "THETA",
                    "type": "Variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.GLOBAL_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "model",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_180": {
                "variable": {
                    "value": "PHI",
                    "type": "Variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.GLOBAL_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "encoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_197": {
                "variable": {
                    "value": "scale_norm",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "scale_norm",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[tf.reduce_mean(v) for v in scale_v]",
                            "ListComp"
                        ],
                        [
                            "tf.reduce_mean(scale_norm)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_234": {
                "shape": {
                    "value": "[self.dim_hidden]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_239": {
                "shape": {
                    "value": "[self.dim_hidden]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_244": {
                "shape": {
                    "value": "[self.dim_hidden]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_249": {
                "shape": {
                    "value": "[self.dim_hidden]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_253": {
                "shape": {
                    "value": "[self.dim_output]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_271": {
                "a": {
                    "value": "hidden4",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "conv_block(hidden3, weights['conv4'], weights['b4'], reuse, scope + '3')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(hidden4, [1, 2])",
                            "Call"
                        ],
                        [
                            "conv_block(hidden3_query, weights['conv4'], weights['b4'], reuse, scope + '3')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(hidden4, [1, 2])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weights['w5']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "equal_278": {
                "x": {
                    "value": "sel_layer",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.random.uniform(shape=(), minval=0, maxval=4, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_292": {
                "x": {
                    "value": "sel_layer",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.random.uniform(shape=(), minval=0, maxval=4, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_302": {
                "x": {
                    "value": "sel_layer",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.random.uniform(shape=(), minval=0, maxval=4, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_312": {
                "x": {
                    "value": "sel_layer",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.random.uniform(shape=(), minval=0, maxval=4, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gradients_114": {
                "variable": {
                    "value": "grads",
                    "type": "Variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.loss_func(self.forward(inputa, fast_weights, reuse=True), labela)",
                            "Call"
                        ]
                    ]
                },
                "xs": {
                    "value": "list(fast_weights.values())",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "no_op_191": {
                "variable": {
                    "value": "self.metatrain_op",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_199": {
                "name": {
                    "value": "prefix + 'full_loss'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "total_losses3[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "scalar_200": {
                "name": {
                    "value": "prefix + 'regularizer'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "total_losses3[-1] - total_losses2[-1]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scalar_202": {
                "name": {
                    "value": "prefix + 'untransformed_scale'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "scale_norm",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[tf.reduce_mean(v) for v in scale_v]",
                            "ListComp"
                        ],
                        [
                            "tf.reduce_mean(scale_norm)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_322": {
                "a": {
                    "value": "hidden4",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "conv_block(hidden3, weights['conv4'], weights['b4'], reuse, scope + '3')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(hidden4, [1, 2])",
                            "Call"
                        ],
                        [
                            "conv_block(hidden3_query, weights['conv4'], weights['b4'], reuse, scope + '3')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(hidden4, [1, 2])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weights['w5']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_162": {
                "input_tensor": {
                    "value": "lossesa[j]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_float_162": {
                "x": {
                    "value": "FLAGS.meta_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_166": {
                "input_tensor": {
                    "value": "msesb[j]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_float_166": {
                "x": {
                    "value": "FLAGS.meta_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_170": {
                "input_tensor": {
                    "value": "lossesb[j]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_float_170": {
                "x": {
                    "value": "FLAGS.meta_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "control_dependencies_190": {
                "control_inputs": {
                    "value": "[metatrain_theta_op, metatrain_phi_op]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_196": {
                "input_tensor": {
                    "value": "v",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reduce_sum_206": {
                "input_tensor": {
                    "value": "lossesa[j]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_float_206": {
                "x": {
                    "value": "FLAGS.meta_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_210": {
                "input_tensor": {
                    "value": "msesb[j]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_float_210": {
                "x": {
                    "value": "FLAGS.meta_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_214": {
                "input_tensor": {
                    "value": "lossesb[j]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_float_214": {
                "x": {
                    "value": "FLAGS.meta_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stop_gradient_89": {
                "input": {
                    "value": "grad",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "stop_gradient_116": {
                "input": {
                    "value": "grad",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        }
    },
    "Drug/data.py": {
        "torch": {
            "DataLoader_346": {
                "dataset": {
                    "value": "self.dataset",
                    "type": "Attribute",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "num_workers": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "drop_last": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "Drug/experiment_builder.py": {
        "torch": {}
    },
    "Drug/few_shot_learning_system.py": {
        "torch": {
            "manual_seed_22": {
                "seed": {
                    "value": "torch_seed",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "rng.randint(0, 999999)",
                            "Call"
                        ]
                    ]
                }
            },
            "Adam_63": {
                "variable": {
                    "value": "self.optimizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "self.trainable_parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "args.meta_lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "amsgrad": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "CosineAnnealingLR_64": {
                "variable": {
                    "value": "self.scheduler",
                    "type": "Attribute",
                    "possible_values": []
                },
                "optimizer": {
                    "value": "self.optimizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "T_max": {
                    "value": "self.args.metatrain_iterations",
                    "type": "Attribute",
                    "possible_values": []
                },
                "eta_min": {
                    "value": "self.args.min_learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Tensor_81": {
                "variable": {
                    "value": "loss_weights",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "grad_104": {
                "variable": {
                    "value": "grads",
                    "type": "Variable",
                    "possible_values": []
                },
                "outputs": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "F.mse_loss(input=preds, target=y.unsqueeze(dim=-1))",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "names_weights_copy.values()",
                    "type": "Call",
                    "possible_values": []
                },
                "create_graph": {
                    "value": "use_second_order",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "mean_117": {
                "variable": {
                    "value": "losses[loss]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "torch.stack(total_losses)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mse_loss_278": {
                "variable": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "preds",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.regressor.forward(x=x, params=weights, training=training, backup_running_statistics=backup_running_statistics, num_step=num_step, mixup=mixup, lam=lam)",
                            "Call"
                        ],
                        [
                            "preds[:int(npreds / 2), :]",
                            "Subscript"
                        ]
                    ]
                },
                "target": {
                    "value": "y.unsqueeze(dim=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "load_356": {
                "variable": {
                    "value": "state",
                    "type": "Variable",
                    "possible_values": []
                },
                "f": {
                    "value": "filepath",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "os.path.join(model_save_dir, '{}_{}'.format(model_name, model_idx))",
                            "Call"
                        ]
                    ]
                }
            },
            "Tensor_150": {
                "variable": {
                    "value": "support_set_x_task",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "Tensor_151": {
                "variable": {
                    "value": "support_set_y_task",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "Tensor_154": {
                "variable": {
                    "value": "target_set_x_task",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "Tensor_155": {
                "variable": {
                    "value": "target_set_y_task",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "sum_253": {
                "variable": {
                    "value": "task_losses",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "torch.stack(task_losses)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "save_351": {
                "obj": {
                    "value": "state",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "torch.load(filepath)",
                            "Call"
                        ]
                    ]
                },
                "f": {
                    "value": "model_save_dir",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "stack_117": {
                "tensors": {
                    "value": "total_losses",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "stack_253": {
                "tensors": {
                    "value": "task_losses",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.sum(torch.stack(task_losses))",
                            "Call"
                        ]
                    ]
                }
            },
            "randperm_195": {
                "variable": {
                    "value": "indices",
                    "type": "Variable",
                    "possible_values": []
                },
                "n": {
                    "value": "ns",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "cat_198": {
                "variable": {
                    "value": "mixed_set_x_task",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(support_set_x_task[indices, :][:nt, :], target_set_x_task)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "randperm_217": {
                "variable": {
                    "value": "indices",
                    "type": "Variable",
                    "possible_values": []
                },
                "n": {
                    "value": "ns",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "cat_219": {
                "variable": {
                    "value": "mixed_set_x_task",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(support_set_x_task[indices, :][:nt, :], target_set_x_task)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "Drug/inner_loop_optimizers.py": {
        "torch": {
            "ParameterDict_89": {
                "variable": {
                    "value": "self.names_learning_rates_dict",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Parameter_91": {
                "variable": {
                    "value": "self.names_learning_rates_dict[key.replace(., -)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.ones(self.total_num_inner_loop_steps + 1) * self.init_learning_rate",
                    "type": "BinOp",
                    "possible_values": []
                },
                "requires_grad": {
                    "value": "self.use_learnable_learning_rates",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_36": {
                "*size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_83": {
                "*size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_92": {
                "*size": {
                    "value": "self.total_num_inner_loop_steps + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "Drug/main.py": {
        "torch": {
            "is_available_77": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Adam_155": {
                "variable": {
                    "value": "meta_optimiser",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "list(maml.parameters())",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "args.meta_lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "weight_decay": {
                    "value": "args.weight_decay",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "load_153": {
                "f": {
                    "value": "model_file",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'{0}/{2}/model{1}'.format(args.logdir, args.test_epoch, exp_string)",
                            "Call"
                        ],
                        [
                            "'{0}/{2}/model{1}'.format(args.logdir, args.test_epoch, exp_string)",
                            "Call"
                        ]
                    ]
                }
            },
            "load_165": {
                "f": {
                    "value": "model_file",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'{0}/{2}/model{1}'.format(args.logdir, args.test_epoch, exp_string)",
                            "Call"
                        ],
                        [
                            "'{0}/{2}/model{1}'.format(args.logdir, args.test_epoch, exp_string)",
                            "Call"
                        ]
                    ]
                }
            },
            "save_118": {
                "obj": {
                    "value": "maml.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "'{0}/{2}/model{1}'.format(args.logdir, step + epoch * data_each_epoch, exp_string)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "Drug/meta_neural_network_architectures.py": {
        "torch": {
            "Parameter_60": {
                "variable": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.empty(num_filters, in_channels, kernel_size, kernel_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "conv2d_89": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "torch.zeros(self.input_shape)",
                            "Call"
                        ],
                        [
                            "torch.zeros(self.input_shape)",
                            "Call"
                        ],
                        [
                            "torch.zeros(self.input_shape)",
                            "Call"
                        ],
                        [
                            "torch.zeros(self.input_shape)",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "weight",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "params['weight']",
                            "Subscript"
                        ],
                        [
                            "self.weight",
                            "Attribute"
                        ],
                        [
                            "params['weights']",
                            "Subscript"
                        ],
                        [
                            "self.weights",
                            "Attribute"
                        ],
                        [
                            "self.weight[num_step]",
                            "Subscript"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "self.bias[num_step]",
                            "Subscript"
                        ],
                        [
                            "params['bias']",
                            "Subscript"
                        ],
                        [
                            "self.bias",
                            "Attribute"
                        ]
                    ]
                },
                "stride": {
                    "value": "self.stride",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding": {
                    "value": "self.padding",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dilation": {
                    "value": "self.dilation_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "groups": {
                    "value": "self.groups",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Parameter_109": {
                "variable": {
                    "value": "self.weights",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.ones(hidden_dim, c)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "linear_140": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "torch.zeros(self.input_shape)",
                            "Call"
                        ],
                        [
                            "torch.zeros(self.input_shape)",
                            "Call"
                        ],
                        [
                            "torch.zeros(self.input_shape)",
                            "Call"
                        ],
                        [
                            "torch.zeros(self.input_shape)",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "weight",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "params['weight']",
                            "Subscript"
                        ],
                        [
                            "self.weight",
                            "Attribute"
                        ],
                        [
                            "params['weights']",
                            "Subscript"
                        ],
                        [
                            "self.weights",
                            "Attribute"
                        ],
                        [
                            "self.weight[num_step]",
                            "Subscript"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "self.bias[num_step]",
                            "Subscript"
                        ],
                        [
                            "params['bias']",
                            "Subscript"
                        ],
                        [
                            "self.bias",
                            "Attribute"
                        ]
                    ]
                }
            },
            "zeros_199": {
                "variable": {
                    "value": "self.backup_running_mean",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*size": {
                    "value": "self.running_mean.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_200": {
                "variable": {
                    "value": "self.backup_running_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*size": {
                    "value": "self.running_var.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "batch_norm_243": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input",
                    "type": "Variable",
                    "possible_values": []
                },
                "running_mean": {
                    "value": "running_mean",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.running_mean[num_step]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "Constant"
                        ]
                    ]
                },
                "running_var": {
                    "value": "running_var",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.running_var[num_step]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "Constant"
                        ]
                    ]
                },
                "weight": {
                    "value": "weight",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "params['weight']",
                            "Subscript"
                        ],
                        [
                            "self.weight",
                            "Attribute"
                        ],
                        [
                            "params['weights']",
                            "Subscript"
                        ],
                        [
                            "self.weights",
                            "Attribute"
                        ],
                        [
                            "self.weight[num_step]",
                            "Subscript"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "self.bias[num_step]",
                            "Subscript"
                        ],
                        [
                            "params['bias']",
                            "Subscript"
                        ],
                        [
                            "self.bias",
                            "Attribute"
                        ]
                    ]
                },
                "training": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "momentum": {
                    "value": "momentum",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.momentum",
                            "Attribute"
                        ],
                        [
                            "0.1",
                            "MethodArgument"
                        ]
                    ]
                },
                "eps": {
                    "value": "self.eps",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ModuleDict_352": {
                "variable": {
                    "value": "self.layer_dict",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_357": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "self.input_shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "leaky_relu_381": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "F.conv2d(input=x, weight=weight, bias=bias, stride=self.stride, padding=self.padding, dilation=self.dilation_rate, groups=self.groups)",
                            "Call"
                        ],
                        [
                            "F.linear(input=x, weight=weight, bias=bias)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.conv(out)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "self.norm_layer(out, num_step=0)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.conv(out, params=conv_params)",
                            "Call"
                        ],
                        [
                            "self.norm_layer.forward(out, num_step=num_step, params=batch_norm_params, training=training, backup_running_statistics=backup_running_statistics)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.linear(out)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "self.norm_layer(out, num_step=0)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.linear(out, params=linear_params)",
                            "Call"
                        ],
                        [
                            "self.norm_layer.forward(out, num_step=num_step, params=batch_norm_params, training=training, backup_running_statistics=backup_running_statistics)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.layer_dict['activation_function_pre'].forward(self.conv.forward(out))",
                            "Call"
                        ],
                        [
                            "self.norm_layer.forward(out, num_step=0)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.norm_layer.forward(out, num_step=num_step, params=batch_norm_params, training=training, backup_running_statistics=backup_running_statistics)",
                            "Call"
                        ],
                        [
                            "self.conv.forward(out, params=conv_params)",
                            "Call"
                        ],
                        [
                            "self.layer_dict['activation_function_pre'].forward(out)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.layer_dict['linear{}'.format(i)](out, training=True, num_step=0)",
                            "Call"
                        ],
                        [
                            "self.layer_dict['linear'](out)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "torch.cat((out0, out0), dim=0)",
                            "Call"
                        ],
                        [
                            "self.layer_dict['linear{}'.format(i)](out, params=param_dict['linear{}'.format(i)], training=training, backup_running_statistics=backup_running_statistics, num_step=num_step)",
                            "Call"
                        ],
                        [
                            "torch.cat((out0, out0), dim=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "leaky_relu_424": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "F.conv2d(input=x, weight=weight, bias=bias, stride=self.stride, padding=self.padding, dilation=self.dilation_rate, groups=self.groups)",
                            "Call"
                        ],
                        [
                            "F.linear(input=x, weight=weight, bias=bias)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.conv(out)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "self.norm_layer(out, num_step=0)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.conv(out, params=conv_params)",
                            "Call"
                        ],
                        [
                            "self.norm_layer.forward(out, num_step=num_step, params=batch_norm_params, training=training, backup_running_statistics=backup_running_statistics)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.linear(out)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "self.norm_layer(out, num_step=0)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.linear(out, params=linear_params)",
                            "Call"
                        ],
                        [
                            "self.norm_layer.forward(out, num_step=num_step, params=batch_norm_params, training=training, backup_running_statistics=backup_running_statistics)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.layer_dict['activation_function_pre'].forward(self.conv.forward(out))",
                            "Call"
                        ],
                        [
                            "self.norm_layer.forward(out, num_step=0)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.norm_layer.forward(out, num_step=num_step, params=batch_norm_params, training=training, backup_running_statistics=backup_running_statistics)",
                            "Call"
                        ],
                        [
                            "self.conv.forward(out, params=conv_params)",
                            "Call"
                        ],
                        [
                            "self.layer_dict['activation_function_pre'].forward(out)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.layer_dict['linear{}'.format(i)](out, training=True, num_step=0)",
                            "Call"
                        ],
                        [
                            "self.layer_dict['linear'](out)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "torch.cat((out0, out0), dim=0)",
                            "Call"
                        ],
                        [
                            "self.layer_dict['linear{}'.format(i)](out, params=param_dict['linear{}'.format(i)], training=training, backup_running_statistics=backup_running_statistics, num_step=num_step)",
                            "Call"
                        ],
                        [
                            "torch.cat((out0, out0), dim=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "ModuleDict_462": {
                "variable": {
                    "value": "self.layer_dict",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_467": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "self.input_shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "leaky_relu_487": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "F.conv2d(input=x, weight=weight, bias=bias, stride=self.stride, padding=self.padding, dilation=self.dilation_rate, groups=self.groups)",
                            "Call"
                        ],
                        [
                            "F.linear(input=x, weight=weight, bias=bias)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.conv(out)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "self.norm_layer(out, num_step=0)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.conv(out, params=conv_params)",
                            "Call"
                        ],
                        [
                            "self.norm_layer.forward(out, num_step=num_step, params=batch_norm_params, training=training, backup_running_statistics=backup_running_statistics)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.linear(out)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "self.norm_layer(out, num_step=0)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.linear(out, params=linear_params)",
                            "Call"
                        ],
                        [
                            "self.norm_layer.forward(out, num_step=num_step, params=batch_norm_params, training=training, backup_running_statistics=backup_running_statistics)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.layer_dict['activation_function_pre'].forward(self.conv.forward(out))",
                            "Call"
                        ],
                        [
                            "self.norm_layer.forward(out, num_step=0)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.norm_layer.forward(out, num_step=num_step, params=batch_norm_params, training=training, backup_running_statistics=backup_running_statistics)",
                            "Call"
                        ],
                        [
                            "self.conv.forward(out, params=conv_params)",
                            "Call"
                        ],
                        [
                            "self.layer_dict['activation_function_pre'].forward(out)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.layer_dict['linear{}'.format(i)](out, training=True, num_step=0)",
                            "Call"
                        ],
                        [
                            "self.layer_dict['linear'](out)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "torch.cat((out0, out0), dim=0)",
                            "Call"
                        ],
                        [
                            "self.layer_dict['linear{}'.format(i)](out, params=param_dict['linear{}'.format(i)], training=training, backup_running_statistics=backup_running_statistics, num_step=num_step)",
                            "Call"
                        ],
                        [
                            "torch.cat((out0, out0), dim=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "leaky_relu_532": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "F.conv2d(input=x, weight=weight, bias=bias, stride=self.stride, padding=self.padding, dilation=self.dilation_rate, groups=self.groups)",
                            "Call"
                        ],
                        [
                            "F.linear(input=x, weight=weight, bias=bias)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.conv(out)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "self.norm_layer(out, num_step=0)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.conv(out, params=conv_params)",
                            "Call"
                        ],
                        [
                            "self.norm_layer.forward(out, num_step=num_step, params=batch_norm_params, training=training, backup_running_statistics=backup_running_statistics)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.linear(out)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "self.norm_layer(out, num_step=0)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.linear(out, params=linear_params)",
                            "Call"
                        ],
                        [
                            "self.norm_layer.forward(out, num_step=num_step, params=batch_norm_params, training=training, backup_running_statistics=backup_running_statistics)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.layer_dict['activation_function_pre'].forward(self.conv.forward(out))",
                            "Call"
                        ],
                        [
                            "self.norm_layer.forward(out, num_step=0)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.norm_layer.forward(out, num_step=num_step, params=batch_norm_params, training=training, backup_running_statistics=backup_running_statistics)",
                            "Call"
                        ],
                        [
                            "self.conv.forward(out, params=conv_params)",
                            "Call"
                        ],
                        [
                            "self.layer_dict['activation_function_pre'].forward(out)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.layer_dict['linear{}'.format(i)](out, training=True, num_step=0)",
                            "Call"
                        ],
                        [
                            "self.layer_dict['linear'](out)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "torch.cat((out0, out0), dim=0)",
                            "Call"
                        ],
                        [
                            "self.layer_dict['linear{}'.format(i)](out, params=param_dict['linear{}'.format(i)], training=training, backup_running_statistics=backup_running_statistics, num_step=num_step)",
                            "Call"
                        ],
                        [
                            "torch.cat((out0, out0), dim=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "ModuleDict_574": {
                "variable": {
                    "value": "self.layer_dict",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_579": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "self.input_shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "LeakyReLU_598": {
                "variable": {
                    "value": "self.layer_dict[activation_function_pre]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_683": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "self.input_shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ModuleDict_685": {
                "variable": {
                    "value": "self.layer_dict",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "leaky_relu_705": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "F.conv2d(input=x, weight=weight, bias=bias, stride=self.stride, padding=self.padding, dilation=self.dilation_rate, groups=self.groups)",
                            "Call"
                        ],
                        [
                            "F.linear(input=x, weight=weight, bias=bias)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.conv(out)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "self.norm_layer(out, num_step=0)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.conv(out, params=conv_params)",
                            "Call"
                        ],
                        [
                            "self.norm_layer.forward(out, num_step=num_step, params=batch_norm_params, training=training, backup_running_statistics=backup_running_statistics)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.linear(out)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "self.norm_layer(out, num_step=0)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.linear(out, params=linear_params)",
                            "Call"
                        ],
                        [
                            "self.norm_layer.forward(out, num_step=num_step, params=batch_norm_params, training=training, backup_running_statistics=backup_running_statistics)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.layer_dict['activation_function_pre'].forward(self.conv.forward(out))",
                            "Call"
                        ],
                        [
                            "self.norm_layer.forward(out, num_step=0)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.norm_layer.forward(out, num_step=num_step, params=batch_norm_params, training=training, backup_running_statistics=backup_running_statistics)",
                            "Call"
                        ],
                        [
                            "self.conv.forward(out, params=conv_params)",
                            "Call"
                        ],
                        [
                            "self.layer_dict['activation_function_pre'].forward(out)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.layer_dict['linear{}'.format(i)](out, training=True, num_step=0)",
                            "Call"
                        ],
                        [
                            "self.layer_dict['linear'](out)",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out)",
                            "Call"
                        ],
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "torch.cat((out0, out0), dim=0)",
                            "Call"
                        ],
                        [
                            "self.layer_dict['linear{}'.format(i)](out, params=param_dict['linear{}'.format(i)], training=training, backup_running_statistics=backup_running_statistics, num_step=num_step)",
                            "Call"
                        ],
                        [
                            "torch.cat((out0, out0), dim=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "leaky_relu_756": {
                "variable": {
                    "value": "out1",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out1",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.layer_dict['linear'](out, param_dict['linear'])",
                            "Call"
                        ],
                        [
                            "F.leaky_relu(out1)",
                            "Call"
                        ]
                    ]
                }
            },
            "Parameter_64": {
                "variable": {
                    "value": "self.bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.zeros(num_filters)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_112": {
                "variable": {
                    "value": "self.bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.zeros(hidden_dim)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_177": {
                "variable": {
                    "value": "self.running_mean",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.zeros(args.num_updates, num_features)",
                    "type": "Call",
                    "possible_values": []
                },
                "requires_grad": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Parameter_179": {
                "variable": {
                    "value": "self.running_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.ones(args.num_updates, num_features)",
                    "type": "Call",
                    "possible_values": []
                },
                "requires_grad": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Parameter_181": {
                "variable": {
                    "value": "self.bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.zeros(args.num_updates, num_features)",
                    "type": "Call",
                    "possible_values": []
                },
                "requires_grad": {
                    "value": "self.learnable_beta",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Parameter_183": {
                "variable": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.ones(args.num_updates, num_features)",
                    "type": "Call",
                    "possible_values": []
                },
                "requires_grad": {
                    "value": "self.learnable_gamma",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Parameter_186": {
                "variable": {
                    "value": "self.running_mean",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.zeros(num_features)",
                    "type": "Call",
                    "possible_values": []
                },
                "requires_grad": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Parameter_187": {
                "variable": {
                    "value": "self.running_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.zeros(num_features)",
                    "type": "Call",
                    "possible_values": []
                },
                "requires_grad": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Parameter_188": {
                "variable": {
                    "value": "self.bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.zeros(num_features)",
                    "type": "Call",
                    "possible_values": []
                },
                "requires_grad": {
                    "value": "self.learnable_beta",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Parameter_190": {
                "variable": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.ones(num_features)",
                    "type": "Call",
                    "possible_values": []
                },
                "requires_grad": {
                    "value": "self.learnable_gamma",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Parameter_194": {
                "variable": {
                    "value": "self.bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.zeros(num_features)",
                    "type": "Call",
                    "possible_values": []
                },
                "requires_grad": {
                    "value": "self.learnable_beta",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Parameter_196": {
                "variable": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.ones(num_features)",
                    "type": "Call",
                    "possible_values": []
                },
                "requires_grad": {
                    "value": "self.learnable_gamma",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Parameter_253": {
                "variable": {
                    "value": "self.running_mean",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "self.backup_running_mean.cuda()",
                    "type": "Call",
                    "possible_values": []
                },
                "requires_grad": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Parameter_254": {
                "variable": {
                    "value": "self.running_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "self.backup_running_var.cuda()",
                    "type": "Call",
                    "possible_values": []
                },
                "requires_grad": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Parameter_279": {
                "variable": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(*input_feature_shape)",
                    "type": "Call",
                    "possible_values": []
                },
                "requires_grad": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Parameter_280": {
                "variable": {
                    "value": "self.bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(*input_feature_shape)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "layer_norm_314": {
                "input": {
                    "value": "input",
                    "type": "Variable",
                    "possible_values": []
                },
                "normalized_shape": {
                    "value": "self.normalized_shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "weight": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias": {
                    "value": "bias",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "self.bias[num_step]",
                            "Subscript"
                        ],
                        [
                            "params['bias']",
                            "Subscript"
                        ],
                        [
                            "self.bias",
                            "Attribute"
                        ]
                    ]
                },
                "eps": {
                    "value": "self.eps",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cat_743": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(out0, out0)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "empty_60": {
                "*size": {
                    "value": "num_filters",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "out_channels",
                            "Name"
                        ]
                    ]
                },
                "out": {
                    "value": "in_channels",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "kernel_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "layout": {
                    "value": "kernel_size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "ones_109": {
                "*size": {
                    "value": "hidden_dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "out": {
                    "value": "c",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "cat_751": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(out0, out0)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_64": {
                "*size": {
                    "value": "num_filters",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "out_channels",
                            "Name"
                        ]
                    ]
                }
            },
            "zeros_112": {
                "*size": {
                    "value": "hidden_dim",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "zeros_177": {
                "*size": {
                    "value": "args.num_updates",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out": {
                    "value": "num_features",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "ones_179": {
                "*size": {
                    "value": "args.num_updates",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out": {
                    "value": "num_features",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "zeros_181": {
                "*size": {
                    "value": "args.num_updates",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out": {
                    "value": "num_features",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "ones_183": {
                "*size": {
                    "value": "args.num_updates",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out": {
                    "value": "num_features",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "zeros_186": {
                "*size": {
                    "value": "num_features",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "zeros_187": {
                "*size": {
                    "value": "num_features",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "zeros_188": {
                "*size": {
                    "value": "num_features",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "ones_190": {
                "*size": {
                    "value": "num_features",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "zeros_194": {
                "*size": {
                    "value": "num_features",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "ones_196": {
                "*size": {
                    "value": "num_features",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "sum_768": {
                "input": {
                    "value": "param.grad",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sum_775": {
                "input": {
                    "value": "param.grad",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "Drug/utils/data_target_assay_list.py": {
        "torch": {
            "DataLoader_290": {
                "dataset": {
                    "value": "self.dataset",
                    "type": "Attribute",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "num_workers": {
                    "value": "self.num_workers",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "drop_last": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "miniImagenet/data_generator.py": {
        "torch": {
            "tensor_26": {
                "variable": {
                    "value": "self.data",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "np.transpose(self.data / np.float32(255), (0, 1, 4, 2, 3))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_39": {
                "*size": {
                    "value": "(self.args.meta_batch_size, self.set_size, 3, 84, 84)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "zeros_40": {
                "*size": {
                    "value": "(self.args.meta_batch_size, self.query_size, 3, 84, 84)",
                    "type": "Tuple",
                    "possible_values": []
                }
            }
        }
    },
    "miniImagenet/learner.py": {
        "torch": {
            "Sequential_19": {
                "variable": {
                    "value": "self.net",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.conv_block(x_dim, hid_dim)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Beta_21": {
                "variable": {
                    "value": "self.dist",
                    "type": "Attribute",
                    "possible_values": []
                },
                "concentration1": {
                    "value": "torch.FloatTensor([2])",
                    "type": "Call",
                    "possible_values": []
                },
                "concentration0": {
                    "value": "torch.FloatTensor([2])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Linear_24": {
                "variable": {
                    "value": "self.logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "final_layer_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.args.num_classes",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "conv2d_37": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "F.conv2d(x, weights, biases, padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(x, running_mean=None, running_var=None, weight=bn_weights, bias=bn_biases, training=is_training)",
                            "Call"
                        ],
                        [
                            "F.relu(x)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(x, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "self.net(x)",
                            "Call"
                        ],
                        [
                            "x.view(x.size(0), -1)",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(x, weights[f'net.{block}.0.weight'], weights[f'net.{block}.0.bias'], weights.get(f'net.{block}.1.weight'), weights.get(f'net.{block}.1.bias'), is_training)",
                            "Call"
                        ],
                        [
                            "x.view(x.size(0), -1)",
                            "Call"
                        ],
                        [
                            "F.linear(x, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden4_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "bias": {
                    "value": "biases",
                    "type": "Variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "batch_norm_38": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "F.conv2d(x, weights, biases, padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(x, running_mean=None, running_var=None, weight=bn_weights, bias=bn_biases, training=is_training)",
                            "Call"
                        ],
                        [
                            "F.relu(x)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(x, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "self.net(x)",
                            "Call"
                        ],
                        [
                            "x.view(x.size(0), -1)",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(x, weights[f'net.{block}.0.weight'], weights[f'net.{block}.0.bias'], weights.get(f'net.{block}.1.weight'), weights.get(f'net.{block}.1.bias'), is_training)",
                            "Call"
                        ],
                        [
                            "x.view(x.size(0), -1)",
                            "Call"
                        ],
                        [
                            "F.linear(x, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden4_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ]
                    ]
                },
                "running_mean": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "running_var": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "weight": {
                    "value": "bn_weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "bias": {
                    "value": "bn_biases",
                    "type": "Variable",
                    "possible_values": []
                },
                "training": {
                    "value": "is_training",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "relu_40": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "F.conv2d(x, weights, biases, padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(x, running_mean=None, running_var=None, weight=bn_weights, bias=bn_biases, training=is_training)",
                            "Call"
                        ],
                        [
                            "F.relu(x)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(x, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "self.net(x)",
                            "Call"
                        ],
                        [
                            "x.view(x.size(0), -1)",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(x, weights[f'net.{block}.0.weight'], weights[f'net.{block}.0.bias'], weights.get(f'net.{block}.1.weight'), weights.get(f'net.{block}.1.bias'), is_training)",
                            "Call"
                        ],
                        [
                            "x.view(x.size(0), -1)",
                            "Call"
                        ],
                        [
                            "F.linear(x, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden4_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ]
                    ]
                }
            },
            "max_pool2d_41": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "F.conv2d(x, weights, biases, padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(x, running_mean=None, running_var=None, weight=bn_weights, bias=bn_biases, training=is_training)",
                            "Call"
                        ],
                        [
                            "F.relu(x)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(x, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "self.net(x)",
                            "Call"
                        ],
                        [
                            "x.view(x.size(0), -1)",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(x, weights[f'net.{block}.0.weight'], weights[f'net.{block}.0.bias'], weights.get(f'net.{block}.1.weight'), weights.get(f'net.{block}.1.bias'), is_training)",
                            "Call"
                        ],
                        [
                            "x.view(x.size(0), -1)",
                            "Call"
                        ],
                        [
                            "F.linear(x, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden4_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "randperm_47": {
                "variable": {
                    "value": "shuffled_index",
                    "type": "Variable",
                    "possible_values": []
                },
                "n": {
                    "value": "query_size",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "xq.shape[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "linear_71": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "F.conv2d(x, weights, biases, padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(x, running_mean=None, running_var=None, weight=bn_weights, bias=bn_biases, training=is_training)",
                            "Call"
                        ],
                        [
                            "F.relu(x)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(x, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "self.net(x)",
                            "Call"
                        ],
                        [
                            "x.view(x.size(0), -1)",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(x, weights[f'net.{block}.0.weight'], weights[f'net.{block}.0.bias'], weights.get(f'net.{block}.1.weight'), weights.get(f'net.{block}.1.bias'), is_training)",
                            "Call"
                        ],
                        [
                            "x.view(x.size(0), -1)",
                            "Call"
                        ],
                        [
                            "F.linear(x, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden4_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "weights['logits.weight']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "bias": {
                    "value": "weights['logits.bias']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cat_90": {
                "variable": {
                    "value": "new_data",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "new_data",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(new_data, dim=0)",
                            "Call"
                        ],
                        [
                            "new_data[indexes]",
                            "Subscript"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "randperm_92": {
                "variable": {
                    "value": "indexes",
                    "type": "Variable",
                    "possible_values": []
                },
                "n": {
                    "value": "new_data.shape[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "linear_120": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "hidden4_query",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "hidden_query.view(hidden_query.size(0), -1)",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "weights['logits.weight']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "bias": {
                    "value": "weights['logits.bias']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "linear_139": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "hidden",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "hidden.view(hidden.size(0), -1)",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(hidden, weights[f'net.{layer}.0.weight'], weights[f'net.{layer}.0.bias'], weights.get(f'net.{layer}.1.weight'), weights.get(f'net.{layer}.1.bias'), is_training)",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "weights['logits.weight']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "bias": {
                    "value": "weights['logits.bias']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "linear_184": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "hidden_query",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.functional_conv_block(hidden_query, weights[f'net.{layer}.0.weight'], weights[f'net.{layer}.0.bias'], weights.get(f'net.{layer}.1.weight'), weights.get(f'net.{layer}.1.bias'), is_training)",
                            "Call"
                        ],
                        [
                            "hidden_query.view(hidden_query.size(0), -1)",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(hidden_query, weights[f'net.{layer}.0.weight'], weights[f'net.{layer}.0.bias'], weights.get(f'net.{layer}.1.weight'), weights.get(f'net.{layer}.1.bias'), is_training)",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "weights['logits.weight']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "bias": {
                    "value": "weights['logits.bias']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "Sequential_27": {
                "*args": {
                    "value": "nn.Conv2d(in_channels, out_channels, 3, padding=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Conv2d_28": {
                "in_channels": {
                    "value": "in_channels",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channels",
                    "type": "Variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_29": {
                "num_features": {
                    "value": "out_channels",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "ReLU_30": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "MaxPool2d_31": {
                "kernel_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_88": {
                "tensors": {
                    "value": "(cur_class_1[:, :start], cur_class_2[:, start:end], cur_class_1[:, end:])",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "miniImagenet/main.py": {
        "torch": {
            "is_available_48": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Adam_150": {
                "variable": {
                    "value": "meta_optimiser",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "list(maml.parameters())",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "args.meta_lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "weight_decay": {
                    "value": "args.weight_decay",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_101": {
                "variable": {
                    "value": "meta_batch_loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "task_losses",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "mean_101": {
                "variable": {
                    "value": "meta_batch_loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "stack_102": {
                "variable": {
                    "value": "meta_batch_acc",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "task_acc",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "mean_102": {
                "variable": {
                    "value": "meta_batch_acc",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "save_117": {
                "obj": {
                    "value": "maml.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "'{0}/{2}/model{1}'.format(args.logdir, step, exp_string)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "load_148": {
                "f": {
                    "value": "model_file",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'{0}/{2}/model{1}'.format(args.logdir, args.test_epoch, exp_string)",
                            "Call"
                        ],
                        [
                            "'{0}/{2}/model{1}'.format(args.logdir, args.test_epoch, exp_string)",
                            "Call"
                        ]
                    ]
                }
            },
            "load_157": {
                "f": {
                    "value": "model_file",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'{0}/{2}/model{1}'.format(args.logdir, args.test_epoch, exp_string)",
                            "Call"
                        ],
                        [
                            "'{0}/{2}/model{1}'.format(args.logdir, args.test_epoch, exp_string)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "miniImagenet/maml.py": {
        "torch": {
            "CrossEntropyLoss_14": {
                "variable": {
                    "value": "self.loss_fn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "grad_28": {
                "variable": {
                    "value": "gradients",
                    "type": "Variable",
                    "possible_values": []
                },
                "outputs": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.loss_fn(logits, ys)",
                            "Call"
                        ],
                        [
                            "self.loss_fn(logits, s_label)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "fast_weights.values()",
                    "type": "Call",
                    "possible_values": []
                },
                "create_graph": {
                    "value": "create_graph",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "True",
                            "Constant"
                        ],
                        [
                            "True",
                            "Constant"
                        ]
                    ]
                }
            },
            "grad_76": {
                "variable": {
                    "value": "gradients",
                    "type": "Variable",
                    "possible_values": []
                },
                "outputs": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.loss_fn(logits, ys)",
                            "Call"
                        ],
                        [
                            "self.loss_fn(logits, s_label)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "fast_weights.values()",
                    "type": "Call",
                    "possible_values": []
                },
                "create_graph": {
                    "value": "create_graph",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "True",
                            "Constant"
                        ],
                        [
                            "True",
                            "Constant"
                        ]
                    ]
                }
            }
        }
    },
    "omniglot/data_generator.py": {
        "torch": {
            "tensor_24": {
                "variable": {
                    "value": "self.data",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "pickle.load(open(self.data_file, 'rb'))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "unsqueeze_26": {
                "variable": {
                    "value": "self.data",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.data",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_37": {
                "*size": {
                    "value": "(self.args.meta_batch_size, self.set_size, 1, 28, 28)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "zeros_38": {
                "*size": {
                    "value": "(self.args.meta_batch_size, self.query_size, 1, 28, 28)",
                    "type": "Tuple",
                    "possible_values": []
                }
            }
        }
    },
    "omniglot/learner.py": {
        "torch": {
            "Sequential_19": {
                "variable": {
                    "value": "self.net",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.conv_block(x_dim, hid_dim)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Beta_21": {
                "variable": {
                    "value": "self.dist",
                    "type": "Attribute",
                    "possible_values": []
                },
                "concentration1": {
                    "value": "torch.FloatTensor([2])",
                    "type": "Call",
                    "possible_values": []
                },
                "concentration0": {
                    "value": "torch.FloatTensor([2])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Linear_24": {
                "variable": {
                    "value": "self.logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "final_layer_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.args.num_classes",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "conv2d_36": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "F.conv2d(x, weights, biases, padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(x, running_mean=None, running_var=None, weight=bn_weights, bias=bn_biases, training=is_training)",
                            "Call"
                        ],
                        [
                            "F.relu(x)",
                            "Call"
                        ],
                        [
                            "self.net(x)",
                            "Call"
                        ],
                        [
                            "torch.mean(x, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(x, weights[f'net.{block}.0.weight'], weights[f'net.{block}.0.bias'], weights.get(f'net.{block}.1.weight'), weights.get(f'net.{block}.1.bias'), is_training)",
                            "Call"
                        ],
                        [
                            "torch.mean(x, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "F.linear(x, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "bias": {
                    "value": "biases",
                    "type": "Variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "batch_norm_37": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "F.conv2d(x, weights, biases, padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(x, running_mean=None, running_var=None, weight=bn_weights, bias=bn_biases, training=is_training)",
                            "Call"
                        ],
                        [
                            "F.relu(x)",
                            "Call"
                        ],
                        [
                            "self.net(x)",
                            "Call"
                        ],
                        [
                            "torch.mean(x, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(x, weights[f'net.{block}.0.weight'], weights[f'net.{block}.0.bias'], weights.get(f'net.{block}.1.weight'), weights.get(f'net.{block}.1.bias'), is_training)",
                            "Call"
                        ],
                        [
                            "torch.mean(x, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "F.linear(x, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ]
                    ]
                },
                "running_mean": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "running_var": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "weight": {
                    "value": "bn_weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "bias": {
                    "value": "bn_biases",
                    "type": "Variable",
                    "possible_values": []
                },
                "training": {
                    "value": "is_training",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "relu_39": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "F.conv2d(x, weights, biases, padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(x, running_mean=None, running_var=None, weight=bn_weights, bias=bn_biases, training=is_training)",
                            "Call"
                        ],
                        [
                            "F.relu(x)",
                            "Call"
                        ],
                        [
                            "self.net(x)",
                            "Call"
                        ],
                        [
                            "torch.mean(x, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(x, weights[f'net.{block}.0.weight'], weights[f'net.{block}.0.bias'], weights.get(f'net.{block}.1.weight'), weights.get(f'net.{block}.1.bias'), is_training)",
                            "Call"
                        ],
                        [
                            "torch.mean(x, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "F.linear(x, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ]
                    ]
                }
            },
            "randperm_45": {
                "variable": {
                    "value": "shuffled_index",
                    "type": "Variable",
                    "possible_values": []
                },
                "n": {
                    "value": "query_size",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "xq.shape[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "mean_57": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "F.conv2d(x, weights, biases, padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(x, running_mean=None, running_var=None, weight=bn_weights, bias=bn_biases, training=is_training)",
                            "Call"
                        ],
                        [
                            "F.relu(x)",
                            "Call"
                        ],
                        [
                            "self.net(x)",
                            "Call"
                        ],
                        [
                            "torch.mean(x, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(x, weights[f'net.{block}.0.weight'], weights[f'net.{block}.0.bias'], weights.get(f'net.{block}.1.weight'), weights.get(f'net.{block}.1.bias'), is_training)",
                            "Call"
                        ],
                        [
                            "torch.mean(x, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "F.linear(x, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "(2, 3)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "mean_67": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "F.conv2d(x, weights, biases, padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(x, running_mean=None, running_var=None, weight=bn_weights, bias=bn_biases, training=is_training)",
                            "Call"
                        ],
                        [
                            "F.relu(x)",
                            "Call"
                        ],
                        [
                            "self.net(x)",
                            "Call"
                        ],
                        [
                            "torch.mean(x, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(x, weights[f'net.{block}.0.weight'], weights[f'net.{block}.0.bias'], weights.get(f'net.{block}.1.weight'), weights.get(f'net.{block}.1.bias'), is_training)",
                            "Call"
                        ],
                        [
                            "torch.mean(x, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "F.linear(x, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "(2, 3)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "linear_69": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "F.conv2d(x, weights, biases, padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(x, running_mean=None, running_var=None, weight=bn_weights, bias=bn_biases, training=is_training)",
                            "Call"
                        ],
                        [
                            "F.relu(x)",
                            "Call"
                        ],
                        [
                            "self.net(x)",
                            "Call"
                        ],
                        [
                            "torch.mean(x, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(x, weights[f'net.{block}.0.weight'], weights[f'net.{block}.0.bias'], weights.get(f'net.{block}.1.weight'), weights.get(f'net.{block}.1.bias'), is_training)",
                            "Call"
                        ],
                        [
                            "torch.mean(x, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "F.linear(x, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ],
                        [
                            "F.linear(hidden_query, weights['logits.weight'], weights['logits.bias'])",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "weights['logits.weight']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "bias": {
                    "value": "weights['logits.bias']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cat_88": {
                "variable": {
                    "value": "new_data",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "new_data",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(new_data, dim=0)",
                            "Call"
                        ],
                        [
                            "new_data[indexes]",
                            "Subscript"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "randperm_90": {
                "variable": {
                    "value": "indexes",
                    "type": "Variable",
                    "possible_values": []
                },
                "n": {
                    "value": "new_data.shape[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "mean_120": {
                "variable": {
                    "value": "hidden_query",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "hidden_query",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "torch.mean(hidden_query, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(hidden_query, weights[f'net.{layer}.0.weight'], weights[f'net.{layer}.0.bias'], weights.get(f'net.{layer}.1.weight'), weights.get(f'net.{layer}.1.bias'), is_training)",
                            "Call"
                        ],
                        [
                            "torch.mean(hidden_query, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(hidden_query, weights[f'net.{layer}.0.weight'], weights[f'net.{layer}.0.bias'], weights.get(f'net.{layer}.1.weight'), weights.get(f'net.{layer}.1.bias'), is_training)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "(2, 3)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "linear_122": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "hidden_query",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "torch.mean(hidden_query, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(hidden_query, weights[f'net.{layer}.0.weight'], weights[f'net.{layer}.0.bias'], weights.get(f'net.{layer}.1.weight'), weights.get(f'net.{layer}.1.bias'), is_training)",
                            "Call"
                        ],
                        [
                            "torch.mean(hidden_query, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(hidden_query, weights[f'net.{layer}.0.weight'], weights[f'net.{layer}.0.bias'], weights.get(f'net.{layer}.1.weight'), weights.get(f'net.{layer}.1.bias'), is_training)",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "weights['logits.weight']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "bias": {
                    "value": "weights['logits.bias']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "mean_141": {
                "variable": {
                    "value": "hidden",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "hidden",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "torch.mean(hidden, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(hidden, weights[f'net.{layer}.0.weight'], weights[f'net.{layer}.0.bias'], weights.get(f'net.{layer}.1.weight'), weights.get(f'net.{layer}.1.bias'), is_training)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "(2, 3)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "linear_143": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "hidden",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "torch.mean(hidden, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(hidden, weights[f'net.{layer}.0.weight'], weights[f'net.{layer}.0.bias'], weights.get(f'net.{layer}.1.weight'), weights.get(f'net.{layer}.1.bias'), is_training)",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "weights['logits.weight']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "bias": {
                    "value": "weights['logits.bias']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "mean_188": {
                "variable": {
                    "value": "hidden_query",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "hidden_query",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "torch.mean(hidden_query, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(hidden_query, weights[f'net.{layer}.0.weight'], weights[f'net.{layer}.0.bias'], weights.get(f'net.{layer}.1.weight'), weights.get(f'net.{layer}.1.bias'), is_training)",
                            "Call"
                        ],
                        [
                            "torch.mean(hidden_query, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(hidden_query, weights[f'net.{layer}.0.weight'], weights[f'net.{layer}.0.bias'], weights.get(f'net.{layer}.1.weight'), weights.get(f'net.{layer}.1.bias'), is_training)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "(2, 3)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "linear_190": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "hidden_query",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "torch.mean(hidden_query, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(hidden_query, weights[f'net.{layer}.0.weight'], weights[f'net.{layer}.0.bias'], weights.get(f'net.{layer}.1.weight'), weights.get(f'net.{layer}.1.bias'), is_training)",
                            "Call"
                        ],
                        [
                            "torch.mean(hidden_query, dim=(2, 3))",
                            "Call"
                        ],
                        [
                            "self.functional_conv_block(hidden_query, weights[f'net.{layer}.0.weight'], weights[f'net.{layer}.0.bias'], weights.get(f'net.{layer}.1.weight'), weights.get(f'net.{layer}.1.bias'), is_training)",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "weights['logits.weight']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "bias": {
                    "value": "weights['logits.bias']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "Sequential_27": {
                "*args": {
                    "value": "nn.Conv2d(in_channels, out_channels, 3, padding=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Conv2d_28": {
                "in_channels": {
                    "value": "in_channels",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channels",
                    "type": "Variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_29": {
                "num_features": {
                    "value": "out_channels",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "ReLU_30": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "MaxPool2d_31": {
                "kernel_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_86": {
                "tensors": {
                    "value": "(cur_class_1[:, :start], cur_class_2[:, start:end], cur_class_1[:, end:])",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "omniglot/main.py": {
        "torch": {
            "is_available_47": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Adam_147": {
                "variable": {
                    "value": "meta_optimiser",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "list(maml.parameters())",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "args.meta_lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "weight_decay": {
                    "value": "args.weight_decay",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_98": {
                "variable": {
                    "value": "meta_batch_loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "task_losses",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "mean_98": {
                "variable": {
                    "value": "meta_batch_loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "stack_99": {
                "variable": {
                    "value": "meta_batch_acc",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "task_acc",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "mean_99": {
                "variable": {
                    "value": "meta_batch_acc",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "save_115": {
                "obj": {
                    "value": "maml.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "'{0}/{2}/model{1}'.format(args.logdir, step, exp_string)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "load_145": {
                "f": {
                    "value": "model_file",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'{0}/{2}/model{1}'.format(args.logdir, args.test_epoch, exp_string)",
                            "Call"
                        ],
                        [
                            "'{0}/{2}/model{1}'.format(args.logdir, test_epoch, exp_string)",
                            "Call"
                        ]
                    ]
                }
            },
            "load_156": {
                "f": {
                    "value": "model_file",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'{0}/{2}/model{1}'.format(args.logdir, args.test_epoch, exp_string)",
                            "Call"
                        ],
                        [
                            "'{0}/{2}/model{1}'.format(args.logdir, test_epoch, exp_string)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "omniglot/maml.py": {
        "torch": {
            "CrossEntropyLoss_14": {
                "variable": {
                    "value": "self.loss_fn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "grad_28": {
                "variable": {
                    "value": "gradients",
                    "type": "Variable",
                    "possible_values": []
                },
                "outputs": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.loss_fn(logits, ys)",
                            "Call"
                        ],
                        [
                            "self.loss_fn(logits, s_label)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "fast_weights.values()",
                    "type": "Call",
                    "possible_values": []
                },
                "create_graph": {
                    "value": "create_graph",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "True",
                            "Constant"
                        ],
                        [
                            "True",
                            "Constant"
                        ]
                    ]
                }
            },
            "grad_81": {
                "variable": {
                    "value": "gradients",
                    "type": "Variable",
                    "possible_values": []
                },
                "outputs": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.loss_fn(logits, ys)",
                            "Call"
                        ],
                        [
                            "self.loss_fn(logits, s_label)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "fast_weights.values()",
                    "type": "Call",
                    "possible_values": []
                },
                "create_graph": {
                    "value": "create_graph",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "True",
                            "Constant"
                        ],
                        [
                            "True",
                            "Constant"
                        ]
                    ]
                }
            },
            "no_grad_48": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    }
}