{
    "log/test1__imp_type_1enc_3dmfvEmbS512BN0LR0001wd0sigma125K5AUG1lsl1_distnoise0chairov1np64/dpdist_and_aue.py": {
        "tensorflow": {
            "placeholder_24": {
                "variable": {
                    "value": "pcA_pl",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point, NUM_DIMS)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "input1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_25": {
                "variable": {
                    "value": "pcB_pl",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point, NUM_DIMS)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "input2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_26": {
                "variable": {
                    "value": "labels_AB",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "labels12",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_27": {
                "variable": {
                    "value": "labels_BA",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "labels21",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_198": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[one_by_one, three_by_three, five_by_five, average_pooling]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                }
            },
            "identity_78": {
                "variable": {
                    "value": "pred_listAB",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pred_listAB",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[0]",
                            "Subscript"
                        ],
                        [
                            "tf.identity(pred_listAB, 'output1')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "output1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_79": {
                "variable": {
                    "value": "pred_listBA",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pred_listBA",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[1]",
                            "Subscript"
                        ],
                        [
                            "tf.identity(pred_listBA, 'output2')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "output2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_107": {
                "variable": {
                    "value": "input_image",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_133": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "global_feat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tanh_141": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "dpdist.DPDist(pcA, pcB, embedding_A, embedding_B, C, is_training, bn_decay=bn_decay, reuse=None, bn=bn, wd=wd, sig=sig, Embedding_Size=Embedding_Size, NUM_DIMS=NUM_DIMS, mlp=localSNmlp, k=k, output_act='relu', conv_version=conv_version)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, point_dim], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(point_feat, 128, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 1024, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf.reshape(global_feat, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, num_point * 3, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, (batch_size, num_point, 3))",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'output')",
                            "Call"
                        ],
                        [
                            "inception_module(grid_fisher, n_filters=256, kernel_sizes=[3, 5], is_training=is_training, bn_decay=bn_decay, scope='inception' + str(layer))",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc' + str(layer), bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, n_points * 3, bn=True, is_training=is_training, scope='fc' + str(layer), bn_decay=bn_decay, activation_fn=None)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_143": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "dpdist.DPDist(pcA, pcB, embedding_A, embedding_B, C, is_training, bn_decay=bn_decay, reuse=None, bn=bn, wd=wd, sig=sig, Embedding_Size=Embedding_Size, NUM_DIMS=NUM_DIMS, mlp=localSNmlp, k=k, output_act='relu', conv_version=conv_version)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, point_dim], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(point_feat, 128, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 1024, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf.reshape(global_feat, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, num_point * 3, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, (batch_size, num_point, 3))",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'output')",
                            "Call"
                        ],
                        [
                            "inception_module(grid_fisher, n_filters=256, kernel_sizes=[3, 5], is_training=is_training, bn_decay=bn_decay, scope='inception' + str(layer))",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc' + str(layer), bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, n_points * 3, bn=True, is_training=is_training, scope='fc' + str(layer), bn_decay=bn_decay, activation_fn=None)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(batch_size, num_point, 3)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "identity_144": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "dpdist.DPDist(pcA, pcB, embedding_A, embedding_B, C, is_training, bn_decay=bn_decay, reuse=None, bn=bn, wd=wd, sig=sig, Embedding_Size=Embedding_Size, NUM_DIMS=NUM_DIMS, mlp=localSNmlp, k=k, output_act='relu', conv_version=conv_version)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, point_dim], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(point_feat, 128, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 1024, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf.reshape(global_feat, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, num_point * 3, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, (batch_size, num_point, 3))",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'output')",
                            "Call"
                        ],
                        [
                            "inception_module(grid_fisher, n_filters=256, kernel_sizes=[3, 5], is_training=is_training, bn_decay=bn_decay, scope='inception' + str(layer))",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc' + str(layer), bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, n_points * 3, bn=True, is_training=is_training, scope='fc' + str(layer), bn_decay=bn_decay, activation_fn=None)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "output",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_158": {
                "variable": {
                    "value": "grid_fisher",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "fv",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "dpdist.get_3dmfv_tf(points, n_gaussians=n_gaussians)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1, res, res, res]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_159": {
                "variable": {
                    "value": "grid_fisher",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "grid_fisher",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(fv, [batch_size, -1, res, res, res])",
                            "Call"
                        ],
                        [
                            "tf.transpose(grid_fisher, [0, 2, 3, 4, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 3, 4, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_167": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "dpdist.DPDist(pcA, pcB, embedding_A, embedding_B, C, is_training, bn_decay=bn_decay, reuse=None, bn=bn, wd=wd, sig=sig, Embedding_Size=Embedding_Size, NUM_DIMS=NUM_DIMS, mlp=localSNmlp, k=k, output_act='relu', conv_version=conv_version)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, point_dim], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(point_feat, 128, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 1024, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf.reshape(global_feat, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, num_point * 3, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, (batch_size, num_point, 3))",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'output')",
                            "Call"
                        ],
                        [
                            "inception_module(grid_fisher, n_filters=256, kernel_sizes=[3, 5], is_training=is_training, bn_decay=bn_decay, scope='inception' + str(layer))",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc' + str(layer), bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, n_points * 3, bn=True, is_training=is_training, scope='fc' + str(layer), bn_decay=bn_decay, activation_fn=None)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_176": {
                "variable": {
                    "value": "reconstructed_points",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "dpdist.DPDist(pcA, pcB, embedding_A, embedding_B, C, is_training, bn_decay=bn_decay, reuse=None, bn=bn, wd=wd, sig=sig, Embedding_Size=Embedding_Size, NUM_DIMS=NUM_DIMS, mlp=localSNmlp, k=k, output_act='relu', conv_version=conv_version)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, point_dim], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(point_feat, 128, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 1024, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf.reshape(global_feat, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, num_point * 3, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, (batch_size, num_point, 3))",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'output')",
                            "Call"
                        ],
                        [
                            "inception_module(grid_fisher, n_filters=256, kernel_sizes=[3, 5], is_training=is_training, bn_decay=bn_decay, scope='inception' + str(layer))",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc' + str(layer), bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, n_points * 3, bn=True, is_training=is_training, scope='fc' + str(layer), bn_decay=bn_decay, activation_fn=None)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, n_points, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tanh_178": {
                "variable": {
                    "value": "reconstructed_points",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "reconstructed_points",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(net, [batch_size, n_points, 3])",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(reconstructed_points)",
                            "Call"
                        ],
                        [
                            "tf.identity(reconstructed_points, 'output')",
                            "Call"
                        ]
                    ]
                }
            },
            "identity_179": {
                "variable": {
                    "value": "reconstructed_points",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "reconstructed_points",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(net, [batch_size, n_points, 3])",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(reconstructed_points)",
                            "Call"
                        ],
                        [
                            "tf.identity(reconstructed_points, 'output')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "output",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_36": {
                "name_or_scope": {
                    "value": "pc_compare",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "variable_scope_101": {
                "name_or_scope": {
                    "value": "aue",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "variable_scope_152": {
                "name_or_scope": {
                    "value": "aue",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            }
        }
    },
    "log/test1__imp_type_1enc_3dmfvEmbS512BN0LR0001wd0sigma125K5AUG1lsl1_distnoise0chairov1np64/dpdist_util.py": {
        "tensorflow": {
            "placeholder_14": {
                "variable": {
                    "value": "pointclouds_pl",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point, NUM_DIMS)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_15": {
                "variable": {
                    "value": "pointclouds_pl_same",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point, NUM_DIMS)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_16": {
                "variable": {
                    "value": "pointclouds_pl_not_same",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point, NUM_DIMS)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_17": {
                "variable": {
                    "value": "noise_pl",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point, NUM_DIMS)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_18": {
                "variable": {
                    "value": "labels_ns",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "constant_50": {
                "variable": {
                    "value": "mu",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.stack([x.flatten(), y.flatten()]).T",
                            "Attribute"
                        ],
                        [
                            "np.stack([x.flatten(), y.flatten(), z.flatten()]).T",
                            "Attribute"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_54": {
                "variable": {
                    "value": "batch_sig",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(sigma, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[n_points, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_55": {
                "variable": {
                    "value": "batch_sig",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(batch_sig, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[n_batches, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_56": {
                "variable": {
                    "value": "batch_mu",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(mu, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[n_points, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_57": {
                "variable": {
                    "value": "batch_mu",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(batch_mu, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[n_batches, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_58": {
                "variable": {
                    "value": "batch_w",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.expand_dims(w, 0), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[n_batches, n_points, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_59": {
                "variable": {
                    "value": "batch_points",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(points, -2)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, n_gaussians, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "multiply_73": {
                "variable": {
                    "value": "w_p",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "p_per_point",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "mvn.prob(batch_points)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "batch_w",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(w, 0), 0), [n_batches, n_points, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_75": {
                "variable": {
                    "value": "Q_per_d",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(Q, -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, 1, D]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_78": {
                "variable": {
                    "value": "d_pi_all",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "(Q - batch_w) / (tf.sqrt(batch_w) * n_points)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_max_80": {
                "variable": {
                    "value": "d_pi_max",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_pi_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims((Q - batch_w) / (tf.sqrt(batch_w) * n_points), -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_81": {
                "variable": {
                    "value": "d_pi_mean",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_pi_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims((Q - batch_w) / (tf.sqrt(batch_w) * n_points), -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_89": {
                "variable": {
                    "value": "d_mu_all_max",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_mu_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "Q_per_d * (batch_points - batch_mu) / batch_sig",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_min_90": {
                "variable": {
                    "value": "d_mu_all_min",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_mu_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "Q_per_d * (batch_points - batch_mu) / batch_sig",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_91": {
                "variable": {
                    "value": "d_mu_all_mean",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_mu_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "Q_per_d * (batch_points - batch_mu) / batch_sig",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_102": {
                "variable": {
                    "value": "d_sig_all_max",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_sig_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "Q_per_d * (tf.pow((batch_points - batch_mu) / batch_sig, 2) - 1)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_min_103": {
                "variable": {
                    "value": "d_sig_all_min",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_sig_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "Q_per_d * (tf.pow((batch_points - batch_mu) / batch_sig, 2) - 1)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_104": {
                "variable": {
                    "value": "d_sig_all_mean",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_sig_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "Q_per_d * (tf.pow((batch_points - batch_mu) / batch_sig, 2) - 1)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_217": {
                "variable": {
                    "value": "embedding",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "embedding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(embedding)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(embedding, 1), [1, NP, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "relu_389": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "features": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_511": {
                "variable": {
                    "value": "net_all",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[net, netB]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_695": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_711": {
                "variable": {
                    "value": "input_image",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(point_cloud, -2), [1, 1, V, 1])",
                            "Call"
                        ],
                        [
                            "point_cloud - Centers",
                            "BinOp"
                        ],
                        [
                            "tf.tile(tf.expand_dims(point_cloud, -2), [1, 1, V, 1])",
                            "Call"
                        ],
                        [
                            "point_cloud - Centers",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_794": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_803": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, vec_size, vec_size, vec_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_842": {
                "variable": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ],
                        [
                            "tf.stack([X[kh:-kh, kh:-kh], Y[kh:-kh, kh:-kh]], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "tf.stack([X, Y, Z], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_844": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [2, 0, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], output.shape[1], -1])",
                            "Call"
                        ],
                        [
                            "tf.image.extract_image_patches(net, [1, k, k, 1], [1, 1, 1, 1], rates=[1, 1, 1, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], (vec_size - 2 * kh) ** 2, -1])",
                            "Call"
                        ],
                        [
                            "tf.extract_volume_patches(net, [1, k, k, k, 1], [1, 1, 1, 1, 1], 'SAME', name='EXTRACT_LOCAL_Z')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value ** 3, -1])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value, -1])",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_845": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [2, 0, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], output.shape[1], -1])",
                            "Call"
                        ],
                        [
                            "tf.image.extract_image_patches(net, [1, k, k, 1], [1, 1, 1, 1], rates=[1, 1, 1, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], (vec_size - 2 * kh) ** 2, -1])",
                            "Call"
                        ],
                        [
                            "tf.extract_volume_patches(net, [1, k, k, k, 1], [1, 1, 1, 1, 1], 'SAME', name='EXTRACT_LOCAL_Z')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value ** 3, -1])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value, -1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[2, 0, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_846": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [2, 0, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], output.shape[1], -1])",
                            "Call"
                        ],
                        [
                            "tf.image.extract_image_patches(net, [1, k, k, 1], [1, 1, 1, 1], rates=[1, 1, 1, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], (vec_size - 2 * kh) ** 2, -1])",
                            "Call"
                        ],
                        [
                            "tf.extract_volume_patches(net, [1, k, k, k, 1], [1, 1, 1, 1, 1], 'SAME', name='EXTRACT_LOCAL_Z')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value ** 3, -1])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[output.shape[0], output.shape[1], -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_862": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, vec_size, vec_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "extract_image_patches_864": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "images": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "ksizes": {
                    "value": "[1, k, k, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "rates": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                }
            },
            "stack_868": {
                "variable": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[X[kh:-kh, kh:-kh], Y[kh:-kh, kh:-kh]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_870": {
                "variable": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ],
                        [
                            "tf.stack([X[kh:-kh, kh:-kh], Y[kh:-kh, kh:-kh]], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "tf.stack([X, Y, Z], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_871": {
                "variable": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ],
                        [
                            "tf.stack([X[kh:-kh, kh:-kh], Y[kh:-kh, kh:-kh]], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "tf.stack([X, Y, Z], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, NUM_DIMS]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_908": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [2, 0, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], output.shape[1], -1])",
                            "Call"
                        ],
                        [
                            "tf.image.extract_image_patches(net, [1, k, k, 1], [1, 1, 1, 1], rates=[1, 1, 1, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], (vec_size - 2 * kh) ** 2, -1])",
                            "Call"
                        ],
                        [
                            "tf.extract_volume_patches(net, [1, k, k, k, 1], [1, 1, 1, 1, 1], 'SAME', name='EXTRACT_LOCAL_Z')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value ** 3, -1])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[output.shape[0], (vec_size - 2 * kh) ** 2, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "identity_978": {
                "variable": {
                    "value": "loss_pred",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "loss_pred",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "(tf.reduce_mean(pred_listAB[:, :, :, 0]) + tf.reduce_mean(pred_listBA[:, :, :, 0])) / 2",
                            "BinOp"
                        ],
                        [
                            "tf.identity(loss_pred, name='loss_pred')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "loss_pred",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tile_63": {
                "variable": {
                    "value": "w_per_batch_per_d",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.expand_dims(w, 0), -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[n_batches, 1, D * 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_65": {
                "variable": {
                    "value": "w_per_batch_per_d",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.expand_dims(w, 0), -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[n_batches, 1, D]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_83": {
                "variable": {
                    "value": "d_pi",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[d_pi_mean, d_pi_max]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_94": {
                "variable": {
                    "value": "d_mu_all_full",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[d_mu_all_mean, d_mu_all_max, d_mu_all_min]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_106": {
                "variable": {
                    "value": "d_sig_all_full",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[d_sig_all_mean, d_sig_all_max, d_sig_all_min]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_124": {
                "variable": {
                    "value": "d_pi",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "d_pi",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([d_pi_mean, d_pi_max], 2)",
                            "Call"
                        ],
                        [
                            "d_pi_mean",
                            "Name"
                        ],
                        [
                            "tf.sign(d_pi) * tf.pow(tf.maximum(tf.abs(d_pi), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_pi, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_pi, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_125": {
                "variable": {
                    "value": "d_mu",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "d_mu",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(w_per_batch_per_d) * d_mu_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_mu) * tf.pow(tf.maximum(tf.abs(d_mu), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_mu, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_mu, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_126": {
                "variable": {
                    "value": "d_sigma",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "d_sigma",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(2 * w_per_batch_per_d) * d_sig_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_sigma) * tf.pow(tf.maximum(tf.abs(d_sigma), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_sigma, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_sigma, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "flatten_129": {
                "variable": {
                    "value": "d_pi",
                    "type": "Variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "tf.transpose(d_pi, perm=[0, 2, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "flatten_130": {
                "variable": {
                    "value": "d_mu",
                    "type": "Variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "tf.transpose(d_mu, perm=[0, 2, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "flatten_131": {
                "variable": {
                    "value": "d_sigma",
                    "type": "Variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "tf.transpose(d_sigma, perm=[0, 2, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_132": {
                "variable": {
                    "value": "fv",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[d_pi, d_mu, d_sigma]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_134": {
                "variable": {
                    "value": "fv",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[d_pi, d_mu, d_sigma]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_135": {
                "variable": {
                    "value": "fv",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "fv",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([d_pi, d_mu, d_sigma], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([d_pi, d_mu, d_sigma], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(fv, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(fv, [0, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_137": {
                "variable": {
                    "value": "fv",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "fv",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([d_pi, d_mu, d_sigma], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([d_pi, d_mu, d_sigma], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(fv, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(fv, [0, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_nd_158": {
                "variable": {
                    "value": "bv",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "bv",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(bv, tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(bv, -1), -1), [1, 1, 1, D])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(bv, tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(bv, -1), -1), [1, 1, 1, D])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tile_163": {
                "variable": {
                    "value": "bv",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.expand_dims(bv, -1), -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, 1, D]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_nd_165": {
                "variable": {
                    "value": "new_pc",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(point_cloud, -2), [1, 1, V, 1])",
                            "Call"
                        ],
                        [
                            "point_cloud - Centers",
                            "BinOp"
                        ],
                        [
                            "tf.tile(tf.expand_dims(point_cloud, -2), [1, 1, V, 1])",
                            "Call"
                        ],
                        [
                            "point_cloud - Centers",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_nd_171": {
                "variable": {
                    "value": "new_emb",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "embedding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(embedding)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(embedding, 1), [1, NP, 1])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.zeros(tf.shape(argmax), tf.int32), tf.cast(argmax, tf.int32)], 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_177": {
                "variable": {
                    "value": "new_in",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[new_pc, new_emb]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_178": {
                "variable": {
                    "value": "new_in",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "new_in",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([new_pc, new_emb], -1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(new_in, -1)",
                            "Call"
                        ],
                        [
                            "tf.concat([new_pc, new_emb], -1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(new_in, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_192": {
                "input": {
                    "value": "Centers",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.expand_dims(Centers, 0), 0)",
                            "Call"
                        ],
                        [
                            "tf.tile(Centers, [batch_size, num_points, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(Centers, 0), 0)",
                            "Call"
                        ],
                        [
                            "tf.tile(Centers, [batch_size, num_points, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_193": {
                "variable": {
                    "value": "Centers",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "Centers",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.expand_dims(Centers, 0), 0)",
                            "Call"
                        ],
                        [
                            "tf.tile(Centers, [batch_size, num_points, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(Centers, 0), 0)",
                            "Call"
                        ],
                        [
                            "tf.tile(Centers, [batch_size, num_points, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[batch_size, num_points, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_194": {
                "variable": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(point_cloud, -2)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, V, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_200": {
                "variable": {
                    "value": "A",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_x > C_x - grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_201": {
                "variable": {
                    "value": "B",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_x <= C_x + grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_202": {
                "variable": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_y > C_y - grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_203": {
                "variable": {
                    "value": "D",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_y <= C_y + grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_212": {
                "variable": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "binary_vect",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "A * B * C * D",
                            "BinOp"
                        ],
                        [
                            "binary_vect * E * F",
                            "BinOp"
                        ],
                        [
                            "A * B * C * D",
                            "BinOp"
                        ],
                        [
                            "binary_vect * E * F",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_424": {
                "variable": {
                    "value": "embedding",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "embedding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(embedding)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(embedding, 1), [1, NP, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_425": {
                "variable": {
                    "value": "embeddingB",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "embeddingB",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.squeeze(embeddingB)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(embeddingB, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(embeddingB, 1), [1, NP, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_495": {
                "variable": {
                    "value": "embedding",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "embedding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(embedding)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(embedding, 1), [1, NP, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_499": {
                "variable": {
                    "value": "embeddingB",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "embeddingB",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.squeeze(embeddingB)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(embeddingB, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(embeddingB, 1), [1, NP, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_503": {
                "variable": {
                    "value": "embedding",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(embedding, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, NP, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_505": {
                "variable": {
                    "value": "embeddingB",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(embeddingB, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, NP, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_507": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.concat([point_cloudB, embedding], -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_509": {
                "variable": {
                    "value": "netB",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.concat([point_cloud, embeddingB], -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tanh_689": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_786": {
                "variable": {
                    "value": "out_vect",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[out_vect, tf.zeros([batch_size, 1, 1, int(Embedding_Size - vec_size ** NUM_DIMS)], tf.float32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_787": {
                "variable": {
                    "value": "out_vect",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "out_vect",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "get_pc_grid_binary_mask(Embedding_Size, point_cloud)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(tf.expand_dims(out_vect, 1), [1, num_points], 'maxpool')",
                            "Call"
                        ],
                        [
                            "tf.concat([out_vect, tf.zeros([batch_size, 1, 1, int(Embedding_Size - vec_size ** NUM_DIMS)], tf.float32)], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out_vect, [batch_size, Embedding_Size])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, Embedding_Size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_919": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, grid_len, grid_len, grid_len, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "squeeze_968": {
                "variable": {
                    "value": "loss_samples",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "loss_samples",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "pred_listAB[:, :, :, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(loss_samples)",
                            "Call"
                        ]
                    ]
                }
            },
            "identity_972": {
                "variable": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reduce_mean(tf.abs(loss_samples - labels))",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "loss_samples",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_to_collection_979": {
                "name": {
                    "value": "loss_pred",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "loss_pred",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "(tf.reduce_mean(pred_listAB[:, :, :, 0]) + tf.reduce_mean(pred_listBA[:, :, :, 0])) / 2",
                            "BinOp"
                        ],
                        [
                            "tf.identity(loss_pred, name='loss_pred')",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_49": {
                "shape": {
                    "value": "[n_gaussians]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_51": {
                "shape": {
                    "value": "[n_gaussians, D]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_54": {
                "input": {
                    "value": "sigma",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "sigma * tf.ones([n_gaussians, D])",
                            "BinOp"
                        ],
                        [
                            "0.0625",
                            "MethodArgument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_55": {
                "input": {
                    "value": "batch_sig",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(sigma, 0), [n_points, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(batch_sig, 0), [n_batches, 1, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_56": {
                "input": {
                    "value": "mu",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.constant(x, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_57": {
                "input": {
                    "value": "batch_mu",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(mu, 0), [n_points, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(batch_mu, 0), [n_batches, 1, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_58": {
                "input": {
                    "value": "w",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.ones([n_gaussians]) / n_gaussians",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_59": {
                "input": {
                    "value": "points",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_74": {
                "input": {
                    "value": "tf.reduce_sum(w_p, axis=-1, keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, n_gaussians]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_75": {
                "input": {
                    "value": "Q",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "w_p / tf.tile(tf.reduce_sum(w_p, axis=-1, keepdims=True), [1, 1, n_gaussians])",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_208": {
                "variable": {
                    "value": "E",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_z > C_z - grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_209": {
                "variable": {
                    "value": "F",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_z <= C_z + grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_nd_436": {
                "variable": {
                    "value": "bv",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "bv",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(bv, tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(bv, -1), -1), [1, 1, 1, D])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(bv, tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(bv, -1), -1), [1, 1, 1, D])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tile_441": {
                "variable": {
                    "value": "bv",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.expand_dims(bv, -1), -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, 1, D]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_nd_443": {
                "variable": {
                    "value": "new_pc",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(point_cloud, -2), [1, 1, V, 1])",
                            "Call"
                        ],
                        [
                            "point_cloud - Centers",
                            "BinOp"
                        ],
                        [
                            "tf.tile(tf.expand_dims(point_cloud, -2), [1, 1, V, 1])",
                            "Call"
                        ],
                        [
                            "point_cloud - Centers",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_nd_449": {
                "variable": {
                    "value": "new_emb",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "embedding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(embedding)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(embedding, 1), [1, NP, 1])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.zeros(tf.shape(argmax), tf.int32), tf.cast(argmax, tf.int32)], 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_455": {
                "variable": {
                    "value": "new_in",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[new_pc, new_emb]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_456": {
                "variable": {
                    "value": "new_in",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "new_in",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([new_pc, new_emb], -1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(new_in, -1)",
                            "Call"
                        ],
                        [
                            "tf.concat([new_pc, new_emb], -1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(new_in, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_470": {
                "input": {
                    "value": "Centers",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.expand_dims(Centers, 0), 0)",
                            "Call"
                        ],
                        [
                            "tf.tile(Centers, [batch_size, num_points, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(Centers, 0), 0)",
                            "Call"
                        ],
                        [
                            "tf.tile(Centers, [batch_size, num_points, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_471": {
                "variable": {
                    "value": "Centers",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "Centers",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.expand_dims(Centers, 0), 0)",
                            "Call"
                        ],
                        [
                            "tf.tile(Centers, [batch_size, num_points, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(Centers, 0), 0)",
                            "Call"
                        ],
                        [
                            "tf.tile(Centers, [batch_size, num_points, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[batch_size, num_points, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_472": {
                "variable": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(point_cloud, -2)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, V, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_478": {
                "variable": {
                    "value": "A",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_x > C_x - grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_479": {
                "variable": {
                    "value": "B",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_x <= C_x + grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_480": {
                "variable": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_y > C_y - grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_481": {
                "variable": {
                    "value": "D",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_y <= C_y + grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_490": {
                "variable": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "binary_vect",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "A * B * C * D",
                            "BinOp"
                        ],
                        [
                            "binary_vect * E * F",
                            "BinOp"
                        ],
                        [
                            "A * B * C * D",
                            "BinOp"
                        ],
                        [
                            "binary_vect * E * F",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_714": {
                "name_or_scope": {
                    "value": "pointnet",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_774": {
                "name_or_scope": {
                    "value": "vox_vect",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_913": {
                "name_or_scope": {
                    "value": "local_z_3d",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "extract_volume_patches_922": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "ksizes": {
                    "value": "[1, k, k, k, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "EXTRACT_LOCAL_Z",
                    "type": "str",
                    "possible_values": []
                }
            },
            "stack_927": {
                "variable": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[X, Y, Z]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_928": {
                "variable": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ],
                        [
                            "tf.stack([X[kh:-kh, kh:-kh], Y[kh:-kh, kh:-kh]], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "tf.stack([X, Y, Z], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_929": {
                "variable": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ],
                        [
                            "tf.stack([X[kh:-kh, kh:-kh], Y[kh:-kh, kh:-kh]], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "tf.stack([X, Y, Z], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, NUM_DIMS]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_930": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [2, 0, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], output.shape[1], -1])",
                            "Call"
                        ],
                        [
                            "tf.image.extract_image_patches(net, [1, k, k, 1], [1, 1, 1, 1], rates=[1, 1, 1, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], (vec_size - 2 * kh) ** 2, -1])",
                            "Call"
                        ],
                        [
                            "tf.extract_volume_patches(net, [1, k, k, k, 1], [1, 1, 1, 1, 1], 'SAME', name='EXTRACT_LOCAL_Z')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value ** 3, -1])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, output.shape[1].value ** 3, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_935": {
                "variable": {
                    "value": "paddings",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[[0, 0], [kh, kh], [kh, kh], [kh, kh], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "pad_940": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "paddings",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.constant([[0, 0], [kh, kh], [kh, kh], [kh, kh], [0, 0]])",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "CONSTANT",
                    "type": "str",
                    "possible_values": []
                }
            },
            "stack_955": {
                "variable": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ],
                        [
                            "tf.stack([X[kh:-kh, kh:-kh], Y[kh:-kh, kh:-kh]], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "tf.stack([X, Y, Z], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_956": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [2, 0, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], output.shape[1], -1])",
                            "Call"
                        ],
                        [
                            "tf.image.extract_image_patches(net, [1, k, k, 1], [1, 1, 1, 1], rates=[1, 1, 1, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], (vec_size - 2 * kh) ** 2, -1])",
                            "Call"
                        ],
                        [
                            "tf.extract_volume_patches(net, [1, k, k, k, 1], [1, 1, 1, 1, 1], 'SAME', name='EXTRACT_LOCAL_Z')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value ** 3, -1])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value, -1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_957": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [2, 0, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], output.shape[1], -1])",
                            "Call"
                        ],
                        [
                            "tf.image.extract_image_patches(net, [1, k, k, 1], [1, 1, 1, 1], rates=[1, 1, 1, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], (vec_size - 2 * kh) ** 2, -1])",
                            "Call"
                        ],
                        [
                            "tf.extract_volume_patches(net, [1, k, k, k, 1], [1, 1, 1, 1, 1], 'SAME', name='EXTRACT_LOCAL_Z')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value ** 3, -1])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, output.shape[1].value, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_to_collection_974": {
                "name": {
                    "value": "loss_samples",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.identity(tf.reduce_mean(tf.abs(loss_samples - labels)), name='loss_samples')",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_63": {
                "input": {
                    "value": "w",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.ones([n_gaussians]) / n_gaussians",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_65": {
                "input": {
                    "value": "w",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.ones([n_gaussians]) / n_gaussians",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_74": {
                "input_tensor": {
                    "value": "w_p",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.multiply(p_per_point, batch_w)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "sqrt_98": {
                "x": {
                    "value": "w_per_batch_per_d",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(w, 0), -1), [n_batches, 1, D * 3])",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(w, 0), -1), [n_batches, 1, D])",
                            "Call"
                        ]
                    ]
                }
            },
            "pow_100": {
                "x": {
                    "value": "(batch_points - batch_mu) / batch_sig",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sqrt_109": {
                "x": {
                    "value": "2 * w_per_batch_per_d",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sign_119": {
                "x": {
                    "value": "d_pi",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([d_pi_mean, d_pi_max], 2)",
                            "Call"
                        ],
                        [
                            "d_pi_mean",
                            "Name"
                        ],
                        [
                            "tf.sign(d_pi) * tf.pow(tf.maximum(tf.abs(d_pi), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_pi, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_pi, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "pow_119": {
                "x": {
                    "value": "tf.maximum(tf.abs(d_pi), epsilon)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "alpha",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0.5",
                            "Constant"
                        ]
                    ]
                }
            },
            "sign_120": {
                "x": {
                    "value": "d_mu",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(w_per_batch_per_d) * d_mu_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_mu) * tf.pow(tf.maximum(tf.abs(d_mu), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_mu, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_mu, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "pow_120": {
                "x": {
                    "value": "tf.maximum(tf.abs(d_mu), epsilon)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "alpha",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0.5",
                            "Constant"
                        ]
                    ]
                }
            },
            "sign_121": {
                "x": {
                    "value": "d_sigma",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(2 * w_per_batch_per_d) * d_sig_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_sigma) * tf.pow(tf.maximum(tf.abs(d_sigma), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_sigma, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_sigma, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "pow_121": {
                "x": {
                    "value": "tf.maximum(tf.abs(d_sigma), epsilon)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "alpha",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0.5",
                            "Constant"
                        ]
                    ]
                }
            },
            "transpose_129": {
                "a": {
                    "value": "d_pi",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([d_pi_mean, d_pi_max], 2)",
                            "Call"
                        ],
                        [
                            "d_pi_mean",
                            "Name"
                        ],
                        [
                            "tf.sign(d_pi) * tf.pow(tf.maximum(tf.abs(d_pi), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_pi, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_pi, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_130": {
                "a": {
                    "value": "d_mu",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(w_per_batch_per_d) * d_mu_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_mu) * tf.pow(tf.maximum(tf.abs(d_mu), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_mu, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_mu, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_131": {
                "a": {
                    "value": "d_sigma",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(2 * w_per_batch_per_d) * d_sig_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_sigma) * tf.pow(tf.maximum(tf.abs(d_sigma), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_sigma, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_sigma, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_158": {
                "values": {
                    "value": "[tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_163": {
                "input": {
                    "value": "bv",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(bv, tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(bv, -1), -1), [1, 1, 1, D])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(bv, tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(bv, -1), -1), [1, 1, 1, D])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_165": {
                "values": {
                    "value": "[tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_171": {
                "values": {
                    "value": "[tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.zeros(tf.shape(argmax), tf.int32), tf.cast(argmax, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_194": {
                "input": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(point_cloud, -2), [1, 1, V, 1])",
                            "Call"
                        ],
                        [
                            "point_cloud - Centers",
                            "BinOp"
                        ],
                        [
                            "tf.tile(tf.expand_dims(point_cloud, -2), [1, 1, V, 1])",
                            "Call"
                        ],
                        [
                            "point_cloud - Centers",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "variable_scope_221": {
                "name_or_scope": {
                    "value": "dpdist_local",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "transpose_253": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_254": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_255": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, k, k, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_256": {
                "variable": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B, NP, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_257": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[net_E, net_D]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_258": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B * NP, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_292": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_293": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_294": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_295": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, k, k, k, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_296": {
                "variable": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B, NP, k, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_297": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[net_E, net_D]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_298": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B * NP, k, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_305": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_307": {
                "variable": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[B, NP, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_309": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[B * NP, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_345": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_346": {
                "variable": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[B, NP, k, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_348": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[B * NP, k, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_486": {
                "variable": {
                    "value": "E",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_z > C_z - grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_487": {
                "variable": {
                    "value": "F",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_z <= C_z + grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_503": {
                "input": {
                    "value": "embedding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(embedding)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(embedding, 1), [1, NP, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_505": {
                "input": {
                    "value": "embeddingB",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.squeeze(embeddingB)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(embeddingB, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(embeddingB, 1), [1, NP, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_507": {
                "values": {
                    "value": "[point_cloudB, embedding]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_509": {
                "values": {
                    "value": "[point_cloud, embeddingB]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "variable_scope_514": {
                "name_or_scope": {
                    "value": "dpdist_local",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "transpose_553": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_554": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_555": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, k, k, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_556": {
                "variable": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B, NP, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_557": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[net_E, net_D]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_558": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B * NP, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_592": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_593": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_594": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_595": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, k, k, k, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_596": {
                "variable": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B, NP, k, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_597": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[net_E, net_D]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_598": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B * NP, k, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_604": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_605": {
                "variable": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B, NP, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_607": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B * NP, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_643": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_644": {
                "variable": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[2 * B, NP, k, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_646": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[2 * B * NP, k, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu6_691": {
                "features": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_784": {
                "input": {
                    "value": "out_vect",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "get_pc_grid_binary_mask(Embedding_Size, point_cloud)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(tf.expand_dims(out_vect, 1), [1, num_points], 'maxpool')",
                            "Call"
                        ],
                        [
                            "tf.concat([out_vect, tf.zeros([batch_size, 1, 1, int(Embedding_Size - vec_size ** NUM_DIMS)], tf.float32)], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out_vect, [batch_size, Embedding_Size])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_838": {
                "variable": {
                    "value": "c",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[X[ii, jj, ll], Y[ii, jj, ll], Z[ii, jj, ll]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_840": {
                "variable": {
                    "value": "z_iijj",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "z_iijj",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(z_iijj)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_972": {
                "input_tensor": {
                    "value": "tf.abs(loss_samples - labels)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_78": {
                "x": {
                    "value": "batch_w",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(w, 0), 0), [n_batches, n_points, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "maximum_119": {
                "x": {
                    "value": "tf.abs(d_pi)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "epsilon",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1e-12",
                            "Constant"
                        ]
                    ]
                }
            },
            "maximum_120": {
                "x": {
                    "value": "tf.abs(d_mu)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "epsilon",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1e-12",
                            "Constant"
                        ]
                    ]
                }
            },
            "maximum_121": {
                "x": {
                    "value": "tf.abs(d_sigma)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "epsilon",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1e-12",
                            "Constant"
                        ]
                    ]
                }
            },
            "abs_188": {
                "x": {
                    "value": "Centers[0][0] - Centers[1][0]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_190": {
                "x": {
                    "value": "Centers[0][2] - Centers[1][2]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_273": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B, NP, 1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_324": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[B, NP, 1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_325": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[net, net_D]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_373": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[B, NP, 1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_374": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[net, net_D]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_436": {
                "values": {
                    "value": "[tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_441": {
                "input": {
                    "value": "bv",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(bv, tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(bv, -1), -1), [1, 1, 1, D])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(bv, tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(bv, -1), -1), [1, 1, 1, D])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_443": {
                "values": {
                    "value": "[tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_449": {
                "values": {
                    "value": "[tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.zeros(tf.shape(argmax), tf.int32), tf.cast(argmax, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_472": {
                "input": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(point_cloud, -2), [1, 1, V, 1])",
                            "Call"
                        ],
                        [
                            "point_cloud - Centers",
                            "BinOp"
                        ],
                        [
                            "tf.tile(tf.expand_dims(point_cloud, -2), [1, 1, V, 1])",
                            "Call"
                        ],
                        [
                            "point_cloud - Centers",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_573": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B, NP, 1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_622": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B, NP, 1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_623": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[net, net_D]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_668": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[2 * B, NP, 1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "identity_669": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "embedding_layer",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_670": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[net, net_D]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "relu6_693": {
                "features": {
                    "value": "net + 3",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_786": {
                "shape": {
                    "value": "[batch_size, 1, 1, int(Embedding_Size - vec_size ** NUM_DIMS)]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "abs_972": {
                "x": {
                    "value": "loss_samples - labels",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_976": {
                "input_tensor": {
                    "value": "pred_listAB[:, :, :, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_mean_977": {
                "input_tensor": {
                    "value": "pred_listBA[:, :, :, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "abs_119": {
                "x": {
                    "value": "d_pi",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([d_pi_mean, d_pi_max], 2)",
                            "Call"
                        ],
                        [
                            "d_pi_mean",
                            "Name"
                        ],
                        [
                            "tf.sign(d_pi) * tf.pow(tf.maximum(tf.abs(d_pi), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_pi, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_pi, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "abs_120": {
                "x": {
                    "value": "d_mu",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(w_per_batch_per_d) * d_mu_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_mu) * tf.pow(tf.maximum(tf.abs(d_mu), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_mu, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_mu, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "abs_121": {
                "x": {
                    "value": "d_sigma",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(2 * w_per_batch_per_d) * d_sig_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_sigma) * tf.pow(tf.maximum(tf.abs(d_sigma), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_sigma, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_sigma, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_159": {
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(argmax)[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_160": {
                "a": {
                    "value": "tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_161": {
                "x": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_166": {
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(argmax)[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_167": {
                "a": {
                    "value": "tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_168": {
                "x": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_172": {
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(argmax)[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_173": {
                "shape": {
                    "value": "tf.shape(argmax)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_174": {
                "x": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_260": {
                "name_or_scope": {
                    "value": "dpdist_local_cnn_fc",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_311": {
                "name_or_scope": {
                    "value": "dpdist_local_cnn_fc",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_349": {
                "name_or_scope": {
                    "value": "dpdist_local_cnn_fc",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "abs_466": {
                "x": {
                    "value": "Centers[0][0] - Centers[1][0]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_468": {
                "x": {
                    "value": "Centers[0][2] - Centers[1][2]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_560": {
                "name_or_scope": {
                    "value": "dpdist_local_cnn_fc",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_609": {
                "name_or_scope": {
                    "value": "dpdist_local_cnn_fc",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_647": {
                "name_or_scope": {
                    "value": "dpdist_local_cnn_fc",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "stack_951": {
                "variable": {
                    "value": "c",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[X[ii, jj, ll], Y[ii, jj, ll], Z[ii, jj, ll]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_159": {
                "input": {
                    "value": "tf.range(tf.shape(argmax)[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_160": {
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(argmax)[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_166": {
                "input": {
                    "value": "tf.range(tf.shape(argmax)[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_167": {
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(argmax)[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_172": {
                "input": {
                    "value": "tf.range(tf.shape(argmax)[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_173": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_437": {
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(argmax)[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_438": {
                "a": {
                    "value": "tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_439": {
                "x": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_444": {
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(argmax)[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_445": {
                "a": {
                    "value": "tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_446": {
                "x": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_450": {
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(argmax)[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_451": {
                "shape": {
                    "value": "tf.shape(argmax)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_452": {
                "x": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_160": {
                "input": {
                    "value": "tf.range(tf.shape(argmax)[1])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_167": {
                "input": {
                    "value": "tf.range(tf.shape(argmax)[1])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_437": {
                "input": {
                    "value": "tf.range(tf.shape(argmax)[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_438": {
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(argmax)[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_444": {
                "input": {
                    "value": "tf.range(tf.shape(argmax)[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_445": {
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(argmax)[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_450": {
                "input": {
                    "value": "tf.range(tf.shape(argmax)[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_451": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_832": {
                "variable": {
                    "value": "z_ij",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.zeros([batch_size, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_159": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_166": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_172": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_438": {
                "input": {
                    "value": "tf.range(tf.shape(argmax)[1])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_445": {
                "input": {
                    "value": "tf.range(tf.shape(argmax)[1])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_160": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_167": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_437": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_444": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_450": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_438": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_445": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "models/dpdist_and_aue.py": {
        "tensorflow": {
            "placeholder_24": {
                "variable": {
                    "value": "pcA_pl",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point, NUM_DIMS)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "input1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_25": {
                "variable": {
                    "value": "pcB_pl",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point, NUM_DIMS)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "input2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_26": {
                "variable": {
                    "value": "labels_AB",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "labels12",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_27": {
                "variable": {
                    "value": "labels_BA",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "labels21",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_198": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[one_by_one, three_by_three, five_by_five, average_pooling]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                }
            },
            "identity_78": {
                "variable": {
                    "value": "pred_listAB",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pred_listAB",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[0]",
                            "Subscript"
                        ],
                        [
                            "tf.identity(pred_listAB, 'output1')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "output1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_79": {
                "variable": {
                    "value": "pred_listBA",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pred_listBA",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[1]",
                            "Subscript"
                        ],
                        [
                            "tf.identity(pred_listBA, 'output2')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "output2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_107": {
                "variable": {
                    "value": "input_image",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_133": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "global_feat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tanh_141": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "dpdist.DPDist(pcA, pcB, embedding_A, embedding_B, C, is_training, bn_decay=bn_decay, reuse=None, bn=bn, wd=wd, sig=sig, Embedding_Size=Embedding_Size, NUM_DIMS=NUM_DIMS, mlp=localSNmlp, k=k, output_act='relu', conv_version=conv_version)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, point_dim], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(point_feat, 128, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 1024, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf.reshape(global_feat, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, num_point * 3, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, (batch_size, num_point, 3))",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'output')",
                            "Call"
                        ],
                        [
                            "inception_module(grid_fisher, n_filters=256, kernel_sizes=[3, 5], is_training=is_training, bn_decay=bn_decay, scope='inception' + str(layer))",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc' + str(layer), bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, n_points * 3, bn=True, is_training=is_training, scope='fc' + str(layer), bn_decay=bn_decay, activation_fn=None)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_143": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "dpdist.DPDist(pcA, pcB, embedding_A, embedding_B, C, is_training, bn_decay=bn_decay, reuse=None, bn=bn, wd=wd, sig=sig, Embedding_Size=Embedding_Size, NUM_DIMS=NUM_DIMS, mlp=localSNmlp, k=k, output_act='relu', conv_version=conv_version)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, point_dim], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(point_feat, 128, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 1024, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf.reshape(global_feat, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, num_point * 3, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, (batch_size, num_point, 3))",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'output')",
                            "Call"
                        ],
                        [
                            "inception_module(grid_fisher, n_filters=256, kernel_sizes=[3, 5], is_training=is_training, bn_decay=bn_decay, scope='inception' + str(layer))",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc' + str(layer), bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, n_points * 3, bn=True, is_training=is_training, scope='fc' + str(layer), bn_decay=bn_decay, activation_fn=None)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(batch_size, num_point, 3)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "identity_144": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "dpdist.DPDist(pcA, pcB, embedding_A, embedding_B, C, is_training, bn_decay=bn_decay, reuse=None, bn=bn, wd=wd, sig=sig, Embedding_Size=Embedding_Size, NUM_DIMS=NUM_DIMS, mlp=localSNmlp, k=k, output_act='relu', conv_version=conv_version)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, point_dim], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(point_feat, 128, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 1024, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf.reshape(global_feat, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, num_point * 3, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, (batch_size, num_point, 3))",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'output')",
                            "Call"
                        ],
                        [
                            "inception_module(grid_fisher, n_filters=256, kernel_sizes=[3, 5], is_training=is_training, bn_decay=bn_decay, scope='inception' + str(layer))",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc' + str(layer), bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, n_points * 3, bn=True, is_training=is_training, scope='fc' + str(layer), bn_decay=bn_decay, activation_fn=None)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "output",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_158": {
                "variable": {
                    "value": "grid_fisher",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "fv",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "dpdist.get_3dmfv_tf(points, n_gaussians=n_gaussians)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1, res, res, res]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_159": {
                "variable": {
                    "value": "grid_fisher",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "grid_fisher",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(fv, [batch_size, -1, res, res, res])",
                            "Call"
                        ],
                        [
                            "tf.transpose(grid_fisher, [0, 2, 3, 4, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 3, 4, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_167": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "dpdist.DPDist(pcA, pcB, embedding_A, embedding_B, C, is_training, bn_decay=bn_decay, reuse=None, bn=bn, wd=wd, sig=sig, Embedding_Size=Embedding_Size, NUM_DIMS=NUM_DIMS, mlp=localSNmlp, k=k, output_act='relu', conv_version=conv_version)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, point_dim], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(point_feat, 128, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 1024, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf.reshape(global_feat, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, num_point * 3, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, (batch_size, num_point, 3))",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'output')",
                            "Call"
                        ],
                        [
                            "inception_module(grid_fisher, n_filters=256, kernel_sizes=[3, 5], is_training=is_training, bn_decay=bn_decay, scope='inception' + str(layer))",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc' + str(layer), bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, n_points * 3, bn=True, is_training=is_training, scope='fc' + str(layer), bn_decay=bn_decay, activation_fn=None)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_176": {
                "variable": {
                    "value": "reconstructed_points",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "dpdist.DPDist(pcA, pcB, embedding_A, embedding_B, C, is_training, bn_decay=bn_decay, reuse=None, bn=bn, wd=wd, sig=sig, Embedding_Size=Embedding_Size, NUM_DIMS=NUM_DIMS, mlp=localSNmlp, k=k, output_act='relu', conv_version=conv_version)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, point_dim], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(point_feat, 128, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 1024, [1, 1], padding='VALID', stride=[1, 1], bn=True, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf.reshape(global_feat, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, num_point * 3, activation_fn=None, scope='fc3')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, (batch_size, num_point, 3))",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'output')",
                            "Call"
                        ],
                        [
                            "inception_module(grid_fisher, n_filters=256, kernel_sizes=[3, 5], is_training=is_training, bn_decay=bn_decay, scope='inception' + str(layer))",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=True, is_training=is_training, scope='fc' + str(layer), bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, n_points * 3, bn=True, is_training=is_training, scope='fc' + str(layer), bn_decay=bn_decay, activation_fn=None)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, n_points, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tanh_178": {
                "variable": {
                    "value": "reconstructed_points",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "reconstructed_points",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(net, [batch_size, n_points, 3])",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(reconstructed_points)",
                            "Call"
                        ],
                        [
                            "tf.identity(reconstructed_points, 'output')",
                            "Call"
                        ]
                    ]
                }
            },
            "identity_179": {
                "variable": {
                    "value": "reconstructed_points",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "reconstructed_points",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(net, [batch_size, n_points, 3])",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(reconstructed_points)",
                            "Call"
                        ],
                        [
                            "tf.identity(reconstructed_points, 'output')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "output",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_36": {
                "name_or_scope": {
                    "value": "pc_compare",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "variable_scope_101": {
                "name_or_scope": {
                    "value": "aue",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "variable_scope_152": {
                "name_or_scope": {
                    "value": "aue",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            }
        }
    },
    "pcrnet-registration/helper.py": {
        "tensorflow": {
            "cos_481": {
                "variable": {
                    "value": "cosval",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "rotation_angle",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "sin_482": {
                "variable": {
                    "value": "sinval",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "rotation_angle",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reshape_483": {
                "variable": {
                    "value": "rotation_matrix",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "[[cosval, 0, sinval], [0, 1, 0], [-sinval, 0, cosval]]",
                    "type": "List",
                    "possible_values": []
                },
                "shape": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_484": {
                "variable": {
                    "value": "data",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "data",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "templates_data(templates_dict)",
                            "Call"
                        ],
                        [
                            "np.asarray(data)",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [-1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [-1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [-1, 3])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.asarray(data)",
                            "Call"
                        ],
                        [
                            "data[start_idx:end_idx, :]",
                            "Subscript"
                        ],
                        [
                            "data.tolist()",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_485": {
                "a": {
                    "value": "data",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "templates_data(templates_dict)",
                            "Call"
                        ],
                        [
                            "np.asarray(data)",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [-1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [-1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [-1, 3])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.asarray(data)",
                            "Call"
                        ],
                        [
                            "data[start_idx:end_idx, :]",
                            "Subscript"
                        ],
                        [
                            "data.tolist()",
                            "Call"
                        ]
                    ]
                }
            },
            "cos_495": {
                "variable": {
                    "value": "cosval",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "rotation_angle",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "sin_496": {
                "variable": {
                    "value": "sinval",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "rotation_angle",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reshape_497": {
                "variable": {
                    "value": "rotation_matrix",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "[[1, 0, 0], [0, cosval, -sinval], [0, sinval, cosval]]",
                    "type": "List",
                    "possible_values": []
                },
                "shape": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_498": {
                "variable": {
                    "value": "data",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "data",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "templates_data(templates_dict)",
                            "Call"
                        ],
                        [
                            "np.asarray(data)",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [-1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [-1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [-1, 3])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.asarray(data)",
                            "Call"
                        ],
                        [
                            "data[start_idx:end_idx, :]",
                            "Subscript"
                        ],
                        [
                            "data.tolist()",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_499": {
                "a": {
                    "value": "data",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "templates_data(templates_dict)",
                            "Call"
                        ],
                        [
                            "np.asarray(data)",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [-1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [-1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [-1, 3])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.asarray(data)",
                            "Call"
                        ],
                        [
                            "data[start_idx:end_idx, :]",
                            "Subscript"
                        ],
                        [
                            "data.tolist()",
                            "Call"
                        ]
                    ]
                }
            },
            "cos_509": {
                "variable": {
                    "value": "cosval",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "rotation_angle",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "sin_510": {
                "variable": {
                    "value": "sinval",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "rotation_angle",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reshape_511": {
                "variable": {
                    "value": "rotation_matrix",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "[[cosval, -sinval, 0], [sinval, cosval, 0], [0, 0, 1]]",
                    "type": "List",
                    "possible_values": []
                },
                "shape": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_512": {
                "variable": {
                    "value": "data",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "data",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "templates_data(templates_dict)",
                            "Call"
                        ],
                        [
                            "np.asarray(data)",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [-1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [-1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [-1, 3])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.asarray(data)",
                            "Call"
                        ],
                        [
                            "data[start_idx:end_idx, :]",
                            "Subscript"
                        ],
                        [
                            "data.tolist()",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_513": {
                "a": {
                    "value": "data",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "templates_data(templates_dict)",
                            "Call"
                        ],
                        [
                            "np.asarray(data)",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [-1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [-1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [-1, 3])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.asarray(data)",
                            "Call"
                        ],
                        [
                            "data[start_idx:end_idx, :]",
                            "Subscript"
                        ],
                        [
                            "data.tolist()",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_528": {
                "variable": {
                    "value": "transformed_data",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[datas.shape[1], datas.shape[2]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_547": {
                "variable": {
                    "value": "transformed_data",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[data.shape[1], 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sqrt_572": {
                "variable": {
                    "value": "x_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(tf.square(x), -1, keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stack_591": {
                "variable": {
                    "value": "Rmatrix",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x, y, z]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_598": {
                "variable": {
                    "value": "transformed_data",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "transformed_data",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.zeros(datas.shape, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "tf.zeros([datas.shape[1], datas.shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.concat([transformed_data, transformed_data_t], 0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(transformed_data, [-1, datas.shape[1], datas.shape[2]])[1:]",
                            "Subscript"
                        ],
                        [
                            "tf.zeros([data.shape[1], 3])",
                            "Call"
                        ],
                        [
                            "tf.concat([transformed_data, temp_rotated_data], 0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(transformed_data, [-1, data.shape[1], 3])[1:]",
                            "Subscript"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(transformed_data, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_518": {
                "x": {
                    "value": "data",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "templates_data(templates_dict)",
                            "Call"
                        ],
                        [
                            "np.asarray(data)",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [-1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [-1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [-1, 3])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.asarray(data)",
                            "Call"
                        ],
                        [
                            "data[start_idx:end_idx, :]",
                            "Subscript"
                        ],
                        [
                            "data.tolist()",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "shift",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "concat_534": {
                "variable": {
                    "value": "transformed_data",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[transformed_data, transformed_data_t]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "slice_550": {
                "variable": {
                    "value": "q0",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "begin": {
                    "value": "[i, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_551": {
                "variable": {
                    "value": "q1",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "begin": {
                    "value": "[i, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_552": {
                "variable": {
                    "value": "q2",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "begin": {
                    "value": "[i, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_553": {
                "variable": {
                    "value": "q3",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "begin": {
                    "value": "[i, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_561": {
                "variable": {
                    "value": "R",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "R",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[[q0 * q0 + q1 * q1 - q2 * q2 - q3 * q3, 2 * (q1 * q2 - q0 * q3), 2 * (q1 * q3 + q0 * q2)], [2 * (q1 * q2 + q0 * q3), q0 * q0 + q2 * q2 - q1 * q1 - q3 * q3, 2 * (q2 * q3 - q0 * q1)], [2 * (q1 * q3 - q0 * q2), 2 * (q2 * q3 + q0 * q1), q0 * q0 + q3 * q3 - q1 * q1 - q2 * q2]]",
                            "List"
                        ],
                        [
                            "tf.reshape(R, [3, 3])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_566": {
                "a": {
                    "value": "data[i, ...]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "add_567": {
                "variable": {
                    "value": "temp_rotated_data",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "temp_rotated_data",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.transpose(tf.tensordot(R, tf.transpose(data[i, ...]), [1, 0]))",
                            "Call"
                        ],
                        [
                            "tf.add(temp_rotated_data, translation[i, ...])",
                            "Call"
                        ],
                        [
                            "tf.transpose(tf.tensordot(Rmatrix[i, ...], tf.transpose(data[i, ...]), [1, 0]))",
                            "Call"
                        ],
                        [
                            "tf.add(temp_rotated_data, translation[i, ...])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "translation[i, ...]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "concat_568": {
                "variable": {
                    "value": "transformed_data",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[transformed_data, temp_rotated_data]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cross_575": {
                "a": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.round(2 * np.random.random_sample() - 1, 2)",
                            "Call"
                        ],
                        [
                            "normalize_vector(x_raw)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "y",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.round(2 * np.random.random_sample() - 1, 2)",
                            "Call"
                        ],
                        [
                            "cross_product(z, x)",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_595": {
                "a": {
                    "value": "data[i, ...]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "add_596": {
                "variable": {
                    "value": "temp_rotated_data",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "temp_rotated_data",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.transpose(tf.tensordot(R, tf.transpose(data[i, ...]), [1, 0]))",
                            "Call"
                        ],
                        [
                            "tf.add(temp_rotated_data, translation[i, ...])",
                            "Call"
                        ],
                        [
                            "tf.transpose(tf.tensordot(Rmatrix[i, ...], tf.transpose(data[i, ...]), [1, 0]))",
                            "Call"
                        ],
                        [
                            "tf.add(temp_rotated_data, translation[i, ...])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "translation[i, ...]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "tensordot_485": {
                "a": {
                    "value": "rotation_matrix",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.array([[cosval, 0, sinval], [0, 1, 0], [-sinval, 0, cosval]])",
                            "Call"
                        ],
                        [
                            "np.array([[1, 0, 0], [0, cosval, -sinval], [0, sinval, cosval]])",
                            "Call"
                        ],
                        [
                            "np.array([[cosval, -sinval, 0], [sinval, cosval, 0], [0, 0, 1]])",
                            "Call"
                        ],
                        [
                            "tf.reshape([[cosval, 0, sinval], [0, 1, 0], [-sinval, 0, cosval]], [3, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape([[1, 0, 0], [0, cosval, -sinval], [0, sinval, cosval]], [3, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape([[cosval, -sinval, 0], [sinval, cosval, 0], [0, 0, 1]], [3, 3])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.transpose(data)",
                    "type": "Call",
                    "possible_values": []
                },
                "axes": {
                    "value": "[1, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tensordot_499": {
                "a": {
                    "value": "rotation_matrix",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.array([[cosval, 0, sinval], [0, 1, 0], [-sinval, 0, cosval]])",
                            "Call"
                        ],
                        [
                            "np.array([[1, 0, 0], [0, cosval, -sinval], [0, sinval, cosval]])",
                            "Call"
                        ],
                        [
                            "np.array([[cosval, -sinval, 0], [sinval, cosval, 0], [0, 0, 1]])",
                            "Call"
                        ],
                        [
                            "tf.reshape([[cosval, 0, sinval], [0, 1, 0], [-sinval, 0, cosval]], [3, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape([[1, 0, 0], [0, cosval, -sinval], [0, sinval, cosval]], [3, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape([[cosval, -sinval, 0], [sinval, cosval, 0], [0, 0, 1]], [3, 3])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.transpose(data)",
                    "type": "Call",
                    "possible_values": []
                },
                "axes": {
                    "value": "[1, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tensordot_513": {
                "a": {
                    "value": "rotation_matrix",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.array([[cosval, 0, sinval], [0, 1, 0], [-sinval, 0, cosval]])",
                            "Call"
                        ],
                        [
                            "np.array([[1, 0, 0], [0, cosval, -sinval], [0, sinval, cosval]])",
                            "Call"
                        ],
                        [
                            "np.array([[cosval, -sinval, 0], [sinval, cosval, 0], [0, 0, 1]])",
                            "Call"
                        ],
                        [
                            "tf.reshape([[cosval, 0, sinval], [0, 1, 0], [-sinval, 0, cosval]], [3, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape([[1, 0, 0], [0, cosval, -sinval], [0, sinval, cosval]], [3, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape([[cosval, -sinval, 0], [sinval, cosval, 0], [0, 0, 1]], [3, 3])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.transpose(data)",
                    "type": "Call",
                    "possible_values": []
                },
                "axes": {
                    "value": "[1, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_535": {
                "tensor": {
                    "value": "transformed_data",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.zeros(datas.shape, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "tf.zeros([datas.shape[1], datas.shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.concat([transformed_data, transformed_data_t], 0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(transformed_data, [-1, datas.shape[1], datas.shape[2]])[1:]",
                            "Subscript"
                        ],
                        [
                            "tf.zeros([data.shape[1], 3])",
                            "Call"
                        ],
                        [
                            "tf.concat([transformed_data, temp_rotated_data], 0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(transformed_data, [-1, data.shape[1], 3])[1:]",
                            "Subscript"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(transformed_data, 0)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, datas.shape[1], datas.shape[2]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_569": {
                "tensor": {
                    "value": "transformed_data",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.zeros(datas.shape, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "tf.zeros([datas.shape[1], datas.shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.concat([transformed_data, transformed_data_t], 0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(transformed_data, [-1, datas.shape[1], datas.shape[2]])[1:]",
                            "Subscript"
                        ],
                        [
                            "tf.zeros([data.shape[1], 3])",
                            "Call"
                        ],
                        [
                            "tf.concat([transformed_data, temp_rotated_data], 0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(transformed_data, [-1, data.shape[1], 3])[1:]",
                            "Subscript"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(transformed_data, 0)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, data.shape[1], 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_572": {
                "input_tensor": {
                    "value": "tf.square(x)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "tensordot_566": {
                "a": {
                    "value": "R",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[[q0 * q0 + q1 * q1 - q2 * q2 - q3 * q3, 2 * (q1 * q2 - q0 * q3), 2 * (q1 * q3 + q0 * q2)], [2 * (q1 * q2 + q0 * q3), q0 * q0 + q2 * q2 - q1 * q1 - q3 * q3, 2 * (q2 * q3 - q0 * q1)], [2 * (q1 * q3 - q0 * q2), 2 * (q2 * q3 + q0 * q1), q0 * q0 + q3 * q3 - q1 * q1 - q2 * q2]]",
                            "List"
                        ],
                        [
                            "tf.reshape(R, [3, 3])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.transpose(data[i, ...])",
                    "type": "Call",
                    "possible_values": []
                },
                "axes": {
                    "value": "[1, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "square_572": {
                "x": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.round(2 * np.random.random_sample() - 1, 2)",
                            "Call"
                        ],
                        [
                            "normalize_vector(x_raw)",
                            "Call"
                        ]
                    ]
                }
            },
            "tensordot_595": {
                "a": {
                    "value": "Rmatrix[i, ...]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "tf.transpose(data[i, ...])",
                    "type": "Call",
                    "possible_values": []
                },
                "axes": {
                    "value": "[1, 0]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "pcrnet-registration/iterative_PCRNet.py": {
        "tensorflow": {
            "exponential_decay_140": {
                "variable": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "BASE_LEARNING_RATE",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "FLAGS.learning_rate",
                            "Attribute"
                        ]
                    ]
                },
                "global_step": {
                    "value": "batch * BATCH_SIZE",
                    "type": "BinOp",
                    "possible_values": []
                },
                "decay_steps": {
                    "value": "DECAY_STEP",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "FLAGS.decay_step",
                            "Attribute"
                        ]
                    ]
                },
                "decay_rate": {
                    "value": "DECAY_RATE",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "FLAGS.decay_rate",
                            "Attribute"
                        ]
                    ]
                },
                "staircase": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "maximum_146": {
                "variable": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.train.exponential_decay(BASE_LEARNING_RATE, batch * BATCH_SIZE, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-05)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                }
            },
            "ConfigProto_186": {
                "variable": {
                    "value": "config",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_190": {
                "variable": {
                    "value": "sess",
                    "type": "Variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ]
                    ]
                }
            },
            "merge_all_193": {
                "variable": {
                    "value": "merged",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_200": {
                "variable": {
                    "value": "init",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_150": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Variable_152": {
                "variable": {
                    "value": "batch",
                    "type": "Variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "placeholder_155": {
                "variable": {
                    "value": "is_training_pl",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Saver_180": {
                "variable": {
                    "value": "saver",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FileWriter_195": {
                "variable": {
                    "value": "train_writer",
                    "type": "Variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "os.path.join(LOG_DIR, 'train')",
                    "type": "Call",
                    "possible_values": []
                },
                "graph": {
                    "value": "sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FileWriter_197": {
                "variable": {
                    "value": "eval_writer",
                    "type": "Variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "os.path.join(LOG_DIR, 'eval')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "device_151": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "device_154": {
                "device_name": {
                    "value": "'/gpu:' + str(GPU_INDEX)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "MomentumOptimizer_172": {
                "variable": {
                    "value": "optimizer",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.train.exponential_decay(BASE_LEARNING_RATE, batch * BATCH_SIZE, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-05)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch)",
                            "Call"
                        ]
                    ]
                },
                "momentum": {
                    "value": "MOMENTUM",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "FLAGS.momentum",
                            "Attribute"
                        ]
                    ]
                }
            },
            "device_178": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "scalar_181": {
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "MODEL.get_loss(predicted_transformation, BATCH_SIZE, template_pointclouds_pl, source_pointclouds_pl, loss_type=FLAGS.loss_type)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_182": {
                "name": {
                    "value": "learning_rate",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.train.exponential_decay(BASE_LEARNING_RATE, batch * BATCH_SIZE, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-05)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_159": {
                "name_or_scope": {
                    "value": "Network",
                    "type": "str",
                    "possible_values": []
                }
            },
            "AdamOptimizer_174": {
                "variable": {
                    "value": "optimizer",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.train.exponential_decay(BASE_LEARNING_RATE, batch * BATCH_SIZE, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-05)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "pcrnet-registration/iterative_PCRNet_ours.py": {
        "tensorflow": {
            "exponential_decay_146": {
                "variable": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "BASE_LEARNING_RATE",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "FLAGS.learning_rate",
                            "Attribute"
                        ]
                    ]
                },
                "global_step": {
                    "value": "batch * BATCH_SIZE",
                    "type": "BinOp",
                    "possible_values": []
                },
                "decay_steps": {
                    "value": "DECAY_STEP",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "FLAGS.decay_step",
                            "Attribute"
                        ]
                    ]
                },
                "decay_rate": {
                    "value": "DECAY_RATE",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "FLAGS.decay_rate",
                            "Attribute"
                        ]
                    ]
                },
                "staircase": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "maximum_152": {
                "variable": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.train.exponential_decay(BASE_LEARNING_RATE, batch * BATCH_SIZE, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-05)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                }
            },
            "global_variables_157": {
                "variable": {
                    "value": "global_vars",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "expand_dims_172": {
                "variable": {
                    "value": "xx",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_173": {
                "variable": {
                    "value": "xx",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "xx",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(x, -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(xx, tf.stack([1, 1, 1, size_y]))",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "tf.stack([1, 1, 1, size_y])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_175": {
                "variable": {
                    "value": "yy",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "y",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_176": {
                "variable": {
                    "value": "yy",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "yy",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(y, -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(yy, tf.stack([1, 1, 1, size_x]))",
                            "Call"
                        ],
                        [
                            "tf.transpose(yy, perm=[0, 3, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "tf.stack([1, 1, 1, size_x])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "transpose_177": {
                "variable": {
                    "value": "yy",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "yy",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(y, -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(yy, tf.stack([1, 1, 1, size_x]))",
                            "Call"
                        ],
                        [
                            "tf.transpose(yy, perm=[0, 3, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 3, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "subtract_179": {
                "variable": {
                    "value": "diff",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "xx",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(x, -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(xx, tf.stack([1, 1, 1, size_y]))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "yy",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(y, -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(yy, tf.stack([1, 1, 1, size_x]))",
                            "Call"
                        ],
                        [
                            "tf.transpose(yy, perm=[0, 3, 2, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "square_180": {
                "variable": {
                    "value": "square_diff",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "diff",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.subtract(xx, yy)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_181": {
                "variable": {
                    "value": "square_dist",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "square_diff",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.square(diff)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_185": {
                "variable": {
                    "value": "s1_s2",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.reduce_min(pairwise_diff(rec_pc, pc), axis=2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_186": {
                "variable": {
                    "value": "s2_s1",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.reduce_min(pairwise_diff(pc, rec_pc), axis=2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Graph_191": {
                "variable": {
                    "value": "graph",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ConfigProto_270": {
                "variable": {
                    "value": "config",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_274": {
                "variable": {
                    "value": "sess",
                    "type": "Variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ]
                    ]
                }
            },
            "merge_278": {
                "variable": {
                    "value": "merged",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[sum_loss, sum_lr, chamfer_loss]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "global_variables_initializer_286": {
                "variable": {
                    "value": "init",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "shape_170": {
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "shape_171": {
                "input": {
                    "value": "y",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "stack_173": {
                "values": {
                    "value": "[1, 1, 1, size_y]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_176": {
                "values": {
                    "value": "[1, 1, 1, size_x]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_min_185": {
                "input_tensor": {
                    "value": "pairwise_diff(rec_pc, pc)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_min_186": {
                "input_tensor": {
                    "value": "pairwise_diff(pc, rec_pc)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Variable_194": {
                "variable": {
                    "value": "batch",
                    "type": "Variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "placeholder_197": {
                "variable": {
                    "value": "is_training_pl",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "slice_213": {
                "variable": {
                    "value": "predicted_position",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "predicted_transformation",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "MODEL.get_pose(source_global_feature, template_global_feature, is_training_pl, bn_decay=None, lim_rot=FLAGS.lim_rot)",
                            "Call"
                        ],
                        [
                            "sess.run([ops['predicted_transformation']], feed_dict=feed_dict)",
                            "Call"
                        ],
                        [
                            "sess.run([ops['predicted_transformation']], feed_dict=feed_dict)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[batch_size, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_214": {
                "variable": {
                    "value": "predicted_quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "predicted_transformation",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "MODEL.get_pose(source_global_feature, template_global_feature, is_training_pl, bn_decay=None, lim_rot=FLAGS.lim_rot)",
                            "Call"
                        ],
                        [
                            "sess.run([ops['predicted_transformation']], feed_dict=feed_dict)",
                            "Call"
                        ],
                        [
                            "sess.run([ops['predicted_transformation']], feed_dict=feed_dict)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[batch_size, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_215": {
                "variable": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(predicted_quat)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sqrt_216": {
                "variable": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.square(predicted_quat), 1)",
                            "Call"
                        ],
                        [
                            "tf.sqrt(norm_predicted_quat)",
                            "Call"
                        ],
                        [
                            "tf.reshape(norm_predicted_quat, (batch_size, 1))",
                            "Call"
                        ],
                        [
                            "tf.add(norm_predicted_quat, const)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_217": {
                "variable": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.square(predicted_quat), 1)",
                            "Call"
                        ],
                        [
                            "tf.sqrt(norm_predicted_quat)",
                            "Call"
                        ],
                        [
                            "tf.reshape(norm_predicted_quat, (batch_size, 1))",
                            "Call"
                        ],
                        [
                            "tf.add(norm_predicted_quat, const)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(batch_size, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "constant_218": {
                "variable": {
                    "value": "const",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "1e-07",
                    "type": "float",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_219": {
                "variable": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.square(predicted_quat), 1)",
                            "Call"
                        ],
                        [
                            "tf.sqrt(norm_predicted_quat)",
                            "Call"
                        ],
                        [
                            "tf.reshape(norm_predicted_quat, (batch_size, 1))",
                            "Call"
                        ],
                        [
                            "tf.add(norm_predicted_quat, const)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "const",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.constant(1e-07, shape=(batch_size, 1), dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "divide_220": {
                "variable": {
                    "value": "predicted_norm_quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "predicted_quat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.slice(predicted_transformation, [0, 3], [batch_size, 4])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.square(predicted_quat), 1)",
                            "Call"
                        ],
                        [
                            "tf.sqrt(norm_predicted_quat)",
                            "Call"
                        ],
                        [
                            "tf.reshape(norm_predicted_quat, (batch_size, 1))",
                            "Call"
                        ],
                        [
                            "tf.add(norm_predicted_quat, const)",
                            "Call"
                        ]
                    ]
                }
            },
            "placeholder_226": {
                "variable": {
                    "value": "is_training_pl_1",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "import_meta_graph_229": {
                "variable": {
                    "value": "saver31",
                    "type": "Variable",
                    "possible_values": []
                },
                "meta_graph_or_file": {
                    "value": "os.path.join(LOG_DIR, 'model.ckpt.meta')",
                    "type": "Call",
                    "possible_values": []
                },
                "import_scope": {
                    "value": "g1",
                    "type": "str",
                    "possible_values": []
                },
                "input_map": {
                    "value": "{'input1': transformed_predicted_point_cloud, 'input2': template_pointclouds_pl, 'Placeholder': is_training_pl_1}",
                    "type": "Dict",
                    "possible_values": []
                },
                "clear_devices": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_collection_255": {
                "variable": {
                    "value": "train_vars",
                    "type": "Variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "Network",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Saver_263": {
                "variable": {
                    "value": "saver",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_264": {
                "variable": {
                    "value": "sum_lr",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "learning_rate",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.train.exponential_decay(BASE_LEARNING_RATE, batch * BATCH_SIZE, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-05)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_265": {
                "variable": {
                    "value": "sum_loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "(s1_s2 + s2_s1) / 2.0",
                            "BinOp"
                        ],
                        [
                            "(tf.reduce_mean(pred_AB3[:, :, :, 0]) + tf.reduce_mean(pred_BA3[:, :, :, 0])) / 2.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "scalar_266": {
                "variable": {
                    "value": "chamfer_loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "loss_chamfer",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "loss_c",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "chmafer_dist(transformed_predicted_point_cloud, template_pointclouds_pl)",
                            "Call"
                        ]
                    ]
                }
            },
            "FileWriter_281": {
                "variable": {
                    "value": "train_writer",
                    "type": "Variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "os.path.join(LOG_DIR, 'train')",
                    "type": "Call",
                    "possible_values": []
                },
                "graph": {
                    "value": "sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FileWriter_283": {
                "variable": {
                    "value": "eval_writer",
                    "type": "Variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "os.path.join(LOG_DIR, 'eval')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variables_initializer_165": {
                "var_list": {
                    "value": "not_initialized_vars",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "list(compress(global_vars, is_not_initialized))",
                            "Call"
                        ]
                    ]
                }
            },
            "device_193": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "device_196": {
                "device_name": {
                    "value": "'/gpu:' + str(GPU_INDEX)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "MomentumOptimizer_240": {
                "variable": {
                    "value": "optimizer3",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.train.exponential_decay(BASE_LEARNING_RATE, batch * BATCH_SIZE, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-05)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch)",
                            "Call"
                        ]
                    ]
                },
                "momentum": {
                    "value": "MOMENTUM",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "FLAGS.momentum",
                            "Attribute"
                        ]
                    ]
                }
            },
            "device_261": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "is_variable_initialized_158": {
                "variable": {
                    "value": "var",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_201": {
                "name_or_scope": {
                    "value": "Network",
                    "type": "str",
                    "possible_values": []
                }
            },
            "square_215": {
                "x": {
                    "value": "predicted_quat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.slice(predicted_transformation, [0, 3], [batch_size, 4])",
                            "Call"
                        ]
                    ]
                }
            },
            "AdamOptimizer_242": {
                "variable": {
                    "value": "optimizer3",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.train.exponential_decay(BASE_LEARNING_RATE, batch * BATCH_SIZE, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-05)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "Adam2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_250": {
                "input_tensor": {
                    "value": "pred_AB3[:, :, :, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_mean_251": {
                "input_tensor": {
                    "value": "pred_BA3[:, :, :, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "pcrnet-registration/models/ipcr_model.py": {
        "tensorflow": {
            "placeholder_15": {
                "variable": {
                    "value": "source_pointclouds_pl",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point, 3)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_16": {
                "variable": {
                    "value": "template_pointclouds_pl",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point, 3)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "concat_35": {
                "variable": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[source_point_cloud, template_point_cloud]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_37": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([source_point_cloud, template_point_cloud], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([source_point_cloud, template_point_cloud], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([source_point_cloud, template_point_cloud], 0)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, k, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_46": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(point_cloud, [batch_size, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "inception_module(net, n_filters=f, kernel_sizes=[3, 5], is_training=is_training, bn_decay=None, scope='inception' + str(i))",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(net, [1, 2, 2, 2, 1], [1, 2, 2, 2, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([source_global_feature, template_global_feature], 1)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=False, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 512, bn=False, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 256, bn=False, is_training=is_training, scope='fc3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.dropout(net, keep_prob=0.7, is_training=is_training, scope='dp4')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_48": {
                "variable": {
                    "value": "source_global_feature",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(point_cloud, [batch_size, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "inception_module(net, n_filters=f, kernel_sizes=[3, 5], is_training=is_training, bn_decay=None, scope='inception' + str(i))",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(net, [1, 2, 2, 2, 1], [1, 2, 2, 2, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([source_global_feature, template_global_feature], 1)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=False, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 512, bn=False, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 256, bn=False, is_training=is_training, scope='fc3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.dropout(net, keep_prob=0.7, is_training=is_training, scope='dp4')",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[int(batch_size / 2), out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_49": {
                "variable": {
                    "value": "template_global_feature",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(point_cloud, [batch_size, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "inception_module(net, n_filters=f, kernel_sizes=[3, 5], is_training=is_training, bn_decay=None, scope='inception' + str(i))",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(net, [1, 2, 2, 2, 1], [1, 2, 2, 2, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([source_global_feature, template_global_feature], 1)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=False, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 512, bn=False, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 256, bn=False, is_training=is_training, scope='fc3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.dropout(net, keep_prob=0.7, is_training=is_training, scope='dp4')",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[int(batch_size / 2), 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[int(batch_size / 2), out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_81": {
                "variable": {
                    "value": "mu",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.stack([x.flatten(), y.flatten()]).T",
                            "Attribute"
                        ],
                        [
                            "np.stack([x.flatten(), y.flatten(), z.flatten()]).T",
                            "Attribute"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_85": {
                "variable": {
                    "value": "batch_sig",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(sigma, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[n_points, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_86": {
                "variable": {
                    "value": "batch_sig",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(batch_sig, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[n_batches, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_87": {
                "variable": {
                    "value": "batch_mu",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(mu, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[n_points, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_88": {
                "variable": {
                    "value": "batch_mu",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(batch_mu, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[n_batches, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_89": {
                "variable": {
                    "value": "batch_w",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.expand_dims(w, 0), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[n_batches, n_points, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_90": {
                "variable": {
                    "value": "batch_points",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(points, -2)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, n_gaussians, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "multiply_104": {
                "variable": {
                    "value": "w_p",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "p_per_point",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "mvn.prob(batch_points)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "batch_w",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(w, 0), 0), [n_batches, n_points, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_106": {
                "variable": {
                    "value": "Q_per_d",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(Q, -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, 1, D]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_109": {
                "variable": {
                    "value": "d_pi_all",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "(Q - batch_w) / (tf.sqrt(batch_w) * n_points)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_max_111": {
                "variable": {
                    "value": "d_pi_max",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_pi_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims((Q - batch_w) / (tf.sqrt(batch_w) * n_points), -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_112": {
                "variable": {
                    "value": "d_pi_mean",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_pi_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims((Q - batch_w) / (tf.sqrt(batch_w) * n_points), -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_120": {
                "variable": {
                    "value": "d_mu_all_max",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_mu_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "Q_per_d * (batch_points - batch_mu) / batch_sig",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_min_121": {
                "variable": {
                    "value": "d_mu_all_min",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_mu_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "Q_per_d * (batch_points - batch_mu) / batch_sig",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_122": {
                "variable": {
                    "value": "d_mu_all_mean",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_mu_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "Q_per_d * (batch_points - batch_mu) / batch_sig",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_133": {
                "variable": {
                    "value": "d_sig_all_max",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_sig_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "Q_per_d * (tf.pow((batch_points - batch_mu) / batch_sig, 2) - 1)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_min_134": {
                "variable": {
                    "value": "d_sig_all_min",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_sig_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "Q_per_d * (tf.pow((batch_points - batch_mu) / batch_sig, 2) - 1)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_135": {
                "variable": {
                    "value": "d_sig_all_mean",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_sig_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "Q_per_d * (tf.pow((batch_points - batch_mu) / batch_sig, 2) - 1)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_194": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[one_by_one, three_by_three, five_by_five, average_pooling]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_199": {
                "variable": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[source_point_cloud, template_point_cloud]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_204": {
                "variable": {
                    "value": "input_image",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([source_point_cloud, template_point_cloud], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([source_point_cloud, template_point_cloud], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([source_point_cloud, template_point_cloud], 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_230": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(point_cloud, [batch_size, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "inception_module(net, n_filters=f, kernel_sizes=[3, 5], is_training=is_training, bn_decay=None, scope='inception' + str(i))",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(net, [1, 2, 2, 2, 1], [1, 2, 2, 2, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([source_global_feature, template_global_feature], 1)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=False, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 512, bn=False, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 256, bn=False, is_training=is_training, scope='fc3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.dropout(net, keep_prob=0.7, is_training=is_training, scope='dp4')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_231": {
                "variable": {
                    "value": "source_global_feature",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(point_cloud, [batch_size, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "inception_module(net, n_filters=f, kernel_sizes=[3, 5], is_training=is_training, bn_decay=None, scope='inception' + str(i))",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(net, [1, 2, 2, 2, 1], [1, 2, 2, 2, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([source_global_feature, template_global_feature], 1)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=False, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 512, bn=False, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 256, bn=False, is_training=is_training, scope='fc3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.dropout(net, keep_prob=0.7, is_training=is_training, scope='dp4')",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[int(batch_size / 2), out_features]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_232": {
                "variable": {
                    "value": "template_global_feature",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(point_cloud, [batch_size, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "inception_module(net, n_filters=f, kernel_sizes=[3, 5], is_training=is_training, bn_decay=None, scope='inception' + str(i))",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(net, [1, 2, 2, 2, 1], [1, 2, 2, 2, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([source_global_feature, template_global_feature], 1)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=False, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 512, bn=False, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 256, bn=False, is_training=is_training, scope='fc3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.dropout(net, keep_prob=0.7, is_training=is_training, scope='dp4')",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[int(batch_size / 2), 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[int(batch_size / 2), out_features]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_237": {
                "variable": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[source_point_cloud, template_point_cloud]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_242": {
                "variable": {
                    "value": "input_image",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([source_point_cloud, template_point_cloud], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([source_point_cloud, template_point_cloud], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([source_point_cloud, template_point_cloud], 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_268": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(point_cloud, [batch_size, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "inception_module(net, n_filters=f, kernel_sizes=[3, 5], is_training=is_training, bn_decay=None, scope='inception' + str(i))",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(net, [1, 2, 2, 2, 1], [1, 2, 2, 2, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([source_global_feature, template_global_feature], 1)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=False, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 512, bn=False, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 256, bn=False, is_training=is_training, scope='fc3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.dropout(net, keep_prob=0.7, is_training=is_training, scope='dp4')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_269": {
                "variable": {
                    "value": "source_global_feature",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(point_cloud, [batch_size, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "inception_module(net, n_filters=f, kernel_sizes=[3, 5], is_training=is_training, bn_decay=None, scope='inception' + str(i))",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(net, [1, 2, 2, 2, 1], [1, 2, 2, 2, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([source_global_feature, template_global_feature], 1)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=False, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 512, bn=False, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 256, bn=False, is_training=is_training, scope='fc3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.dropout(net, keep_prob=0.7, is_training=is_training, scope='dp4')",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[int(batch_size / 2), out_features]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_270": {
                "variable": {
                    "value": "template_global_feature",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(point_cloud, [batch_size, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "inception_module(net, n_filters=f, kernel_sizes=[3, 5], is_training=is_training, bn_decay=None, scope='inception' + str(i))",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(net, [1, 2, 2, 2, 1], [1, 2, 2, 2, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([source_global_feature, template_global_feature], 1)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=False, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 512, bn=False, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 256, bn=False, is_training=is_training, scope='fc3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.dropout(net, keep_prob=0.7, is_training=is_training, scope='dp4')",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[int(batch_size / 2), 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[int(batch_size / 2), out_features]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_274": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[source_global_feature, template_global_feature]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_286": {
                "variable": {
                    "value": "(translation, rot_angle, rot_direction)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "predicted_transformation",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.fully_connected(net, 7, activation_fn=None, scope='fc4')",
                            "Call"
                        ],
                        [
                            "quat_normalize(predicted_transformation, rot_lim=lim_rot)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "[3, 1, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cos_291": {
                "variable": {
                    "value": "rot_angle",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "rot_angle / 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "tile_94": {
                "variable": {
                    "value": "w_per_batch_per_d",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.expand_dims(w, 0), -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[n_batches, 1, D * 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_96": {
                "variable": {
                    "value": "w_per_batch_per_d",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.expand_dims(w, 0), -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[n_batches, 1, D]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_114": {
                "variable": {
                    "value": "d_pi",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[d_pi_mean, d_pi_max]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_125": {
                "variable": {
                    "value": "d_mu_all_full",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[d_mu_all_mean, d_mu_all_max, d_mu_all_min]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_137": {
                "variable": {
                    "value": "d_sig_all_full",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[d_sig_all_mean, d_sig_all_max, d_sig_all_min]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_155": {
                "variable": {
                    "value": "d_pi",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "d_pi",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([d_pi_mean, d_pi_max], 2)",
                            "Call"
                        ],
                        [
                            "d_pi_mean",
                            "Name"
                        ],
                        [
                            "tf.sign(d_pi) * tf.pow(tf.maximum(tf.abs(d_pi), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_pi, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_pi, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_156": {
                "variable": {
                    "value": "d_mu",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "d_mu",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(w_per_batch_per_d) * d_mu_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_mu) * tf.pow(tf.maximum(tf.abs(d_mu), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_mu, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_mu, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_157": {
                "variable": {
                    "value": "d_sigma",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "d_sigma",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(2 * w_per_batch_per_d) * d_sig_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_sigma) * tf.pow(tf.maximum(tf.abs(d_sigma), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_sigma, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_sigma, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "flatten_160": {
                "variable": {
                    "value": "d_pi",
                    "type": "Variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "tf.transpose(d_pi, perm=[0, 2, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "flatten_161": {
                "variable": {
                    "value": "d_mu",
                    "type": "Variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "tf.transpose(d_mu, perm=[0, 2, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "flatten_162": {
                "variable": {
                    "value": "d_sigma",
                    "type": "Variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "tf.transpose(d_sigma, perm=[0, 2, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_163": {
                "variable": {
                    "value": "fv",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[d_pi, d_mu, d_sigma]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_165": {
                "variable": {
                    "value": "fv",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[d_pi, d_mu, d_sigma]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_166": {
                "variable": {
                    "value": "fv",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "fv",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([d_pi, d_mu, d_sigma], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([d_pi, d_mu, d_sigma], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(fv, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(fv, [0, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_168": {
                "variable": {
                    "value": "fv",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "fv",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([d_pi, d_mu, d_sigma], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([d_pi, d_mu, d_sigma], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(fv, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(fv, [0, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_294": {
                "values": {
                    "value": "[translation, rot_angle, rot_direction]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "slice_298": {
                "variable": {
                    "value": "predicted_position",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "predicted_transformation",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.fully_connected(net, 7, activation_fn=None, scope='fc4')",
                            "Call"
                        ],
                        [
                            "quat_normalize(predicted_transformation, rot_lim=lim_rot)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[batch_size, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_299": {
                "variable": {
                    "value": "predicted_quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "predicted_transformation",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.fully_connected(net, 7, activation_fn=None, scope='fc4')",
                            "Call"
                        ],
                        [
                            "quat_normalize(predicted_transformation, rot_lim=lim_rot)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[batch_size, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_302": {
                "variable": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(predicted_quat)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sqrt_303": {
                "variable": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.square(predicted_quat), 1)",
                            "Call"
                        ],
                        [
                            "tf.sqrt(norm_predicted_quat)",
                            "Call"
                        ],
                        [
                            "tf.reshape(norm_predicted_quat, (batch_size, 1))",
                            "Call"
                        ],
                        [
                            "tf.add(norm_predicted_quat, const)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_304": {
                "variable": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.square(predicted_quat), 1)",
                            "Call"
                        ],
                        [
                            "tf.sqrt(norm_predicted_quat)",
                            "Call"
                        ],
                        [
                            "tf.reshape(norm_predicted_quat, (batch_size, 1))",
                            "Call"
                        ],
                        [
                            "tf.add(norm_predicted_quat, const)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(batch_size, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "constant_305": {
                "variable": {
                    "value": "const",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "1e-07",
                    "type": "float",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_306": {
                "variable": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.square(predicted_quat), 1)",
                            "Call"
                        ],
                        [
                            "tf.sqrt(norm_predicted_quat)",
                            "Call"
                        ],
                        [
                            "tf.reshape(norm_predicted_quat, (batch_size, 1))",
                            "Call"
                        ],
                        [
                            "tf.add(norm_predicted_quat, const)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "const",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.constant(1e-07, shape=(batch_size, 1), dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "divide_307": {
                "variable": {
                    "value": "predicted_norm_quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "predicted_quat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.slice(predicted_transformation, [0, 3], [batch_size, 4])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.square(predicted_quat), 1)",
                            "Call"
                        ],
                        [
                            "tf.sqrt(norm_predicted_quat)",
                            "Call"
                        ],
                        [
                            "tf.reshape(norm_predicted_quat, (batch_size, 1))",
                            "Call"
                        ],
                        [
                            "tf.add(norm_predicted_quat, const)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_318": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(32, 1024, 3)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "max_pool3d_43": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(point_cloud, [batch_size, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "inception_module(net, n_filters=f, kernel_sizes=[3, 5], is_training=is_training, bn_decay=None, scope='inception' + str(i))",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(net, [1, 2, 2, 2, 1], [1, 2, 2, 2, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([source_global_feature, template_global_feature], 1)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=False, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 512, bn=False, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 256, bn=False, is_training=is_training, scope='fc3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.dropout(net, keep_prob=0.7, is_training=is_training, scope='dp4')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 2, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_47": {
                "input": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(point_cloud, [batch_size, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "inception_module(net, n_filters=f, kernel_sizes=[3, 5], is_training=is_training, bn_decay=None, scope='inception' + str(i))",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(net, [1, 2, 2, 2, 1], [1, 2, 2, 2, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, out_features, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([source_global_feature, template_global_feature], 1)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=False, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 512, bn=False, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 256, bn=False, is_training=is_training, scope='fc3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.dropout(net, keep_prob=0.7, is_training=is_training, scope='dp4')",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_80": {
                "shape": {
                    "value": "[n_gaussians]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_82": {
                "shape": {
                    "value": "[n_gaussians, D]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_85": {
                "input": {
                    "value": "sigma",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "sigma * tf.ones([n_gaussians, D])",
                            "BinOp"
                        ],
                        [
                            "0.0625",
                            "MethodArgument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_86": {
                "input": {
                    "value": "batch_sig",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(sigma, 0), [n_points, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(batch_sig, 0), [n_batches, 1, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_87": {
                "input": {
                    "value": "mu",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.constant(x, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_88": {
                "input": {
                    "value": "batch_mu",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(mu, 0), [n_points, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(batch_mu, 0), [n_batches, 1, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_89": {
                "input": {
                    "value": "w",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.ones([n_gaussians]) / n_gaussians",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_90": {
                "input": {
                    "value": "points",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_105": {
                "input": {
                    "value": "tf.reduce_sum(w_p, axis=-1, keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, n_gaussians]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_106": {
                "input": {
                    "value": "Q",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "w_p / tf.tile(tf.reduce_sum(w_p, axis=-1, keepdims=True), [1, 1, n_gaussians])",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tanh_287": {
                "x": {
                    "value": "rot_angle",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tanh(rot_angle) * tf.constant(np.pi / 180.0 * rot_lim)",
                            "BinOp"
                        ],
                        [
                            "tf.cos(rot_angle / 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_287": {
                "value": {
                    "value": "np.pi / 180.0 * rot_lim",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "norm_288": {
                "tensor": {
                    "value": "rot_direction",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "rot_direction / rot_direction_norm",
                            "BinOp"
                        ],
                        [
                            "rot_direction * tf.sin(rot_angle / 2)",
                            "BinOp"
                        ]
                    ]
                },
                "ord": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "sin_290": {
                "x": {
                    "value": "rot_angle / 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "tanh_293": {
                "x": {
                    "value": "translation",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tanh(translation) * 0.1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "variable_scope_297": {
                "name_or_scope": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Graph_317": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "expand_dims_94": {
                "input": {
                    "value": "w",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.ones([n_gaussians]) / n_gaussians",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_96": {
                "input": {
                    "value": "w",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.ones([n_gaussians]) / n_gaussians",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_105": {
                "input_tensor": {
                    "value": "w_p",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.multiply(p_per_point, batch_w)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "sqrt_129": {
                "x": {
                    "value": "w_per_batch_per_d",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(w, 0), -1), [n_batches, 1, D * 3])",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(w, 0), -1), [n_batches, 1, D])",
                            "Call"
                        ]
                    ]
                }
            },
            "pow_131": {
                "x": {
                    "value": "(batch_points - batch_mu) / batch_sig",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sqrt_140": {
                "x": {
                    "value": "2 * w_per_batch_per_d",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sign_150": {
                "x": {
                    "value": "d_pi",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([d_pi_mean, d_pi_max], 2)",
                            "Call"
                        ],
                        [
                            "d_pi_mean",
                            "Name"
                        ],
                        [
                            "tf.sign(d_pi) * tf.pow(tf.maximum(tf.abs(d_pi), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_pi, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_pi, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "pow_150": {
                "x": {
                    "value": "tf.maximum(tf.abs(d_pi), epsilon)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "alpha",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0.5",
                            "Constant"
                        ]
                    ]
                }
            },
            "sign_151": {
                "x": {
                    "value": "d_mu",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(w_per_batch_per_d) * d_mu_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_mu) * tf.pow(tf.maximum(tf.abs(d_mu), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_mu, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_mu, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "pow_151": {
                "x": {
                    "value": "tf.maximum(tf.abs(d_mu), epsilon)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "alpha",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0.5",
                            "Constant"
                        ]
                    ]
                }
            },
            "sign_152": {
                "x": {
                    "value": "d_sigma",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(2 * w_per_batch_per_d) * d_sig_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_sigma) * tf.pow(tf.maximum(tf.abs(d_sigma), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_sigma, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_sigma, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "pow_152": {
                "x": {
                    "value": "tf.maximum(tf.abs(d_sigma), epsilon)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "alpha",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0.5",
                            "Constant"
                        ]
                    ]
                }
            },
            "transpose_160": {
                "a": {
                    "value": "d_pi",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([d_pi_mean, d_pi_max], 2)",
                            "Call"
                        ],
                        [
                            "d_pi_mean",
                            "Name"
                        ],
                        [
                            "tf.sign(d_pi) * tf.pow(tf.maximum(tf.abs(d_pi), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_pi, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_pi, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_161": {
                "a": {
                    "value": "d_mu",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(w_per_batch_per_d) * d_mu_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_mu) * tf.pow(tf.maximum(tf.abs(d_mu), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_mu, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_mu, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_162": {
                "a": {
                    "value": "d_sigma",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(2 * w_per_batch_per_d) * d_sig_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_sigma) * tf.pow(tf.maximum(tf.abs(d_sigma), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_sigma, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_sigma, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "square_302": {
                "x": {
                    "value": "predicted_quat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.slice(predicted_transformation, [0, 3], [batch_size, 4])",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_319": {
                "value": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "sqrt_109": {
                "x": {
                    "value": "batch_w",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(w, 0), 0), [n_batches, n_points, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "maximum_150": {
                "x": {
                    "value": "tf.abs(d_pi)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "epsilon",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1e-12",
                            "Constant"
                        ]
                    ]
                }
            },
            "maximum_151": {
                "x": {
                    "value": "tf.abs(d_mu)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "epsilon",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1e-12",
                            "Constant"
                        ]
                    ]
                }
            },
            "maximum_152": {
                "x": {
                    "value": "tf.abs(d_sigma)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "epsilon",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1e-12",
                            "Constant"
                        ]
                    ]
                }
            },
            "abs_150": {
                "x": {
                    "value": "d_pi",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([d_pi_mean, d_pi_max], 2)",
                            "Call"
                        ],
                        [
                            "d_pi_mean",
                            "Name"
                        ],
                        [
                            "tf.sign(d_pi) * tf.pow(tf.maximum(tf.abs(d_pi), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_pi, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_pi, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "abs_151": {
                "x": {
                    "value": "d_mu",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(w_per_batch_per_d) * d_mu_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_mu) * tf.pow(tf.maximum(tf.abs(d_mu), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_mu, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_mu, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "abs_152": {
                "x": {
                    "value": "d_sigma",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(2 * w_per_batch_per_d) * d_sig_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_sigma) * tf.pow(tf.maximum(tf.abs(d_sigma), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_sigma, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_sigma, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "pcrnet-registration/models/pcr_model.py": {
        "tensorflow": {
            "placeholder_16": {
                "variable": {
                    "value": "source_pointclouds_pl",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point, 3)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_17": {
                "variable": {
                    "value": "template_pointclouds_pl",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point, 3)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "concat_22": {
                "variable": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[source_point_cloud, template_point_cloud]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_27": {
                "variable": {
                    "value": "input_image",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([source_point_cloud, template_point_cloud], 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_54": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, feature_size, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([source_global_feature, template_global_feature], 1)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=False, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=False, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 512, bn=False, is_training=is_training, scope='fc3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 512, bn=False, is_training=is_training, scope='fc4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 256, bn=False, is_training=is_training, scope='fc5', bn_decay=bn_decay)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_57": {
                "variable": {
                    "value": "source_global_feature",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, feature_size, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([source_global_feature, template_global_feature], 1)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=False, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=False, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 512, bn=False, is_training=is_training, scope='fc3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 512, bn=False, is_training=is_training, scope='fc4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 256, bn=False, is_training=is_training, scope='fc5', bn_decay=bn_decay)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[int(batch_size / 2), feature_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_58": {
                "variable": {
                    "value": "template_global_feature",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(input_image, 64, [1, 3], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, feature_size, [1, 1], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv5', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([source_global_feature, template_global_feature], 1)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=False, is_training=is_training, scope='fc1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 1024, bn=False, is_training=is_training, scope='fc2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 512, bn=False, is_training=is_training, scope='fc3', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 512, bn=False, is_training=is_training, scope='fc4', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.fully_connected(net, 256, bn=False, is_training=is_training, scope='fc5', bn_decay=bn_decay)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[int(batch_size / 2), 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[int(batch_size / 2), feature_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_63": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[source_global_feature, template_global_feature]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_97": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(32, 1024, 3)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "slice_74": {
                "variable": {
                    "value": "predicted_position",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "predicted_transformation",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.fully_connected(net, 7, activation_fn=None, scope='fc6')",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[batch_size, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_75": {
                "variable": {
                    "value": "predicted_quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "predicted_transformation",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.fully_connected(net, 7, activation_fn=None, scope='fc6')",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[batch_size, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_78": {
                "variable": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(predicted_quat)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sqrt_79": {
                "variable": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.square(predicted_quat), 1)",
                            "Call"
                        ],
                        [
                            "tf.sqrt(norm_predicted_quat)",
                            "Call"
                        ],
                        [
                            "tf.reshape(norm_predicted_quat, (batch_size, 1))",
                            "Call"
                        ],
                        [
                            "tf.add(norm_predicted_quat, const)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_80": {
                "variable": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.square(predicted_quat), 1)",
                            "Call"
                        ],
                        [
                            "tf.sqrt(norm_predicted_quat)",
                            "Call"
                        ],
                        [
                            "tf.reshape(norm_predicted_quat, (batch_size, 1))",
                            "Call"
                        ],
                        [
                            "tf.add(norm_predicted_quat, const)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(batch_size, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "constant_81": {
                "variable": {
                    "value": "const",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "1e-07",
                    "type": "float",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_82": {
                "variable": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.square(predicted_quat), 1)",
                            "Call"
                        ],
                        [
                            "tf.sqrt(norm_predicted_quat)",
                            "Call"
                        ],
                        [
                            "tf.reshape(norm_predicted_quat, (batch_size, 1))",
                            "Call"
                        ],
                        [
                            "tf.add(norm_predicted_quat, const)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "const",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.constant(1e-07, shape=(batch_size, 1), dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "divide_83": {
                "variable": {
                    "value": "predicted_norm_quat",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "predicted_quat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.slice(predicted_transformation, [0, 3], [batch_size, 4])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "norm_predicted_quat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.square(predicted_quat), 1)",
                            "Call"
                        ],
                        [
                            "tf.sqrt(norm_predicted_quat)",
                            "Call"
                        ],
                        [
                            "tf.reshape(norm_predicted_quat, (batch_size, 1))",
                            "Call"
                        ],
                        [
                            "tf.add(norm_predicted_quat, const)",
                            "Call"
                        ]
                    ]
                }
            },
            "Graph_96": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_73": {
                "name_or_scope": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_98": {
                "value": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "square_78": {
                "x": {
                    "value": "predicted_quat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.slice(predicted_transformation, [0, 3], [batch_size, 4])",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "pcrnet-registration/results_itrPCRNet_no_stop.py": {
        "tensorflow": {
            "exponential_decay_92": {
                "variable": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "BASE_LEARNING_RATE",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "FLAGS.learning_rate",
                            "Attribute"
                        ]
                    ]
                },
                "global_step": {
                    "value": "batch * BATCH_SIZE",
                    "type": "BinOp",
                    "possible_values": []
                },
                "decay_steps": {
                    "value": "DECAY_STEP",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "FLAGS.decay_step",
                            "Attribute"
                        ]
                    ]
                },
                "decay_rate": {
                    "value": "DECAY_RATE",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "FLAGS.decay_rate",
                            "Attribute"
                        ]
                    ]
                },
                "staircase": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "maximum_98": {
                "variable": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.train.exponential_decay(BASE_LEARNING_RATE, batch * BATCH_SIZE, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-05)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                }
            },
            "exponential_decay_103": {
                "variable": {
                    "value": "bn_momentum",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "BN_INIT_DECAY",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0.5",
                            "Constant"
                        ]
                    ]
                },
                "global_step": {
                    "value": "batch * BATCH_SIZE",
                    "type": "BinOp",
                    "possible_values": []
                },
                "decay_steps": {
                    "value": "BN_DECAY_DECAY_STEP",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "float(DECAY_STEP)",
                            "Call"
                        ]
                    ]
                },
                "decay_rate": {
                    "value": "BN_DECAY_DECAY_RATE",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0.5",
                            "Constant"
                        ]
                    ]
                },
                "staircase": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "minimum_109": {
                "variable": {
                    "value": "bn_decay",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "BN_DECAY_CLIP",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0.99",
                            "Constant"
                        ]
                    ]
                },
                "y": {
                    "value": "1 - bn_momentum",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ConfigProto_197": {
                "variable": {
                    "value": "config",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_201": {
                "variable": {
                    "value": "sess",
                    "type": "Variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ]
                    ]
                }
            },
            "global_variables_initializer_204": {
                "variable": {
                    "value": "init",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_170": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Variable_172": {
                "variable": {
                    "value": "batch",
                    "type": "Variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "placeholder_175": {
                "variable": {
                    "value": "is_training_pl",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Saver_193": {
                "variable": {
                    "value": "saver",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "device_171": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "device_174": {
                "device_name": {
                    "value": "'/gpu:' + str(GPU_INDEX)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "device_191": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_180": {
                "name_or_scope": {
                    "value": "Network",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "pcrnet-registration/utils/tf_util.py": {
        "tensorflow": {
            "get_variable_21": {
                "variable": {
                    "value": "var",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.contrib.layers.xavier_initializer()",
                            "Call"
                        ],
                        [
                            "tf.truncated_normal_initializer(stddev=stddev)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.float16 if use_fp16 else tf.float32",
                            "IfExp"
                        ]
                    ]
                }
            },
            "truncated_normal_initializer_44": {
                "variable": {
                    "value": "initializer",
                    "type": "Variable",
                    "possible_values": []
                },
                "stddev": {
                    "value": "stddev",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0.001",
                            "MethodArgument"
                        ],
                        [
                            "0.001",
                            "MethodArgument"
                        ],
                        [
                            "0.001",
                            "MethodArgument"
                        ],
                        [
                            "0.001",
                            "MethodArgument"
                        ],
                        [
                            "0.001",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "multiply_47": {
                "variable": {
                    "value": "weight_decay",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.nn.l2_loss(var)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "wd",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "weight_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "conv1d_94": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "kernel",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ]
                    ]
                },
                "stride": {
                    "value": "stride",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "[1",
                            "MethodArgument"
                        ],
                        [
                            "[1",
                            "MethodArgument"
                        ],
                        [
                            "[1",
                            "MethodArgument"
                        ],
                        [
                            "[2",
                            "MethodArgument"
                        ],
                        [
                            "[2",
                            "MethodArgument"
                        ],
                        [
                            "[2",
                            "MethodArgument"
                        ],
                        [
                            "[2",
                            "MethodArgument"
                        ]
                    ]
                },
                "padding": {
                    "value": "padding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "bias_add_99": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(inputs, kernel, stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv1d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d_transpose(inputs, kernel, output_shape, [1, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv3d(inputs, kernel, [1, stride_d, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv3d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, weights)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_fc(outputs, is_training, bn_decay, 'bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_training, lambda : tf.nn.dropout(inputs, keep_prob, noise_shape), lambda : inputs)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_outputs], tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_156": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "kernel",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "bias_add_161": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(inputs, kernel, stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv1d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d_transpose(inputs, kernel, output_shape, [1, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv3d(inputs, kernel, [1, stride_d, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv3d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, weights)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_fc(outputs, is_training, bn_decay, 'bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_training, lambda : tf.nn.dropout(inputs, keep_prob, noise_shape), lambda : inputs)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_outputs], tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_transpose_235": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "kernel",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ]
                    ]
                },
                "output_shape": {
                    "value": "output_shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[batch_size, out_height, out_width, num_output_channels]",
                            "List"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "bias_add_240": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(inputs, kernel, stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv1d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d_transpose(inputs, kernel, output_shape, [1, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv3d(inputs, kernel, [1, stride_d, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv3d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, weights)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_fc(outputs, is_training, bn_decay, 'bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_training, lambda : tf.nn.dropout(inputs, keep_prob, noise_shape), lambda : inputs)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_outputs], tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "conv3d_296": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "kernel",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride_d, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "bias_add_301": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(inputs, kernel, stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv1d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d_transpose(inputs, kernel, output_shape, [1, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv3d(inputs, kernel, [1, stride_d, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv3d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, weights)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_fc(outputs, is_training, bn_decay, 'bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_training, lambda : tf.nn.dropout(inputs, keep_prob, noise_shape), lambda : inputs)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_outputs], tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_337": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "b": {
                    "value": "weights",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "_variable_with_weight_decay('weights', shape=[num_input_units, num_outputs], use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ]
                    ]
                }
            },
            "bias_add_340": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(inputs, kernel, stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv1d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d_transpose(inputs, kernel, output_shape, [1, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv3d(inputs, kernel, [1, stride_d, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv3d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, weights)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_fc(outputs, is_training, bn_decay, 'bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_training, lambda : tf.nn.dropout(inputs, keep_prob, noise_shape), lambda : inputs)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_outputs], tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "max_pool_368": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "ksize": {
                    "value": "[1, kernel_h, kernel_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ]
                    ]
                },
                "name": {
                    "value": "sc.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "avg_pool_393": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "ksize": {
                    "value": "[1, kernel_h, kernel_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ]
                    ]
                },
                "name": {
                    "value": "sc.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "max_pool3d_419": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "ksize": {
                    "value": "[1, kernel_d, kernel_h, kernel_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride_d, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ]
                    ]
                },
                "name": {
                    "value": "sc.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "avg_pool3d_444": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "ksize": {
                    "value": "[1, kernel_d, kernel_h, kernel_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride_d, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ]
                    ]
                },
                "name": {
                    "value": "sc.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_470": {
                "variable": {
                    "value": "beta",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "beta",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant(0.0, shape=[num_channels])",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_472": {
                "variable": {
                    "value": "gamma",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "gamma",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant(1.0, shape=[num_channels])",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "moments_476": {
                "variable": {
                    "value": "(batch_mean, batch_var)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "axes": {
                    "value": "moments_dims",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "moments",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ExponentialMovingAverage_478": {
                "variable": {
                    "value": "ema",
                    "type": "Variable",
                    "possible_values": []
                },
                "decay": {
                    "value": "decay",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "bn_decay if bn_decay is not None else 0.9",
                            "IfExp"
                        ]
                    ]
                }
            },
            "cond_480": {
                "variable": {
                    "value": "ema_apply_op",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_training",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : ema.apply([batch_mean, batch_var])",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.no_op()",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_490": {
                "variable": {
                    "value": "(mean, var)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_training",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "mean_var_with_update",
                    "type": "Variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (ema.average(batch_mean), ema.average(batch_var))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "batch_normalization_493": {
                "variable": {
                    "value": "normed",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "mean": {
                    "value": "mean",
                    "type": "Variable",
                    "possible_values": []
                },
                "variance": {
                    "value": "var",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name, shape, initializer=initializer, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu(name, shape, initializer)",
                            "Call"
                        ]
                    ]
                },
                "offset": {
                    "value": "beta",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.get_variable('beta', initializer=tf.constant(0.0, shape=[num_channels]), trainable=True)",
                            "Call"
                        ]
                    ]
                },
                "scale": {
                    "value": "gamma",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.get_variable('gamma', initializer=tf.constant(1.0, shape=[num_channels]), trainable=True)",
                            "Call"
                        ]
                    ]
                },
                "variance_epsilon": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "cond_574": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_training",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : tf.nn.dropout(inputs, keep_prob, noise_shape)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : inputs",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "device_19": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_to_collection_48": {
                "name": {
                    "value": "losses",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "weight_decay",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.multiply(tf.nn.l2_loss(var), wd, name='weight_loss')",
                            "Call"
                        ],
                        [
                            "0.0",
                            "MethodArgument"
                        ],
                        [
                            "0.0",
                            "MethodArgument"
                        ],
                        [
                            "0.0",
                            "MethodArgument"
                        ],
                        [
                            "0.0",
                            "MethodArgument"
                        ],
                        [
                            "0.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_85": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_145": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_207": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_285": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_330": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_365": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_390": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_416": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_441": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_468": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_573": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "l2_loss_47": {
                "t": {
                    "value": "var",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name, shape, initializer=initializer, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu(name, shape, initializer)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_initializer_98": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_160": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_239": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_300": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_339": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_470": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_472": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "no_op_482": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "control_dependencies_486": {
                "control_inputs": {
                    "value": "[ema_apply_op]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dropout_575": {
                "x": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0.5",
                            "MethodArgument"
                        ]
                    ]
                },
                "noise_shape": {
                    "value": "noise_shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "identity_487": {
                "input": {
                    "value": "batch_var",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        }
    },
    "pcrnet-registration/utils/tf_util_loss.py": {
        "tensorflow": {
            "conv2d_27": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.contrib.layers.conv2d(inputs, num_out_channel, kernel_size=1, normalizer_fn=bn, normalizer_params=bn_params, scope='conv_%d' % i)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "layer_dims[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "activation_fn": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "scope": {
                    "value": "'conv_%d' % (len(layer_dims) - 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_37": {
                "variable": {
                    "value": "dist1",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.sqrt(dist1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_38": {
                "variable": {
                    "value": "dist2",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.sqrt(dist2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_44": {
                "variable": {
                    "value": "num_points",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pcd1.shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "mean_55": {
                "variable": {
                    "value": "(avg, update)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "a": {
                    "value": "value",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "conv2d_21": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.contrib.layers.conv2d(inputs, num_out_channel, kernel_size=1, normalizer_fn=bn, normalizer_params=bn_params, scope='conv_%d' % i)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "num_out_channel",
                    "type": "Variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "normalizer_fn": {
                    "value": "bn",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "normalizer_params": {
                    "value": "bn_params",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "scope": {
                    "value": "'conv_%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_47": {
                "input_tensor": {
                    "value": "cost / num_points",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scalar_51": {
                "name": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": []
                },
                "data": {
                    "value": "value",
                    "type": "Variable",
                    "possible_values": []
                },
                "collections": {
                    "value": "['train_summary']",
                    "type": "List",
                    "possible_values": []
                }
            },
            "scalar_56": {
                "name": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": []
                },
                "data": {
                    "value": "avg",
                    "type": "Variable",
                    "possible_values": []
                },
                "collections": {
                    "value": "['valid_summary']",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sqrt_37": {
                "x": {
                    "value": "dist1",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.sqrt(dist1))",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_38": {
                "x": {
                    "value": "dist2",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.sqrt(dist2))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "train_multi_gpu_pc_compare_dist.py": {
        "tensorflow": {
            "expand_dims_896": {
                "variable": {
                    "value": "xx",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_897": {
                "variable": {
                    "value": "xx",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "xx",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(x, -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(xx, tf.stack([1, 1, 1, size_y]))",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "tf.stack([1, 1, 1, size_y])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_899": {
                "variable": {
                    "value": "yy",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "y",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_900": {
                "variable": {
                    "value": "yy",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "yy",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(y, -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(yy, tf.stack([1, 1, 1, size_x]))",
                            "Call"
                        ],
                        [
                            "tf.transpose(yy, perm=[0, 3, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "tf.stack([1, 1, 1, size_x])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "transpose_901": {
                "variable": {
                    "value": "yy",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "yy",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(y, -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(yy, tf.stack([1, 1, 1, size_x]))",
                            "Call"
                        ],
                        [
                            "tf.transpose(yy, perm=[0, 3, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 3, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "subtract_903": {
                "variable": {
                    "value": "diff",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "xx",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(x, -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(xx, tf.stack([1, 1, 1, size_y]))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "yy",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(y, -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(yy, tf.stack([1, 1, 1, size_x]))",
                            "Call"
                        ],
                        [
                            "tf.transpose(yy, perm=[0, 3, 2, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "square_904": {
                "variable": {
                    "value": "square_diff",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "diff",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.subtract(xx, yy)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_905": {
                "variable": {
                    "value": "square_dist",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "square_diff",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.square(diff)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_913": {
                "variable": {
                    "value": "s1_s2",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.reduce_min(pairwise_diff(rec_pc, pc), axis=2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_914": {
                "variable": {
                    "value": "s2_s1",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.reduce_min(pairwise_diff(pc, rec_pc), axis=2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "global_variables_920": {
                "variable": {
                    "value": "global_vars",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "exponential_decay_981": {
                "variable": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "base_lr",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "set_base_lr",
                            "Name"
                        ],
                        [
                            "BASE_LEARNING_RATE",
                            "Name"
                        ]
                    ]
                },
                "global_step": {
                    "value": "batch",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.get_variable('batch', [], initializer=tf.constant_initializer(0), trainable=False)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('batch', [], initializer=tf.constant_initializer(0), trainable=False)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('batch', [], initializer=tf.constant_initializer(0), trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "decay_steps": {
                    "value": "DECAY_STEP",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "FLAGS.decay_step",
                            "Attribute"
                        ]
                    ]
                },
                "decay_rate": {
                    "value": "DECAY_RATE",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "FLAGS.decay_rate",
                            "Attribute"
                        ]
                    ]
                },
                "staircase": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "maximum_987": {
                "variable": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_DPDist)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_TASK)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_TASK)",
                            "Call"
                        ],
                        [
                            "tf.train.exponential_decay(base_lr, batch, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-07)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1e-07",
                    "type": "float",
                    "possible_values": []
                }
            },
            "exponential_decay_993": {
                "variable": {
                    "value": "bn_momentum",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "BN_INIT_DECAY",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0.5",
                            "Constant"
                        ]
                    ]
                },
                "global_step": {
                    "value": "batch",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.get_variable('batch', [], initializer=tf.constant_initializer(0), trainable=False)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('batch', [], initializer=tf.constant_initializer(0), trainable=False)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('batch', [], initializer=tf.constant_initializer(0), trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "decay_steps": {
                    "value": "BN_DECAY_DECAY_STEP",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "float(DECAY_STEP)",
                            "Call"
                        ]
                    ]
                },
                "decay_rate": {
                    "value": "BN_DECAY_DECAY_RATE",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0.5",
                            "Constant"
                        ]
                    ]
                },
                "staircase": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "minimum_999": {
                "variable": {
                    "value": "bn_decay",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "BN_DECAY_CLIP",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0.99",
                            "Constant"
                        ]
                    ]
                },
                "y": {
                    "value": "1 - bn_momentum",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Graph_188": {
                "variable": {
                    "value": "g1",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_359": {
                "variable": {
                    "value": "g2",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_408": {
                "variable": {
                    "value": "graph",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "concat_965": {
                "variable": {
                    "value": "grad",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "values": {
                    "value": "grads",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "optimizer3.compute_gradients(loss_p, train_vars)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "reduce_mean_966": {
                "variable": {
                    "value": "grad",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "grad",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat(axis=0, values=grads)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(grad, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Saver_305": {
                "variable": {
                    "value": "saver",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ConfigProto_308": {
                "variable": {
                    "value": "config",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_312": {
                "variable": {
                    "value": "sess",
                    "type": "Variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ],
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ],
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ]
                    ]
                }
            },
            "merge_all_315": {
                "variable": {
                    "value": "merged",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FileWriter_322": {
                "variable": {
                    "value": "train_writer",
                    "type": "Variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "os.path.join(RUN_DIR, 'train')",
                    "type": "Call",
                    "possible_values": []
                },
                "graph": {
                    "value": "sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FileWriter_323": {
                "variable": {
                    "value": "test_writer",
                    "type": "Variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "os.path.join(RUN_DIR, 'test')",
                    "type": "Call",
                    "possible_values": []
                },
                "graph": {
                    "value": "sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_initializer_326": {
                "variable": {
                    "value": "init",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_387": {
                "variable": {
                    "value": "saver2",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ConfigProto_390": {
                "variable": {
                    "value": "config",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_394": {
                "variable": {
                    "value": "sess2",
                    "type": "Variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ],
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ],
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ]
                    ]
                }
            },
            "global_variables_initializer_396": {
                "variable": {
                    "value": "init",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "merge_all_465": {
                "variable": {
                    "value": "merged_old",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_466": {
                "variable": {
                    "value": "ours_summary",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "DPDist",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "loss_p",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "(tf.reduce_mean(pred_AB3[:, :, :, 0]) + tf.reduce_mean(pred_BA3[:, :, :, 0])) / 2.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "scalar_467": {
                "variable": {
                    "value": "chamf_summary",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Chamfer",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "loss_c",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "chmafer_dist(x1, out2)",
                            "Call"
                        ]
                    ]
                }
            },
            "merge_469": {
                "variable": {
                    "value": "merged",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[ours_summary, chamf_summary, learning_rate_summary]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Saver_471": {
                "variable": {
                    "value": "saver3",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ConfigProto_475": {
                "variable": {
                    "value": "config",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "InteractiveSession_479": {
                "variable": {
                    "value": "sess3",
                    "type": "Variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ],
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ],
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ]
                    ]
                }
            },
            "FileWriter_480": {
                "variable": {
                    "value": "train_writer",
                    "type": "Variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "os.path.join(LOG_DIR, 'train' + OPT_TYPE + add_name)",
                    "type": "Call",
                    "possible_values": []
                },
                "graph": {
                    "value": "sess3.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FileWriter_481": {
                "variable": {
                    "value": "test_writer",
                    "type": "Variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "os.path.join(LOG_DIR, 'test' + OPT_TYPE + add_name)",
                    "type": "Call",
                    "possible_values": []
                },
                "graph": {
                    "value": "sess3.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_initializer_483": {
                "variable": {
                    "value": "init",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "shape_894": {
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "shape_895": {
                "input": {
                    "value": "y",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "stack_897": {
                "values": {
                    "value": "[1, 1, 1, size_y]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_900": {
                "values": {
                    "value": "[1, 1, 1, size_x]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_min_913": {
                "input_tensor": {
                    "value": "pairwise_diff(rec_pc, pc)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_min_914": {
                "input_tensor": {
                    "value": "pairwise_diff(pc, rec_pc)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_959": {
                "variable": {
                    "value": "expanded_g",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "placeholder_194": {
                "variable": {
                    "value": "is_training_pl",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_195": {
                "variable": {
                    "value": "noise_pl",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(BATCH_SIZE, NUM_POINT, NUM_DIMS)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "add_noise",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_201": {
                "variable": {
                    "value": "batch",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "batch",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "concat_291": {
                "variable": {
                    "value": "pred_AB",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "pred_gpu_AB",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_292": {
                "variable": {
                    "value": "pred_BA",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "pred_gpu_BA",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_294": {
                "variable": {
                    "value": "total_loss_s",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "total_loss_gpu_s",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "reduce_mean_295": {
                "variable": {
                    "value": "total_loss_p",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "total_loss_gpu_p",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "get_variable_363": {
                "variable": {
                    "value": "batch",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "batch",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "placeholder_369": {
                "variable": {
                    "value": "pcC",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[BATCH_SIZE, NUM_POINT, NUM_DIMS]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_370": {
                "variable": {
                    "value": "is_training_pl_2",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "get_variable_411": {
                "variable": {
                    "value": "batch",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "batch",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "scalar_417": {
                "variable": {
                    "value": "learning_rate_summary",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "learning_rate_aue",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_DPDist)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_TASK)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_TASK)",
                            "Call"
                        ],
                        [
                            "tf.train.exponential_decay(base_lr, batch, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-07)",
                            "Call"
                        ]
                    ]
                }
            },
            "placeholder_419": {
                "variable": {
                    "value": "is_training_pl_1",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_420": {
                "variable": {
                    "value": "is_training_pl_2",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_422": {
                "variable": {
                    "value": "x1",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(BATCH_SIZE, NUM_POINT, NUM_DIMS)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "input1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_423": {
                "variable": {
                    "value": "x2",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(BATCH_SIZE, NUM_POINT, NUM_DIMS)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "input2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_424": {
                "variable": {
                    "value": "x3",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(BATCH_SIZE, NUM_POINT, NUM_DIMS)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "input3",
                    "type": "str",
                    "possible_values": []
                }
            },
            "import_meta_graph_427": {
                "variable": {
                    "value": "saver32",
                    "type": "Variable",
                    "possible_values": []
                },
                "meta_graph_or_file": {
                    "value": "os.path.join(LOG_DIR, 'model2.ckpt.meta')",
                    "type": "Call",
                    "possible_values": []
                },
                "import_scope": {
                    "value": "g2",
                    "type": "str",
                    "possible_values": []
                },
                "input_map": {
                    "value": "{'input': x1, 'Placeholder': is_training_pl_2}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "import_meta_graph_433": {
                "variable": {
                    "value": "saver31",
                    "type": "Variable",
                    "possible_values": []
                },
                "meta_graph_or_file": {
                    "value": "os.path.join(LOG_DIR, 'model.ckpt.meta')",
                    "type": "Call",
                    "possible_values": []
                },
                "import_scope": {
                    "value": "g1",
                    "type": "str",
                    "possible_values": []
                },
                "input_map": {
                    "value": "{'input1': out2, 'input2': x2, 'Placeholder': is_training_pl_1, 'add_noise': x3}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "get_collection_457": {
                "variable": {
                    "value": "train_vars",
                    "type": "Variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "g2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_908": {
                "x": {
                    "value": "tf.tile(tf.expand_dims(np.eye(square_dist.shape[1]) * 10, 0), [square_dist.shape[0], 1, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variables_initializer_928": {
                "var_list": {
                    "value": "not_initialized_vars",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "list(compress(global_vars, is_not_initialized))",
                            "Call"
                        ]
                    ]
                }
            },
            "device_190": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "scalar_206": {
                "name": {
                    "value": "bn_decay",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "bn_decay",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "get_bn_decay(batch)",
                            "Call"
                        ],
                        [
                            "get_bn_decay(batch)",
                            "Call"
                        ],
                        [
                            "get_bn_decay(batch)",
                            "Call"
                        ],
                        [
                            "tf.minimum(BN_DECAY_CLIP, 1 - bn_momentum)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_212": {
                "name": {
                    "value": "learning_rate",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_DPDist)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_TASK)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_TASK)",
                            "Call"
                        ],
                        [
                            "tf.train.exponential_decay(base_lr, batch, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-07)",
                            "Call"
                        ]
                    ]
                }
            },
            "MomentumOptimizer_214": {
                "variable": {
                    "value": "optimizer",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_DPDist)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_TASK)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_TASK)",
                            "Call"
                        ],
                        [
                            "tf.train.exponential_decay(base_lr, batch, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-07)",
                            "Call"
                        ]
                    ]
                },
                "momentum": {
                    "value": "MOMENTUM",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "FLAGS.momentum",
                            "Attribute"
                        ]
                    ]
                }
            },
            "device_361": {
                "device_name": {
                    "value": "'/gpu:' + str(GPU_INDEX)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scalar_366": {
                "name": {
                    "value": "bn_decay",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "bn_decay",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "get_bn_decay(batch)",
                            "Call"
                        ],
                        [
                            "get_bn_decay(batch)",
                            "Call"
                        ],
                        [
                            "get_bn_decay(batch)",
                            "Call"
                        ],
                        [
                            "tf.minimum(BN_DECAY_CLIP, 1 - bn_momentum)",
                            "Call"
                        ]
                    ]
                }
            },
            "MomentumOptimizer_380": {
                "variable": {
                    "value": "optimizer2",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_DPDist)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_TASK)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_TASK)",
                            "Call"
                        ],
                        [
                            "tf.train.exponential_decay(base_lr, batch, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-07)",
                            "Call"
                        ]
                    ]
                },
                "momentum": {
                    "value": "MOMENTUM",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "FLAGS.momentum",
                            "Attribute"
                        ]
                    ]
                }
            },
            "device_410": {
                "device_name": {
                    "value": "'/gpu:' + str(GPU_INDEX)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scalar_414": {
                "name": {
                    "value": "bn_decay",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "bn_decay",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "get_bn_decay(batch)",
                            "Call"
                        ],
                        [
                            "get_bn_decay(batch)",
                            "Call"
                        ],
                        [
                            "get_bn_decay(batch)",
                            "Call"
                        ],
                        [
                            "tf.minimum(BN_DECAY_CLIP, 1 - bn_momentum)",
                            "Call"
                        ]
                    ]
                }
            },
            "MomentumOptimizer_444": {
                "variable": {
                    "value": "optimizer3",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_DPDist)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_TASK)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_TASK)",
                            "Call"
                        ],
                        [
                            "tf.train.exponential_decay(base_lr, batch, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-07)",
                            "Call"
                        ]
                    ]
                },
                "momentum": {
                    "value": "MOMENTUM",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "FLAGS.momentum",
                            "Attribute"
                        ]
                    ]
                }
            },
            "tile_908": {
                "input": {
                    "value": "tf.expand_dims(np.eye(square_dist.shape[1]) * 10, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[square_dist.shape[0], 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "is_variable_initialized_921": {
                "variable": {
                    "value": "var",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "AdamOptimizer_216": {
                "variable": {
                    "value": "optimizer",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_DPDist)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_TASK)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_TASK)",
                            "Call"
                        ],
                        [
                            "tf.train.exponential_decay(base_lr, batch, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-07)",
                            "Call"
                        ]
                    ]
                }
            },
            "AdamOptimizer_382": {
                "variable": {
                    "value": "optimizer2",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_DPDist)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_TASK)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_TASK)",
                            "Call"
                        ],
                        [
                            "tf.train.exponential_decay(base_lr, batch, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-07)",
                            "Call"
                        ]
                    ]
                }
            },
            "AdamOptimizer_446": {
                "variable": {
                    "value": "optimizer3",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_DPDist)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_TASK)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch, BASE_LEARNING_RATE_TASK)",
                            "Call"
                        ],
                        [
                            "tf.train.exponential_decay(base_lr, batch, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-07)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "Adam2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_908": {
                "input": {
                    "value": "np.eye(square_dist.shape[1]) * 10",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_initializer_202": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_238": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "slice_241": {
                "variable": {
                    "value": "pcA_pl_batch",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "pcA_pl",
                    "type": "Variable",
                    "possible_values": []
                },
                "begin": {
                    "value": "[i * DEVICE_BATCH_SIZE, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[DEVICE_BATCH_SIZE, -1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_243": {
                "variable": {
                    "value": "pcB_pl_batch",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "pcB_pl",
                    "type": "Variable",
                    "possible_values": []
                },
                "begin": {
                    "value": "[i * DEVICE_BATCH_SIZE, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[DEVICE_BATCH_SIZE, -1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_245": {
                "variable": {
                    "value": "labels_AB_batch",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "labels_AB_pl",
                    "type": "Variable",
                    "possible_values": []
                },
                "begin": {
                    "value": "[i * DEVICE_BATCH_SIZE, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[DEVICE_BATCH_SIZE, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_247": {
                "variable": {
                    "value": "labels_BA_batch",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "labels_BA_pl",
                    "type": "Variable",
                    "possible_values": []
                },
                "begin": {
                    "value": "[i * DEVICE_BATCH_SIZE, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[DEVICE_BATCH_SIZE, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_250": {
                "variable": {
                    "value": "noise_pl_batch",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "noise_pl",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, shape=(BATCH_SIZE, NUM_POINT, NUM_DIMS), name='add_noise')",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[i * DEVICE_BATCH_SIZE, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[DEVICE_BATCH_SIZE, -1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_collection_262": {
                "variable": {
                    "value": "loss_samples",
                    "type": "Variable",
                    "possible_values": []
                },
                "key": {
                    "value": "loss_samples",
                    "type": "str",
                    "possible_values": []
                },
                "scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "add_n_263": {
                "variable": {
                    "value": "total_loss_samples",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "loss_samples",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.get_collection('loss_samples', scope)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "total_loss_samples",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_265": {
                "variable": {
                    "value": "loss_pred",
                    "type": "Variable",
                    "possible_values": []
                },
                "key": {
                    "value": "loss_pred",
                    "type": "str",
                    "possible_values": []
                },
                "scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "add_n_266": {
                "variable": {
                    "value": "total_loss_pred",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "loss_pred",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.get_collection('loss_pred', scope)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "total_loss_pred",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_274": {
                "variable": {
                    "value": "train_vars_s",
                    "type": "Variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "pc_compare",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_275": {
                "variable": {
                    "value": "train_vars_p",
                    "type": "Variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_364": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_initializer_412": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_452": {
                "input_tensor": {
                    "value": "pred_AB3[:, :, :, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_mean_453": {
                "input_tensor": {
                    "value": "pred_BA3[:, :, :, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "get_variable_scope_238": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "device_239": {
                "device_name": {
                    "value": "'/gpu:%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "name_scope_239": {
                "name": {
                    "value": "'gpu_%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scalar_271": {
                "name": {
                    "value": "l.op.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "l",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "loss_samples + [total_loss_samples] + loss_pred + [total_loss_pred]",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "utils/dpdist_util.py": {
        "tensorflow": {
            "placeholder_14": {
                "variable": {
                    "value": "pointclouds_pl",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point, NUM_DIMS)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_15": {
                "variable": {
                    "value": "pointclouds_pl_same",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point, NUM_DIMS)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_16": {
                "variable": {
                    "value": "pointclouds_pl_not_same",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point, NUM_DIMS)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_17": {
                "variable": {
                    "value": "noise_pl",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point, NUM_DIMS)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_18": {
                "variable": {
                    "value": "labels_ns",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "constant_50": {
                "variable": {
                    "value": "mu",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "np.stack([x.flatten(), y.flatten()]).T",
                            "Attribute"
                        ],
                        [
                            "np.stack([x.flatten(), y.flatten(), z.flatten()]).T",
                            "Attribute"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_54": {
                "variable": {
                    "value": "batch_sig",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(sigma, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[n_points, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_55": {
                "variable": {
                    "value": "batch_sig",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(batch_sig, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[n_batches, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_56": {
                "variable": {
                    "value": "batch_mu",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(mu, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[n_points, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_57": {
                "variable": {
                    "value": "batch_mu",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(batch_mu, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[n_batches, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_58": {
                "variable": {
                    "value": "batch_w",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.expand_dims(w, 0), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[n_batches, n_points, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_59": {
                "variable": {
                    "value": "batch_points",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(points, -2)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, n_gaussians, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "multiply_73": {
                "variable": {
                    "value": "w_p",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "p_per_point",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "mvn.prob(batch_points)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "batch_w",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(w, 0), 0), [n_batches, n_points, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_75": {
                "variable": {
                    "value": "Q_per_d",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(Q, -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, 1, D]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_78": {
                "variable": {
                    "value": "d_pi_all",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "(Q - batch_w) / (tf.sqrt(batch_w) * n_points)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_max_80": {
                "variable": {
                    "value": "d_pi_max",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_pi_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims((Q - batch_w) / (tf.sqrt(batch_w) * n_points), -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_81": {
                "variable": {
                    "value": "d_pi_mean",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_pi_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims((Q - batch_w) / (tf.sqrt(batch_w) * n_points), -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_89": {
                "variable": {
                    "value": "d_mu_all_max",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_mu_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "Q_per_d * (batch_points - batch_mu) / batch_sig",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_min_90": {
                "variable": {
                    "value": "d_mu_all_min",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_mu_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "Q_per_d * (batch_points - batch_mu) / batch_sig",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_91": {
                "variable": {
                    "value": "d_mu_all_mean",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_mu_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "Q_per_d * (batch_points - batch_mu) / batch_sig",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_102": {
                "variable": {
                    "value": "d_sig_all_max",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_sig_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "Q_per_d * (tf.pow((batch_points - batch_mu) / batch_sig, 2) - 1)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_min_103": {
                "variable": {
                    "value": "d_sig_all_min",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_sig_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "Q_per_d * (tf.pow((batch_points - batch_mu) / batch_sig, 2) - 1)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_104": {
                "variable": {
                    "value": "d_sig_all_mean",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "d_sig_all",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "Q_per_d * (tf.pow((batch_points - batch_mu) / batch_sig, 2) - 1)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_217": {
                "variable": {
                    "value": "embedding",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "embedding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(embedding)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(embedding, 1), [1, NP, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "relu_389": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "features": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_511": {
                "variable": {
                    "value": "net_all",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[net, netB]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_695": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_711": {
                "variable": {
                    "value": "input_image",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(point_cloud, -2), [1, 1, V, 1])",
                            "Call"
                        ],
                        [
                            "point_cloud - Centers",
                            "BinOp"
                        ],
                        [
                            "tf.tile(tf.expand_dims(point_cloud, -2), [1, 1, V, 1])",
                            "Call"
                        ],
                        [
                            "point_cloud - Centers",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_794": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_803": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, vec_size, vec_size, vec_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_842": {
                "variable": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ],
                        [
                            "tf.stack([X[kh:-kh, kh:-kh], Y[kh:-kh, kh:-kh]], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "tf.stack([X, Y, Z], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_844": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [2, 0, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], output.shape[1], -1])",
                            "Call"
                        ],
                        [
                            "tf.image.extract_image_patches(net, [1, k, k, 1], [1, 1, 1, 1], rates=[1, 1, 1, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], (vec_size - 2 * kh) ** 2, -1])",
                            "Call"
                        ],
                        [
                            "tf.extract_volume_patches(net, [1, k, k, k, 1], [1, 1, 1, 1, 1], 'SAME', name='EXTRACT_LOCAL_Z')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value ** 3, -1])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value, -1])",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_845": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [2, 0, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], output.shape[1], -1])",
                            "Call"
                        ],
                        [
                            "tf.image.extract_image_patches(net, [1, k, k, 1], [1, 1, 1, 1], rates=[1, 1, 1, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], (vec_size - 2 * kh) ** 2, -1])",
                            "Call"
                        ],
                        [
                            "tf.extract_volume_patches(net, [1, k, k, k, 1], [1, 1, 1, 1, 1], 'SAME', name='EXTRACT_LOCAL_Z')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value ** 3, -1])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value, -1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[2, 0, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_846": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [2, 0, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], output.shape[1], -1])",
                            "Call"
                        ],
                        [
                            "tf.image.extract_image_patches(net, [1, k, k, 1], [1, 1, 1, 1], rates=[1, 1, 1, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], (vec_size - 2 * kh) ** 2, -1])",
                            "Call"
                        ],
                        [
                            "tf.extract_volume_patches(net, [1, k, k, k, 1], [1, 1, 1, 1, 1], 'SAME', name='EXTRACT_LOCAL_Z')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value ** 3, -1])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[output.shape[0], output.shape[1], -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_862": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, vec_size, vec_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "extract_image_patches_864": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "images": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "ksizes": {
                    "value": "[1, k, k, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "rates": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                }
            },
            "stack_868": {
                "variable": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[X[kh:-kh, kh:-kh], Y[kh:-kh, kh:-kh]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_870": {
                "variable": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ],
                        [
                            "tf.stack([X[kh:-kh, kh:-kh], Y[kh:-kh, kh:-kh]], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "tf.stack([X, Y, Z], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_871": {
                "variable": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ],
                        [
                            "tf.stack([X[kh:-kh, kh:-kh], Y[kh:-kh, kh:-kh]], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "tf.stack([X, Y, Z], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, NUM_DIMS]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_908": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [2, 0, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], output.shape[1], -1])",
                            "Call"
                        ],
                        [
                            "tf.image.extract_image_patches(net, [1, k, k, 1], [1, 1, 1, 1], rates=[1, 1, 1, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], (vec_size - 2 * kh) ** 2, -1])",
                            "Call"
                        ],
                        [
                            "tf.extract_volume_patches(net, [1, k, k, k, 1], [1, 1, 1, 1, 1], 'SAME', name='EXTRACT_LOCAL_Z')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value ** 3, -1])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[output.shape[0], (vec_size - 2 * kh) ** 2, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "identity_978": {
                "variable": {
                    "value": "loss_pred",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "loss_pred",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "(tf.reduce_mean(pred_listAB[:, :, :, 0]) + tf.reduce_mean(pred_listBA[:, :, :, 0])) / 2",
                            "BinOp"
                        ],
                        [
                            "tf.identity(loss_pred, name='loss_pred')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "loss_pred",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tile_63": {
                "variable": {
                    "value": "w_per_batch_per_d",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.expand_dims(w, 0), -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[n_batches, 1, D * 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_65": {
                "variable": {
                    "value": "w_per_batch_per_d",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.expand_dims(w, 0), -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[n_batches, 1, D]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_83": {
                "variable": {
                    "value": "d_pi",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[d_pi_mean, d_pi_max]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_94": {
                "variable": {
                    "value": "d_mu_all_full",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[d_mu_all_mean, d_mu_all_max, d_mu_all_min]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_106": {
                "variable": {
                    "value": "d_sig_all_full",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[d_sig_all_mean, d_sig_all_max, d_sig_all_min]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_124": {
                "variable": {
                    "value": "d_pi",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "d_pi",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([d_pi_mean, d_pi_max], 2)",
                            "Call"
                        ],
                        [
                            "d_pi_mean",
                            "Name"
                        ],
                        [
                            "tf.sign(d_pi) * tf.pow(tf.maximum(tf.abs(d_pi), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_pi, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_pi, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_125": {
                "variable": {
                    "value": "d_mu",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "d_mu",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(w_per_batch_per_d) * d_mu_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_mu) * tf.pow(tf.maximum(tf.abs(d_mu), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_mu, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_mu, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_126": {
                "variable": {
                    "value": "d_sigma",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "d_sigma",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(2 * w_per_batch_per_d) * d_sig_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_sigma) * tf.pow(tf.maximum(tf.abs(d_sigma), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_sigma, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_sigma, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "flatten_129": {
                "variable": {
                    "value": "d_pi",
                    "type": "Variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "tf.transpose(d_pi, perm=[0, 2, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "flatten_130": {
                "variable": {
                    "value": "d_mu",
                    "type": "Variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "tf.transpose(d_mu, perm=[0, 2, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "flatten_131": {
                "variable": {
                    "value": "d_sigma",
                    "type": "Variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "tf.transpose(d_sigma, perm=[0, 2, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_132": {
                "variable": {
                    "value": "fv",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[d_pi, d_mu, d_sigma]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_134": {
                "variable": {
                    "value": "fv",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[d_pi, d_mu, d_sigma]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_135": {
                "variable": {
                    "value": "fv",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "fv",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([d_pi, d_mu, d_sigma], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([d_pi, d_mu, d_sigma], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(fv, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(fv, [0, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_137": {
                "variable": {
                    "value": "fv",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "fv",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([d_pi, d_mu, d_sigma], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([d_pi, d_mu, d_sigma], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(fv, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(fv, [0, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_nd_158": {
                "variable": {
                    "value": "bv",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "bv",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(bv, tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(bv, -1), -1), [1, 1, 1, D])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(bv, tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(bv, -1), -1), [1, 1, 1, D])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tile_163": {
                "variable": {
                    "value": "bv",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.expand_dims(bv, -1), -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, 1, D]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_nd_165": {
                "variable": {
                    "value": "new_pc",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(point_cloud, -2), [1, 1, V, 1])",
                            "Call"
                        ],
                        [
                            "point_cloud - Centers",
                            "BinOp"
                        ],
                        [
                            "tf.tile(tf.expand_dims(point_cloud, -2), [1, 1, V, 1])",
                            "Call"
                        ],
                        [
                            "point_cloud - Centers",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_nd_171": {
                "variable": {
                    "value": "new_emb",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "embedding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(embedding)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(embedding, 1), [1, NP, 1])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.zeros(tf.shape(argmax), tf.int32), tf.cast(argmax, tf.int32)], 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_177": {
                "variable": {
                    "value": "new_in",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[new_pc, new_emb]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_178": {
                "variable": {
                    "value": "new_in",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "new_in",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([new_pc, new_emb], -1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(new_in, -1)",
                            "Call"
                        ],
                        [
                            "tf.concat([new_pc, new_emb], -1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(new_in, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_192": {
                "input": {
                    "value": "Centers",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.expand_dims(Centers, 0), 0)",
                            "Call"
                        ],
                        [
                            "tf.tile(Centers, [batch_size, num_points, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(Centers, 0), 0)",
                            "Call"
                        ],
                        [
                            "tf.tile(Centers, [batch_size, num_points, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_193": {
                "variable": {
                    "value": "Centers",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "Centers",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.expand_dims(Centers, 0), 0)",
                            "Call"
                        ],
                        [
                            "tf.tile(Centers, [batch_size, num_points, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(Centers, 0), 0)",
                            "Call"
                        ],
                        [
                            "tf.tile(Centers, [batch_size, num_points, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[batch_size, num_points, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_194": {
                "variable": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(point_cloud, -2)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, V, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_200": {
                "variable": {
                    "value": "A",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_x > C_x - grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_201": {
                "variable": {
                    "value": "B",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_x <= C_x + grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_202": {
                "variable": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_y > C_y - grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_203": {
                "variable": {
                    "value": "D",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_y <= C_y + grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_212": {
                "variable": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "binary_vect",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "A * B * C * D",
                            "BinOp"
                        ],
                        [
                            "binary_vect * E * F",
                            "BinOp"
                        ],
                        [
                            "A * B * C * D",
                            "BinOp"
                        ],
                        [
                            "binary_vect * E * F",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_424": {
                "variable": {
                    "value": "embedding",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "embedding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(embedding)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(embedding, 1), [1, NP, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_425": {
                "variable": {
                    "value": "embeddingB",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "embeddingB",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.squeeze(embeddingB)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(embeddingB, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(embeddingB, 1), [1, NP, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_495": {
                "variable": {
                    "value": "embedding",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "embedding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(embedding)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(embedding, 1), [1, NP, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_499": {
                "variable": {
                    "value": "embeddingB",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "embeddingB",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.squeeze(embeddingB)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(embeddingB, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(embeddingB, 1), [1, NP, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_503": {
                "variable": {
                    "value": "embedding",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(embedding, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, NP, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_505": {
                "variable": {
                    "value": "embeddingB",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(embeddingB, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, NP, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_507": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.concat([point_cloudB, embedding], -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_509": {
                "variable": {
                    "value": "netB",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.concat([point_cloud, embeddingB], -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tanh_689": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_786": {
                "variable": {
                    "value": "out_vect",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[out_vect, tf.zeros([batch_size, 1, 1, int(Embedding_Size - vec_size ** NUM_DIMS)], tf.float32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_787": {
                "variable": {
                    "value": "out_vect",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "out_vect",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "get_pc_grid_binary_mask(Embedding_Size, point_cloud)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(tf.expand_dims(out_vect, 1), [1, num_points], 'maxpool')",
                            "Call"
                        ],
                        [
                            "tf.concat([out_vect, tf.zeros([batch_size, 1, 1, int(Embedding_Size - vec_size ** NUM_DIMS)], tf.float32)], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out_vect, [batch_size, Embedding_Size])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, Embedding_Size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_919": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, grid_len, grid_len, grid_len, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "squeeze_968": {
                "variable": {
                    "value": "loss_samples",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "loss_samples",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "pred_listAB[:, :, :, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(loss_samples)",
                            "Call"
                        ]
                    ]
                }
            },
            "identity_972": {
                "variable": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reduce_mean(tf.abs(loss_samples - labels))",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "loss_samples",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_to_collection_979": {
                "name": {
                    "value": "loss_pred",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "loss_pred",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "(tf.reduce_mean(pred_listAB[:, :, :, 0]) + tf.reduce_mean(pred_listBA[:, :, :, 0])) / 2",
                            "BinOp"
                        ],
                        [
                            "tf.identity(loss_pred, name='loss_pred')",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_49": {
                "shape": {
                    "value": "[n_gaussians]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_51": {
                "shape": {
                    "value": "[n_gaussians, D]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_54": {
                "input": {
                    "value": "sigma",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "sigma * tf.ones([n_gaussians, D])",
                            "BinOp"
                        ],
                        [
                            "0.0625",
                            "MethodArgument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_55": {
                "input": {
                    "value": "batch_sig",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(sigma, 0), [n_points, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(batch_sig, 0), [n_batches, 1, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_56": {
                "input": {
                    "value": "mu",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.constant(x, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_57": {
                "input": {
                    "value": "batch_mu",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(mu, 0), [n_points, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(batch_mu, 0), [n_batches, 1, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_58": {
                "input": {
                    "value": "w",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.ones([n_gaussians]) / n_gaussians",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_59": {
                "input": {
                    "value": "points",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_74": {
                "input": {
                    "value": "tf.reduce_sum(w_p, axis=-1, keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, n_gaussians]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_75": {
                "input": {
                    "value": "Q",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "w_p / tf.tile(tf.reduce_sum(w_p, axis=-1, keepdims=True), [1, 1, n_gaussians])",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_208": {
                "variable": {
                    "value": "E",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_z > C_z - grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_209": {
                "variable": {
                    "value": "F",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_z <= C_z + grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_nd_436": {
                "variable": {
                    "value": "bv",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "bv",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(bv, tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(bv, -1), -1), [1, 1, 1, D])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(bv, tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(bv, -1), -1), [1, 1, 1, D])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tile_441": {
                "variable": {
                    "value": "bv",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.expand_dims(bv, -1), -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, 1, D]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_nd_443": {
                "variable": {
                    "value": "new_pc",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(point_cloud, -2), [1, 1, V, 1])",
                            "Call"
                        ],
                        [
                            "point_cloud - Centers",
                            "BinOp"
                        ],
                        [
                            "tf.tile(tf.expand_dims(point_cloud, -2), [1, 1, V, 1])",
                            "Call"
                        ],
                        [
                            "point_cloud - Centers",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_nd_449": {
                "variable": {
                    "value": "new_emb",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "embedding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(embedding)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(embedding, 1), [1, NP, 1])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.zeros(tf.shape(argmax), tf.int32), tf.cast(argmax, tf.int32)], 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_455": {
                "variable": {
                    "value": "new_in",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[new_pc, new_emb]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_456": {
                "variable": {
                    "value": "new_in",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "new_in",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([new_pc, new_emb], -1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(new_in, -1)",
                            "Call"
                        ],
                        [
                            "tf.concat([new_pc, new_emb], -1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(new_in, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_470": {
                "input": {
                    "value": "Centers",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.expand_dims(Centers, 0), 0)",
                            "Call"
                        ],
                        [
                            "tf.tile(Centers, [batch_size, num_points, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(Centers, 0), 0)",
                            "Call"
                        ],
                        [
                            "tf.tile(Centers, [batch_size, num_points, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_471": {
                "variable": {
                    "value": "Centers",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "Centers",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.expand_dims(Centers, 0), 0)",
                            "Call"
                        ],
                        [
                            "tf.tile(Centers, [batch_size, num_points, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(Centers, 0), 0)",
                            "Call"
                        ],
                        [
                            "tf.tile(Centers, [batch_size, num_points, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[batch_size, num_points, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_472": {
                "variable": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(point_cloud, -2)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, V, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_478": {
                "variable": {
                    "value": "A",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_x > C_x - grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_479": {
                "variable": {
                    "value": "B",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_x <= C_x + grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_480": {
                "variable": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_y > C_y - grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_481": {
                "variable": {
                    "value": "D",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_y <= C_y + grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_490": {
                "variable": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "binary_vect",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "A * B * C * D",
                            "BinOp"
                        ],
                        [
                            "binary_vect * E * F",
                            "BinOp"
                        ],
                        [
                            "A * B * C * D",
                            "BinOp"
                        ],
                        [
                            "binary_vect * E * F",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_714": {
                "name_or_scope": {
                    "value": "pointnet",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_774": {
                "name_or_scope": {
                    "value": "vox_vect",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_913": {
                "name_or_scope": {
                    "value": "local_z_3d",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "extract_volume_patches_922": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "ksizes": {
                    "value": "[1, k, k, k, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "EXTRACT_LOCAL_Z",
                    "type": "str",
                    "possible_values": []
                }
            },
            "stack_927": {
                "variable": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[X, Y, Z]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_928": {
                "variable": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ],
                        [
                            "tf.stack([X[kh:-kh, kh:-kh], Y[kh:-kh, kh:-kh]], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "tf.stack([X, Y, Z], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_929": {
                "variable": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ],
                        [
                            "tf.stack([X[kh:-kh, kh:-kh], Y[kh:-kh, kh:-kh]], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "tf.stack([X, Y, Z], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, NUM_DIMS]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_930": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [2, 0, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], output.shape[1], -1])",
                            "Call"
                        ],
                        [
                            "tf.image.extract_image_patches(net, [1, k, k, 1], [1, 1, 1, 1], rates=[1, 1, 1, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], (vec_size - 2 * kh) ** 2, -1])",
                            "Call"
                        ],
                        [
                            "tf.extract_volume_patches(net, [1, k, k, k, 1], [1, 1, 1, 1, 1], 'SAME', name='EXTRACT_LOCAL_Z')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value ** 3, -1])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, output.shape[1].value ** 3, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_935": {
                "variable": {
                    "value": "paddings",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[[0, 0], [kh, kh], [kh, kh], [kh, kh], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "pad_940": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "paddings",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.constant([[0, 0], [kh, kh], [kh, kh], [kh, kh], [0, 0]])",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "CONSTANT",
                    "type": "str",
                    "possible_values": []
                }
            },
            "stack_955": {
                "variable": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "C",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(pc_y > C_y - grid_size, tf.float32)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ],
                        [
                            "tf.stack([X[kh:-kh, kh:-kh], Y[kh:-kh, kh:-kh]], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "tf.stack([X, Y, Z], -1)",
                            "Call"
                        ],
                        [
                            "tf.cast(C, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(C, [-1, NUM_DIMS])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(C)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_956": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [2, 0, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], output.shape[1], -1])",
                            "Call"
                        ],
                        [
                            "tf.image.extract_image_patches(net, [1, k, k, 1], [1, 1, 1, 1], rates=[1, 1, 1, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], (vec_size - 2 * kh) ** 2, -1])",
                            "Call"
                        ],
                        [
                            "tf.extract_volume_patches(net, [1, k, k, k, 1], [1, 1, 1, 1, 1], 'SAME', name='EXTRACT_LOCAL_Z')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value ** 3, -1])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value, -1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_957": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [2, 0, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], output.shape[1], -1])",
                            "Call"
                        ],
                        [
                            "tf.image.extract_image_patches(net, [1, k, k, 1], [1, 1, 1, 1], rates=[1, 1, 1, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0], (vec_size - 2 * kh) ** 2, -1])",
                            "Call"
                        ],
                        [
                            "tf.extract_volume_patches(net, [1, k, k, k, 1], [1, 1, 1, 1, 1], 'SAME', name='EXTRACT_LOCAL_Z')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value ** 3, -1])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [batch_size, output.shape[1].value, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, output.shape[1].value, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_to_collection_974": {
                "name": {
                    "value": "loss_samples",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.identity(tf.reduce_mean(tf.abs(loss_samples - labels)), name='loss_samples')",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_63": {
                "input": {
                    "value": "w",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.ones([n_gaussians]) / n_gaussians",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_65": {
                "input": {
                    "value": "w",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.ones([n_gaussians]) / n_gaussians",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_74": {
                "input_tensor": {
                    "value": "w_p",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.multiply(p_per_point, batch_w)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "sqrt_98": {
                "x": {
                    "value": "w_per_batch_per_d",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(w, 0), -1), [n_batches, 1, D * 3])",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(w, 0), -1), [n_batches, 1, D])",
                            "Call"
                        ]
                    ]
                }
            },
            "pow_100": {
                "x": {
                    "value": "(batch_points - batch_mu) / batch_sig",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sqrt_109": {
                "x": {
                    "value": "2 * w_per_batch_per_d",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sign_119": {
                "x": {
                    "value": "d_pi",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([d_pi_mean, d_pi_max], 2)",
                            "Call"
                        ],
                        [
                            "d_pi_mean",
                            "Name"
                        ],
                        [
                            "tf.sign(d_pi) * tf.pow(tf.maximum(tf.abs(d_pi), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_pi, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_pi, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "pow_119": {
                "x": {
                    "value": "tf.maximum(tf.abs(d_pi), epsilon)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "alpha",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0.5",
                            "Constant"
                        ]
                    ]
                }
            },
            "sign_120": {
                "x": {
                    "value": "d_mu",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(w_per_batch_per_d) * d_mu_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_mu) * tf.pow(tf.maximum(tf.abs(d_mu), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_mu, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_mu, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "pow_120": {
                "x": {
                    "value": "tf.maximum(tf.abs(d_mu), epsilon)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "alpha",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0.5",
                            "Constant"
                        ]
                    ]
                }
            },
            "sign_121": {
                "x": {
                    "value": "d_sigma",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(2 * w_per_batch_per_d) * d_sig_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_sigma) * tf.pow(tf.maximum(tf.abs(d_sigma), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_sigma, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_sigma, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "pow_121": {
                "x": {
                    "value": "tf.maximum(tf.abs(d_sigma), epsilon)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "alpha",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0.5",
                            "Constant"
                        ]
                    ]
                }
            },
            "transpose_129": {
                "a": {
                    "value": "d_pi",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([d_pi_mean, d_pi_max], 2)",
                            "Call"
                        ],
                        [
                            "d_pi_mean",
                            "Name"
                        ],
                        [
                            "tf.sign(d_pi) * tf.pow(tf.maximum(tf.abs(d_pi), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_pi, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_pi, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_130": {
                "a": {
                    "value": "d_mu",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(w_per_batch_per_d) * d_mu_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_mu) * tf.pow(tf.maximum(tf.abs(d_mu), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_mu, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_mu, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_131": {
                "a": {
                    "value": "d_sigma",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(2 * w_per_batch_per_d) * d_sig_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_sigma) * tf.pow(tf.maximum(tf.abs(d_sigma), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_sigma, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_sigma, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_158": {
                "values": {
                    "value": "[tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_163": {
                "input": {
                    "value": "bv",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(bv, tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(bv, -1), -1), [1, 1, 1, D])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(bv, tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(bv, -1), -1), [1, 1, 1, D])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_165": {
                "values": {
                    "value": "[tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_171": {
                "values": {
                    "value": "[tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.zeros(tf.shape(argmax), tf.int32), tf.cast(argmax, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_194": {
                "input": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(point_cloud, -2), [1, 1, V, 1])",
                            "Call"
                        ],
                        [
                            "point_cloud - Centers",
                            "BinOp"
                        ],
                        [
                            "tf.tile(tf.expand_dims(point_cloud, -2), [1, 1, V, 1])",
                            "Call"
                        ],
                        [
                            "point_cloud - Centers",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "variable_scope_221": {
                "name_or_scope": {
                    "value": "dpdist_local",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "transpose_253": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_254": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_255": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, k, k, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_256": {
                "variable": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B, NP, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_257": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[net_E, net_D]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_258": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B * NP, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_292": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_293": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_294": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_295": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, k, k, k, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_296": {
                "variable": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B, NP, k, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_297": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[net_E, net_D]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_298": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B * NP, k, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_305": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_307": {
                "variable": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[B, NP, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_309": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[B * NP, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_345": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_346": {
                "variable": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[B, NP, k, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_348": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[B * NP, k, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_486": {
                "variable": {
                    "value": "E",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_z > C_z - grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_487": {
                "variable": {
                    "value": "F",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pc_z <= C_z + grid_size",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_503": {
                "input": {
                    "value": "embedding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(embedding)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(embedding, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(embedding, 1), [1, NP, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_505": {
                "input": {
                    "value": "embeddingB",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.squeeze(embeddingB)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(embeddingB, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(embeddingB, 1), [1, NP, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_507": {
                "values": {
                    "value": "[point_cloudB, embedding]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_509": {
                "values": {
                    "value": "[point_cloud, embeddingB]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "variable_scope_514": {
                "name_or_scope": {
                    "value": "dpdist_local",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "transpose_553": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_554": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_555": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, k, k, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_556": {
                "variable": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B, NP, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_557": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[net_E, net_D]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_558": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B * NP, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_592": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_593": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_594": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_595": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, k, k, k, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_596": {
                "variable": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B, NP, k, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_597": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[net_E, net_D]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_598": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B * NP, k, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_604": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_605": {
                "variable": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B, NP, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_607": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B * NP, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_643": {
                "variable": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net_D",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net_D, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(net_D, [1, 1, k, k, k, 1])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "net[:, :, E:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net_D, [0, 1, 3, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_644": {
                "variable": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[2 * B, NP, k, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_646": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net_E",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B, NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :, :E, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B, NP, k, k, k, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[2 * B * NP, k, k, k, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu6_691": {
                "features": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_784": {
                "input": {
                    "value": "out_vect",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "get_pc_grid_binary_mask(Embedding_Size, point_cloud)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(tf.expand_dims(out_vect, 1), [1, num_points], 'maxpool')",
                            "Call"
                        ],
                        [
                            "tf.concat([out_vect, tf.zeros([batch_size, 1, 1, int(Embedding_Size - vec_size ** NUM_DIMS)], tf.float32)], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out_vect, [batch_size, Embedding_Size])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_838": {
                "variable": {
                    "value": "c",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[X[ii, jj, ll], Y[ii, jj, ll], Z[ii, jj, ll]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_840": {
                "variable": {
                    "value": "z_iijj",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "z_iijj",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(z_iijj)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_972": {
                "input_tensor": {
                    "value": "tf.abs(loss_samples - labels)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_78": {
                "x": {
                    "value": "batch_w",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(w, 0), 0), [n_batches, n_points, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "maximum_119": {
                "x": {
                    "value": "tf.abs(d_pi)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "epsilon",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1e-12",
                            "Constant"
                        ]
                    ]
                }
            },
            "maximum_120": {
                "x": {
                    "value": "tf.abs(d_mu)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "epsilon",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1e-12",
                            "Constant"
                        ]
                    ]
                }
            },
            "maximum_121": {
                "x": {
                    "value": "tf.abs(d_sigma)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "epsilon",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1e-12",
                            "Constant"
                        ]
                    ]
                }
            },
            "abs_188": {
                "x": {
                    "value": "Centers[0][0] - Centers[1][0]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_190": {
                "x": {
                    "value": "Centers[0][2] - Centers[1][2]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_273": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B, NP, 1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_324": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[B, NP, 1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_325": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[net, net_D]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_373": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[B, NP, 1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_374": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[net, net_D]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_436": {
                "values": {
                    "value": "[tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_441": {
                "input": {
                    "value": "bv",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(bv, tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(bv, -1), -1), [1, 1, 1, D])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(bv, tf.stack([tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)], 2))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(bv, -1), -1), [1, 1, 1, D])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_443": {
                "values": {
                    "value": "[tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.transpose(tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])), tf.cast(argmax, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_449": {
                "values": {
                    "value": "[tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1), [1, tf.shape(argmax)[1]]), tf.zeros(tf.shape(argmax), tf.int32), tf.cast(argmax, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_472": {
                "input": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(point_cloud, -2), [1, 1, V, 1])",
                            "Call"
                        ],
                        [
                            "point_cloud - Centers",
                            "BinOp"
                        ],
                        [
                            "tf.tile(tf.expand_dims(point_cloud, -2), [1, 1, V, 1])",
                            "Call"
                        ],
                        [
                            "point_cloud - Centers",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_573": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B, NP, 1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_622": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[4 * B, NP, 1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_623": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[net, net_D]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_668": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[2 * B, NP, 1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "identity_669": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net * binary_vect",
                            "BinOp"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_1', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, filters, kernel, padding=padding, stride=stride, bn=bn, is_training=is_training, scope=scope + '_2', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "net + net_in",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(tf.concat([point_cloudB, embedding], -1), 2)",
                            "Call"
                        ],
                        [
                            "net_all",
                            "Name"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, E + NUM_DIMS], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[0], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net_E, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [4 * B * NP, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(net_E, [2 * B * NP, k, k, k, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[1], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='SAME', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 64, [3, 3], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [4 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 64, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv0', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "resnet3d(net, [3, 3, 3], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv3d(net, 16, [1, 1, 1], padding='SAME', stride=[1, 1, 1], bn=bn, is_training=is_training, scope='mapper_conv3', bn_decay=bn_decay, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, [2 * B, NP, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.identity(net, 'embedding_layer')",
                            "Call"
                        ],
                        [
                            "tf.concat([net, net_D], -1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, mlp[2], [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv5', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, output_size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='mapper_conv6', bn_decay=bn_decay, reuse=reuse, weight_decay=wd, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu6(net) / 3",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu6(net + 3) / 3 - 1",
                            "BinOp"
                        ],
                        [
                            "tf.split(net, 2, 0)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(input_image, 128, [1, NUM_DIMS], padding='VALID', stride=[1, 1], bn=False, is_training=is_training, scope='conv1', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 128, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv2', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, 512, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv3', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(net, Embedding_Size, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv4', bn_decay=bn_decay, reuse=reuse, weight_decay=wd)",
                            "Call"
                        ],
                        [
                            "tf_util.max_pool2d(net, [num_point, 1], padding='VALID', scope='maxpool')",
                            "Call"
                        ],
                        [
                            "tf_util.avg_pool2d(net, [num_point, 1], padding='VALID', scope='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(net, -1)",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** NUM_DIMS)]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(vec_size ** 2), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, vec_size, vec_size, -1])",
                            "Call"
                        ],
                        [
                            "net[:, :int(grid_len ** NUM_DIMS), :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(net, [batch_size, grid_len, grid_len, grid_len, -1])",
                            "Call"
                        ],
                        [
                            "tf.pad(net, paddings, 'CONSTANT')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "embedding_layer",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_670": {
                "variable": {
                    "value": "net",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[net, net_D]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "relu6_693": {
                "features": {
                    "value": "net + 3",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_786": {
                "shape": {
                    "value": "[batch_size, 1, 1, int(Embedding_Size - vec_size ** NUM_DIMS)]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "abs_972": {
                "x": {
                    "value": "loss_samples - labels",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_976": {
                "input_tensor": {
                    "value": "pred_listAB[:, :, :, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_mean_977": {
                "input_tensor": {
                    "value": "pred_listBA[:, :, :, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "abs_119": {
                "x": {
                    "value": "d_pi",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([d_pi_mean, d_pi_max], 2)",
                            "Call"
                        ],
                        [
                            "d_pi_mean",
                            "Name"
                        ],
                        [
                            "tf.sign(d_pi) * tf.pow(tf.maximum(tf.abs(d_pi), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_pi, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_pi, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "abs_120": {
                "x": {
                    "value": "d_mu",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(w_per_batch_per_d) * d_mu_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_mu) * tf.pow(tf.maximum(tf.abs(d_mu), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_mu, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_mu, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "abs_121": {
                "x": {
                    "value": "d_sigma",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1 / tf.sqrt(2 * w_per_batch_per_d) * d_sig_all_full",
                            "BinOp"
                        ],
                        [
                            "tf.sign(d_sigma) * tf.pow(tf.maximum(tf.abs(d_sigma), epsilon), alpha)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.l2_normalize(d_sigma, dim=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.flatten(tf.transpose(d_sigma, perm=[0, 2, 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_159": {
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(argmax)[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_160": {
                "a": {
                    "value": "tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_161": {
                "x": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_166": {
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(argmax)[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_167": {
                "a": {
                    "value": "tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_168": {
                "x": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_172": {
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(argmax)[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_173": {
                "shape": {
                    "value": "tf.shape(argmax)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_174": {
                "x": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_260": {
                "name_or_scope": {
                    "value": "dpdist_local_cnn_fc",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_311": {
                "name_or_scope": {
                    "value": "dpdist_local_cnn_fc",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_349": {
                "name_or_scope": {
                    "value": "dpdist_local_cnn_fc",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "abs_466": {
                "x": {
                    "value": "Centers[0][0] - Centers[1][0]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_468": {
                "x": {
                    "value": "Centers[0][2] - Centers[1][2]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_560": {
                "name_or_scope": {
                    "value": "dpdist_local_cnn_fc",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_609": {
                "name_or_scope": {
                    "value": "dpdist_local_cnn_fc",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_647": {
                "name_or_scope": {
                    "value": "dpdist_local_cnn_fc",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "stack_951": {
                "variable": {
                    "value": "c",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[X[ii, jj, ll], Y[ii, jj, ll], Z[ii, jj, ll]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_159": {
                "input": {
                    "value": "tf.range(tf.shape(argmax)[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_160": {
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(argmax)[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_166": {
                "input": {
                    "value": "tf.range(tf.shape(argmax)[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_167": {
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(argmax)[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_172": {
                "input": {
                    "value": "tf.range(tf.shape(argmax)[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_173": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_437": {
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(argmax)[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_438": {
                "a": {
                    "value": "tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_439": {
                "x": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_444": {
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(argmax)[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_445": {
                "a": {
                    "value": "tf.tile(tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1), [1, tf.shape(argmax)[0]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_446": {
                "x": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_450": {
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.shape(argmax)[0]), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(argmax)[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_451": {
                "shape": {
                    "value": "tf.shape(argmax)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_452": {
                "x": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_160": {
                "input": {
                    "value": "tf.range(tf.shape(argmax)[1])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_167": {
                "input": {
                    "value": "tf.range(tf.shape(argmax)[1])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_437": {
                "input": {
                    "value": "tf.range(tf.shape(argmax)[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_438": {
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(argmax)[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_444": {
                "input": {
                    "value": "tf.range(tf.shape(argmax)[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_445": {
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.shape(argmax)[1]), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(argmax)[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_450": {
                "input": {
                    "value": "tf.range(tf.shape(argmax)[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_451": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_832": {
                "variable": {
                    "value": "z_ij",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.zeros([batch_size, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_159": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_166": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_172": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_438": {
                "input": {
                    "value": "tf.range(tf.shape(argmax)[1])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_445": {
                "input": {
                    "value": "tf.range(tf.shape(argmax)[1])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_160": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_167": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_437": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_444": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_450": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_438": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_445": {
                "input": {
                    "value": "argmax",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.math.argmax(input=binary_vect, axis=2)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "utils/tf_util.py": {
        "tensorflow": {
            "squeeze_32": {
                "variable": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.squeeze(point_cloud)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(point_cloud, 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_36": {
                "variable": {
                    "value": "point_cloud_transpose",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.squeeze(point_cloud)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(point_cloud, 0)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_37": {
                "variable": {
                    "value": "point_cloud_inner",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.squeeze(point_cloud)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(point_cloud, 0)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "point_cloud_transpose",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.transpose(point_cloud, perm=[0, 2, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_39": {
                "variable": {
                    "value": "point_cloud_square",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(point_cloud)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "transpose_40": {
                "variable": {
                    "value": "point_cloud_square_tranpose",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "point_cloud_square",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.square(point_cloud), axis=-1, keep_dims=True)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "top_k_54": {
                "variable": {
                    "value": "(_, nn_idx)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "neg_adj",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "-adj_matrix",
                            "UnaryOp"
                        ]
                    ]
                },
                "k": {
                    "value": "k",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "20",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reduce_mean_13": {
                "variable": {
                    "value": "mean",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "var",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name, shape, initializer=initializer, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu(name, shape, initializer)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_34": {
                "variable": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.squeeze(point_cloud)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(point_cloud, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_68": {
                "variable": {
                    "value": "var",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "''",
                            "MethodArgument"
                        ]
                    ]
                },
                "shape": {
                    "value": "shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.contrib.layers.xavier_initializer()",
                            "Call"
                        ],
                        [
                            "tf.truncated_normal_initializer(stddev=stddev)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.float16 if use_fp16 else tf.float32",
                            "IfExp"
                        ]
                    ]
                }
            },
            "truncated_normal_initializer_93": {
                "variable": {
                    "value": "initializer",
                    "type": "Variable",
                    "possible_values": []
                },
                "stddev": {
                    "value": "stddev",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.sqrt(tf.reduce_mean(tf.square(var - mean)))",
                            "Call"
                        ],
                        [
                            "0.001",
                            "MethodArgument"
                        ],
                        [
                            "0.001",
                            "MethodArgument"
                        ],
                        [
                            "0.001",
                            "MethodArgument"
                        ],
                        [
                            "0.001",
                            "MethodArgument"
                        ],
                        [
                            "0.001",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "multiply_96": {
                "variable": {
                    "value": "weight_decay",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.nn.l2_loss(var)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "wd",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "weight_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "conv1d_143": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "kernel",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ]
                    ]
                },
                "stride": {
                    "value": "stride",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "[1",
                            "MethodArgument"
                        ],
                        [
                            "[1",
                            "MethodArgument"
                        ],
                        [
                            "[1",
                            "MethodArgument"
                        ],
                        [
                            "[2",
                            "MethodArgument"
                        ],
                        [
                            "[2",
                            "MethodArgument"
                        ],
                        [
                            "[2",
                            "MethodArgument"
                        ],
                        [
                            "[2",
                            "MethodArgument"
                        ]
                    ]
                },
                "padding": {
                    "value": "padding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "bias_add_148": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(inputs, kernel, stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv1d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', reuse=reuse, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d_transpose(inputs, kernel, output_shape, [1, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv3d(inputs, kernel, [1, stride_d, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv3d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, weights)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_fc(outputs, is_training, bn_decay, 'bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_training, lambda : tf.nn.dropout(inputs, keep_prob, noise_shape), lambda : inputs)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_outputs], tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_213": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "kernel",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ]
                    ]
                },
                "data_format": {
                    "value": "data_format",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'NHWC'",
                            "MethodArgument"
                        ],
                        [
                            "'NHWC'",
                            "MethodArgument"
                        ],
                        [
                            "'NHWC'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "bias_add_219": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(inputs, kernel, stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv1d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', reuse=reuse, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d_transpose(inputs, kernel, output_shape, [1, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv3d(inputs, kernel, [1, stride_d, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv3d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, weights)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_fc(outputs, is_training, bn_decay, 'bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_training, lambda : tf.nn.dropout(inputs, keep_prob, noise_shape), lambda : inputs)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_outputs], tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                },
                "data_format": {
                    "value": "data_format",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'NHWC'",
                            "MethodArgument"
                        ],
                        [
                            "'NHWC'",
                            "MethodArgument"
                        ],
                        [
                            "'NHWC'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "conv2d_transpose_294": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "kernel",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ]
                    ]
                },
                "output_shape": {
                    "value": "output_shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[batch_size, out_height, out_width, num_output_channels]",
                            "List"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "bias_add_299": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(inputs, kernel, stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv1d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', reuse=reuse, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d_transpose(inputs, kernel, output_shape, [1, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv3d(inputs, kernel, [1, stride_d, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv3d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, weights)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_fc(outputs, is_training, bn_decay, 'bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_training, lambda : tf.nn.dropout(inputs, keep_prob, noise_shape), lambda : inputs)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_outputs], tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "conv3d_355": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "kernel",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride_d, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "bias_add_360": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(inputs, kernel, stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv1d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', reuse=reuse, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d_transpose(inputs, kernel, output_shape, [1, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv3d(inputs, kernel, [1, stride_d, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv3d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, weights)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_fc(outputs, is_training, bn_decay, 'bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_training, lambda : tf.nn.dropout(inputs, keep_prob, noise_shape), lambda : inputs)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_outputs], tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_397": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "b": {
                    "value": "weights",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "_variable_with_weight_decay('weights', shape=[num_input_units, num_outputs], use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ]
                    ]
                }
            },
            "bias_add_400": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(inputs, kernel, stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv1d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', reuse=reuse, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d_transpose(inputs, kernel, output_shape, [1, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv3d(inputs, kernel, [1, stride_d, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv3d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, weights)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_fc(outputs, is_training, bn_decay, 'bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_training, lambda : tf.nn.dropout(inputs, keep_prob, noise_shape), lambda : inputs)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_outputs], tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "max_pool_428": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "ksize": {
                    "value": "[1, kernel_h, kernel_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ]
                    ]
                },
                "name": {
                    "value": "sc.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "avg_pool_453": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "ksize": {
                    "value": "[1, kernel_h, kernel_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ]
                    ]
                },
                "name": {
                    "value": "sc.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "max_pool3d_479": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "ksize": {
                    "value": "[1, kernel_d, kernel_h, kernel_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride_d, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ]
                    ]
                },
                "name": {
                    "value": "sc.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "avg_pool3d_504": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "ksize": {
                    "value": "[1, kernel_d, kernel_h, kernel_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride_d, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'SAME'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ],
                        [
                            "'VALID'",
                            "MethodArgument"
                        ]
                    ]
                },
                "name": {
                    "value": "sc.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_531": {
                "variable": {
                    "value": "beta",
                    "type": "Variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.constant(0.0, shape=[num_channels])",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "beta",
                    "type": "str",
                    "possible_values": []
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Variable_533": {
                "variable": {
                    "value": "gamma",
                    "type": "Variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.constant(1.0, shape=[num_channels])",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "gamma",
                    "type": "str",
                    "possible_values": []
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "moments_535": {
                "variable": {
                    "value": "(batch_mean, batch_var)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "axes": {
                    "value": "moments_dims",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "moments",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ExponentialMovingAverage_538": {
                "variable": {
                    "value": "ema",
                    "type": "Variable",
                    "possible_values": []
                },
                "decay": {
                    "value": "decay",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "bn_decay if bn_decay is not None else 0.9",
                            "IfExp"
                        ]
                    ]
                }
            },
            "cond_540": {
                "variable": {
                    "value": "ema_apply_op",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_training",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : ema.apply([batch_mean, batch_var])",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.no_op()",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_551": {
                "variable": {
                    "value": "(mean, var)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_training",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "mean_var_with_update",
                    "type": "Variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (ema.average(batch_mean), ema.average(batch_var))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "batch_normalization_555": {
                "variable": {
                    "value": "normed",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "mean": {
                    "value": "mean",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(var)",
                            "Call"
                        ]
                    ]
                },
                "variance": {
                    "value": "var",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name, shape, initializer=initializer, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu(name, shape, initializer)",
                            "Call"
                        ]
                    ]
                },
                "offset": {
                    "value": "beta",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.Variable(tf.constant(0.0, shape=[num_channels]), name='beta', trainable=True)",
                            "Call"
                        ]
                    ]
                },
                "scale": {
                    "value": "gamma",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.Variable(tf.constant(1.0, shape=[num_channels]), name='gamma', trainable=True)",
                            "Call"
                        ]
                    ]
                },
                "variance_epsilon": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "cond_666": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_training",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : tf.nn.dropout(inputs, keep_prob, noise_shape)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : inputs",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "name_scope_12": {
                "name": {
                    "value": "'summaries_' + name",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scalar_14": {
                "name": {
                    "value": "mean",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "mean",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(var)",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_16": {
                "variable": {
                    "value": "stddev",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_mean(tf.square(var - mean))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_17": {
                "name": {
                    "value": "stddev",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "stddev",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.sqrt(tf.reduce_mean(tf.square(var - mean)))",
                            "Call"
                        ],
                        [
                            "0.001",
                            "MethodArgument"
                        ],
                        [
                            "0.001",
                            "MethodArgument"
                        ],
                        [
                            "0.001",
                            "MethodArgument"
                        ],
                        [
                            "0.001",
                            "MethodArgument"
                        ],
                        [
                            "0.001",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "scalar_18": {
                "name": {
                    "value": "max",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_max(var)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_19": {
                "name": {
                    "value": "min",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_min(var)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "histogram_20": {
                "name": {
                    "value": "histogram",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "var",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name, shape, initializer=initializer, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu(name, shape, initializer)",
                            "Call"
                        ]
                    ]
                }
            },
            "square_39": {
                "x": {
                    "value": "point_cloud",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.squeeze(point_cloud)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(point_cloud, 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "device_66": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_to_collection_97": {
                "name": {
                    "value": "losses",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "weight_decay",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.multiply(tf.nn.l2_loss(var), wd, name='weight_loss')",
                            "Call"
                        ],
                        [
                            "0.0",
                            "MethodArgument"
                        ],
                        [
                            "0.0",
                            "MethodArgument"
                        ],
                        [
                            "0.0",
                            "MethodArgument"
                        ],
                        [
                            "0.0",
                            "MethodArgument"
                        ],
                        [
                            "0.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_134": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_196": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_266": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_344": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_390": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_425": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_450": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_476": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_501": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_529": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_537": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_549": {
                "name_or_scope": {
                    "value": "scope + '1'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_665": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "name_scope_15": {
                "name": {
                    "value": "stddev",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_max_18": {
                "input_tensor": {
                    "value": "var",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name, shape, initializer=initializer, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu(name, shape, initializer)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_min_19": {
                "input_tensor": {
                    "value": "var",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name, shape, initializer=initializer, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu(name, shape, initializer)",
                            "Call"
                        ]
                    ]
                }
            },
            "l2_loss_96": {
                "t": {
                    "value": "var",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name, shape, initializer=initializer, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu(name, shape, initializer)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_initializer_147": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_218": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_298": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_359": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_399": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_531": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_533": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_scope_537": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_mean_16": {
                "input_tensor": {
                    "value": "tf.square(var - mean)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "no_op_542": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "control_dependencies_546": {
                "control_inputs": {
                    "value": "[ema_apply_op]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dropout_667": {
                "x": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0.5",
                            "MethodArgument"
                        ]
                    ]
                },
                "noise_shape": {
                    "value": "noise_shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "square_16": {
                "x": {
                    "value": "var - mean",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "identity_547": {
                "input": {
                    "value": "batch_var",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        }
    }
}