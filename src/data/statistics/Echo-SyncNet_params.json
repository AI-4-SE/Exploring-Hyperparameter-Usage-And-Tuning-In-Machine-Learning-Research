{
    "algos/algorithm.py": {
        "tensorflow": {
            "reshape_57": {
                "variable": {
                    "value": "embs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "embs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "emb(cnn_feats, num_steps)",
                            "Call"
                        ],
                        [
                            "tf.reshape(embs, [-1, num_steps, channels])",
                            "Call"
                        ],
                        [
                            "self.call(data, steps, seq_lens, training=True)",
                            "Call"
                        ],
                        [
                            "embs",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, num_steps, channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "executing_eagerly_107": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "gradients_111": {
                "variable": {
                    "value": "gradients",
                    "type": "variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.compute_loss(embs, steps, seq_lens, global_step, training=True, frame_labels=data['frame_labels'], seq_labels=data['seq_labels'])",
                            "Call"
                        ],
                        [
                            "loss * (1.0 / num_replicas)",
                            "BinOp"
                        ],
                        [
                            "loss",
                            "Method Argument"
                        ]
                    ]
                },
                "xs": {
                    "value": "self.variables",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_125": {
                "variable": {
                    "value": "reg_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.stack(self.losses)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_strategy_135": {
                "variable": {
                    "value": "strategy",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_mean_147": {
                "variable": {
                    "value": "grad_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.stack([tf.reduce_sum(grad * grad) for grad in gradients])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "GradientTape_119": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_126": {
                "name": {
                    "value": "reg_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "reg_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.stack(self.losses))",
                            "Call"
                        ]
                    ]
                },
                "step": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_144": {
                "variable": {
                    "value": "norm",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "g * g",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scalar_149": {
                "name": {
                    "value": "grad_norm",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "grad_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.stack([tf.reduce_sum(grad * grad) for grad in gradients]))",
                            "Call"
                        ]
                    ]
                },
                "step": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_125": {
                "values": {
                    "value": "self.losses",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_145": {
                "name": {
                    "value": "'grad_norm_%s' % v.name",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(g * g)",
                            "Call"
                        ]
                    ]
                },
                "step": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_147": {
                "values": {
                    "value": "[tf.reduce_sum(grad * grad) for grad in gradients]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "histogram_152": {
                "name": {
                    "value": "var_.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "var_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.model[k].variables",
                            "Attribute"
                        ]
                    ]
                },
                "step": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_147": {
                "input_tensor": {
                    "value": "grad * grad",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "algos/alignment_sal_tcn.py": {
        "tensorflow": {
            "stack_101": {
                "variable": {
                    "value": "embs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "embs_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "stack_102": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "steps_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "stack_103": {
                "variable": {
                    "value": "seq_lens",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "seq_lens_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "cond_90": {
                "variable": {
                    "value": "chosen_steps",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.random.uniform(()) < 0.5",
                    "type": "Compare",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.range(0, 2 * num_steps, 2)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.range(1, 2 * num_steps, 2)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "gather_94": {
                "variable": {
                    "value": "embs_",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "embs[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "indices": {
                    "value": "chosen_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cond(tf.random.uniform(()) < 0.5, lambda : tf.range(0, 2 * num_steps, 2), lambda : tf.range(1, 2 * num_steps, 2))",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_95": {
                "variable": {
                    "value": "steps_",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "steps[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "indices": {
                    "value": "chosen_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cond(tf.random.uniform(()) < 0.5, lambda : tf.range(0, 2 * num_steps, 2), lambda : tf.range(1, 2 * num_steps, 2))",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_69": {
                "name": {
                    "value": "alignment_sal_tcn/tcn_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tcn_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.tcn_algo.compute_loss(embs, steps, seq_lens, global_step, training, frame_labels, seq_labels)",
                            "Call"
                        ],
                        [
                            "0.0",
                            "float"
                        ]
                    ]
                },
                "step": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "global_step",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "scalar_110": {
                "name": {
                    "value": "alignment_sal_tcn/alignment_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "alignment_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.alignment_algo.compute_loss(embs, steps, seq_lens, num_steps, batch_size, global_step, training)",
                            "Call"
                        ],
                        [
                            "0.0",
                            "float"
                        ]
                    ]
                },
                "step": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "global_step",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "scalar_120": {
                "name": {
                    "value": "alignment_sal_tcn/sal_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "sal_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sal_algo.compute_loss(embs, steps, seq_lens, global_step, training, frame_labels, seq_labels)",
                            "Call"
                        ],
                        [
                            "0.0",
                            "float"
                        ]
                    ]
                },
                "step": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "global_step",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "uniform_90": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            }
        }
    },
    "algos/sal.py": {
        "tensorflow": {
            "shuffle_27": {
                "variable": {
                    "value": "shuffle_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.cast(num_shuffled_examples * [1] + (total_num_samples - num_shuffled_examples) * [0], tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sort_30": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "random_choice_noreplace(total_num_samples, num_steps)[:, :5]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_33": {
                "variable": {
                    "value": "shuffled_samples",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.less_equal(tf.random.uniform((total_num_samples, 1)), 0.5)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.gather(indices, [1, 0, 3], axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.gather(indices, [1, 4, 3], axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_37": {
                "variable": {
                    "value": "ordered_samples",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sort(random_choice_noreplace(total_num_samples, num_steps)[:, :5], axis=1)",
                            "Call"
                        ],
                        [
                            "randomly_reverse_indices(indices)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.equal(tf.expand_dims(shuffle_labels, axis=-1), 1), shuffled_samples, ordered_samples)",
                            "Call"
                        ],
                        [
                            "get_shuffled_indices_and_labels(batch_size, num_samples, shuffle_fraction, num_steps)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(indices)",
                            "Call"
                        ],
                        [
                            "indices",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "[1, 2, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_38": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.equal(tf.expand_dims(shuffle_labels, axis=-1), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "shuffled_samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.less_equal(tf.random.uniform((total_num_samples, 1)), 0.5), tf.gather(indices, [1, 0, 3], axis=1), tf.gather(indices, [1, 4, 3], axis=1))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "ordered_samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(indices, [1, 2, 3], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "one_hot_52": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_shuffled_indices_and_labels(batch_size, num_samples, shuffle_fraction, num_steps)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels, 2)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "sample_batch(embs, batch_size, num_steps)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stop_gradient_53": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_shuffled_indices_and_labels(batch_size, num_samples, shuffle_fraction, num_steps)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels, 2)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "sample_batch(embs, batch_size, num_steps)",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_54": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sort(random_choice_noreplace(total_num_samples, num_steps)[:, :5], axis=1)",
                            "Call"
                        ],
                        [
                            "randomly_reverse_indices(indices)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.equal(tf.expand_dims(shuffle_labels, axis=-1), 1), shuffled_samples, ordered_samples)",
                            "Call"
                        ],
                        [
                            "get_shuffled_indices_and_labels(batch_size, num_samples, shuffle_fraction, num_steps)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(indices)",
                            "Call"
                        ],
                        [
                            "indices",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "tile_55": {
                "variable": {
                    "value": "embs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "embs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(embs, [num_samples, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.gather(embs, indices, axis=1, batch_dims=-1)",
                            "Call"
                        ],
                        [
                            "embs",
                            "Method Argument"
                        ],
                        [
                            "embs",
                            "Method Argument"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[num_samples, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_56": {
                "variable": {
                    "value": "embs",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "embs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(embs, [num_samples, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.gather(embs, indices, axis=1, batch_dims=-1)",
                            "Call"
                        ],
                        [
                            "embs",
                            "Method Argument"
                        ],
                        [
                            "embs",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sort(random_choice_noreplace(total_num_samples, num_steps)[:, :5], axis=1)",
                            "Call"
                        ],
                        [
                            "randomly_reverse_indices(indices)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.equal(tf.expand_dims(shuffle_labels, axis=-1), 1), shuffled_samples, ordered_samples)",
                            "Call"
                        ],
                        [
                            "get_shuffled_indices_and_labels(batch_size, num_samples, shuffle_fraction, num_steps)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(indices)",
                            "Call"
                        ],
                        [
                            "indices",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "batch_dims": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "squeeze_57": {
                "variable": {
                    "value": "concat_embs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.concat(tf.split(embs, 3, axis=1), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cond_16": {
                "pred": {
                    "value": "tf.random.uniform(()) < 0.5",
                    "type": "Compare",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : indices",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : indices[:, ::-1]",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "reduce_mean_90": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.keras.losses.categorical_crossentropy(y_true=labels, y_pred=logits, from_logits=True, label_smoothing=CONFIG.SAL.LABEL_SMOOTHING)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_27": {
                "x": {
                    "value": "num_shuffled_examples * [1] + (total_num_samples - num_shuffled_examples) * [0]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "less_equal_34": {
                "x": {
                    "value": "tf.random.uniform((total_num_samples, 1))",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "gather_35": {
                "params": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sort(random_choice_noreplace(total_num_samples, num_steps)[:, :5], axis=1)",
                            "Call"
                        ],
                        [
                            "randomly_reverse_indices(indices)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.equal(tf.expand_dims(shuffle_labels, axis=-1), 1), shuffled_samples, ordered_samples)",
                            "Call"
                        ],
                        [
                            "get_shuffled_indices_and_labels(batch_size, num_samples, shuffle_fraction, num_steps)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(indices)",
                            "Call"
                        ],
                        [
                            "indices",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "[1, 0, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_36": {
                "params": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sort(random_choice_noreplace(total_num_samples, num_steps)[:, :5], axis=1)",
                            "Call"
                        ],
                        [
                            "randomly_reverse_indices(indices)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.equal(tf.expand_dims(shuffle_labels, axis=-1), 1), shuffled_samples, ordered_samples)",
                            "Call"
                        ],
                        [
                            "get_shuffled_indices_and_labels(batch_size, num_samples, shuffle_fraction, num_steps)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(indices)",
                            "Call"
                        ],
                        [
                            "indices",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "[1, 4, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_38": {
                "x": {
                    "value": "tf.expand_dims(shuffle_labels, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_57": {
                "values": {
                    "value": "tf.split(embs, 3, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "uniform_16": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "uniform_34": {
                "shape": {
                    "value": "(total_num_samples, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "expand_dims_38": {
                "input": {
                    "value": "shuffle_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random.shuffle(tf.cast(num_shuffled_examples * [1] + (total_num_samples - num_shuffled_examples) * [0], tf.int32))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "split_57": {
                "value": {
                    "value": "embs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(embs, [num_samples, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.gather(embs, indices, axis=1, batch_dims=-1)",
                            "Call"
                        ],
                        [
                            "embs",
                            "Method Argument"
                        ],
                        [
                            "embs",
                            "Method Argument"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "categorical_crossentropy_91": {
                "y_true": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_shuffled_indices_and_labels(batch_size, num_samples, shuffle_fraction, num_steps)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels, 2)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "sample_batch(embs, batch_size, num_steps)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.model['sal_classifier'](concat_embs)",
                            "Call"
                        ]
                    ]
                },
                "from_logits": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "label_smoothing": {
                    "value": "CONFIG.SAL.LABEL_SMOOTHING",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "algos/tcn.py": {
        "tensorflow": {
            "reduce_mean_16": {
                "variable": {
                    "value": "reg_anchor",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.reduce_sum(tf.square(embeddings_anchor), 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_17": {
                "variable": {
                    "value": "reg_positive",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.reduce_sum(tf.square(embeddings_positive), 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_22": {
                "variable": {
                    "value": "similarity_matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "embeddings_anchor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embs[0::2]",
                            "Subscript"
                        ],
                        [
                            "embeddings_anchor",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "embeddings_positive",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embs[1::2]",
                            "Subscript"
                        ],
                        [
                            "embeddings_positive",
                            "Method Argument"
                        ]
                    ]
                },
                "transpose_a": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_27": {
                "variable": {
                    "value": "lshape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(labels, [lshape[0], 1])",
                            "Call"
                        ],
                        [
                            "tf.range(num_steps)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_29": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(labels, [lshape[0], 1])",
                            "Call"
                        ],
                        [
                            "tf.range(num_steps)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[lshape[0], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_31": {
                "variable": {
                    "value": "labels_remapped",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(labels, tf.transpose(labels))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_36": {
                "variable": {
                    "value": "xent_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "similarity_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(embeddings_anchor, embeddings_positive, transpose_a=False, transpose_b=True)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "labels_remapped",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.equal(labels, tf.transpose(labels)), tf.float32)",
                            "Call"
                        ],
                        [
                            "labels_remapped / tf.reduce_sum(labels_remapped, 1, keepdims=True)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_mean_38": {
                "variable": {
                    "value": "xent_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "xent_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=similarity_matrix, labels=labels_remapped)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(xent_loss)",
                            "Call"
                        ]
                    ]
                }
            },
            "range_46": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "stop_gradient_47": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(labels, [lshape[0], 1])",
                            "Call"
                        ],
                        [
                            "tf.range(num_steps)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_33": {
                "input_tensor": {
                    "value": "labels_remapped",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.equal(labels, tf.transpose(labels)), tf.float32)",
                            "Call"
                        ],
                        [
                            "labels_remapped / tf.reduce_sum(labels_remapped, 1, keepdims=True)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "stack_78": {
                "variable": {
                    "value": "embs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "tf.split(embs, 2 * num_steps, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_93": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.stack(losses)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_16": {
                "input_tensor": {
                    "value": "tf.square(embeddings_anchor)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_17": {
                "input_tensor": {
                    "value": "tf.square(embeddings_positive)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_32": {
                "x": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(labels, [lshape[0], 1])",
                            "Call"
                        ],
                        [
                            "tf.range(num_steps)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.transpose(labels)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "square_16": {
                "x": {
                    "value": "embeddings_anchor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embs[0::2]",
                            "Subscript"
                        ],
                        [
                            "embeddings_anchor",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "square_18": {
                "x": {
                    "value": "embeddings_positive",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embs[1::2]",
                            "Subscript"
                        ],
                        [
                            "embeddings_positive",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "transpose_32": {
                "a": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(labels, [lshape[0], 1])",
                            "Call"
                        ],
                        [
                            "tf.range(num_steps)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "split_78": {
                "value": {
                    "value": "embs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "emb(cnn_feats, 2 * num_steps)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(embs, 2 * num_steps, axis=0), axis=1)",
                            "Call"
                        ],
                        [
                            "embs",
                            "Method Argument"
                        ],
                        [
                            "embs",
                            "Method Argument"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2 * num_steps",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_93": {
                "values": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            }
        }
    },
    "datasets.py": {
        "tensorflow": {
            "cast_23": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "frame",
                    "type": "variable",
                    "possible_values": [
                        [
                            "frame",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenSequenceFeature_99": {
                "variable": {
                    "value": "seq_features[video]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "parse_single_sequence_example_115": {
                "variable": {
                    "value": "(context_data, sequence_data)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "serialized": {
                    "value": "serialized_example",
                    "type": "variable",
                    "possible_values": [
                        [
                            "serialized_example",
                            "Method Argument"
                        ]
                    ]
                },
                "context_features": {
                    "value": "context_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'name': tf.io.FixedLenFeature([], dtype=tf.string), 'len': tf.io.FixedLenFeature([], dtype=tf.int64), 'label': tf.io.FixedLenFeature([], dtype=tf.int64)}",
                            "Dict"
                        ]
                    ]
                },
                "sequence_features": {
                    "value": "seq_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{}",
                            "Dict"
                        ]
                    ]
                }
            },
            "cast_130": {
                "variable": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "context_data['name']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_243": {
                "variable": {
                    "value": "video",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "video",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sequence_data.get('video', [])",
                            "Call"
                        ],
                        [
                            "tf.gather(video, steps)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(tf.image.decode_jpeg, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.uint8)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(normalize_input, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "preprocess_input(video, augment)",
                            "Call"
                        ],
                        [
                            "tf.gather(video, steps)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(tf.image.decode_jpeg, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.uint8)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(normalize_input, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "preprocess_input(video, augment)",
                            "Call"
                        ],
                        [
                            "video",
                            "Method Argument"
                        ],
                        [
                            "video",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_244": {
                "variable": {
                    "value": "rgb_video",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "rgb_video",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sequence_data.get('rgb_video', [])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.gather(rgb_video, steps)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(tf.image.decode_jpeg, rgb_video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.uint8)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(normalize_input, rgb_video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "preprocess_input(rgb_video, augment)",
                            "Call"
                        ],
                        [
                            "rgb_video",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "map_fn_246": {
                "variable": {
                    "value": "video",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "tf.image.decode_jpeg",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "video",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sequence_data.get('video', [])",
                            "Call"
                        ],
                        [
                            "tf.gather(video, steps)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(tf.image.decode_jpeg, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.uint8)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(normalize_input, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "preprocess_input(video, augment)",
                            "Call"
                        ],
                        [
                            "tf.gather(video, steps)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(tf.image.decode_jpeg, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.uint8)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(normalize_input, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "preprocess_input(video, augment)",
                            "Call"
                        ],
                        [
                            "video",
                            "Method Argument"
                        ],
                        [
                            "video",
                            "Method Argument"
                        ]
                    ]
                },
                "parallel_iterations": {
                    "value": "NUM_PARALLEL_CALLS",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8",
                            "int"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.uint8",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_fn_251": {
                "variable": {
                    "value": "rgb_video",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "tf.image.decode_jpeg",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "rgb_video",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sequence_data.get('rgb_video', [])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.gather(rgb_video, steps)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(tf.image.decode_jpeg, rgb_video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.uint8)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(normalize_input, rgb_video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "preprocess_input(rgb_video, augment)",
                            "Call"
                        ],
                        [
                            "rgb_video",
                            "Method Argument"
                        ]
                    ]
                },
                "parallel_iterations": {
                    "value": "NUM_PARALLEL_CALLS",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8",
                            "int"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.uint8",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_fn_258": {
                "variable": {
                    "value": "video",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "normalize_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "normalize_input",
                            "Call"
                        ]
                    ]
                },
                "elems": {
                    "value": "video",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sequence_data.get('video', [])",
                            "Call"
                        ],
                        [
                            "tf.gather(video, steps)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(tf.image.decode_jpeg, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.uint8)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(normalize_input, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "preprocess_input(video, augment)",
                            "Call"
                        ],
                        [
                            "tf.gather(video, steps)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(tf.image.decode_jpeg, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.uint8)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(normalize_input, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "preprocess_input(video, augment)",
                            "Call"
                        ],
                        [
                            "video",
                            "Method Argument"
                        ],
                        [
                            "video",
                            "Method Argument"
                        ]
                    ]
                },
                "parallel_iterations": {
                    "value": "NUM_PARALLEL_CALLS",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8",
                            "int"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_fn_264": {
                "variable": {
                    "value": "rgb_video",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "normalize_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "normalize_input",
                            "Call"
                        ]
                    ]
                },
                "elems": {
                    "value": "rgb_video",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sequence_data.get('rgb_video', [])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.gather(rgb_video, steps)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(tf.image.decode_jpeg, rgb_video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.uint8)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(normalize_input, rgb_video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "preprocess_input(rgb_video, augment)",
                            "Call"
                        ],
                        [
                            "rgb_video",
                            "Method Argument"
                        ]
                    ]
                },
                "parallel_iterations": {
                    "value": "NUM_PARALLEL_CALLS",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8",
                            "int"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_388": {
                "variable": {
                    "value": "video",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "video",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sequence_data.get('video', [])",
                            "Call"
                        ],
                        [
                            "tf.gather(video, steps)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(tf.image.decode_jpeg, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.uint8)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(normalize_input, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "preprocess_input(video, augment)",
                            "Call"
                        ],
                        [
                            "tf.gather(video, steps)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(tf.image.decode_jpeg, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.uint8)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(normalize_input, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "preprocess_input(video, augment)",
                            "Call"
                        ],
                        [
                            "video",
                            "Method Argument"
                        ],
                        [
                            "video",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "map_fn_390": {
                "variable": {
                    "value": "video",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "tf.image.decode_jpeg",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "video",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sequence_data.get('video', [])",
                            "Call"
                        ],
                        [
                            "tf.gather(video, steps)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(tf.image.decode_jpeg, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.uint8)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(normalize_input, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "preprocess_input(video, augment)",
                            "Call"
                        ],
                        [
                            "tf.gather(video, steps)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(tf.image.decode_jpeg, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.uint8)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(normalize_input, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "preprocess_input(video, augment)",
                            "Call"
                        ],
                        [
                            "video",
                            "Method Argument"
                        ],
                        [
                            "video",
                            "Method Argument"
                        ]
                    ]
                },
                "parallel_iterations": {
                    "value": "NUM_PARALLEL_CALLS",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8",
                            "int"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.uint8",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_fn_396": {
                "variable": {
                    "value": "video",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "normalize_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "normalize_input",
                            "Call"
                        ]
                    ]
                },
                "elems": {
                    "value": "video",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sequence_data.get('video', [])",
                            "Call"
                        ],
                        [
                            "tf.gather(video, steps)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(tf.image.decode_jpeg, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.uint8)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(normalize_input, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "preprocess_input(video, augment)",
                            "Call"
                        ],
                        [
                            "tf.gather(video, steps)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(tf.image.decode_jpeg, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.uint8)",
                            "Call"
                        ],
                        [
                            "tf.map_fn(normalize_input, video, parallel_iterations=NUM_PARALLEL_CALLS, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "preprocess_input(video, augment)",
                            "Call"
                        ],
                        [
                            "video",
                            "Method Argument"
                        ],
                        [
                            "video",
                            "Method Argument"
                        ]
                    ]
                },
                "parallel_iterations": {
                    "value": "NUM_PARALLEL_CALLS",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8",
                            "int"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenSequenceFeature_101": {
                "variable": {
                    "value": "seq_features[rgb_video]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_234": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.map_fn(get_steps, steps)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "maximum_235": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.cast(0, tf.int64)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "minimum_236": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "seq_len - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_280": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(labels, steps)",
                            "Call"
                        ],
                        [
                            "tf.gather(labels, steps)",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_379": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.map_fn(get_steps, steps)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "maximum_380": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.cast(0, tf.int64)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "minimum_381": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "seq_len - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_407": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(labels, steps)",
                            "Call"
                        ],
                        [
                            "tf.gather(labels, steps)",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "sample_from_datasets_519": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                },
                "datasets": {
                    "value": "datasets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "weights": {
                    "value": "len(datasets) * [1.0]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "TFRecordDataset_553": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                },
                "filenames": {
                    "value": "tfrecord_files",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sorted(tf.io.gfile.glob(path_to_tfrecords))",
                            "Call"
                        ],
                        [
                            "sorted(tf.io.gfile.glob(path_to_tfrecords))",
                            "Call"
                        ],
                        [
                            "get_tfrecords(dataset_name, split, CONFIG.PATH_TO_TFRECORDS, per_class=per_class)",
                            "Call"
                        ],
                        [
                            "get_tfrecords(dataset, split, CONFIG.PATH_TO_TFRECORDS if path_to_tfrecords is None else path_to_tfrecords)",
                            "Call"
                        ]
                    ]
                },
                "num_parallel_reads": {
                    "value": "NUM_PARALLEL_CALLS",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8",
                            "int"
                        ]
                    ]
                }
            },
            "FixedLenFeature_90": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_91": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_92": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenSequenceFeature_106": {
                "variable": {
                    "value": "seq_features[frame_labels]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenSequenceFeature_111": {
                "variable": {
                    "value": "seq_features[frame_labels]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "uniform_179": {
                "variable": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "tf.maximum(tf.cast(1, tf.int64), seq_len - stride * num_steps)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "minimum_185": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "seq_len - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.range(offset, offset + num_steps * stride + 1, stride)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "map_fn_222": {
                "variable": {
                    "value": "pos_steps",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda step: tf.random.uniform((), minval=step - pos_window, maxval=step, dtype=tf.int64)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_228": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[pos_steps, steps]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_229": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.transpose(steps)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "uniform_324": {
                "variable": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "tf.maximum(tf.cast(1, tf.int64), seq_len - stride * num_steps)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "minimum_330": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "seq_len - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.range(offset, offset + num_steps * stride + 1, stride)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "map_fn_367": {
                "variable": {
                    "value": "pos_steps",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda step: tf.random.uniform((), minval=step - pos_window, maxval=step, dtype=tf.int64)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_373": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[pos_steps, steps]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_374": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.transpose(steps)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "device_497": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "TFRecordDataset_501": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                },
                "filenames": {
                    "value": "tfrecord_files",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sorted(tf.io.gfile.glob(path_to_tfrecords))",
                            "Call"
                        ],
                        [
                            "sorted(tf.io.gfile.glob(path_to_tfrecords))",
                            "Call"
                        ],
                        [
                            "get_tfrecords(dataset_name, split, CONFIG.PATH_TO_TFRECORDS, per_class=per_class)",
                            "Call"
                        ],
                        [
                            "get_tfrecords(dataset, split, CONFIG.PATH_TO_TFRECORDS if path_to_tfrecords is None else path_to_tfrecords)",
                            "Call"
                        ]
                    ]
                },
                "num_parallel_reads": {
                    "value": "NUM_PARALLEL_CALLS",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8",
                            "int"
                        ]
                    ]
                }
            },
            "device_552": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_168": {
                "input": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "assert_greater_equal_192": {
                "variable": {
                    "value": "check1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "seq_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "context_data['len']",
                            "Subscript"
                        ],
                        [
                            "tf.shape(steps)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(steps)[0]",
                            "Subscript"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.cast(CONFIG.DATA.RANDOM_OFFSET, tf.int64)",
                    "type": "Call",
                    "possible_values": []
                },
                "message": {
                    "value": "Random offset is more than sequence length.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "less_equal_196": {
                "variable": {
                    "value": "check2",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.cast(num_steps, tf.int64)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "seq_len - tf.cast(CONFIG.DATA.RANDOM_OFFSET, tf.int64)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cond_213": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "check2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less_equal(tf.cast(num_steps, tf.int64), seq_len - tf.cast(CONFIG.DATA.RANDOM_OFFSET, tf.int64))",
                            "Call"
                        ],
                        [
                            "tf.less_equal(tf.cast(num_steps, tf.int64), seq_len - tf.cast(CONFIG.DATA.RANDOM_OFFSET, tf.int64))",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "_sample_random",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_sample_random",
                            "Call"
                        ],
                        [
                            "_sample_random",
                            "Call"
                        ]
                    ]
                },
                "false_fn": {
                    "value": "_sample_all",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_sample_all",
                            "Call"
                        ],
                        [
                            "_sample_all",
                            "Call"
                        ]
                    ]
                }
            },
            "map_fn_234": {
                "fn": {
                    "value": "get_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_steps",
                            "Call"
                        ]
                    ]
                },
                "elems": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_235": {
                "x": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_313": {
                "input": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "assert_greater_equal_337": {
                "variable": {
                    "value": "check1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "seq_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "context_data['len']",
                            "Subscript"
                        ],
                        [
                            "tf.shape(steps)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(steps)[0]",
                            "Subscript"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.cast(CONFIG.DATA.RANDOM_OFFSET, tf.int64)",
                    "type": "Call",
                    "possible_values": []
                },
                "message": {
                    "value": "Random offset is more than sequence length.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "less_equal_341": {
                "variable": {
                    "value": "check2",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.cast(num_steps, tf.int64)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "seq_len - tf.cast(CONFIG.DATA.RANDOM_OFFSET, tf.int64)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cond_358": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "check2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less_equal(tf.cast(num_steps, tf.int64), seq_len - tf.cast(CONFIG.DATA.RANDOM_OFFSET, tf.int64))",
                            "Call"
                        ],
                        [
                            "tf.less_equal(tf.cast(num_steps, tf.int64), seq_len - tf.cast(CONFIG.DATA.RANDOM_OFFSET, tf.int64))",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "_sample_random",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_sample_random",
                            "Call"
                        ],
                        [
                            "_sample_random",
                            "Call"
                        ]
                    ]
                },
                "false_fn": {
                    "value": "_sample_all",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_sample_all",
                            "Call"
                        ],
                        [
                            "_sample_all",
                            "Call"
                        ]
                    ]
                }
            },
            "map_fn_379": {
                "fn": {
                    "value": "get_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_steps",
                            "Call"
                        ]
                    ]
                },
                "elems": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_380": {
                "x": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "glob_427": {
                "pattern": {
                    "value": "path_to_tfrecords",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(path % dataset, '*%s*' % split)",
                            "Call"
                        ],
                        [
                            "os.path.join(path % dataset if '%s' in path else path, '%s_%s*' % (dataset, split))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "glob_433": {
                "pattern": {
                    "value": "path_to_tfrecords",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(path % dataset, '*%s*' % split)",
                            "Call"
                        ],
                        [
                            "os.path.join(path % dataset if '%s' in path else path, '%s_%s*' % (dataset, split))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "maximum_180": {
                "x": {
                    "value": "tf.cast(1, tf.int64)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "seq_len - stride * num_steps",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "transpose_229": {
                "a": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "maximum_325": {
                "x": {
                    "value": "tf.cast(1, tf.int64)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "seq_len - stride * num_steps",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "transpose_374": {
                "a": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_54": {
                "input": {
                    "value": "frames",
                    "type": "variable",
                    "possible_values": [
                        [
                            "preprocess_sequence.preprocess_sequence(((frames, preprocess_sequence.IMAGE),), preprocessing_ranges)",
                            "Call"
                        ],
                        [
                            "frames",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_78": {
                "input": {
                    "value": "frames",
                    "type": "variable",
                    "possible_values": [
                        [
                            "preprocess_sequence.preprocess_sequence(((frames, preprocess_sequence.IMAGE),), preprocessing_ranges)",
                            "Call"
                        ],
                        [
                            "frames",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_180": {
                "x": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_194": {
                "x": {
                    "value": "CONFIG.DATA.RANDOM_OFFSET",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_197": {
                "x": {
                    "value": "num_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "CONFIG.DATA.NUM_STEPS",
                            "Attribute"
                        ],
                        [
                            "CONFIG.TRAIN.NUM_FRAMES",
                            "Attribute"
                        ],
                        [
                            "CONFIG.EVAL.NUM_FRAMES",
                            "Attribute"
                        ],
                        [
                            "CONFIG.TRAIN.NUM_FRAMES",
                            "Attribute"
                        ],
                        [
                            "CONFIG.EVAL.NUM_FRAMES",
                            "Attribute"
                        ],
                        [
                            "num_steps",
                            "Method Argument"
                        ],
                        [
                            "num_steps",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shuffle_204": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.range(offset, seq_len)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_205": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.range(0, num_steps)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_206": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.nn.top_k(steps, k=num_steps).indices[::-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "uniform_223": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "minval": {
                    "value": "step - pos_window",
                    "type": "BinOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "step",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_325": {
                "x": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_339": {
                "x": {
                    "value": "CONFIG.DATA.RANDOM_OFFSET",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_342": {
                "x": {
                    "value": "num_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "CONFIG.DATA.NUM_STEPS",
                            "Attribute"
                        ],
                        [
                            "CONFIG.TRAIN.NUM_FRAMES",
                            "Attribute"
                        ],
                        [
                            "CONFIG.EVAL.NUM_FRAMES",
                            "Attribute"
                        ],
                        [
                            "CONFIG.TRAIN.NUM_FRAMES",
                            "Attribute"
                        ],
                        [
                            "CONFIG.EVAL.NUM_FRAMES",
                            "Attribute"
                        ],
                        [
                            "num_steps",
                            "Method Argument"
                        ],
                        [
                            "num_steps",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shuffle_349": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.range(offset, seq_len)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_350": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.range(0, num_steps)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_351": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.nn.top_k(steps, k=num_steps).indices[::-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "range_356": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "uniform_368": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "minval": {
                    "value": "step - pos_window",
                    "type": "BinOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "step",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_198": {
                "x": {
                    "value": "CONFIG.DATA.RANDOM_OFFSET",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "control_dependencies_202": {
                "control_inputs": {
                    "value": "[tf.identity(check1.outputs[0])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_343": {
                "x": {
                    "value": "CONFIG.DATA.RANDOM_OFFSET",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "control_dependencies_347": {
                "control_inputs": {
                    "value": "[tf.identity(check1.outputs[0])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "range_204": {},
            "range_205": {},
            "range_349": {},
            "range_350": {},
            "identity_202": {
                "input": {
                    "value": "check1.outputs[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "identity_347": {
                "input": {
                    "value": "check1.outputs[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "top_k_207": {
                "input": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "num_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "CONFIG.DATA.NUM_STEPS",
                            "Attribute"
                        ],
                        [
                            "CONFIG.TRAIN.NUM_FRAMES",
                            "Attribute"
                        ],
                        [
                            "CONFIG.EVAL.NUM_FRAMES",
                            "Attribute"
                        ],
                        [
                            "CONFIG.TRAIN.NUM_FRAMES",
                            "Attribute"
                        ],
                        [
                            "CONFIG.EVAL.NUM_FRAMES",
                            "Attribute"
                        ],
                        [
                            "num_steps",
                            "Method Argument"
                        ],
                        [
                            "num_steps",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "top_k_352": {
                "input": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(step - (num_steps - 1) * stride, step + stride, stride)",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ],
                        [
                            "tf.range(0, seq_len, sample_all_stride)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, tf.range(offset, offset + num_steps * stride + 1, stride))",
                            "Call"
                        ],
                        [
                            "steps[:num_steps]",
                            "Subscript"
                        ],
                        [
                            "tf.cond(check2, _sample_random, _sample_all)",
                            "Call"
                        ],
                        [
                            "tf.stack([pos_steps, steps])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(steps), (-1,))",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.map_fn(get_steps, steps), [-1])",
                            "Call"
                        ],
                        [
                            "tf.maximum(tf.cast(0, tf.int64), steps)",
                            "Call"
                        ],
                        [
                            "tf.minimum(seq_len - 1, steps)",
                            "Call"
                        ],
                        [
                            "tf.random.shuffle(tf.range(offset, seq_len))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.range(0, num_steps))",
                            "Call"
                        ],
                        [
                            "tf.gather(steps, tf.nn.top_k(steps, k=num_steps).indices[::-1])",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "num_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "CONFIG.DATA.NUM_STEPS",
                            "Attribute"
                        ],
                        [
                            "CONFIG.TRAIN.NUM_FRAMES",
                            "Attribute"
                        ],
                        [
                            "CONFIG.EVAL.NUM_FRAMES",
                            "Attribute"
                        ],
                        [
                            "CONFIG.TRAIN.NUM_FRAMES",
                            "Attribute"
                        ],
                        [
                            "CONFIG.EVAL.NUM_FRAMES",
                            "Attribute"
                        ],
                        [
                            "num_steps",
                            "Method Argument"
                        ],
                        [
                            "num_steps",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "extract_embeddings.py": {
        "tensorflow": {
            "function_138": {
                "variable": {
                    "value": "algo.call",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "function_139": {
                "variable": {
                    "value": "algo.compute_loss",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "models.py": {
        "tensorflow": {
            "Model_83": {
                "variable": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "outputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.Conv2D(channels, kernel_size, padding='same', kernel_initializer='he_normal', kernel_regularizer=regularizers.l2(l2_reg_weight), bias_regularizer=regularizers.l2(l2_reg_weight))(x)",
                            "Call"
                        ],
                        [
                            "layers.BatchNormalization()(x)",
                            "Call"
                        ],
                        [
                            "layers.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "layers.MaxPooling2D(pool_size=max_pool_size, strides=2, padding='same', name=name)(x)",
                            "Call"
                        ],
                        [
                            "layers.MaxPooling2D(pool_size=1, strides=1, padding='same', name=name)(x)",
                            "Call"
                        ],
                        [
                            "layers.Input(shape=(image_size, image_size, 3), dtype='float32')",
                            "Call"
                        ],
                        [
                            "layers.ZeroPadding2D(padding=(3, 3))(x)",
                            "Call"
                        ],
                        [
                            "layers.Conv2D(64, (7, 7), strides=(2, 2), padding='valid', kernel_initializer='he_normal', name='conv1')(x)",
                            "Call"
                        ],
                        [
                            "layers.BatchNormalization()(x)",
                            "Call"
                        ],
                        [
                            "layers.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "layers.ZeroPadding2D(padding=(1, 1))(x)",
                            "Call"
                        ],
                        [
                            "layers.MaxPooling2D(pool_size=(3, 3), strides=(2, 2), padding='valid')(x)",
                            "Call"
                        ],
                        [
                            "get_vggm_conv_block(x, 2 * [(channels, filter_size)], use_bn, max_pool_size, name='conv%s' % (i + 2))",
                            "Call"
                        ],
                        [
                            "self.base_model(images, training=CONFIG.MODEL.TRAIN_BASE != 'frozen')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size, num_steps, h, w, c])",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size * num_frames, num_context, h, w, c])",
                            "Call"
                        ],
                        [
                            "layers.SpatialDropout3D(base_dropout_rate)(x)",
                            "Call"
                        ],
                        [
                            "layers.Dropout(base_dropout_rate)(x)",
                            "Call"
                        ],
                        [
                            "conv_layer(x)",
                            "Call"
                        ],
                        [
                            "bn_layer(x)",
                            "Call"
                        ],
                        [
                            "layers.GlobalMaxPooling3D()(x)",
                            "Call"
                        ],
                        [
                            "self.activations[i](x)",
                            "Call"
                        ],
                        [
                            "layers.GlobalAveragePooling3D()(x)",
                            "Call"
                        ],
                        [
                            "layers.Dropout(fc_dropout_rate)(x)",
                            "Call"
                        ],
                        [
                            "fc_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embedding_layer(x)",
                            "Call"
                        ],
                        [
                            "layers.Flatten()(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size * num_steps, h, w, c])",
                            "Call"
                        ],
                        [
                            "self.dropout(x)",
                            "Call"
                        ],
                        [
                            "conv_layer(x)",
                            "Call"
                        ],
                        [
                            "layers.GlobalMaxPooling2D()(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size, num_steps, c])",
                            "Call"
                        ],
                        [
                            "bn_layer(x)",
                            "Call"
                        ],
                        [
                            "self.activations[i](x)",
                            "Call"
                        ],
                        [
                            "gru_layer(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size * num_steps, c])",
                            "Call"
                        ],
                        [
                            "self.dropout(x)",
                            "Call"
                        ],
                        [
                            "fc_layer(x)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Model_120": {
                "variable": {
                    "value": "self.base_model",
                    "type": "Attribute",
                    "possible_values": []
                },
                "inputs": {
                    "value": "base_model.input",
                    "type": "Attribute",
                    "possible_values": []
                },
                "outputs": {
                    "value": "base_model.get_layer(layer).output",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_129": {
                "variable": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size * num_steps, h, w, c]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_134": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.Conv2D(channels, kernel_size, padding='same', kernel_initializer='he_normal', kernel_regularizer=regularizers.l2(l2_reg_weight), bias_regularizer=regularizers.l2(l2_reg_weight))(x)",
                            "Call"
                        ],
                        [
                            "layers.BatchNormalization()(x)",
                            "Call"
                        ],
                        [
                            "layers.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "layers.MaxPooling2D(pool_size=max_pool_size, strides=2, padding='same', name=name)(x)",
                            "Call"
                        ],
                        [
                            "layers.MaxPooling2D(pool_size=1, strides=1, padding='same', name=name)(x)",
                            "Call"
                        ],
                        [
                            "layers.Input(shape=(image_size, image_size, 3), dtype='float32')",
                            "Call"
                        ],
                        [
                            "layers.ZeroPadding2D(padding=(3, 3))(x)",
                            "Call"
                        ],
                        [
                            "layers.Conv2D(64, (7, 7), strides=(2, 2), padding='valid', kernel_initializer='he_normal', name='conv1')(x)",
                            "Call"
                        ],
                        [
                            "layers.BatchNormalization()(x)",
                            "Call"
                        ],
                        [
                            "layers.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "layers.ZeroPadding2D(padding=(1, 1))(x)",
                            "Call"
                        ],
                        [
                            "layers.MaxPooling2D(pool_size=(3, 3), strides=(2, 2), padding='valid')(x)",
                            "Call"
                        ],
                        [
                            "get_vggm_conv_block(x, 2 * [(channels, filter_size)], use_bn, max_pool_size, name='conv%s' % (i + 2))",
                            "Call"
                        ],
                        [
                            "self.base_model(images, training=CONFIG.MODEL.TRAIN_BASE != 'frozen')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size, num_steps, h, w, c])",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size * num_frames, num_context, h, w, c])",
                            "Call"
                        ],
                        [
                            "layers.SpatialDropout3D(base_dropout_rate)(x)",
                            "Call"
                        ],
                        [
                            "layers.Dropout(base_dropout_rate)(x)",
                            "Call"
                        ],
                        [
                            "conv_layer(x)",
                            "Call"
                        ],
                        [
                            "bn_layer(x)",
                            "Call"
                        ],
                        [
                            "layers.GlobalMaxPooling3D()(x)",
                            "Call"
                        ],
                        [
                            "self.activations[i](x)",
                            "Call"
                        ],
                        [
                            "layers.GlobalAveragePooling3D()(x)",
                            "Call"
                        ],
                        [
                            "layers.Dropout(fc_dropout_rate)(x)",
                            "Call"
                        ],
                        [
                            "fc_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embedding_layer(x)",
                            "Call"
                        ],
                        [
                            "layers.Flatten()(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size * num_steps, h, w, c])",
                            "Call"
                        ],
                        [
                            "self.dropout(x)",
                            "Call"
                        ],
                        [
                            "conv_layer(x)",
                            "Call"
                        ],
                        [
                            "layers.GlobalMaxPooling2D()(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size, num_steps, c])",
                            "Call"
                        ],
                        [
                            "bn_layer(x)",
                            "Call"
                        ],
                        [
                            "self.activations[i](x)",
                            "Call"
                        ],
                        [
                            "gru_layer(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size * num_steps, c])",
                            "Call"
                        ],
                        [
                            "self.dropout(x)",
                            "Call"
                        ],
                        [
                            "fc_layer(x)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, num_steps, h, w, c]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_177": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.Conv2D(channels, kernel_size, padding='same', kernel_initializer='he_normal', kernel_regularizer=regularizers.l2(l2_reg_weight), bias_regularizer=regularizers.l2(l2_reg_weight))(x)",
                            "Call"
                        ],
                        [
                            "layers.BatchNormalization()(x)",
                            "Call"
                        ],
                        [
                            "layers.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "layers.MaxPooling2D(pool_size=max_pool_size, strides=2, padding='same', name=name)(x)",
                            "Call"
                        ],
                        [
                            "layers.MaxPooling2D(pool_size=1, strides=1, padding='same', name=name)(x)",
                            "Call"
                        ],
                        [
                            "layers.Input(shape=(image_size, image_size, 3), dtype='float32')",
                            "Call"
                        ],
                        [
                            "layers.ZeroPadding2D(padding=(3, 3))(x)",
                            "Call"
                        ],
                        [
                            "layers.Conv2D(64, (7, 7), strides=(2, 2), padding='valid', kernel_initializer='he_normal', name='conv1')(x)",
                            "Call"
                        ],
                        [
                            "layers.BatchNormalization()(x)",
                            "Call"
                        ],
                        [
                            "layers.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "layers.ZeroPadding2D(padding=(1, 1))(x)",
                            "Call"
                        ],
                        [
                            "layers.MaxPooling2D(pool_size=(3, 3), strides=(2, 2), padding='valid')(x)",
                            "Call"
                        ],
                        [
                            "get_vggm_conv_block(x, 2 * [(channels, filter_size)], use_bn, max_pool_size, name='conv%s' % (i + 2))",
                            "Call"
                        ],
                        [
                            "self.base_model(images, training=CONFIG.MODEL.TRAIN_BASE != 'frozen')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size, num_steps, h, w, c])",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size * num_frames, num_context, h, w, c])",
                            "Call"
                        ],
                        [
                            "layers.SpatialDropout3D(base_dropout_rate)(x)",
                            "Call"
                        ],
                        [
                            "layers.Dropout(base_dropout_rate)(x)",
                            "Call"
                        ],
                        [
                            "conv_layer(x)",
                            "Call"
                        ],
                        [
                            "bn_layer(x)",
                            "Call"
                        ],
                        [
                            "layers.GlobalMaxPooling3D()(x)",
                            "Call"
                        ],
                        [
                            "self.activations[i](x)",
                            "Call"
                        ],
                        [
                            "layers.GlobalAveragePooling3D()(x)",
                            "Call"
                        ],
                        [
                            "layers.Dropout(fc_dropout_rate)(x)",
                            "Call"
                        ],
                        [
                            "fc_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embedding_layer(x)",
                            "Call"
                        ],
                        [
                            "layers.Flatten()(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size * num_steps, h, w, c])",
                            "Call"
                        ],
                        [
                            "self.dropout(x)",
                            "Call"
                        ],
                        [
                            "conv_layer(x)",
                            "Call"
                        ],
                        [
                            "layers.GlobalMaxPooling2D()(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size, num_steps, c])",
                            "Call"
                        ],
                        [
                            "bn_layer(x)",
                            "Call"
                        ],
                        [
                            "self.activations[i](x)",
                            "Call"
                        ],
                        [
                            "gru_layer(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size * num_steps, c])",
                            "Call"
                        ],
                        [
                            "self.dropout(x)",
                            "Call"
                        ],
                        [
                            "fc_layer(x)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size * num_frames, num_context, h, w, c]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_252": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.Conv2D(channels, kernel_size, padding='same', kernel_initializer='he_normal', kernel_regularizer=regularizers.l2(l2_reg_weight), bias_regularizer=regularizers.l2(l2_reg_weight))(x)",
                            "Call"
                        ],
                        [
                            "layers.BatchNormalization()(x)",
                            "Call"
                        ],
                        [
                            "layers.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "layers.MaxPooling2D(pool_size=max_pool_size, strides=2, padding='same', name=name)(x)",
                            "Call"
                        ],
                        [
                            "layers.MaxPooling2D(pool_size=1, strides=1, padding='same', name=name)(x)",
                            "Call"
                        ],
                        [
                            "layers.Input(shape=(image_size, image_size, 3), dtype='float32')",
                            "Call"
                        ],
                        [
                            "layers.ZeroPadding2D(padding=(3, 3))(x)",
                            "Call"
                        ],
                        [
                            "layers.Conv2D(64, (7, 7), strides=(2, 2), padding='valid', kernel_initializer='he_normal', name='conv1')(x)",
                            "Call"
                        ],
                        [
                            "layers.BatchNormalization()(x)",
                            "Call"
                        ],
                        [
                            "layers.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "layers.ZeroPadding2D(padding=(1, 1))(x)",
                            "Call"
                        ],
                        [
                            "layers.MaxPooling2D(pool_size=(3, 3), strides=(2, 2), padding='valid')(x)",
                            "Call"
                        ],
                        [
                            "get_vggm_conv_block(x, 2 * [(channels, filter_size)], use_bn, max_pool_size, name='conv%s' % (i + 2))",
                            "Call"
                        ],
                        [
                            "self.base_model(images, training=CONFIG.MODEL.TRAIN_BASE != 'frozen')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size, num_steps, h, w, c])",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size * num_frames, num_context, h, w, c])",
                            "Call"
                        ],
                        [
                            "layers.SpatialDropout3D(base_dropout_rate)(x)",
                            "Call"
                        ],
                        [
                            "layers.Dropout(base_dropout_rate)(x)",
                            "Call"
                        ],
                        [
                            "conv_layer(x)",
                            "Call"
                        ],
                        [
                            "bn_layer(x)",
                            "Call"
                        ],
                        [
                            "layers.GlobalMaxPooling3D()(x)",
                            "Call"
                        ],
                        [
                            "self.activations[i](x)",
                            "Call"
                        ],
                        [
                            "layers.GlobalAveragePooling3D()(x)",
                            "Call"
                        ],
                        [
                            "layers.Dropout(fc_dropout_rate)(x)",
                            "Call"
                        ],
                        [
                            "fc_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embedding_layer(x)",
                            "Call"
                        ],
                        [
                            "layers.Flatten()(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size * num_steps, h, w, c])",
                            "Call"
                        ],
                        [
                            "self.dropout(x)",
                            "Call"
                        ],
                        [
                            "conv_layer(x)",
                            "Call"
                        ],
                        [
                            "layers.GlobalMaxPooling2D()(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size, num_steps, c])",
                            "Call"
                        ],
                        [
                            "bn_layer(x)",
                            "Call"
                        ],
                        [
                            "self.activations[i](x)",
                            "Call"
                        ],
                        [
                            "gru_layer(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size * num_steps, c])",
                            "Call"
                        ],
                        [
                            "self.dropout(x)",
                            "Call"
                        ],
                        [
                            "fc_layer(x)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size * num_steps, h, w, c]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_268": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.Conv2D(channels, kernel_size, padding='same', kernel_initializer='he_normal', kernel_regularizer=regularizers.l2(l2_reg_weight), bias_regularizer=regularizers.l2(l2_reg_weight))(x)",
                            "Call"
                        ],
                        [
                            "layers.BatchNormalization()(x)",
                            "Call"
                        ],
                        [
                            "layers.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "layers.MaxPooling2D(pool_size=max_pool_size, strides=2, padding='same', name=name)(x)",
                            "Call"
                        ],
                        [
                            "layers.MaxPooling2D(pool_size=1, strides=1, padding='same', name=name)(x)",
                            "Call"
                        ],
                        [
                            "layers.Input(shape=(image_size, image_size, 3), dtype='float32')",
                            "Call"
                        ],
                        [
                            "layers.ZeroPadding2D(padding=(3, 3))(x)",
                            "Call"
                        ],
                        [
                            "layers.Conv2D(64, (7, 7), strides=(2, 2), padding='valid', kernel_initializer='he_normal', name='conv1')(x)",
                            "Call"
                        ],
                        [
                            "layers.BatchNormalization()(x)",
                            "Call"
                        ],
                        [
                            "layers.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "layers.ZeroPadding2D(padding=(1, 1))(x)",
                            "Call"
                        ],
                        [
                            "layers.MaxPooling2D(pool_size=(3, 3), strides=(2, 2), padding='valid')(x)",
                            "Call"
                        ],
                        [
                            "get_vggm_conv_block(x, 2 * [(channels, filter_size)], use_bn, max_pool_size, name='conv%s' % (i + 2))",
                            "Call"
                        ],
                        [
                            "self.base_model(images, training=CONFIG.MODEL.TRAIN_BASE != 'frozen')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size, num_steps, h, w, c])",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size * num_frames, num_context, h, w, c])",
                            "Call"
                        ],
                        [
                            "layers.SpatialDropout3D(base_dropout_rate)(x)",
                            "Call"
                        ],
                        [
                            "layers.Dropout(base_dropout_rate)(x)",
                            "Call"
                        ],
                        [
                            "conv_layer(x)",
                            "Call"
                        ],
                        [
                            "bn_layer(x)",
                            "Call"
                        ],
                        [
                            "layers.GlobalMaxPooling3D()(x)",
                            "Call"
                        ],
                        [
                            "self.activations[i](x)",
                            "Call"
                        ],
                        [
                            "layers.GlobalAveragePooling3D()(x)",
                            "Call"
                        ],
                        [
                            "layers.Dropout(fc_dropout_rate)(x)",
                            "Call"
                        ],
                        [
                            "fc_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embedding_layer(x)",
                            "Call"
                        ],
                        [
                            "layers.Flatten()(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size * num_steps, h, w, c])",
                            "Call"
                        ],
                        [
                            "self.dropout(x)",
                            "Call"
                        ],
                        [
                            "conv_layer(x)",
                            "Call"
                        ],
                        [
                            "layers.GlobalMaxPooling2D()(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size, num_steps, c])",
                            "Call"
                        ],
                        [
                            "bn_layer(x)",
                            "Call"
                        ],
                        [
                            "self.activations[i](x)",
                            "Call"
                        ],
                        [
                            "gru_layer(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size * num_steps, c])",
                            "Call"
                        ],
                        [
                            "self.dropout(x)",
                            "Call"
                        ],
                        [
                            "fc_layer(x)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, num_steps, c]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_275": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.Conv2D(channels, kernel_size, padding='same', kernel_initializer='he_normal', kernel_regularizer=regularizers.l2(l2_reg_weight), bias_regularizer=regularizers.l2(l2_reg_weight))(x)",
                            "Call"
                        ],
                        [
                            "layers.BatchNormalization()(x)",
                            "Call"
                        ],
                        [
                            "layers.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "layers.MaxPooling2D(pool_size=max_pool_size, strides=2, padding='same', name=name)(x)",
                            "Call"
                        ],
                        [
                            "layers.MaxPooling2D(pool_size=1, strides=1, padding='same', name=name)(x)",
                            "Call"
                        ],
                        [
                            "layers.Input(shape=(image_size, image_size, 3), dtype='float32')",
                            "Call"
                        ],
                        [
                            "layers.ZeroPadding2D(padding=(3, 3))(x)",
                            "Call"
                        ],
                        [
                            "layers.Conv2D(64, (7, 7), strides=(2, 2), padding='valid', kernel_initializer='he_normal', name='conv1')(x)",
                            "Call"
                        ],
                        [
                            "layers.BatchNormalization()(x)",
                            "Call"
                        ],
                        [
                            "layers.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "layers.ZeroPadding2D(padding=(1, 1))(x)",
                            "Call"
                        ],
                        [
                            "layers.MaxPooling2D(pool_size=(3, 3), strides=(2, 2), padding='valid')(x)",
                            "Call"
                        ],
                        [
                            "get_vggm_conv_block(x, 2 * [(channels, filter_size)], use_bn, max_pool_size, name='conv%s' % (i + 2))",
                            "Call"
                        ],
                        [
                            "self.base_model(images, training=CONFIG.MODEL.TRAIN_BASE != 'frozen')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size, num_steps, h, w, c])",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size * num_frames, num_context, h, w, c])",
                            "Call"
                        ],
                        [
                            "layers.SpatialDropout3D(base_dropout_rate)(x)",
                            "Call"
                        ],
                        [
                            "layers.Dropout(base_dropout_rate)(x)",
                            "Call"
                        ],
                        [
                            "conv_layer(x)",
                            "Call"
                        ],
                        [
                            "bn_layer(x)",
                            "Call"
                        ],
                        [
                            "layers.GlobalMaxPooling3D()(x)",
                            "Call"
                        ],
                        [
                            "self.activations[i](x)",
                            "Call"
                        ],
                        [
                            "layers.GlobalAveragePooling3D()(x)",
                            "Call"
                        ],
                        [
                            "layers.Dropout(fc_dropout_rate)(x)",
                            "Call"
                        ],
                        [
                            "fc_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embedding_layer(x)",
                            "Call"
                        ],
                        [
                            "layers.Flatten()(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size * num_steps, h, w, c])",
                            "Call"
                        ],
                        [
                            "self.dropout(x)",
                            "Call"
                        ],
                        [
                            "conv_layer(x)",
                            "Call"
                        ],
                        [
                            "layers.GlobalMaxPooling2D()(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size, num_steps, c])",
                            "Call"
                        ],
                        [
                            "bn_layer(x)",
                            "Call"
                        ],
                        [
                            "self.activations[i](x)",
                            "Call"
                        ],
                        [
                            "gru_layer(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size * num_steps, c])",
                            "Call"
                        ],
                        [
                            "self.dropout(x)",
                            "Call"
                        ],
                        [
                            "fc_layer(x)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size * num_steps, c]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "l2_normalize_219": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.Conv2D(channels, kernel_size, padding='same', kernel_initializer='he_normal', kernel_regularizer=regularizers.l2(l2_reg_weight), bias_regularizer=regularizers.l2(l2_reg_weight))(x)",
                            "Call"
                        ],
                        [
                            "layers.BatchNormalization()(x)",
                            "Call"
                        ],
                        [
                            "layers.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "layers.MaxPooling2D(pool_size=max_pool_size, strides=2, padding='same', name=name)(x)",
                            "Call"
                        ],
                        [
                            "layers.MaxPooling2D(pool_size=1, strides=1, padding='same', name=name)(x)",
                            "Call"
                        ],
                        [
                            "layers.Input(shape=(image_size, image_size, 3), dtype='float32')",
                            "Call"
                        ],
                        [
                            "layers.ZeroPadding2D(padding=(3, 3))(x)",
                            "Call"
                        ],
                        [
                            "layers.Conv2D(64, (7, 7), strides=(2, 2), padding='valid', kernel_initializer='he_normal', name='conv1')(x)",
                            "Call"
                        ],
                        [
                            "layers.BatchNormalization()(x)",
                            "Call"
                        ],
                        [
                            "layers.Activation('relu')(x)",
                            "Call"
                        ],
                        [
                            "layers.ZeroPadding2D(padding=(1, 1))(x)",
                            "Call"
                        ],
                        [
                            "layers.MaxPooling2D(pool_size=(3, 3), strides=(2, 2), padding='valid')(x)",
                            "Call"
                        ],
                        [
                            "get_vggm_conv_block(x, 2 * [(channels, filter_size)], use_bn, max_pool_size, name='conv%s' % (i + 2))",
                            "Call"
                        ],
                        [
                            "self.base_model(images, training=CONFIG.MODEL.TRAIN_BASE != 'frozen')",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size, num_steps, h, w, c])",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size * num_frames, num_context, h, w, c])",
                            "Call"
                        ],
                        [
                            "layers.SpatialDropout3D(base_dropout_rate)(x)",
                            "Call"
                        ],
                        [
                            "layers.Dropout(base_dropout_rate)(x)",
                            "Call"
                        ],
                        [
                            "conv_layer(x)",
                            "Call"
                        ],
                        [
                            "bn_layer(x)",
                            "Call"
                        ],
                        [
                            "layers.GlobalMaxPooling3D()(x)",
                            "Call"
                        ],
                        [
                            "self.activations[i](x)",
                            "Call"
                        ],
                        [
                            "layers.GlobalAveragePooling3D()(x)",
                            "Call"
                        ],
                        [
                            "layers.Dropout(fc_dropout_rate)(x)",
                            "Call"
                        ],
                        [
                            "fc_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embedding_layer(x)",
                            "Call"
                        ],
                        [
                            "layers.Flatten()(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size * num_steps, h, w, c])",
                            "Call"
                        ],
                        [
                            "self.dropout(x)",
                            "Call"
                        ],
                        [
                            "conv_layer(x)",
                            "Call"
                        ],
                        [
                            "layers.GlobalMaxPooling2D()(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size, num_steps, c])",
                            "Call"
                        ],
                        [
                            "bn_layer(x)",
                            "Call"
                        ],
                        [
                            "self.activations[i](x)",
                            "Call"
                        ],
                        [
                            "gru_layer(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size * num_steps, c])",
                            "Call"
                        ],
                        [
                            "self.dropout(x)",
                            "Call"
                        ],
                        [
                            "fc_layer(x)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "preprocessors/preprocess_sequence.py": {
        "tensorflow": {
            "uniform_139": {
                "variable": {
                    "value": "delta",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "-max_delta",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "max_delta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "preprocess_ranges[BRIGHTNESS]['max_delta']",
                            "Subscript"
                        ],
                        [
                            "preprocess_ranges[HUE]['max_delta']",
                            "Subscript"
                        ]
                    ]
                },
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "uniform_144": {
                "variable": {
                    "value": "factor",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "lower",
                    "type": "variable",
                    "possible_values": [
                        [
                            "preprocess_ranges[CONTRAST]['lower']",
                            "Subscript"
                        ],
                        [
                            "preprocess_ranges[SATURATION]['lower']",
                            "Subscript"
                        ]
                    ]
                },
                "maxval": {
                    "value": "upper",
                    "type": "variable",
                    "possible_values": [
                        [
                            "preprocess_ranges[CONTRAST]['upper']",
                            "Subscript"
                        ],
                        [
                            "preprocess_ranges[SATURATION]['upper']",
                            "Subscript"
                        ]
                    ]
                },
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "uniform_148": {
                "variable": {
                    "value": "delta",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "max_stddev",
                    "type": "variable",
                    "possible_values": [
                        [
                            "preprocess_ranges[GAUSSIAN_NOISE]['max_stddev']",
                            "Subscript"
                        ]
                    ]
                },
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "uniform_152": {
                "variable": {
                    "value": "delta",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "-max_delta",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "max_delta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "preprocess_ranges[BRIGHTNESS]['max_delta']",
                            "Subscript"
                        ],
                        [
                            "preprocess_ranges[HUE]['max_delta']",
                            "Subscript"
                        ]
                    ]
                },
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "uniform_157": {
                "variable": {
                    "value": "factor",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "lower",
                    "type": "variable",
                    "possible_values": [
                        [
                            "preprocess_ranges[CONTRAST]['lower']",
                            "Subscript"
                        ],
                        [
                            "preprocess_ranges[SATURATION]['lower']",
                            "Subscript"
                        ]
                    ]
                },
                "maxval": {
                    "value": "upper",
                    "type": "variable",
                    "possible_values": [
                        [
                            "preprocess_ranges[CONTRAST]['upper']",
                            "Subscript"
                        ],
                        [
                            "preprocess_ranges[SATURATION]['upper']",
                            "Subscript"
                        ]
                    ]
                },
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "less_172": {
                "variable": {
                    "value": "do_flip",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.random.uniform([], seed=seed)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "probability",
                    "type": "variable",
                    "possible_values": [
                        [
                            "preprocess_ranges[FLIP]['probability']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "uniform_172": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "preprocessors/sequence_preprocessor.py": {
        "tensorflow": {
            "reduce_min_76": {
                "variable": {
                    "value": "min_dim",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "image_size[0:2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "stack_77": {
                "variable": {
                    "value": "output_size",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[min_dim, min_dim, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_int32_78": {
                "variable": {
                    "value": "height_offset",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "(image_size[0] - min_dim) / 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_int32_79": {
                "variable": {
                    "value": "width_offset",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "(image_size[1] - min_dim) / 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "stack_80": {
                "variable": {
                    "value": "output_begin",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[height_offset, width_offset, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_min_99": {
                "variable": {
                    "value": "min_dim",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "image_size[0:2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_int32_100": {
                "variable": {
                    "value": "sampled_size",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.to_float(min_dim) * tf.random_uniform([], min_scale, 1.0)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "stack_102": {
                "variable": {
                    "value": "output_size",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[sampled_size, sampled_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_111": {
                "variable": {
                    "value": "output_begin",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[height_offset, width_offset, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_133": {
                "variable": {
                    "value": "sequence_begin",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.constant([0]), single_slice_begin]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_134": {
                "variable": {
                    "value": "sequence_size",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.constant([-1]), single_slice_size]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cond_173": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "do_flip",
                    "type": "variable",
                    "possible_values": [
                        [
                            "do_flip",
                            "Method Argument"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "flip",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flip",
                            "Call"
                        ]
                    ]
                },
                "false_fn": {
                    "value": "lambda : tensor",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "adjust_brightness_16": {
                "image": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "delta": {
                    "value": "brightness_change",
                    "type": "variable",
                    "possible_values": [
                        [
                            "brightness_change",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "adjust_contrast_21": {
                "images": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "contrast_factor": {
                    "value": "contrast_change",
                    "type": "variable",
                    "possible_values": [
                        [
                            "contrast_change",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "clip_by_value_26": {
                "t": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "lower_limit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lower_limit",
                            "Method Argument"
                        ]
                    ]
                },
                "clip_value_max": {
                    "value": "upper_limit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "upper_limit",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "map_structure_36": {
                "func": {
                    "value": "tf.stop_gradient",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*structure": {
                    "value": "tf.map_fn(lambda x: tf.image.convert_image_dtype(x, dtype), tensor, dtype=dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "map_fn_45": {
                "fn": {
                    "value": "lambda x: tf.image.adjust_hue(*x)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "[tensor, tf.tile([hue_change], tf.reshape(tf.shape(tensor)[0], [1]))]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "back_prop": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "map_fn_55": {
                "fn": {
                    "value": "lambda x: tf.image.adjust_saturation(*x)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "[tensor, tf.tile([saturation_change], tf.reshape(tf.shape(tensor)[0], [1]))]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "back_prop": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "slice_135": {
                "input_": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "sequence_begin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.constant([0]), single_slice_begin], 0)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "sequence_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.constant([-1]), single_slice_size], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "resize_152": {
                "images": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "size": {
                    "value": "new_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "new_size",
                            "Method Argument"
                        ]
                    ]
                },
                "method": {
                    "value": "method",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.ResizeMethod.BILINEAR",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "map_fn_37": {
                "fn": {
                    "value": "lambda x: tf.image.convert_image_dtype(x, dtype)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reverse_171": {
                "tensor": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "[dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "adjust_hue_46": {
                "image": {
                    "value": "*x",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "tile_48": {
                "input": {
                    "value": "[hue_change]",
                    "type": "List",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tf.reshape(tf.shape(tensor)[0], [1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "adjust_saturation_56": {
                "image": {
                    "value": "*x",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "tile_58": {
                "input": {
                    "value": "[saturation_change]",
                    "type": "List",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tf.reshape(tf.shape(tensor)[0], [1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_101": {
                "x": {
                    "value": "min_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_min(image_size[0:2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(image_size[0:2])",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_133": {
                "value": {
                    "value": "[0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_134": {
                "value": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_32": {
                "input": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "convert_image_dtype_38": {
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_48": {
                "tensor": {
                    "value": "tf.shape(tensor)[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_58": {
                "tensor": {
                    "value": "tf.shape(tensor)[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_48": {
                "input": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_58": {
                "input": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "tcc/alignment.py": {
        "tensorflow": {
            "tile_157": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.range(num_steps), axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_163": {
                "variable": {
                    "value": "seq_lens",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(num_steps, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "l2_normalize_186": {
                "variable": {
                    "value": "embs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "embs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(embs)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(embs, axis=-1)",
                            "Call"
                        ],
                        [
                            "embs",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_153": {
                "input": {
                    "value": "embs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(embs)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(embs, axis=-1)",
                            "Call"
                        ],
                        [
                            "embs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "executing_eagerly_165": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "identity_169": {
                "variable": {
                    "value": "embs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "embs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(embs)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(embs, axis=-1)",
                            "Call"
                        ],
                        [
                            "embs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "identity_175": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.range(num_steps), axis=0), [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "tf.identity(steps)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "assert_equal_177": {
                "x": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch_size",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.shape(steps)[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "assert_equal_178": {
                "x": {
                    "value": "num_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(embs)[1]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.shape(steps)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "assert_equal_179": {
                "x": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch_size",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.shape(embs)[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "expand_dims_157": {
                "input": {
                    "value": "tf.range(num_steps)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_163": {
                "input": {
                    "value": "num_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(embs)[1]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "control_dependencies_167": {
                "control_inputs": {
                    "value": "[tf.assert_equal(batch_size, tf.shape(embs)[0])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "control_dependencies_171": {
                "control_inputs": {
                    "value": "[tf.assert_equal(num_steps, tf.shape(steps)[1]), tf.assert_equal(batch_size, tf.shape(steps)[0])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_177": {
                "input": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.range(num_steps), axis=0), [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "tf.identity(steps)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_178": {
                "input": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.range(num_steps), axis=0), [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "tf.identity(steps)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_179": {
                "input": {
                    "value": "embs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(embs)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(embs, axis=-1)",
                            "Call"
                        ],
                        [
                            "embs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "assert_equal_167": {
                "x": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch_size",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.shape(embs)[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "assert_equal_171": {
                "x": {
                    "value": "num_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(embs)[1]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.shape(steps)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "assert_equal_173": {
                "x": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch_size",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.shape(steps)[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_168": {
                "input": {
                    "value": "embs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(embs)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(embs, axis=-1)",
                            "Call"
                        ],
                        [
                            "embs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_172": {
                "input": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.range(num_steps), axis=0), [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "tf.identity(steps)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_174": {
                "input": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.range(num_steps), axis=0), [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "tf.identity(steps)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "tcc/deterministic_alignment.py": {
        "tensorflow": {
            "reduce_sum_30": {
                "variable": {
                    "value": "norm1",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(embs1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_31": {
                "variable": {
                    "value": "norm1",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "norm1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.square(embs1), 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(norm1, [-1, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_32": {
                "variable": {
                    "value": "norm2",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(embs2)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_33": {
                "variable": {
                    "value": "norm2",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "norm2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.square(embs2), 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(norm2, [1, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "maximum_37": {
                "variable": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "norm1 + norm2 - 2.0 * tf.matmul(embs1, embs2, False, True)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "cast_61": {
                "variable": {
                    "value": "channels",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.shape(embs1)[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_104": {
                "variable": {
                    "value": "softmaxed_sim_12",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "sim_12",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_scaled_similarity(embs1, embs2, similarity_type, temperature)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_107": {
                "variable": {
                    "value": "nn_embs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "softmaxed_sim_12",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(sim_12, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "embs2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embs2",
                            "Method Argument"
                        ],
                        [
                            "embs2",
                            "Method Argument"
                        ],
                        [
                            "embs2",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "one_hot_113": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.range(max_num_steps)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "max_num_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(embs1)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "concat_189": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "logits_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_190": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "labels_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_191": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "steps_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_192": {
                "variable": {
                    "value": "seq_lens",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "seq_lens_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_64": {
                "variable": {
                    "value": "similarity",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "embs1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embs1",
                            "Method Argument"
                        ],
                        [
                            "embs1",
                            "Method Argument"
                        ],
                        [
                            "embs1",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "embs2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embs2",
                            "Method Argument"
                        ],
                        [
                            "embs2",
                            "Method Argument"
                        ],
                        [
                            "embs2",
                            "Method Argument"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "square_30": {
                "x": {
                    "value": "embs1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embs1",
                            "Method Argument"
                        ],
                        [
                            "embs1",
                            "Method Argument"
                        ],
                        [
                            "embs1",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "square_32": {
                "x": {
                    "value": "embs2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embs2",
                            "Method Argument"
                        ],
                        [
                            "embs2",
                            "Method Argument"
                        ],
                        [
                            "embs2",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_99": {
                "input": {
                    "value": "embs1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embs1",
                            "Method Argument"
                        ],
                        [
                            "embs1",
                            "Method Argument"
                        ],
                        [
                            "embs1",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_61": {
                "input": {
                    "value": "embs1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embs1",
                            "Method Argument"
                        ],
                        [
                            "embs1",
                            "Method Argument"
                        ],
                        [
                            "embs1",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_38": {
                "a": {
                    "value": "embs1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embs1",
                            "Method Argument"
                        ],
                        [
                            "embs1",
                            "Method Argument"
                        ],
                        [
                            "embs1",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "embs2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embs2",
                            "Method Argument"
                        ],
                        [
                            "embs2",
                            "Method Argument"
                        ],
                        [
                            "embs2",
                            "Method Argument"
                        ]
                    ]
                },
                "transpose_a": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "tile_186": {
                "input": {
                    "value": "steps[i:i + 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[num_steps, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_187": {
                "input": {
                    "value": "seq_lens[i:i + 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[num_steps]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "tcc/losses.py": {
        "tensorflow": {
            "stop_gradient_42": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stop_gradient_89": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stop_gradient_90": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(steps)",
                            "Call"
                        ],
                        [
                            "tf.cast(steps, tf.float32) / tile_seq_lens",
                            "BinOp"
                        ],
                        [
                            "tf.cast(steps, tf.float32)",
                            "Call"
                        ],
                        [
                            "steps",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_100": {
                "variable": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_101": {
                "variable": {
                    "value": "true_time",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "steps * labels",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_102": {
                "variable": {
                    "value": "pred_time",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "steps * beta",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_43": {
                "input_tensor": {
                    "value": "tf.keras.losses.categorical_crossentropy(y_true=labels, y_pred=logits, from_logits=True, label_smoothing=label_smoothing)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_93": {
                "variable": {
                    "value": "float_seq_lens",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "seq_lens",
                    "type": "variable",
                    "possible_values": [
                        [
                            "seq_lens",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_94": {
                "variable": {
                    "value": "tile_seq_lens",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(float_seq_lens, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, num_steps]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_98": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(steps)",
                            "Call"
                        ],
                        [
                            "tf.cast(steps, tf.float32) / tile_seq_lens",
                            "BinOp"
                        ],
                        [
                            "tf.cast(steps, tf.float32)",
                            "Call"
                        ],
                        [
                            "steps",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "categorical_crossentropy_43": {
                "y_true": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "from_logits": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "label_smoothing": {
                    "value": "label_smoothing",
                    "type": "variable",
                    "possible_values": [
                        [
                            "label_smoothing",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "tile_107": {
                "variable": {
                    "value": "pred_time_tiled",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(pred_time, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, num_steps]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_110": {
                "variable": {
                    "value": "pred_time_variance",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(steps - pred_time_tiled) * beta",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_114": {
                "variable": {
                    "value": "pred_time_log_var",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pred_time_variance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.square(steps - pred_time_tiled) * beta, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "square_115": {
                "variable": {
                    "value": "squared_error",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "true_time - pred_time",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_95": {
                "input": {
                    "value": "float_seq_lens",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(seq_lens, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_96": {
                "x": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(steps)",
                            "Call"
                        ],
                        [
                            "tf.cast(steps, tf.float32) / tile_seq_lens",
                            "BinOp"
                        ],
                        [
                            "tf.cast(steps, tf.float32)",
                            "Call"
                        ],
                        [
                            "steps",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_116": {
                "input_tensor": {
                    "value": "tf.math.exp(-pred_time_log_var) * squared_error + variance_lambda * pred_time_log_var",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_120": {
                "input_tensor": {
                    "value": "tf.keras.losses.mean_squared_error(y_true=true_time, y_pred=pred_time)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_124": {
                "input_tensor": {
                    "value": "tf.keras.losses.huber_loss(y_true=true_time, y_pred=pred_time, delta=huber_delta)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_107": {
                "input": {
                    "value": "pred_time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(steps * beta, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "mean_squared_error_121": {
                "y_true": {
                    "value": "true_time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(steps * labels, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "pred_time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(steps * beta, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "huber_loss_124": {
                "y_true": {
                    "value": "true_time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(steps * labels, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "pred_time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(steps * beta, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "delta": {
                    "value": "huber_delta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "huber_delta",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "square_111": {
                "x": {
                    "value": "steps - pred_time_tiled",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_116": {
                "x": {
                    "value": "-pred_time_log_var",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "tcc/stochastic_alignment.py": {
        "tensorflow": {
            "one_hot_34": {
                "variable": {
                    "value": "onehot_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "n_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform((), minval=0, maxval=num_steps, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_steps",
                            "Method Argument"
                        ],
                        [
                            "num_steps",
                            "Method Argument"
                        ],
                        [
                            "num_steps",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_91": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "logits_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "stack_92": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "labels_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "tile_120": {
                "variable": {
                    "value": "sorted_idxes",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.range(batch_size), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[num_cycles, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_122": {
                "variable": {
                    "value": "sorted_idxes",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "sorted_idxes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.range(batch_size), 0), [num_cycles, 1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(sorted_idxes, [batch_size, num_cycles])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, num_cycles]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_123": {
                "variable": {
                    "value": "cycles",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.random.shuffle(sorted_idxes)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_cycles, batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_127": {
                "variable": {
                    "value": "cycles",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[cycles, cycles[:, 0:1]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_65": {
                "variable": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "similarity",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-mean_squared_distance",
                            "UnaryOp"
                        ],
                        [
                            "similarity / temperature",
                            "BinOp"
                        ],
                        [
                            "tf.squeeze(tf.matmul(candidate_feats, query_feats, transpose_b=True))",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_66": {
                "variable": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(similarity)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(beta, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.tile(beta, [1, num_channels])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_67": {
                "variable": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(similarity)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(beta, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.tile(beta, [1, num_channels])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, num_channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_70": {
                "variable": {
                    "value": "query_feats",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "beta * candidate_feats",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_39": {
                "input": {
                    "value": "query_feats",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embs[cycle[0], n_idx:n_idx + 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_sum(beta * candidate_feats, axis=0, keepdims=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_45": {
                "variable": {
                    "value": "mean_squared_distance",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.squared_difference(tf.tile(query_feats, [num_steps, 1]), candidate_feats)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_60": {
                "x": {
                    "value": "num_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(query_feats)[-1]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_120": {
                "input": {
                    "value": "tf.range(batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shuffle_123": {
                "value": {
                    "value": "sorted_idxes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.range(batch_size), 0), [num_cycles, 1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(sorted_idxes, [batch_size, num_cycles])",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_193": {
                "variable": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(steps, cycles[:, 0])",
                            "Call"
                        ],
                        [
                            "steps",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "cycles[:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "gather_194": {
                "variable": {
                    "value": "seq_lens",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "seq_lens",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(seq_lens, cycles[:, 0])",
                            "Call"
                        ],
                        [
                            "seq_lens",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "cycles[:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "squeeze_53": {
                "variable": {
                    "value": "similarity",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.matmul(candidate_feats, query_feats, transpose_b=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "squared_difference_46": {
                "x": {
                    "value": "tf.tile(query_feats, [num_steps, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "candidate_feats",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embs[cycle[c]]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "tile_46": {
                "input": {
                    "value": "query_feats",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embs[cycle[0], n_idx:n_idx + 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_sum(beta * candidate_feats, axis=0, keepdims=True)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[num_steps, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_53": {
                "a": {
                    "value": "candidate_feats",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embs[cycle[c]]",
                            "Subscript"
                        ]
                    ]
                },
                "b": {
                    "value": "query_feats",
                    "type": "variable",
                    "possible_values": [
                        [
                            "embs[cycle[0], n_idx:n_idx + 1]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_sum(beta * candidate_feats, axis=0, keepdims=True)",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "utils.py": {
        "tensorflow": {
            "unstack_31": {
                "variable": {
                    "value": "frames_list",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "frames",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data['frames']",
                            "Subscript"
                        ],
                        [
                            "data['video_frames']",
                            "Subscript"
                        ],
                        [
                            "data['frames']",
                            "Subscript"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.concatenate(frames, axis=0)",
                            "Call"
                        ],
                        [
                            "frames[~np.isnan(embs).any(axis=1)]",
                            "Subscript"
                        ]
                    ]
                },
                "num": {
                    "value": "num_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "CONFIG.TRAIN.NUM_FRAMES * CONFIG.DATA.NUM_STEPS",
                            "BinOp"
                        ],
                        [
                            "CONFIG.EVAL.NUM_FRAMES * CONFIG.DATA.NUM_STEPS",
                            "BinOp"
                        ],
                        [
                            "CONFIG.DATA.NUM_STEPS",
                            "Attribute"
                        ],
                        [
                            "seq_len - i * frames_per_batch",
                            "BinOp"
                        ],
                        [
                            "frames_per_batch",
                            "variable"
                        ],
                        [
                            "num_steps",
                            "Method Argument"
                        ],
                        [
                            "num_steps",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_steps",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_32": {
                "variable": {
                    "value": "frames_summaries",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "frames_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unstack(frames, num=num_steps, axis=1)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_33": {
                "variable": {
                    "value": "batch_list",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "frames_summaries",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(frames_list, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch_size",
                            "Method Argument"
                        ],
                        [
                            "batch_size",
                            "Method Argument"
                        ],
                        [
                            "batch_size",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_34": {
                "variable": {
                    "value": "batch_summaries",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "batch_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.split(frames_summaries, batch_size, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unstack_64": {
                "variable": {
                    "value": "image_list",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "frames",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data['frames']",
                            "Subscript"
                        ],
                        [
                            "data['video_frames']",
                            "Subscript"
                        ],
                        [
                            "data['frames']",
                            "Subscript"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.concatenate(frames, axis=0)",
                            "Call"
                        ],
                        [
                            "frames[~np.isnan(embs).any(axis=1)]",
                            "Subscript"
                        ]
                    ]
                },
                "num": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch_size",
                            "Method Argument"
                        ],
                        [
                            "batch_size",
                            "Method Argument"
                        ],
                        [
                            "batch_size",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_100": {
                "variable": {
                    "value": "summary_im",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.concat([vstack(im) for im in im_list], axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_150": {
                "variable": {
                    "value": "rate_index",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.where(tf.greater_equal(global_step, boundaries), list(range(num_boundaries)), [0] * num_boundaries)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Checkpoint_232": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "CheckpointManager_233": {
                "variable": {
                    "value": "ckpt_manager",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.Checkpoint(**ckpt_objects)",
                            "Call"
                        ],
                        [
                            "tf.train.Checkpoint(**ckpt_objects)",
                            "Call"
                        ]
                    ]
                },
                "directory": {
                    "value": "logdir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logdir",
                            "Method Argument"
                        ],
                        [
                            "logdir",
                            "Method Argument"
                        ],
                        [
                            "logdir",
                            "Method Argument"
                        ],
                        [
                            "logdir",
                            "Method Argument"
                        ]
                    ]
                },
                "max_to_keep": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "keep_checkpoint_every_n_hours": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Checkpoint_247": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "CheckpointManager_248": {
                "variable": {
                    "value": "ckpt_manager",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.Checkpoint(**ckpt_objects)",
                            "Call"
                        ],
                        [
                            "tf.train.Checkpoint(**ckpt_objects)",
                            "Call"
                        ]
                    ]
                },
                "directory": {
                    "value": "logdir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logdir",
                            "Method Argument"
                        ],
                        [
                            "logdir",
                            "Method Argument"
                        ],
                        [
                            "logdir",
                            "Method Argument"
                        ],
                        [
                            "logdir",
                            "Method Argument"
                        ]
                    ]
                },
                "max_to_keep": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "keep_checkpoint_every_n_hours": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "decode_png_535": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "buf.getvalue()",
                    "type": "Call",
                    "possible_values": []
                },
                "channels": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_537": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_png(buf.getvalue(), channels=4)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "list_physical_devices_589": {
                "variable": {
                    "value": "GPUS",
                    "type": "variable",
                    "possible_values": []
                },
                "device_type": {
                    "value": "GPU",
                    "type": "str",
                    "possible_values": []
                }
            },
            "image_35": {
                "name": {
                    "value": "train_batch",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "batch_summaries",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(batch_list, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "step": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "optimizer.iterations",
                            "Attribute"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_51": {
                "variable": {
                    "value": "emb_feats",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "tf.split(emb_feats, 2 * num_steps, axis=0)[::2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_56": {
                "variable": {
                    "value": "emb_feats",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "tf.split(emb_feats, num_steps, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_94": {
                "variable": {
                    "value": "nn_img",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "nn_img_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_102": {
                "name": {
                    "value": "'%s/nn' % split",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "summary_im",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.concat([vstack(im) for im in im_list], axis=0), axis=0)",
                            "Call"
                        ]
                    ]
                },
                "step": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "optimizer.iterations",
                            "Attribute"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "image_105": {
                "name": {
                    "value": "'%s/similarity_matrix' % split",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "np.expand_dims(sim_matrix, axis=3)",
                    "type": "Call",
                    "possible_values": []
                },
                "step": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "optimizer.iterations",
                            "Attribute"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_118": {
                "x": {
                    "value": "tf.argsort(tf.random.uniform((m, n)), axis=axis)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_131": {
                "variable": {
                    "value": "global_steps_int",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "optimizer.iterations",
                            "Attribute"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_132": {
                "variable": {
                    "value": "warmup_steps_int",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "lr_params.NUM_WARMUP_STEPS",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_135": {
                "variable": {
                    "value": "global_steps_float",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "global_steps_int",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(global_step, tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_136": {
                "variable": {
                    "value": "warmup_steps_float",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "warmup_steps_int",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(lr_params.NUM_WARMUP_STEPS, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_141": {
                "variable": {
                    "value": "is_warmup",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "global_steps_int < warmup_steps_int",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_154": {
                "input_tensor": {
                    "value": "rates * tf.one_hot(rate_index, depth=num_boundaries)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Adam_212": {
                "variable": {
                    "value": "opt",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "optimizer.learning_rate",
                            "Attribute"
                        ],
                        [
                            "learning_rate",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "makedirs_268": {
                "path": {
                    "value": "logdir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logdir",
                            "Method Argument"
                        ],
                        [
                            "logdir",
                            "Method Argument"
                        ],
                        [
                            "logdir",
                            "Method Argument"
                        ],
                        [
                            "logdir",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "makedirs_289": {
                "path": {
                    "value": "train_logs_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(logdir, 'train.logs')",
                            "Call"
                        ]
                    ]
                }
            },
            "makedirs_294": {
                "path": {
                    "value": "logdir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logdir",
                            "Method Argument"
                        ],
                        [
                            "logdir",
                            "Method Argument"
                        ],
                        [
                            "logdir",
                            "Method Argument"
                        ],
                        [
                            "logdir",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "makedirs_295": {
                "path": {
                    "value": "os.path.join(logdir, 'eval_logs')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tile_88": {
                "variable": {
                    "value": "curr_query_feats",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "query_feats[j:j + 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[num_steps, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_89": {
                "variable": {
                    "value": "mean_squared_distance",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.math.squared_difference(curr_query_feats, candidate_feats)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_98": {
                "values": {
                    "value": "tf.unstack(im, num=num_steps)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_100": {
                "values": {
                    "value": "[vstack(im) for im in im_list]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argsort_118": {
                "values": {
                    "value": "tf.random.uniform((m, n))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-1",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "where_151": {
                "condition": {
                    "value": "tf.greater_equal(global_step, boundaries)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "list(range(num_boundaries))",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "[0] * num_boundaries",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "SGD_214": {
                "variable": {
                    "value": "opt",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "optimizer.learning_rate",
                            "Attribute"
                        ],
                        [
                            "learning_rate",
                            "Method Argument"
                        ]
                    ]
                },
                "momentum": {
                    "value": "0.9",
                    "type": "float",
                    "possible_values": []
                }
            },
            "exists_297": {
                "path": {
                    "value": "config_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(logdir, 'config.json')",
                            "Call"
                        ],
                        [
                            "os.path.join(logdir, 'config.json')",
                            "Call"
                        ],
                        [
                            "config_path",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "list_logical_devices_597": {
                "variable": {
                    "value": "logical_gpus",
                    "type": "variable",
                    "possible_values": []
                },
                "device_type": {
                    "value": "GPU",
                    "type": "str",
                    "possible_values": []
                }
            },
            "split_56": {
                "value": {
                    "value": "emb_feats",
                    "type": "variable",
                    "possible_values": [
                        [
                            "emb(cnn_feats, 2 * num_steps)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(emb_feats, 2 * num_steps, axis=0)[::2], axis=1)",
                            "Call"
                        ],
                        [
                            "emb(cnn_feats, num_steps)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(emb_feats, num_steps, axis=0), axis=1)",
                            "Call"
                        ],
                        [
                            "emb(cnn_feats, num_steps)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "num_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "CONFIG.TRAIN.NUM_FRAMES * CONFIG.DATA.NUM_STEPS",
                            "BinOp"
                        ],
                        [
                            "CONFIG.EVAL.NUM_FRAMES * CONFIG.DATA.NUM_STEPS",
                            "BinOp"
                        ],
                        [
                            "CONFIG.DATA.NUM_STEPS",
                            "Attribute"
                        ],
                        [
                            "seq_len - i * frames_per_batch",
                            "BinOp"
                        ],
                        [
                            "frames_per_batch",
                            "variable"
                        ],
                        [
                            "num_steps",
                            "Method Argument"
                        ],
                        [
                            "num_steps",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_steps",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unstack_98": {
                "value": {
                    "value": "im",
                    "type": "variable",
                    "possible_values": [
                        [
                            "im",
                            "Method Argument"
                        ]
                    ]
                },
                "num": {
                    "value": "num_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "CONFIG.TRAIN.NUM_FRAMES * CONFIG.DATA.NUM_STEPS",
                            "BinOp"
                        ],
                        [
                            "CONFIG.EVAL.NUM_FRAMES * CONFIG.DATA.NUM_STEPS",
                            "BinOp"
                        ],
                        [
                            "CONFIG.DATA.NUM_STEPS",
                            "Attribute"
                        ],
                        [
                            "seq_len - i * frames_per_batch",
                            "BinOp"
                        ],
                        [
                            "frames_per_batch",
                            "variable"
                        ],
                        [
                            "num_steps",
                            "Method Argument"
                        ],
                        [
                            "num_steps",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_steps",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "uniform_118": {
                "shape": {
                    "value": "(m, n)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "greater_equal_152": {
                "x": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "optimizer.iterations",
                            "Attribute"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "boundaries",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[0] + boundaries",
                            "BinOp"
                        ],
                        [
                            "boundaries",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "one_hot_154": {
                "indices": {
                    "value": "rate_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(tf.where(tf.greater_equal(global_step, boundaries), list(range(num_boundaries)), [0] * num_boundaries))",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_boundaries",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(boundaries)",
                            "Call"
                        ]
                    ]
                }
            },
            "GFile_274": {
                "name": {
                    "value": "config_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(logdir, 'config.json')",
                            "Call"
                        ],
                        [
                            "os.path.join(logdir, 'config.json')",
                            "Call"
                        ],
                        [
                            "config_path",
                            "Method Argument"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_280": {
                "name": {
                    "value": "config_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(logdir, 'config.json')",
                            "Call"
                        ],
                        [
                            "os.path.join(logdir, 'config.json')",
                            "Call"
                        ],
                        [
                            "config_path",
                            "Method Argument"
                        ]
                    ]
                },
                "mode": {
                    "value": "r",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_303": {
                "name": {
                    "value": "config_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(logdir, 'config.json')",
                            "Call"
                        ],
                        [
                            "os.path.join(logdir, 'config.json')",
                            "Call"
                        ],
                        [
                            "config_path",
                            "Method Argument"
                        ]
                    ]
                },
                "mode": {
                    "value": "r",
                    "type": "str",
                    "possible_values": []
                }
            },
            "set_visible_devices_592": {
                "devices": {
                    "value": "GPUS[ind]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "device_type": {
                    "value": "GPU",
                    "type": "str",
                    "possible_values": []
                }
            },
            "split_52": {
                "value": {
                    "value": "emb_feats",
                    "type": "variable",
                    "possible_values": [
                        [
                            "emb(cnn_feats, 2 * num_steps)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(emb_feats, 2 * num_steps, axis=0)[::2], axis=1)",
                            "Call"
                        ],
                        [
                            "emb(cnn_feats, num_steps)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(emb_feats, num_steps, axis=0), axis=1)",
                            "Call"
                        ],
                        [
                            "emb(cnn_feats, num_steps)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2 * num_steps",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unstack_82": {
                "value": {
                    "value": "image_list[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "num": {
                    "value": "num_steps * num_frames_per_step",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squared_difference_90": {
                "x": {
                    "value": "curr_query_feats",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(query_feats[j:j + 1], [num_steps, 1])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "candidate_feats",
                    "type": "variable",
                    "possible_values": [
                        [
                            "emb_feats[i]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "exponential_decay_175": {
                "learning_rate": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(1.0 - is_warmup) * lr + is_warmup * warmup_lr",
                            "BinOp"
                        ],
                        [
                            "lr",
                            "Method Argument"
                        ],
                        [
                            "lr",
                            "Method Argument"
                        ],
                        [
                            "lr",
                            "Method Argument"
                        ],
                        [
                            "lr",
                            "Method Argument"
                        ],
                        [
                            "lr",
                            "Method Argument"
                        ]
                    ]
                },
                "global_step": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "optimizer.iterations",
                            "Attribute"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ]
                    ]
                },
                "decay_steps": {
                    "value": "lr_params.EXP_DECAY_STEPS",
                    "type": "Attribute",
                    "possible_values": []
                },
                "decay_rate": {
                    "value": "lr_params.EXP_DECAY_RATE",
                    "type": "Attribute",
                    "possible_values": []
                },
                "staircase": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "set_memory_growth_596": {
                "device": {
                    "value": "gpu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "GPUS",
                            "variable"
                        ]
                    ]
                },
                "enable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "unstack_79": {
                "value": {
                    "value": "image_list[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "num": {
                    "value": "2 * num_steps * num_frames_per_step",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmin_92": {
                "input": {
                    "value": "mean_squared_distance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.math.squared_difference(curr_query_feats, candidate_feats), axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_423": {
                "variable": {
                    "value": "curr_data[k]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "params": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data.items()",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "idxes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_indices(curr_idx, num_steps, seq_len)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "polynomial_decay_193": {
                "learning_rate": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(1.0 - is_warmup) * lr + is_warmup * warmup_lr",
                            "BinOp"
                        ],
                        [
                            "lr",
                            "Method Argument"
                        ],
                        [
                            "lr",
                            "Method Argument"
                        ],
                        [
                            "lr",
                            "Method Argument"
                        ],
                        [
                            "lr",
                            "Method Argument"
                        ],
                        [
                            "lr",
                            "Method Argument"
                        ]
                    ]
                },
                "global_step": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "optimizer.iterations",
                            "Attribute"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ],
                        [
                            "global_step",
                            "Method Argument"
                        ]
                    ]
                },
                "decay_steps": {
                    "value": "CONFIG.TRAIN.MAX_ITERS",
                    "type": "Attribute",
                    "possible_values": []
                },
                "end_learning_rate": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "power": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "cycle": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    }
}