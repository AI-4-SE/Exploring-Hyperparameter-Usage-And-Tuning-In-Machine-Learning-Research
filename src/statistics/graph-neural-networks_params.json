{
    "mlp.py": {
        "tensorflow": {
            "zeros_initializer_12": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "Dense_39": {
                "variable": {
                    "value": "new_layer",
                    "possible_values": []
                },
                "units": {
                    "value": "size",
                    "possible_values": []
                },
                "activation": {
                    "value": "activation",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "use_bias",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                },
                "kernel_initializer": {
                    "value": "kernel_initializer",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "bias_initializer": {
                    "value": "bias_initializer",
                    "possible_values": [
                        [
                            "tf.zeros_initializer()",
                            "MethodArgument"
                        ]
                    ]
                },
                "kernel_regularizer": {
                    "value": "kernel_regularizer",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "bias_regularizer": {
                    "value": "bias_regularizer",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "activity_regularizer": {
                    "value": "activity_regularizer",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "kernel_constraint": {
                    "value": "kernel_constraint",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "bias_constraint": {
                    "value": "bias_constraint",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "trainable": {
                    "value": "trainable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                },
                "name": {
                    "value": "internal_name",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "name + '_MLP_layer_{}'.format(i + 1)",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "neurosat/model.py": {
        "tensorflow": {
            "placeholder_16": {
                "variable": {
                    "value": "instance_SAT",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "possible_values": []
                },
                "name": {
                    "value": "instance_SAT",
                    "possible_values": []
                }
            },
            "placeholder_17": {
                "variable": {
                    "value": "time_steps",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "possible_values": []
                },
                "name": {
                    "value": "time_steps",
                    "possible_values": []
                }
            },
            "placeholder_18": {
                "variable": {
                    "value": "matrix_placeholder",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None]",
                    "possible_values": []
                },
                "name": {
                    "value": "M",
                    "possible_values": []
                }
            },
            "placeholder_19": {
                "variable": {
                    "value": "num_vars_on_instance",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "possible_values": []
                },
                "name": {
                    "value": "instance_n",
                    "possible_values": []
                }
            },
            "shape_22": {
                "variable": {
                    "value": "s",
                    "possible_values": []
                },
                "input": {
                    "value": "matrix_placeholder",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [None, None], name='M')",
                            "Call"
                        ]
                    ]
                }
            },
            "floordiv_25": {
                "variable": {
                    "value": "n",
                    "possible_values": []
                },
                "x": {
                    "value": "l",
                    "possible_values": [
                        [
                            "s[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(Lh)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.constant(2)",
                    "possible_values": []
                }
            },
            "shape_41": {
                "variable": {
                    "value": "s",
                    "possible_values": []
                },
                "input": {
                    "value": "matrix_placeholder",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [None, None], name='M')",
                            "Call"
                        ]
                    ]
                }
            },
            "TensorArray_125": {
                "variable": {
                    "value": "predicted_SAT",
                    "possible_values": []
                },
                "size": {
                    "value": "p",
                    "possible_values": [
                        [
                            "tf.shape(instance_SAT)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "while_loop_126": {
                "variable": {
                    "value": "(_, _, _, _, _, predicted_SAT, _)",
                    "possible_values": []
                },
                "cond": {
                    "value": "_vote_while_cond",
                    "possible_values": []
                },
                "body": {
                    "value": "_vote_while_body",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "[tf.constant(0, dtype=tf.int32), p, tf.constant(0, dtype=tf.int32), n, num_vars_on_instance, predicted_SAT, L_vote]",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_with_logits_134": {
                "variable": {
                    "value": "predict_costs",
                    "possible_values": []
                },
                "labels": {
                    "value": "instance_SAT",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [None], name='instance_SAT')",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "predicted_SAT",
                    "possible_values": [
                        [
                            "tf.TensorArray(size=p, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "predicted_SAT.stack()",
                            "Call"
                        ],
                        [
                            "predicted_SAT.write(i, problem_predicted_SAT)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_135": {
                "variable": {
                    "value": "predict_cost",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "predict_costs",
                    "possible_values": [
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=instance_SAT, logits=predicted_SAT)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_136": {
                "variable": {
                    "value": "vars_cost",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "possible_values": []
                }
            },
            "trainable_variables_137": {
                "variable": {
                    "value": "tvars",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "add_141": {
                "variable": {
                    "value": "loss",
                    "possible_values": []
                },
                "x": {
                    "value": "predict_cost",
                    "possible_values": [
                        [
                            "tf.reduce_mean(predict_costs)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.multiply(vars_cost, parameter_l2norm_scaling)",
                    "possible_values": []
                }
            },
            "AdamOptimizer_142": {
                "variable": {
                    "value": "optimizer",
                    "possible_values": []
                },
                "name": {
                    "value": "Adam",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "possible_values": [
                        [
                            "2e-05",
                            "Constant"
                        ]
                    ]
                }
            },
            "clip_by_global_norm_143": {
                "variable": {
                    "value": "(grads, _)",
                    "possible_values": []
                },
                "t_list": {
                    "value": "tf.gradients(loss, tvars)",
                    "possible_values": []
                },
                "clip_norm": {
                    "value": "global_norm_gradient_clipping_ratio",
                    "possible_values": [
                        [
                            "0.65",
                            "Constant"
                        ]
                    ]
                }
            },
            "reduce_mean_146": {
                "variable": {
                    "value": "accuracy",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(tf.equal(tf.cast(instance_SAT, tf.bool), tf.cast(tf.round(tf.nn.sigmoid(predicted_SAT)), tf.bool)), tf.float32)",
                    "possible_values": []
                }
            },
            "div_32": {
                "variable": {
                    "value": "n",
                    "possible_values": []
                },
                "x": {
                    "value": "l",
                    "possible_values": [
                        [
                            "s[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(Lh)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.constant(2)",
                    "possible_values": []
                }
            },
            "gather_34": {
                "variable": {
                    "value": "Lh_pos",
                    "possible_values": []
                },
                "params": {
                    "value": "Lh",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.range(tf.constant(0), n)",
                    "possible_values": []
                }
            },
            "gather_35": {
                "variable": {
                    "value": "Lh_neg",
                    "possible_values": []
                },
                "params": {
                    "value": "Lh",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.range(n, l)",
                    "possible_values": []
                }
            },
            "concat_36": {
                "variable": {
                    "value": "Lh_inverted",
                    "possible_values": []
                },
                "values": {
                    "value": "[Lh_neg, Lh_pos]",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "gather_116": {
                "variable": {
                    "value": "pos_lits",
                    "possible_values": []
                },
                "params": {
                    "value": "L_vote",
                    "possible_values": [
                        [
                            "L_vote_MLP(L_n)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.range(n_acc, tf.add(n_acc, i_n))",
                    "possible_values": []
                }
            },
            "gather_117": {
                "variable": {
                    "value": "neg_lits",
                    "possible_values": []
                },
                "params": {
                    "value": "L_vote",
                    "possible_values": [
                        [
                            "L_vote_MLP(L_n)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.range(tf.add(n, n_acc), tf.add(n, tf.add(n_acc, i_n)))",
                    "possible_values": []
                }
            },
            "reduce_mean_119": {
                "variable": {
                    "value": "problem_predicted_SAT",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.concat([pos_lits, neg_lits], axis=1)",
                    "possible_values": []
                }
            },
            "add_139": {
                "variable": {
                    "value": "vars_cost",
                    "possible_values": []
                },
                "x": {
                    "value": "vars_cost",
                    "possible_values": [
                        [
                            "tf.zeros([])",
                            "Call"
                        ],
                        [
                            "tf.add(vars_cost, tf.nn.l2_loss(var))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.nn.l2_loss(var)",
                    "possible_values": []
                }
            },
            "constant_25": {
                "value": {
                    "value": "2",
                    "possible_values": []
                }
            },
            "shape_27": {
                "input": {
                    "value": "instance_SAT",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [None], name='instance_SAT')",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_43": {
                "initializer": {
                    "value": "tf.random_normal((1, d))",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                },
                "name": {
                    "value": "'{v}_init'.format(v=v)",
                    "possible_values": []
                }
            },
            "tile_45": {
                "input": {
                    "value": "tf.div(init, tf.sqrt(tf.cast(var[v], tf.float32)))",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[num_vars[v], 1]",
                    "possible_values": []
                }
            },
            "less_109": {
                "x": {
                    "value": "i",
                    "possible_values": []
                },
                "y": {
                    "value": "p",
                    "possible_values": [
                        [
                            "tf.shape(instance_SAT)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "multiply_141": {
                "x": {
                    "value": "vars_cost",
                    "possible_values": [
                        [
                            "tf.zeros([])",
                            "Call"
                        ],
                        [
                            "tf.add(vars_cost, tf.nn.l2_loss(var))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "parameter_l2norm_scaling",
                    "possible_values": [
                        [
                            "1e-10",
                            "Constant"
                        ]
                    ]
                }
            },
            "gradients_143": {
                "ys": {
                    "value": "loss",
                    "possible_values": [
                        [
                            "tf.add(predict_cost, tf.multiply(vars_cost, parameter_l2norm_scaling))",
                            "Call"
                        ]
                    ]
                },
                "xs": {
                    "value": "tvars",
                    "possible_values": [
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_147": {
                "x": {
                    "value": "tf.equal(tf.cast(instance_SAT, tf.bool), tf.cast(tf.round(tf.nn.sigmoid(predicted_SAT)), tf.bool))",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "shape_31": {
                "input": {
                    "value": "Lh",
                    "possible_values": []
                }
            },
            "constant_32": {
                "value": {
                    "value": "2",
                    "possible_values": []
                }
            },
            "div_46": {
                "x": {
                    "value": "init",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.sqrt(tf.cast(var[v], tf.float32))",
                    "possible_values": []
                }
            },
            "zeros_initializer_96": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "concat_119": {
                "values": {
                    "value": "[pos_lits, neg_lits]",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "add_122": {
                "x": {
                    "value": "n_acc",
                    "possible_values": []
                },
                "y": {
                    "value": "i_n",
                    "possible_values": [
                        [
                            "n_var_list[i]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "constant_129": {
                "value": {
                    "value": "0",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "possible_values": []
                }
            },
            "l2_loss_139": {
                "t": {
                    "value": "var",
                    "possible_values": [
                        [
                            "{'L': d, 'C': d}",
                            "Dict"
                        ],
                        [
                            "tvars",
                            "Name"
                        ]
                    ]
                }
            },
            "equal_148": {
                "x": {
                    "value": "tf.cast(instance_SAT, tf.bool)",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(tf.round(tf.nn.sigmoid(predicted_SAT)), tf.bool)",
                    "possible_values": []
                }
            },
            "constant_34": {
                "value": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "sqrt_48": {
                "x": {
                    "value": "tf.cast(var[v], tf.float32)",
                    "possible_values": []
                }
            },
            "add_116": {
                "x": {
                    "value": "n_acc",
                    "possible_values": []
                },
                "y": {
                    "value": "i_n",
                    "possible_values": [
                        [
                            "n_var_list[i]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "add_117": {
                "x": {
                    "value": "n_acc",
                    "possible_values": []
                },
                "y": {
                    "value": "i_n",
                    "possible_values": [
                        [
                            "n_var_list[i]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "constant_122": {
                "value": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "cast_149": {
                "x": {
                    "value": "instance_SAT",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [None], name='instance_SAT')",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.bool",
                    "possible_values": []
                }
            },
            "cast_150": {
                "x": {
                    "value": "tf.round(tf.nn.sigmoid(predicted_SAT))",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "possible_values": []
                }
            },
            "cast_48": {
                "x": {
                    "value": "var[v]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "round_150": {
                "x": {
                    "value": "tf.nn.sigmoid(predicted_SAT)",
                    "possible_values": []
                }
            },
            "sigmoid_150": {
                "x": {
                    "value": "predicted_SAT",
                    "possible_values": [
                        [
                            "tf.TensorArray(size=p, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "predicted_SAT.stack()",
                            "Call"
                        ],
                        [
                            "predicted_SAT.write(i, problem_predicted_SAT)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "neurosat/neurosat.py": {
        "tensorflow": {
            "Saver_43": {
                "variable": {
                    "value": "saver",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "ConfigProto_46": {
                "variable": {
                    "value": "config",
                    "possible_values": []
                },
                "gpu_options": {
                    "value": "tf.GPUOptions(allow_growth=True)",
                    "possible_values": []
                }
            },
            "Session_50": {
                "config": {
                    "value": "config",
                    "possible_values": [
                        [
                            "tf.ConfigProto(gpu_options=tf.GPUOptions(allow_growth=True))",
                            "Call"
                        ]
                    ]
                }
            },
            "GPUOptions_48": {
                "allow_growth": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "global_variables_initializer_54": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            }
        }
    },
    "neurosat/sat-test.py": {
        "tensorflow": {
            "Saver_34": {
                "variable": {
                    "value": "saver",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "Session_36": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "global_variables_initializer_40": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            }
        }
    },
    "tgn.py": {
        "tensorflow": {
            "shape_190": {
                "variable": {
                    "value": "init_shape",
                    "possible_values": []
                },
                "input": {
                    "value": "initial_embeddings[v]",
                    "possible_values": []
                }
            },
            "shape_232": {
                "variable": {
                    "value": "mat_shape",
                    "possible_values": []
                },
                "input": {
                    "value": "adjacency_matrices[mat]",
                    "possible_values": []
                }
            },
            "variable_scope_65": {
                "name_or_scope": {
                    "value": "self.name",
                    "possible_values": []
                }
            },
            "variable_scope_129": {
                "name_or_scope": {
                    "value": "self.name",
                    "possible_values": []
                }
            },
            "while_loop_175": {
                "variable": {
                    "value": "(_, last_states)",
                    "possible_values": []
                },
                "cond": {
                    "value": "lambda t, states: tf.less(t, time_steps)",
                    "possible_values": []
                },
                "body": {
                    "value": "while_body",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "[0, states]",
                    "possible_values": []
                }
            },
            "shape_204": {
                "variable": {
                    "value": "lstm_init_shape",
                    "possible_values": []
                },
                "input": {
                    "value": "LSTM_initial_states[v]",
                    "possible_values": []
                }
            },
            "variable_scope_66": {
                "name_or_scope": {
                    "value": "parameters",
                    "possible_values": []
                }
            },
            "variable_scope_130": {
                "name_or_scope": {
                    "value": "assertions",
                    "possible_values": []
                }
            },
            "control_dependencies_133": {
                "control_inputs": {
                    "value": "assertions",
                    "possible_values": [
                        [
                            "self.check_run(adjacency_matrices, initial_embeddings, time_steps, LSTM_initial_states)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "LSTMStateTuple_138": {
                "variable": {
                    "value": "states[v]",
                    "possible_values": []
                },
                "h": {
                    "value": "h0",
                    "possible_values": [
                        [
                            "init",
                            "Name"
                        ]
                    ]
                },
                "c": {
                    "value": "c0",
                    "possible_values": [
                        [
                            "tf.zeros_like(h0, dtype=self.float_dtype) if v not in LSTM_initial_states else LSTM_initial_states[v]",
                            "IfExp"
                        ]
                    ]
                }
            },
            "assert_equal_193": {
                "x": {
                    "value": "init_shape[1]",
                    "possible_values": []
                },
                "y": {
                    "value": "d",
                    "possible_values": []
                },
                "data": {
                    "value": "[init_shape[1]]",
                    "possible_values": []
                },
                "message": {
                    "value": "\"Initial embedding of variable {v} doesn't have the same dimensionality {d} as declared\".format(v=v, d=d)",
                    "possible_values": []
                }
            },
            "assert_equal_234": {
                "x": {
                    "value": "mat_shape[0]",
                    "possible_values": []
                },
                "y": {
                    "value": "num_vars[v1]",
                    "possible_values": []
                },
                "data": {
                    "value": "[mat_shape[0], num_vars[v1]]",
                    "possible_values": []
                },
                "message": {
                    "value": "\"Matrix {m} doesn't have the same number of nodes as the initial embeddings of its variable {v}\".format(v=v1, m=mat)",
                    "possible_values": []
                }
            },
            "concat_167": {
                "variable": {
                    "value": "inputs",
                    "possible_values": []
                },
                "values": {
                    "value": "inputs",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(inputs, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "assert_equal_206": {
                "x": {
                    "value": "lstm_init_shape[1]",
                    "possible_values": []
                },
                "y": {
                    "value": "d",
                    "possible_values": []
                },
                "data": {
                    "value": "[lstm_init_shape[1]]",
                    "possible_values": []
                },
                "message": {
                    "value": "\"Initial hidden state of variable {v}'s LSTM doesn't have the same dimensionality {d} as declared\".format(v=v, d=d)",
                    "possible_values": []
                }
            },
            "assert_equal_218": {
                "x": {
                    "value": "lstm_init_shape",
                    "possible_values": [
                        [
                            "tf.shape(LSTM_initial_states[v])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "init_shape",
                    "possible_values": [
                        [
                            "tf.shape(initial_embeddings[v])",
                            "Call"
                        ]
                    ]
                },
                "data": {
                    "value": "[init_shape, lstm_init_shape]",
                    "possible_values": []
                },
                "message": {
                    "value": "\"Initial embeddings of variable {v} don't have the same shape as the its LSTM's initial hidden state\".format(v=v, d=d)",
                    "possible_values": []
                }
            },
            "assert_equal_246": {
                "x": {
                    "value": "mat_shape[1]",
                    "possible_values": []
                },
                "y": {
                    "value": "v2",
                    "possible_values": []
                },
                "data": {
                    "value": "[mat_shape[1], v2]",
                    "possible_values": []
                },
                "message": {
                    "value": "\"Matrix {m} doesn't have the same dimensionality {d} on the second variable as declared\".format(m=mat, d=v2)",
                    "possible_values": []
                }
            },
            "assert_equal_258": {
                "x": {
                    "value": "mat_shape[1]",
                    "possible_values": []
                },
                "y": {
                    "value": "num_vars[v2]",
                    "possible_values": []
                },
                "data": {
                    "value": "[mat_shape[1], num_vars[v2]]",
                    "possible_values": []
                },
                "message": {
                    "value": "\"Matrix {m} doesn't have the same number of nodes as the initial embeddings of its variable {v}\".format(v=v2, m=mat)",
                    "possible_values": []
                }
            },
            "zeros_like_137": {
                "input": {
                    "value": "h0",
                    "possible_values": [
                        [
                            "init",
                            "Name"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.float_dtype",
                    "possible_values": []
                }
            },
            "less_176": {
                "x": {
                    "value": "t",
                    "possible_values": []
                },
                "y": {
                    "value": "time_steps",
                    "possible_values": []
                }
            },
            "variable_scope_168": {
                "name_or_scope": {
                    "value": "'{v}_cell'.format(v=v)",
                    "possible_values": []
                }
            },
            "matmul_156": {
                "variable": {
                    "value": "y",
                    "possible_values": []
                },
                "a": {
                    "value": "adjacency_matrices[update['mat']]",
                    "possible_values": []
                },
                "b": {
                    "value": "y",
                    "possible_values": [
                        [
                            "states[update['var']].h",
                            "Attribute"
                        ],
                        [
                            "update['fun'](y)",
                            "Call"
                        ],
                        [
                            "self._msg_MLPs[update['msg']](y)",
                            "Call"
                        ],
                        [
                            "tf.matmul(adjacency_matrices[update['mat']], y, adjoint_a=update['transpose?'] if 'transpose?' in update else False)",
                            "Call"
                        ]
                    ]
                },
                "adjoint_a": {
                    "value": "update['transpose?'] if 'transpose?' in update else False",
                    "possible_values": []
                }
            }
        }
    },
    "util.py": {
        "tensorflow": {
            "Saver_74": {
                "variable": {
                    "value": "saver",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "Saver_76": {
                "variable": {
                    "value": "saver",
                    "possible_values": []
                },
                "var_list": {
                    "value": "tf.get_collection(tf.GraphKeys.GLOBAL_VARIABLES, scope=scope)",
                    "possible_values": []
                }
            },
            "Saver_59": {
                "variable": {
                    "value": "saver",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "Saver_61": {
                "variable": {
                    "value": "saver",
                    "possible_values": []
                },
                "var_list": {
                    "value": "tf.get_collection(tf.GraphKeys.GLOBAL_VARIABLES, scope=scope)",
                    "possible_values": []
                }
            },
            "get_collection_76": {
                "key": {
                    "value": "tf.GraphKeys.GLOBAL_VARIABLES",
                    "possible_values": []
                },
                "scope": {
                    "value": "scope",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "get_collection_61": {
                "key": {
                    "value": "tf.GraphKeys.GLOBAL_VARIABLES",
                    "possible_values": []
                },
                "scope": {
                    "value": "scope",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            }
        }
    }
}