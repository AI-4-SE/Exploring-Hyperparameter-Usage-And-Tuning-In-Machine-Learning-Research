{
    "facenet.py": {
        "sklearn": {
            "KFold_430": {
                "variable": {
                    "value": "k_fold",
                    "type": "Name",
                    "possible_values": []
                },
                "n_splits": {
                    "value": "nrof_folds",
                    "type": "Name",
                    "possible_values": [
                        [
                            "10",
                            "MethodArgument"
                        ],
                        [
                            "10",
                            "MethodArgument"
                        ]
                    ]
                },
                "shuffle": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "KFold_477": {
                "variable": {
                    "value": "k_fold",
                    "type": "Name",
                    "possible_values": []
                },
                "n_splits": {
                    "value": "nrof_folds",
                    "type": "Name",
                    "possible_values": [
                        [
                            "10",
                            "MethodArgument"
                        ],
                        [
                            "10",
                            "MethodArgument"
                        ]
                    ]
                },
                "shuffle": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "get_variable_70": {
                "variable": {
                    "value": "centers",
                    "type": "Name",
                    "possible_values": []
                },
                "name": {
                    "value": "centers",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[nrof_classes, nrof_features]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reshape_72": {
                "variable": {
                    "value": "label",
                    "type": "Name",
                    "possible_values": []
                },
                "tensor": {
                    "value": "label",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reshape(label, [-1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_73": {
                "variable": {
                    "value": "centers_batch",
                    "type": "Name",
                    "possible_values": []
                },
                "params": {
                    "value": "centers",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.get_variable('centers', [nrof_classes, nrof_features], dtype=tf.float32, initializer=tf.constant_initializer(0), trainable=False)",
                            "Call"
                        ],
                        [
                            "tf.scatter_sub(centers, label, diff)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "label",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reshape(label, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "scatter_sub_75": {
                "variable": {
                    "value": "centers",
                    "type": "Name",
                    "possible_values": []
                },
                "ref": {
                    "value": "centers",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.get_variable('centers', [nrof_classes, nrof_features], dtype=tf.float32, initializer=tf.constant_initializer(0), trainable=False)",
                            "Call"
                        ],
                        [
                            "tf.scatter_sub(centers, label, diff)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "label",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reshape(label, [-1])",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "diff",
                    "type": "Name",
                    "possible_values": [
                        [
                            "(1 - alfa) * (centers_batch - features)",
                            "BinOp"
                        ],
                        [
                            "sz1 - sz2",
                            "BinOp"
                        ],
                        [
                            "np.subtract(embeddings1, embeddings2)",
                            "Call"
                        ]
                    ]
                }
            },
            "batch_join_132": {
                "variable": {
                    "value": "(image_batch, label_batch)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensors_list": {
                    "value": "images_and_labels_list",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "batch_size_placeholder",
                    "type": "Name",
                    "possible_values": []
                },
                "shapes": {
                    "value": "[image_size + (3,), ()]",
                    "type": "List",
                    "possible_values": []
                },
                "enqueue_many": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "capacity": {
                    "value": "4 * nrof_preprocess_threads * 100",
                    "type": "BinOp",
                    "possible_values": []
                },
                "allow_smaller_final_batch": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "ExponentialMovingAverage_155": {
                "variable": {
                    "value": "loss_averages",
                    "type": "Name",
                    "possible_values": []
                },
                "decay": {
                    "value": "0.9",
                    "type": "Constant",
                    "possible_values": []
                },
                "name": {
                    "value": "avg",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_collection_156": {
                "variable": {
                    "value": "losses",
                    "type": "Name",
                    "possible_values": []
                },
                "key": {
                    "value": "losses",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "ExponentialMovingAverage_205": {
                "variable": {
                    "value": "variable_averages",
                    "type": "Name",
                    "possible_values": []
                },
                "decay": {
                    "value": "moving_average_decay",
                    "type": "Name",
                    "possible_values": []
                },
                "num_updates": {
                    "value": "global_step",
                    "type": "Name",
                    "possible_values": []
                }
            },
            "get_checkpoint_state_393": {
                "variable": {
                    "value": "ckpt",
                    "type": "Name",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "model_dir",
                    "type": "Name",
                    "possible_values": []
                }
            },
            "NewCheckpointReader_547": {
                "variable": {
                    "value": "reader",
                    "type": "Name",
                    "possible_values": []
                },
                "filepattern": {
                    "value": "filename",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.unstack(filenames)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_57": {
                "variable": {
                    "value": "pos_dist",
                    "type": "Name",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(tf.subtract(anchor, positive))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_sum_58": {
                "variable": {
                    "value": "neg_dist",
                    "type": "Name",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(tf.subtract(anchor, negative))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "add_60": {
                "variable": {
                    "value": "basic_loss",
                    "type": "Name",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.subtract(pos_dist, neg_dist)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "alpha",
                    "type": "Name",
                    "possible_values": []
                }
            },
            "reduce_mean_61": {
                "variable": {
                    "value": "loss",
                    "type": "Name",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.maximum(basic_loss, 0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_mean_77": {
                "variable": {
                    "value": "loss",
                    "type": "Name",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(features - centers_batch)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_141": {
                "x": {
                    "value": "tf.mod(tf.floor_div(control, field), 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "no_op_210": {
                "variable": {
                    "value": "train_op",
                    "type": "Name",
                    "possible_values": []
                },
                "name": {
                    "value": "train",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "import_meta_graph_382": {
                "variable": {
                    "value": "saver",
                    "type": "Name",
                    "possible_values": []
                },
                "meta_graph_or_file": {
                    "value": "os.path.join(model_exp, meta_file)",
                    "type": "Call",
                    "possible_values": []
                },
                "input_map": {
                    "value": "input_map",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_56": {
                "name_or_scope": {
                    "value": "triplet_loss",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "control_dependencies_76": {
                "control_inputs": {
                    "value": "[centers]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "unstack_109": {
                "value": {
                    "value": "filenames",
                    "type": "Name",
                    "possible_values": []
                }
            },
            "read_file_110": {
                "variable": {
                    "value": "file_contents",
                    "type": "Name",
                    "possible_values": []
                },
                "filename": {
                    "value": "filename",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.unstack(filenames)",
                            "Call"
                        ]
                    ]
                }
            },
            "decode_image_111": {
                "variable": {
                    "value": "image",
                    "type": "Name",
                    "possible_values": []
                },
                "contents": {
                    "value": "file_contents",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.read_file(filename)",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cond_112": {
                "variable": {
                    "value": "image",
                    "type": "Name",
                    "possible_values": []
                },
                "pred": {
                    "value": "get_control_flag(control[0], RANDOM_ROTATE)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.py_func(random_rotate_image, [image], tf.uint8)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.identity(image)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_115": {
                "variable": {
                    "value": "image",
                    "type": "Name",
                    "possible_values": []
                },
                "pred": {
                    "value": "get_control_flag(control[0], RANDOM_CROP)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.random_crop(image, image_size + (3,))",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.image.resize_image_with_crop_or_pad(image, image_size[0], image_size[1])",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_118": {
                "variable": {
                    "value": "image",
                    "type": "Name",
                    "possible_values": []
                },
                "pred": {
                    "value": "get_control_flag(control[0], RANDOM_FLIP)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.image.random_flip_left_right(image)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.identity(image)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_121": {
                "variable": {
                    "value": "image",
                    "type": "Name",
                    "possible_values": []
                },
                "pred": {
                    "value": "get_control_flag(control[0], FIXED_STANDARDIZATION)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : (tf.cast(image, tf.float32) - 127.5) / 128.0",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.image.per_image_standardization(image)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_124": {
                "variable": {
                    "value": "image",
                    "type": "Name",
                    "possible_values": []
                },
                "pred": {
                    "value": "get_control_flag(control[0], FLIP)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.image.flip_left_right(image)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.identity(image)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "mod_141": {
                "x1": {
                    "value": "tf.floor_div(control, field)",
                    "type": "Call",
                    "possible_values": []
                },
                "x2": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "scalar_164": {
                "name": {
                    "value": "l.op.name + ' (raw)'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "l",
                    "type": "Name",
                    "possible_values": [
                        [
                            "losses + [total_loss]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "scalar_165": {
                "name": {
                    "value": "l.op.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "loss_averages.average(l)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "control_dependencies_174": {
                "control_inputs": {
                    "value": "[loss_averages_op]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "AdagradOptimizer_176": {
                "variable": {
                    "value": "opt",
                    "type": "Name",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "Name",
                    "possible_values": [
                        [
                            "lr",
                            "Name"
                        ]
                    ]
                }
            },
            "trainable_variables_195": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "trainable_variables_207": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "control_dependencies_209": {
                "control_inputs": {
                    "value": "[apply_gradient_op, variables_averages_op]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "GraphDef_372": {
                "variable": {
                    "value": "graph_def",
                    "type": "Name",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "square_57": {
                "x": {
                    "value": "tf.subtract(anchor, positive)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "square_58": {
                "x": {
                    "value": "tf.subtract(anchor, negative)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "subtract_60": {
                "x": {
                    "value": "pos_dist",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.square(tf.subtract(anchor, positive)), 1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "neg_dist",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.square(tf.subtract(anchor, negative)), 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "maximum_61": {
                "x": {
                    "value": "basic_loss",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.add(tf.subtract(pos_dist, neg_dist), alpha)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0.0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "constant_initializer_71": {
                "value": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "square_77": {
                "x": {
                    "value": "features - centers_batch",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "floor_div_141": {
                "x": {
                    "value": "control",
                    "type": "Name",
                    "possible_values": []
                },
                "y": {
                    "value": "field",
                    "type": "Name",
                    "possible_values": []
                }
            },
            "AdadeltaOptimizer_178": {
                "variable": {
                    "value": "opt",
                    "type": "Name",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "Name",
                    "possible_values": [
                        [
                            "lr",
                            "Name"
                        ]
                    ]
                },
                "rho": {
                    "value": "0.9",
                    "type": "Constant",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "1e-06",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "histogram_196": {
                "name": {
                    "value": "var.op.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "var",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ]
                    ]
                }
            },
            "FastGFile_371": {
                "name": {
                    "value": "model_exp",
                    "type": "Name",
                    "possible_values": [
                        [
                            "os.path.expanduser(model)",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "rb",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "import_graph_def_374": {
                "graph_def": {
                    "value": "graph_def",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.compat.v1.GraphDef()",
                            "Call"
                        ]
                    ]
                },
                "input_map": {
                    "value": "input_map",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "name": {
                    "value": "",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_default_session_383": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "subtract_57": {
                "x": {
                    "value": "anchor",
                    "type": "Name",
                    "possible_values": []
                },
                "y": {
                    "value": "positive",
                    "type": "Name",
                    "possible_values": []
                }
            },
            "subtract_58": {
                "x": {
                    "value": "anchor",
                    "type": "Name",
                    "possible_values": []
                },
                "y": {
                    "value": "negative",
                    "type": "Name",
                    "possible_values": []
                }
            },
            "AdamOptimizer_180": {
                "variable": {
                    "value": "opt",
                    "type": "Name",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "Name",
                    "possible_values": [
                        [
                            "lr",
                            "Name"
                        ]
                    ]
                },
                "beta1": {
                    "value": "0.9",
                    "type": "Constant",
                    "possible_values": []
                },
                "beta2": {
                    "value": "0.999",
                    "type": "Constant",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "0.1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "histogram_202": {
                "name": {
                    "value": "var.op.name + '/gradients'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "grad",
                    "type": "Name",
                    "possible_values": []
                }
            },
            "py_func_113": {
                "func": {
                    "value": "random_rotate_image",
                    "type": "Name",
                    "possible_values": []
                },
                "inp": {
                    "value": "[image]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.uint8",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "identity_114": {
                "input": {
                    "value": "image",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.image.decode_image(file_contents, 3)",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_ROTATE), lambda : tf.py_func(random_rotate_image, [image], tf.uint8), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_CROP), lambda : tf.random_crop(image, image_size + (3,)), lambda : tf.image.resize_image_with_crop_or_pad(image, image_size[0], image_size[1]))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_FLIP), lambda : tf.image.random_flip_left_right(image), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], FIXED_STANDARDIZATION), lambda : (tf.cast(image, tf.float32) - 127.5) / 128.0, lambda : tf.image.per_image_standardization(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], FLIP), lambda : tf.image.flip_left_right(image), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "image[sz1 - sz2 + v:sz1 + sz2 + v, sz1 - sz2 + h:sz1 + sz2 + h, :]",
                            "Subscript"
                        ],
                        [
                            "np.fliplr(image)",
                            "Call"
                        ]
                    ]
                }
            },
            "random_crop_116": {
                "value": {
                    "value": "image",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.image.decode_image(file_contents, 3)",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_ROTATE), lambda : tf.py_func(random_rotate_image, [image], tf.uint8), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_CROP), lambda : tf.random_crop(image, image_size + (3,)), lambda : tf.image.resize_image_with_crop_or_pad(image, image_size[0], image_size[1]))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_FLIP), lambda : tf.image.random_flip_left_right(image), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], FIXED_STANDARDIZATION), lambda : (tf.cast(image, tf.float32) - 127.5) / 128.0, lambda : tf.image.per_image_standardization(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], FLIP), lambda : tf.image.flip_left_right(image), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "image[sz1 - sz2 + v:sz1 + sz2 + v, sz1 - sz2 + h:sz1 + sz2 + h, :]",
                            "Subscript"
                        ],
                        [
                            "np.fliplr(image)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "image_size + (3,)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "random_flip_left_right_119": {
                "image": {
                    "value": "image",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.image.decode_image(file_contents, 3)",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_ROTATE), lambda : tf.py_func(random_rotate_image, [image], tf.uint8), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_CROP), lambda : tf.random_crop(image, image_size + (3,)), lambda : tf.image.resize_image_with_crop_or_pad(image, image_size[0], image_size[1]))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_FLIP), lambda : tf.image.random_flip_left_right(image), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], FIXED_STANDARDIZATION), lambda : (tf.cast(image, tf.float32) - 127.5) / 128.0, lambda : tf.image.per_image_standardization(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], FLIP), lambda : tf.image.flip_left_right(image), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "image[sz1 - sz2 + v:sz1 + sz2 + v, sz1 - sz2 + h:sz1 + sz2 + h, :]",
                            "Subscript"
                        ],
                        [
                            "np.fliplr(image)",
                            "Call"
                        ]
                    ]
                }
            },
            "identity_120": {
                "input": {
                    "value": "image",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.image.decode_image(file_contents, 3)",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_ROTATE), lambda : tf.py_func(random_rotate_image, [image], tf.uint8), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_CROP), lambda : tf.random_crop(image, image_size + (3,)), lambda : tf.image.resize_image_with_crop_or_pad(image, image_size[0], image_size[1]))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_FLIP), lambda : tf.image.random_flip_left_right(image), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], FIXED_STANDARDIZATION), lambda : (tf.cast(image, tf.float32) - 127.5) / 128.0, lambda : tf.image.per_image_standardization(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], FLIP), lambda : tf.image.flip_left_right(image), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "image[sz1 - sz2 + v:sz1 + sz2 + v, sz1 - sz2 + h:sz1 + sz2 + h, :]",
                            "Subscript"
                        ],
                        [
                            "np.fliplr(image)",
                            "Call"
                        ]
                    ]
                }
            },
            "per_image_standardization_123": {
                "image": {
                    "value": "image",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.image.decode_image(file_contents, 3)",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_ROTATE), lambda : tf.py_func(random_rotate_image, [image], tf.uint8), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_CROP), lambda : tf.random_crop(image, image_size + (3,)), lambda : tf.image.resize_image_with_crop_or_pad(image, image_size[0], image_size[1]))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_FLIP), lambda : tf.image.random_flip_left_right(image), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], FIXED_STANDARDIZATION), lambda : (tf.cast(image, tf.float32) - 127.5) / 128.0, lambda : tf.image.per_image_standardization(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], FLIP), lambda : tf.image.flip_left_right(image), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "image[sz1 - sz2 + v:sz1 + sz2 + v, sz1 - sz2 + h:sz1 + sz2 + h, :]",
                            "Subscript"
                        ],
                        [
                            "np.fliplr(image)",
                            "Call"
                        ]
                    ]
                }
            },
            "flip_left_right_125": {
                "image": {
                    "value": "image",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.image.decode_image(file_contents, 3)",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_ROTATE), lambda : tf.py_func(random_rotate_image, [image], tf.uint8), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_CROP), lambda : tf.random_crop(image, image_size + (3,)), lambda : tf.image.resize_image_with_crop_or_pad(image, image_size[0], image_size[1]))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_FLIP), lambda : tf.image.random_flip_left_right(image), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], FIXED_STANDARDIZATION), lambda : (tf.cast(image, tf.float32) - 127.5) / 128.0, lambda : tf.image.per_image_standardization(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], FLIP), lambda : tf.image.flip_left_right(image), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "image[sz1 - sz2 + v:sz1 + sz2 + v, sz1 - sz2 + h:sz1 + sz2 + h, :]",
                            "Subscript"
                        ],
                        [
                            "np.fliplr(image)",
                            "Call"
                        ]
                    ]
                }
            },
            "identity_126": {
                "input": {
                    "value": "image",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.image.decode_image(file_contents, 3)",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_ROTATE), lambda : tf.py_func(random_rotate_image, [image], tf.uint8), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_CROP), lambda : tf.random_crop(image, image_size + (3,)), lambda : tf.image.resize_image_with_crop_or_pad(image, image_size[0], image_size[1]))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_FLIP), lambda : tf.image.random_flip_left_right(image), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], FIXED_STANDARDIZATION), lambda : (tf.cast(image, tf.float32) - 127.5) / 128.0, lambda : tf.image.per_image_standardization(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], FLIP), lambda : tf.image.flip_left_right(image), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "image[sz1 - sz2 + v:sz1 + sz2 + v, sz1 - sz2 + h:sz1 + sz2 + h, :]",
                            "Subscript"
                        ],
                        [
                            "np.fliplr(image)",
                            "Call"
                        ]
                    ]
                }
            },
            "RMSPropOptimizer_182": {
                "variable": {
                    "value": "opt",
                    "type": "Name",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "Name",
                    "possible_values": [
                        [
                            "lr",
                            "Name"
                        ]
                    ]
                },
                "decay": {
                    "value": "0.9",
                    "type": "Constant",
                    "possible_values": []
                },
                "momentum": {
                    "value": "0.9",
                    "type": "Constant",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "1.0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "MomentumOptimizer_184": {
                "variable": {
                    "value": "opt",
                    "type": "Name",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "Name",
                    "possible_values": [
                        [
                            "lr",
                            "Name"
                        ]
                    ]
                },
                "momentum": {
                    "value": "0.9",
                    "type": "Constant",
                    "possible_values": []
                },
                "use_nesterov": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cast_122": {
                "x": {
                    "value": "image",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.image.decode_image(file_contents, 3)",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_ROTATE), lambda : tf.py_func(random_rotate_image, [image], tf.uint8), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_CROP), lambda : tf.random_crop(image, image_size + (3,)), lambda : tf.image.resize_image_with_crop_or_pad(image, image_size[0], image_size[1]))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], RANDOM_FLIP), lambda : tf.image.random_flip_left_right(image), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], FIXED_STANDARDIZATION), lambda : (tf.cast(image, tf.float32) - 127.5) / 128.0, lambda : tf.image.per_image_standardization(image))",
                            "Call"
                        ],
                        [
                            "tf.cond(get_control_flag(control[0], FLIP), lambda : tf.image.flip_left_right(image), lambda : tf.identity(image))",
                            "Call"
                        ],
                        [
                            "image[sz1 - sz2 + v:sz1 + sz2 + v, sz1 - sz2 + h:sz1 + sz2 + h, :]",
                            "Subscript"
                        ],
                        [
                            "np.fliplr(image)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "facenet_cam.py": {
        "tensorflow": {
            "Graph_78": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_default_graph_81": {
                "variable": {
                    "value": "embeddings",
                    "type": "Name",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_default_graph_82": {
                "variable": {
                    "value": "images_placeholder",
                    "type": "Name",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_default_graph_83": {
                "variable": {
                    "value": "phase_train_placeholder",
                    "type": "Name",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_79": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "facenet_imgviewer.py": {
        "tensorflow": {
            "Graph_49": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_default_graph_52": {
                "variable": {
                    "value": "embeddings",
                    "type": "Name",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_default_graph_53": {
                "variable": {
                    "value": "images_placeholder",
                    "type": "Name",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_default_graph_54": {
                "variable": {
                    "value": "phase_train_placeholder",
                    "type": "Name",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_50": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "rp_facenet_cam.py": {
        "tensorflow": {
            "Interpreter_45": {
                "variable": {
                    "value": "interpreter",
                    "type": "Name",
                    "possible_values": []
                },
                "model_path": {
                    "value": "tf_path",
                    "type": "Name",
                    "possible_values": []
                }
            }
        }
    }
}