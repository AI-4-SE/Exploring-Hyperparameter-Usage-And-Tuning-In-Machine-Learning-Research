{
    "GLMs.py": {
        "sklearn": {
            "Lasso_34": {
                "variable": {
                    "value": "las",
                    "possible_values": []
                },
                "alpha": {
                    "value": "reg",
                    "possible_values": []
                }
            },
            "Ridge_53": {
                "variable": {
                    "value": "rid",
                    "possible_values": []
                },
                "alpha": {
                    "value": "reg",
                    "possible_values": []
                }
            }
        }
    },
    "CNN.py": {
        "tensorflow": {
            "Graph_34": {
                "variable": {
                    "value": "self.graph",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "placeholder_41": {
                "variable": {
                    "value": "self.X",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, s[1], s[0], s[0]]",
                    "possible_values": []
                }
            },
            "placeholder_43": {
                "variable": {
                    "value": "self.Y",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "placeholder_46": {
                "variable": {
                    "value": "self.is_train",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "possible_values": []
                }
            },
            "get_collection_126": {
                "variable": {
                    "value": "self.update_ops",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.UPDATE_OPS",
                    "possible_values": []
                }
            },
            "Variable_136": {
                "variable": {
                    "value": "self.WM",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "self.WM_init",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                },
                "name": {
                    "value": "WM",
                    "possible_values": []
                }
            },
            "reshape_141": {
                "tensor": {
                    "value": "self.conv[-1]",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, s[2] ** 2]",
                    "possible_values": []
                }
            },
            "Variable_151": {
                "variable": {
                    "value": "self.WW",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "self.WW_init",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                },
                "name": {
                    "value": "WW",
                    "possible_values": []
                }
            },
            "reduce_mean_177": {
                "variable": {
                    "value": "self.regM",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.reduce_sum(tf.abs(self.WM), 0)",
                    "possible_values": []
                }
            },
            "reduce_mean_178": {
                "variable": {
                    "value": "self.regW",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.reduce_sum(tf.abs(self.WW), 0)",
                    "possible_values": []
                }
            },
            "reduce_mean_182": {
                "input_tensor": {
                    "value": "self.res * self.res",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "placeholder_187": {
                "variable": {
                    "value": "self.step_size",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "AdamOptimizer_188": {
                "variable": {
                    "value": "self.training",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.step_size",
                    "possible_values": []
                }
            },
            "Saver_191": {
                "variable": {
                    "value": "self.saver",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "set_random_seed_38": {
                "seed": {
                    "value": "tf_seed",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "abs_139": {
                "variable": {
                    "value": "self.WM",
                    "possible_values": []
                },
                "x": {
                    "value": "self.WM",
                    "possible_values": []
                }
            },
            "abs_155": {
                "variable": {
                    "value": "self.WW",
                    "possible_values": []
                },
                "x": {
                    "value": "self.WW",
                    "possible_values": []
                }
            },
            "transpose_163": {
                "variable": {
                    "value": "self.Y_",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.squeeze(self.mask)",
                    "possible_values": []
                }
            },
            "squeeze_166": {
                "variable": {
                    "value": "self.Y_",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.transpose(tf.reduce_sum(tf.multiply(self.mask, self.WW), 1, keep_dims=True))",
                    "possible_values": []
                }
            },
            "transpose_170": {
                "a": {
                    "value": "self.Y_",
                    "possible_values": []
                }
            },
            "get_variable_114": {
                "variable": {
                    "value": "self.WK",
                    "possible_values": []
                },
                "name": {
                    "value": "kernels",
                    "possible_values": []
                },
                "shape": {
                    "value": "[sK[0], sK[0], s[1], num_kern[0]]",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.truncated_normal_initializer(mean=init_scales[0, 0], stddev=init_scales[0, 1])",
                    "possible_values": []
                }
            },
            "matmul_141": {
                "a": {
                    "value": "tf.reshape(self.conv[-1], [-1, s[2] ** 2])",
                    "possible_values": []
                },
                "b": {
                    "value": "self.WM",
                    "possible_values": []
                }
            },
            "reduce_sum_177": {
                "input_tensor": {
                    "value": "tf.abs(self.WM)",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "reduce_sum_178": {
                "input_tensor": {
                    "value": "tf.abs(self.WW)",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "dropout_69": {
                "variable": {
                    "value": "inputs",
                    "possible_values": []
                },
                "x": {
                    "value": "self.X",
                    "possible_values": []
                },
                "rate": {
                    "value": "reg[3]",
                    "possible_values": []
                },
                "training": {
                    "value": "self.is_train",
                    "possible_values": []
                }
            },
            "dropout_73": {
                "variable": {
                    "value": "inputs",
                    "possible_values": []
                },
                "x": {
                    "value": "self.conv[c - 1]",
                    "possible_values": []
                },
                "rate": {
                    "value": "reg[3]",
                    "possible_values": []
                },
                "training": {
                    "value": "self.is_train",
                    "possible_values": []
                }
            },
            "sqrt_157": {
                "x": {
                    "value": "tf.reduce_sum(tf.square(self.WW), 0, keep_dims=True)",
                    "possible_values": []
                }
            },
            "abs_159": {
                "x": {
                    "value": "self.WW",
                    "possible_values": []
                }
            },
            "squeeze_163": {
                "input": {
                    "value": "self.mask",
                    "possible_values": []
                }
            },
            "transpose_166": {
                "a": {
                    "value": "tf.reduce_sum(tf.multiply(self.mask, self.WW), 1, keep_dims=True)",
                    "possible_values": []
                }
            },
            "bias_add_170": {
                "value": {
                    "value": "tf.transpose(self.Y_)",
                    "possible_values": []
                },
                "activation_fn": {
                    "value": "tf.nn.relu",
                    "possible_values": []
                }
            },
            "abs_177": {
                "x": {
                    "value": "self.WM",
                    "possible_values": []
                }
            },
            "abs_178": {
                "x": {
                    "value": "self.WW",
                    "possible_values": []
                }
            },
            "variable_scope_106": {
                "name_or_scope": {
                    "value": "scope",
                    "possible_values": [
                        [
                            "'conv' + str(c)",
                            "BinOp"
                        ]
                    ]
                },
                "reuse": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "conv2d_122": {
                "input": {
                    "value": "self.X",
                    "possible_values": []
                },
                "filters": {
                    "value": "self.WK[-1]",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "possible_values": []
                },
                "data_format": {
                    "value": "NCHW",
                    "possible_values": []
                }
            },
            "reduce_sum_157": {
                "input_tensor": {
                    "value": "tf.square(self.WW)",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "sqrt_159": {
                "x": {
                    "value": "tf.reduce_sum(tf.square(self.WW), 0, keep_dims=True)",
                    "possible_values": []
                }
            },
            "reduce_sum_166": {
                "input_tensor": {
                    "value": "tf.multiply(self.mask, self.WW)",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "get_variable_107": {
                "name": {
                    "value": "weights",
                    "possible_values": []
                }
            },
            "truncated_normal_initializer_117": {
                "mean": {
                    "value": "init_scales[0, 0]",
                    "possible_values": []
                },
                "stddev": {
                    "value": "init_scales[0, 1]",
                    "possible_values": []
                }
            },
            "square_157": {
                "x": {
                    "value": "self.WW",
                    "possible_values": []
                }
            },
            "reduce_sum_159": {
                "input_tensor": {
                    "value": "tf.square(self.WW)",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "multiply_166": {
                "x": {
                    "value": "self.mask",
                    "possible_values": []
                },
                "y": {
                    "value": "self.WW",
                    "possible_values": []
                }
            },
            "random_normal_initializer_99": {
                "mean": {
                    "value": "init_scales[0, 0]",
                    "possible_values": []
                },
                "stddev": {
                    "value": "init_scales[0, 1]",
                    "possible_values": []
                }
            },
            "sqrt_109": {
                "x": {
                    "value": "tf.reduce_sum(tf.square(self.WK[-1]), [0, 1], keep_dims=True)",
                    "possible_values": []
                }
            },
            "sqrt_121": {
                "x": {
                    "value": "tf.reduce_sum(tf.square(self.WK), [0, 1], keep_dims=True)",
                    "possible_values": []
                }
            },
            "square_159": {
                "x": {
                    "value": "self.WW",
                    "possible_values": []
                }
            },
            "reduce_sum_109": {
                "input_tensor": {
                    "value": "tf.square(self.WK[-1])",
                    "possible_values": []
                },
                "axis": {
                    "value": "[0, 1]",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "reduce_sum_121": {
                "input_tensor": {
                    "value": "tf.square(self.WK)",
                    "possible_values": []
                },
                "axis": {
                    "value": "[0, 1]",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "square_109": {
                "x": {
                    "value": "self.WK[-1]",
                    "possible_values": []
                }
            },
            "square_121": {
                "x": {
                    "value": "self.WK",
                    "possible_values": []
                }
            }
        }
    },
    "generate_data.py": {
        "tensorflow": {
            "GPUOptions_32": {
                "variable": {
                    "value": "gpu_options",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "Graph_47": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "set_random_seed_49": {
                "seed": {
                    "value": "tf_seed",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "get_variable_52": {
                "variable": {
                    "value": "input_train",
                    "possible_values": []
                },
                "name": {
                    "value": "input_train",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_pixel, num_train]",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer()",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "possible_values": []
                },
                "collections": {
                    "value": "[]",
                    "possible_values": []
                }
            },
            "get_variable_55": {
                "variable": {
                    "value": "input_val",
                    "possible_values": []
                },
                "name": {
                    "value": "input_val",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_pixel, num_val]",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer()",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "possible_values": []
                },
                "collections": {
                    "value": "[]",
                    "possible_values": []
                }
            },
            "get_variable_58": {
                "variable": {
                    "value": "input_test",
                    "possible_values": []
                },
                "name": {
                    "value": "input_test",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_pixel, num_test]",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer()",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "possible_values": []
                },
                "collections": {
                    "value": "[]",
                    "possible_values": []
                }
            },
            "constant_62": {
                "variable": {
                    "value": "RF",
                    "possible_values": []
                },
                "value": {
                    "value": "rf",
                    "possible_values": [
                        [
                            "RF.astype(np.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_64": {
                "variable": {
                    "value": "output_train",
                    "possible_values": []
                },
                "a": {
                    "value": "RF",
                    "possible_values": [
                        [
                            "tf.constant(rf)",
                            "Call"
                        ],
                        [
                            "tf.constant(rf)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "input_train",
                    "possible_values": [
                        [
                            "tf.get_variable(name='input_train', shape=[num_pixel, num_train], initializer=tf.random_normal_initializer(), trainable=False, collections=[])",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name='input_train', shape=[num_pixel, num_train], initializer=tf.random_normal_initializer(), trainable=False, collections=[])",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_65": {
                "variable": {
                    "value": "output_val",
                    "possible_values": []
                },
                "a": {
                    "value": "RF",
                    "possible_values": [
                        [
                            "tf.constant(rf)",
                            "Call"
                        ],
                        [
                            "tf.constant(rf)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "input_val",
                    "possible_values": [
                        [
                            "tf.get_variable(name='input_val', shape=[num_pixel, num_val], initializer=tf.random_normal_initializer(), trainable=False, collections=[])",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_66": {
                "variable": {
                    "value": "output_test",
                    "possible_values": []
                },
                "a": {
                    "value": "RF",
                    "possible_values": [
                        [
                            "tf.constant(rf)",
                            "Call"
                        ],
                        [
                            "tf.constant(rf)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "input_test",
                    "possible_values": [
                        [
                            "tf.get_variable(name='input_test', shape=[num_pixel, num_test], initializer=tf.random_normal_initializer(), trainable=False, collections=[])",
                            "Call"
                        ]
                    ]
                }
            },
            "device_50": {
                "device_name": {
                    "value": "/gpu:0",
                    "possible_values": []
                }
            },
            "Session_75": {
                "config": {
                    "value": "tf.ConfigProto(gpu_options=gpu_options)",
                    "possible_values": []
                }
            },
            "Graph_90": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "set_random_seed_92": {
                "seed": {
                    "value": "tf_seed",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "get_variable_94": {
                "variable": {
                    "value": "input_train",
                    "possible_values": []
                },
                "name": {
                    "value": "input_train",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_pixel, num_train]",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer()",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "possible_values": []
                },
                "collections": {
                    "value": "[]",
                    "possible_values": []
                }
            },
            "constant_97": {
                "variable": {
                    "value": "RF",
                    "possible_values": []
                },
                "value": {
                    "value": "rf",
                    "possible_values": [
                        [
                            "RF.astype(np.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_98": {
                "variable": {
                    "value": "output_train",
                    "possible_values": []
                },
                "a": {
                    "value": "RF",
                    "possible_values": [
                        [
                            "tf.constant(rf)",
                            "Call"
                        ],
                        [
                            "tf.constant(rf)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "input_train",
                    "possible_values": [
                        [
                            "tf.get_variable(name='input_train', shape=[num_pixel, num_train], initializer=tf.random_normal_initializer(), trainable=False, collections=[])",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name='input_train', shape=[num_pixel, num_train], initializer=tf.random_normal_initializer(), trainable=False, collections=[])",
                            "Call"
                        ]
                    ]
                }
            },
            "device_93": {
                "device_name": {
                    "value": "/gpu:0",
                    "possible_values": []
                }
            },
            "Session_102": {
                "config": {
                    "value": "tf.ConfigProto(gpu_options=gpu_options)",
                    "possible_values": []
                }
            },
            "random_normal_initializer_53": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "random_normal_initializer_56": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "random_normal_initializer_59": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "shape_70": {
                "input": {
                    "value": "output_train",
                    "possible_values": [
                        [
                            "tf.matmul(RF, input_train)",
                            "Call"
                        ],
                        [
                            "output_train + tf.random_normal(tf.shape(output_train), 0, tf.sqrt(tf.abs(output_train)))",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(RF, input_train)",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_71": {
                "x": {
                    "value": "tf.abs(output_train)",
                    "possible_values": []
                }
            },
            "shape_72": {
                "input": {
                    "value": "output_val",
                    "possible_values": [
                        [
                            "tf.matmul(RF, input_val)",
                            "Call"
                        ],
                        [
                            "output_val + tf.random_normal(tf.shape(output_val), 0, tf.sqrt(tf.abs(output_val)))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "sqrt_73": {
                "x": {
                    "value": "tf.abs(output_val)",
                    "possible_values": []
                }
            },
            "ConfigProto_75": {
                "gpu_options": {
                    "value": "gpu_options",
                    "possible_values": [
                        [
                            "tf.GPUOptions()",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_99": {
                "input": {
                    "value": "output_train",
                    "possible_values": [
                        [
                            "tf.matmul(RF, input_train)",
                            "Call"
                        ],
                        [
                            "output_train + tf.random_normal(tf.shape(output_train), 0, tf.sqrt(tf.abs(output_train)))",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(RF, input_train)",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_100": {
                "x": {
                    "value": "tf.abs(output_train)",
                    "possible_values": []
                }
            },
            "abs_71": {
                "x": {
                    "value": "output_train",
                    "possible_values": [
                        [
                            "tf.matmul(RF, input_train)",
                            "Call"
                        ],
                        [
                            "output_train + tf.random_normal(tf.shape(output_train), 0, tf.sqrt(tf.abs(output_train)))",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(RF, input_train)",
                            "Call"
                        ]
                    ]
                }
            },
            "abs_73": {
                "x": {
                    "value": "output_val",
                    "possible_values": [
                        [
                            "tf.matmul(RF, input_val)",
                            "Call"
                        ],
                        [
                            "output_val + tf.random_normal(tf.shape(output_val), 0, tf.sqrt(tf.abs(output_val)))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "random_normal_initializer_95": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "abs_100": {
                "x": {
                    "value": "output_train",
                    "possible_values": [
                        [
                            "tf.matmul(RF, input_train)",
                            "Call"
                        ],
                        [
                            "output_train + tf.random_normal(tf.shape(output_train), 0, tf.sqrt(tf.abs(output_train)))",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(RF, input_train)",
                            "Call"
                        ]
                    ]
                }
            },
            "ConfigProto_102": {
                "gpu_options": {
                    "value": "gpu_options",
                    "possible_values": [
                        [
                            "tf.GPUOptions()",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "training.py": {
        "tensorflow": {
            "set_random_seed_190": {
                "seed": {
                    "value": "tf_seed",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Session_191": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "global_variables_initializer_192": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            }
        }
    },
    "v1data/convnet.py": {
        "tensorflow": {
            "constant_14": {
                "variable": {
                    "value": "lap",
                    "possible_values": []
                },
                "value": {
                    "value": "[[0.25, 0.5, 0.25], [0.5, -3.0, 0.5], [0.25, 0.5, 0.25]]",
                    "possible_values": []
                }
            },
            "expand_dims_15": {
                "input": {
                    "value": "lap",
                    "possible_values": [
                        [
                            "tf.constant([[0.25, 0.5, 0.25], [0.5, -3.0, 0.5], [0.25, 0.5, 0.25]])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(lap, 2), 3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "possible_values": []
                }
            },
            "depthwise_conv2d_17": {
                "variable": {
                    "value": "W_lap",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.transpose(W, perm=[3, 0, 1, 2])",
                    "possible_values": []
                },
                "filter": {
                    "value": "tf.tile(lap, [1, 1, out_channels, 1])",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "possible_values": []
                }
            },
            "reduce_sum_20": {
                "input_tensor": {
                    "value": "tf.square(W)",
                    "possible_values": []
                },
                "axis": {
                    "value": "[0, 1]",
                    "possible_values": []
                }
            },
            "identity_21": {
                "variable": {
                    "value": "penalty",
                    "possible_values": []
                },
                "input": {
                    "value": "weight * penalty",
                    "possible_values": []
                },
                "name": {
                    "value": "penalty",
                    "possible_values": []
                }
            },
            "reduce_sum_28": {
                "input_tensor": {
                    "value": "tf.square(W)",
                    "possible_values": []
                },
                "axis": {
                    "value": "[0, 1]",
                    "possible_values": []
                }
            },
            "identity_29": {
                "variable": {
                    "value": "penalty",
                    "possible_values": []
                },
                "input": {
                    "value": "weight * penalty",
                    "possible_values": []
                },
                "name": {
                    "value": "penalty",
                    "possible_values": []
                }
            },
            "log_35": {
                "x": {
                    "value": "tf.exp(x) + 1",
                    "possible_values": []
                },
                "name": {
                    "value": "elu",
                    "possible_values": []
                }
            },
            "reduce_mean_43": {
                "input_tensor": {
                    "value": "tf.reduce_sum(prediction - response * tf.log(prediction + 1e-05), 1)",
                    "possible_values": []
                },
                "name": {
                    "value": "poisson",
                    "possible_values": []
                }
            },
            "Session_92": {
                "variable": {
                    "value": "self.session",
                    "possible_values": []
                },
                "graph": {
                    "value": "self.graph",
                    "possible_values": []
                }
            },
            "Saver_94": {
                "variable": {
                    "value": "self.saver",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "variable_scope_13": {
                "name_or_scope": {
                    "value": "smoothness",
                    "possible_values": []
                }
            },
            "add_to_collection_22": {
                "name": {
                    "value": "smoothness_regularizer_2d",
                    "possible_values": []
                },
                "value": {
                    "value": "penalty",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.reduce_sum(tf.square(W_lap), [1, 2]) / tf.transpose(tf.reduce_sum(tf.square(W), [0, 1])))",
                            "Call"
                        ],
                        [
                            "tf.identity(weight * penalty, name='penalty')",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(tf.sqrt(tf.reduce_sum(tf.square(W), [0, 1])))",
                            "Call"
                        ],
                        [
                            "tf.identity(weight * penalty, name='penalty')",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_27": {
                "name_or_scope": {
                    "value": "group_sparsity",
                    "possible_values": []
                }
            },
            "add_to_collection_30": {
                "name": {
                    "value": "group_sparsity_regularizer_2d",
                    "possible_values": []
                },
                "value": {
                    "value": "penalty",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.reduce_sum(tf.square(W_lap), [1, 2]) / tf.transpose(tf.reduce_sum(tf.square(W), [0, 1])))",
                            "Call"
                        ],
                        [
                            "tf.identity(weight * penalty, name='penalty')",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(tf.sqrt(tf.reduce_sum(tf.square(W), [0, 1])))",
                            "Call"
                        ],
                        [
                            "tf.identity(weight * penalty, name='penalty')",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_43": {
                "input_tensor": {
                    "value": "prediction - response * tf.log(prediction + 1e-05)",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "possible_values": []
                }
            },
            "placeholder_85": {
                "variable": {
                    "value": "self.is_training",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "possible_values": []
                }
            },
            "placeholder_86": {
                "variable": {
                    "value": "self.learning_rate",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                }
            },
            "placeholder_87": {
                "variable": {
                    "value": "self.images",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, data.px_y, data.px_x, 1]",
                    "possible_values": []
                }
            },
            "placeholder_88": {
                "variable": {
                    "value": "self.responses",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, data.num_neurons]",
                    "possible_values": []
                }
            },
            "get_collection_125": {
                "variable": {
                    "value": "update_ops",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.UPDATE_OPS",
                    "possible_values": []
                }
            },
            "get_total_loss_300": {
                "variable": {
                    "value": "self.total_loss",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "add_n_303": {
                "variable": {
                    "value": "self.smoothness_regularizer",
                    "possible_values": []
                },
                "inputs": {
                    "value": "tf.get_collection('smoothness_regularizer_2d')",
                    "possible_values": []
                }
            },
            "add_n_304": {
                "variable": {
                    "value": "self.group_sparsity_regularizer",
                    "possible_values": []
                },
                "inputs": {
                    "value": "tf.get_collection('group_sparsity_regularizer_2d')",
                    "possible_values": []
                }
            },
            "AdamOptimizer_307": {
                "variable": {
                    "value": "self.train_step",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.learning_rate",
                    "possible_values": []
                }
            },
            "squeeze_339": {
                "variable": {
                    "value": "self.prediction",
                    "possible_values": []
                },
                "input": {
                    "value": "tmp",
                    "possible_values": [
                        [
                            "tf.contrib.layers.convolution2d(self.images, self.data.num_neurons, self.data.px_x, 1, 'VALID', activation_fn=tf.exp, normalizer_fn=None, weights_initializer=tf.truncated_normal_initializer(stddev=0.01), weights_regularizer=lambda w: smoothness_regularizer_2d(w, smooth_reg_weight) + tf.contrib.layers.l1_regularizer(sparse_reg_weight)(w), biases_initializer=tf.constant_initializer(value=-1.0), scope='lnp')",
                            "Call"
                        ]
                    ]
                },
                "squeeze_dims": {
                    "value": "[1, 2]",
                    "possible_values": []
                }
            },
            "AdamOptimizer_342": {
                "variable": {
                    "value": "self.train_step",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.learning_rate",
                    "possible_values": []
                }
            },
            "transpose_17": {
                "a": {
                    "value": "W",
                    "possible_values": [
                        [
                            "tf.get_variable('weights')",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[3, 0, 1, 2]",
                    "possible_values": []
                }
            },
            "tile_18": {
                "input": {
                    "value": "lap",
                    "possible_values": [
                        [
                            "tf.constant([[0.25, 0.5, 0.25], [0.5, -3.0, 0.5], [0.25, 0.5, 0.25]])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(lap, 2), 3)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, out_channels, 1]",
                    "possible_values": []
                }
            },
            "sqrt_28": {
                "x": {
                    "value": "tf.reduce_sum(tf.square(W), [0, 1])",
                    "possible_values": []
                }
            },
            "exp_35": {
                "x": {
                    "value": "x",
                    "possible_values": [
                        [
                            "zscore(x[:, :, :, 0])",
                            "Call"
                        ],
                        [
                            "max_idx % s[2]",
                            "BinOp"
                        ],
                        [
                            "self.images if not i else self.conv[i - 1]",
                            "IfExp"
                        ]
                    ]
                }
            },
            "Graph_84": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "global_variables_initializer_93": {
                "params": {
                    "value": "default",
                    "possible_values": []
                }
            },
            "reshape_238": {
                "variable": {
                    "value": "conv_flat",
                    "possible_values": []
                },
                "tensor": {
                    "value": "c",
                    "possible_values": [
                        [
                            "layers.convolution2d(inputs=x, num_outputs=out_chans, kernel_size=int(filter_size), stride=int(stride), padding=padding, activation_fn=elu if i < len(filter_sizes) - 1 else None, normalizer_fn=layers.batch_norm, normalizer_params=bn_params, weights_initializer=tf.truncated_normal_initializer(mean=0.0, stddev=0.01), weights_regularizer=reg, scope=scope)",
                            "Call"
                        ],
                        [
                            "layers.flatten(c)",
                            "Call"
                        ],
                        [
                            "layers.dropout(c, 0.5, is_training=self.is_training)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, px_conv, out_channels[-1], 1]",
                    "possible_values": []
                }
            },
            "reshape_259": {
                "variable": {
                    "value": "W_spatial_flat",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.W_spatial",
                    "possible_values": []
                },
                "shape": {
                    "value": "[px_conv, 1, 1, self.data.num_neurons]",
                    "possible_values": []
                }
            },
            "abs_260": {
                "variable": {
                    "value": "W_spatial_flat",
                    "possible_values": []
                },
                "x": {
                    "value": "W_spatial_flat",
                    "possible_values": [
                        [
                            "tf.reshape(self.W_spatial, [px_conv, 1, 1, self.data.num_neurons])",
                            "Call"
                        ],
                        [
                            "tf.abs(W_spatial_flat)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_261": {
                "variable": {
                    "value": "h_spatial",
                    "possible_values": []
                },
                "input": {
                    "value": "conv_flat",
                    "possible_values": [
                        [
                            "tf.reshape(c, [-1, px_conv, out_channels[-1], 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "W_spatial_flat",
                    "possible_values": [
                        [
                            "tf.reshape(self.W_spatial, [px_conv, 1, 1, self.data.num_neurons])",
                            "Call"
                        ],
                        [
                            "tf.abs(W_spatial_flat)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "possible_values": []
                }
            },
            "get_variable_262": {
                "variable": {
                    "value": "self.W_features",
                    "possible_values": []
                },
                "name": {
                    "value": "W_features",
                    "possible_values": []
                },
                "shape": {
                    "value": "[out_channels[-1], self.data.num_neurons]",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.truncated_normal_initializer(mean=0.0, stddev=0.01)",
                    "possible_values": []
                }
            },
            "abs_265": {
                "variable": {
                    "value": "self.W_features",
                    "possible_values": []
                },
                "x": {
                    "value": "self.W_features",
                    "possible_values": []
                }
            },
            "reduce_sum_266": {
                "variable": {
                    "value": "self.h_out",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.multiply(h_spatial, self.W_features)",
                    "possible_values": []
                },
                "axis": {
                    "value": "[1, 2]",
                    "possible_values": []
                }
            },
            "get_variable_276": {
                "variable": {
                    "value": "self.b_out",
                    "possible_values": []
                },
                "name": {
                    "value": "b_out",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.data.num_neurons]",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(b)",
                    "possible_values": []
                }
            },
            "flatten_283": {
                "variable": {
                    "value": "c",
                    "possible_values": []
                },
                "structure": {
                    "value": "c",
                    "possible_values": [
                        [
                            "layers.convolution2d(inputs=x, num_outputs=out_chans, kernel_size=int(filter_size), stride=int(stride), padding=padding, activation_fn=elu if i < len(filter_sizes) - 1 else None, normalizer_fn=layers.batch_norm, normalizer_params=bn_params, weights_initializer=tf.truncated_normal_initializer(mean=0.0, stddev=0.01), weights_regularizer=reg, scope=scope)",
                            "Call"
                        ],
                        [
                            "layers.flatten(c)",
                            "Call"
                        ],
                        [
                            "layers.dropout(c, 0.5, is_training=self.is_training)",
                            "Call"
                        ]
                    ]
                }
            },
            "dropout_284": {
                "variable": {
                    "value": "c",
                    "possible_values": []
                },
                "x": {
                    "value": "c",
                    "possible_values": [
                        [
                            "layers.convolution2d(inputs=x, num_outputs=out_chans, kernel_size=int(filter_size), stride=int(stride), padding=padding, activation_fn=elu if i < len(filter_sizes) - 1 else None, normalizer_fn=layers.batch_norm, normalizer_params=bn_params, weights_initializer=tf.truncated_normal_initializer(mean=0.0, stddev=0.01), weights_regularizer=reg, scope=scope)",
                            "Call"
                        ],
                        [
                            "layers.flatten(c)",
                            "Call"
                        ],
                        [
                            "layers.dropout(c, 0.5, is_training=self.is_training)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "0.5",
                    "possible_values": []
                },
                "is_training": {
                    "value": "self.is_training",
                    "possible_values": []
                }
            },
            "add_loss_299": {
                "loss": {
                    "value": "self.poisson",
                    "possible_values": []
                }
            },
            "get_variable_337": {
                "variable": {
                    "value": "self.weights",
                    "possible_values": []
                },
                "name": {
                    "value": "weights",
                    "possible_values": []
                }
            },
            "get_variable_338": {
                "variable": {
                    "value": "self.biases",
                    "possible_values": []
                },
                "name": {
                    "value": "biases",
                    "possible_values": []
                }
            },
            "transpose_20": {
                "a": {
                    "value": "tf.reduce_sum(tf.square(W), [0, 1])",
                    "possible_values": []
                }
            },
            "get_variable_224": {
                "variable": {
                    "value": "W",
                    "possible_values": []
                },
                "name": {
                    "value": "weights",
                    "possible_values": []
                }
            },
            "get_variable_240": {
                "variable": {
                    "value": "self.W_spatial",
                    "possible_values": []
                },
                "name": {
                    "value": "W_spatial",
                    "possible_values": []
                },
                "shape": {
                    "value": "[px_conv, self.data.num_neurons]",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.truncated_normal_initializer(mean=0.0, stddev=0.01)",
                    "possible_values": []
                }
            },
            "get_variable_254": {
                "variable": {
                    "value": "self.W_spatial",
                    "possible_values": []
                },
                "name": {
                    "value": "W_spatial",
                    "possible_values": []
                },
                "shape": {
                    "value": "[px_conv, self.data.num_neurons]",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(w_init)",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "possible_values": []
                }
            },
            "add_loss_273": {
                "loss": {
                    "value": "self.readout_sparseness_regularizer",
                    "possible_values": []
                },
                "loss_collection": {
                    "value": "tf.GraphKeys.REGULARIZATION_LOSSES",
                    "possible_values": []
                }
            },
            "add_loss_295": {
                "loss": {
                    "value": "self.readout_sparseness_regularizer",
                    "possible_values": []
                },
                "loss_collection": {
                    "value": "tf.GraphKeys.REGULARIZATION_LOSSES",
                    "possible_values": []
                }
            },
            "get_collection_303": {
                "key": {
                    "value": "smoothness_regularizer_2d",
                    "possible_values": []
                }
            },
            "get_collection_304": {
                "key": {
                    "value": "group_sparsity_regularizer_2d",
                    "possible_values": []
                }
            },
            "variable_scope_336": {
                "name_or_scope": {
                    "value": "lnp",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "add_n_341": {
                "inputs": {
                    "value": "tf.get_collection(tf.GraphKeys.REGULARIZATION_LOSSES)",
                    "possible_values": []
                }
            },
            "square_20": {
                "x": {
                    "value": "W",
                    "possible_values": [
                        [
                            "tf.get_variable('weights')",
                            "Call"
                        ]
                    ]
                }
            },
            "square_28": {
                "x": {
                    "value": "W",
                    "possible_values": [
                        [
                            "tf.get_variable('weights')",
                            "Call"
                        ]
                    ]
                }
            },
            "log_43": {
                "x": {
                    "value": "prediction + 1e-05",
                    "possible_values": []
                }
            },
            "variable_scope_223": {
                "name_or_scope": {
                    "value": "scope",
                    "possible_values": [
                        [
                            "'conv{}'.format(i)",
                            "Call"
                        ]
                    ]
                },
                "reuse": {
                    "value": "True",
                    "possible_values": []
                }
            },
            "multiply_266": {
                "x": {
                    "value": "h_spatial",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(conv_flat, W_spatial_flat, strides=[1, 1, 1, 1], padding='VALID')",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.W_features",
                    "possible_values": []
                }
            },
            "reduce_sum_269": {
                "input_tensor": {
                    "value": "tf.reduce_sum(tf.abs(self.W_spatial), 0) * tf.reduce_sum(tf.abs(self.W_features), 0)",
                    "possible_values": []
                }
            },
            "reduce_sum_293": {
                "input_tensor": {
                    "value": "tf.reduce_mean(self.prediction, 0)",
                    "possible_values": []
                }
            },
            "truncated_normal_initializer_331": {
                "stddev": {
                    "value": "0.01",
                    "possible_values": []
                }
            },
            "constant_initializer_334": {
                "value": {
                    "value": "-1.0",
                    "possible_values": []
                }
            },
            "get_collection_341": {
                "key": {
                    "value": "tf.GraphKeys.REGULARIZATION_LOSSES",
                    "possible_values": []
                }
            },
            "truncated_normal_initializer_219": {
                "mean": {
                    "value": "0.0",
                    "possible_values": []
                },
                "stddev": {
                    "value": "0.01",
                    "possible_values": []
                }
            },
            "truncated_normal_initializer_264": {
                "mean": {
                    "value": "0.0",
                    "possible_values": []
                },
                "stddev": {
                    "value": "0.01",
                    "possible_values": []
                }
            },
            "constant_initializer_279": {
                "value": {
                    "value": "b",
                    "possible_values": [
                        [
                            "inv_elu(responses.mean(axis=0))",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_initializer_289": {
                "value": {
                    "value": "b",
                    "possible_values": [
                        [
                            "inv_elu(responses.mean(axis=0))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_294": {
                "input_tensor": {
                    "value": "self.prediction",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "truncated_normal_initializer_242": {
                "mean": {
                    "value": "0.0",
                    "possible_values": []
                },
                "stddev": {
                    "value": "0.01",
                    "possible_values": []
                }
            },
            "constant_initializer_256": {
                "value": {
                    "value": "w_init",
                    "possible_values": [
                        [
                            "np.zeros([self.data.num_neurons, px_x_conv, px_y_conv])",
                            "Call"
                        ],
                        [
                            "np.reshape(w_init, [w_init.shape[0], -1]).T",
                            "Attribute"
                        ]
                    ]
                }
            },
            "reduce_sum_270": {
                "input_tensor": {
                    "value": "tf.abs(self.W_spatial)",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "reduce_sum_271": {
                "input_tensor": {
                    "value": "tf.abs(self.W_features)",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "possible_values": []
                }
            },
            "abs_270": {
                "x": {
                    "value": "self.W_spatial",
                    "possible_values": []
                }
            },
            "abs_271": {
                "x": {
                    "value": "self.W_features",
                    "possible_values": []
                }
            }
        }
    },
    "v1data/populate.py": {
        "tensorflow": {}
    },
    "v1data/standalone.py": {
        "tensorflow": {}
    }
}