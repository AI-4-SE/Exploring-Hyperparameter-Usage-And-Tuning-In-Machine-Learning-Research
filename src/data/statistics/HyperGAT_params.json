{
    "generate_lda.py": {
        "sklearn": {
            "CountVectorizer_51": {
                "variable": {
                    "value": "vectorizer",
                    "type": "variable",
                    "possible_values": []
                },
                "stop_words": {
                    "value": "english",
                    "type": "str",
                    "possible_values": []
                },
                "max_df": {
                    "value": "0.98",
                    "type": "float",
                    "possible_values": []
                }
            },
            "LatentDirichletAllocation_54": {
                "variable": {
                    "value": "lda",
                    "type": "variable",
                    "possible_values": []
                },
                "n_components": {
                    "value": "args.topics",
                    "type": "Attribute",
                    "possible_values": []
                },
                "learning_method": {
                    "value": "online",
                    "type": "str",
                    "possible_values": []
                },
                "learning_offset": {
                    "value": "50.0",
                    "type": "float",
                    "possible_values": []
                },
                "random_state": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "model.py": {
        "sklearn": {
            "classification_report_152": {
                "variable": {
                    "value": "details",
                    "type": "variable",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "test_labels + list(targets)",
                            "BinOp"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "test_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "test_pred + list(trans_to_cpu(pre_indices).detach().numpy())",
                            "BinOp"
                        ]
                    ]
                },
                "digits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                }
            },
            "accuracy_score_153": {
                "variable": {
                    "value": "acc",
                    "type": "variable",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "test_labels + list(targets)",
                            "BinOp"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "test_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "test_pred + list(trans_to_cpu(pre_indices).detach().numpy())",
                            "BinOp"
                        ]
                    ]
                }
            },
            "classification_report_157": {
                "y_true": {
                    "value": "test_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "test_labels + list(targets)",
                            "BinOp"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "test_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "test_pred + list(trans_to_cpu(pre_indices).detach().numpy())",
                            "BinOp"
                        ]
                    ]
                },
                "digits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                }
            },
            "precision_recall_fscore_support_159": {
                "y_true": {
                    "value": "test_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "test_labels + list(targets)",
                            "BinOp"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "test_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "test_pred + list(trans_to_cpu(pre_indices).detach().numpy())",
                            "BinOp"
                        ]
                    ]
                },
                "average": {
                    "value": "macro",
                    "type": "str",
                    "possible_values": []
                }
            },
            "precision_recall_fscore_support_161": {
                "y_true": {
                    "value": "test_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "test_labels + list(targets)",
                            "BinOp"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "test_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "test_pred + list(trans_to_cpu(pre_indices).detach().numpy())",
                            "BinOp"
                        ]
                    ]
                },
                "average": {
                    "value": "micro",
                    "type": "str",
                    "possible_values": []
                }
            }
        },
        "torch": {
            "stack_112": {
                "variable": {
                    "value": "seq_hidden",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[get(i) for i in torch.arange(len(alias_inputs)).long()]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "is_available_14": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "is_available_21": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "dropout_36": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.gat1(x, H)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.gat2(x, H)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Embedding_55": {
                "variable": {
                    "value": "self.embedding",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "self.n_node + 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "self.initial_feature",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding_idx": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "LayerNorm_56": {
                "variable": {
                    "value": "self.layer_normH",
                    "type": "Attribute",
                    "possible_values": []
                },
                "normalized_shape": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "eps": {
                    "value": "1e-06",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Linear_60": {
                "variable": {
                    "value": "self.prediction_transform",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.n_categories",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "CrossEntropyLoss_71": {
                "variable": {
                    "value": "self.loss_function",
                    "type": "Attribute",
                    "possible_values": []
                },
                "weight": {
                    "value": "trans_to_cuda(torch.Tensor(self.class_weights).float())",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Adam_72": {
                "variable": {
                    "value": "self.optimizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "self.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "opt.lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "weight_decay": {
                    "value": "opt.l2",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "StepLR_73": {
                "variable": {
                    "value": "self.scheduler",
                    "type": "Attribute",
                    "possible_values": []
                },
                "optimizer": {
                    "value": "self.optimizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "step_size": {
                    "value": "opt.lr_dc_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "gamma": {
                    "value": "opt.lr_dc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "LayerNorm_58": {
                "variable": {
                    "value": "self.layer_normC",
                    "type": "Attribute",
                    "possible_values": []
                },
                "normalized_shape": {
                    "value": "self.n_categories",
                    "type": "Attribute",
                    "possible_values": []
                },
                "eps": {
                    "value": "1e-06",
                    "type": "float",
                    "possible_values": []
                }
            },
            "sum_86": {
                "input": {
                    "value": "node_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "trans_to_cuda(torch.Tensor(node_masks).float())",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "transpose_86": {
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dim0": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "arange_112": {
                "start": {
                    "value": "len(alias_inputs)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "preprocess.py": {
        "sklearn": {
            "compute_class_weight_105": {
                "variable": {
                    "value": "class_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "class_weight": {
                    "value": "balanced",
                    "type": "str",
                    "possible_values": []
                },
                "classes": {
                    "value": "np.unique(train_set_y)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "train_set_y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[j for (i, j) in doc_train_list]",
                            "ListComp"
                        ]
                    ]
                }
            }
        }
    },
    "run.py": {
        "sklearn": {}
    },
    "layers.py": {
        "torch": {
            "Parameter_25": {
                "variable": {
                    "value": "self.weight2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(self.in_features, self.out_features)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_26": {
                "variable": {
                    "value": "self.weight3",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(self.out_features, self.out_features)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Embedding_33": {
                "variable": {
                    "value": "self.word_context",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "self.out_features",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Parameter_35": {
                "variable": {
                    "value": "self.a",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.zeros(size=(2 * out_features, 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_36": {
                "variable": {
                    "value": "self.a2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.zeros(size=(2 * out_features, 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "LeakyReLU_37": {
                "variable": {
                    "value": "self.leakyrelu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "negative_slope": {
                    "value": "self.alpha",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cat_70": {
                "variable": {
                    "value": "x1",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[get(i) for i in torch.arange(x.shape[0]).long()]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "cat_75": {
                "variable": {
                    "value": "pair_h",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(q1, x1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "dropout_78": {
                "variable": {
                    "value": "pair_e",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pair_e",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.leakyrelu(torch.matmul(pair_h, self.a).squeeze()).t()",
                            "Call"
                        ],
                        [
                            "F.dropout(pair_e, self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.leakyrelu(torch.matmul(pair_h, self.a2).squeeze()).t()",
                            "Call"
                        ],
                        [
                            "F.dropout(pair_e, self.dropout, training=self.training)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sparse_coo_tensor_80": {
                "variable": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "pair",
                    "type": "variable",
                    "possible_values": [
                        [
                            "adj.nonzero().t()",
                            "Call"
                        ]
                    ]
                },
                "values": {
                    "value": "pair_e",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.leakyrelu(torch.matmul(pair_h, self.a).squeeze()).t()",
                            "Call"
                        ],
                        [
                            "F.dropout(pair_e, self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.leakyrelu(torch.matmul(pair_h, self.a2).squeeze()).t()",
                            "Call"
                        ],
                        [
                            "F.dropout(pair_e, self.dropout, training=self.training)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "torch.Size([x.shape[0], N1, N2])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_83": {
                "variable": {
                    "value": "attention",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "adj > 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.sparse_coo_tensor(pair, pair_e, torch.Size([x.shape[0], N1, N2])).to_dense()",
                            "Call"
                        ],
                        [
                            "torch.sparse_coo_tensor(pair, pair_e, torch.Size([x.shape[0], N1, N2])).to_dense()",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "zero_vec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-9000000000000000.0 * torch.ones_like(e)",
                            "BinOp"
                        ],
                        [
                            "-9000000000000000.0 * torch.ones_like(e)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "softmax_86": {
                "variable": {
                    "value": "attention_edge",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attention",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.where(adj > 0, e, zero_vec)",
                            "Call"
                        ],
                        [
                            "torch.where(adj > 0, e, zero_vec)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_88": {
                "variable": {
                    "value": "edge",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attention_edge",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.softmax(attention, dim=2)",
                            "Call"
                        ]
                    ]
                },
                "other": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.matmul(self.weight)",
                            "Call"
                        ],
                        [
                            "x + self.bias",
                            "BinOp"
                        ]
                    ]
                }
            },
            "dropout_90": {
                "variable": {
                    "value": "edge",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "edge",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.matmul(attention_edge, x)",
                            "Call"
                        ],
                        [
                            "F.dropout(edge, self.dropout, training=self.training)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cat_95": {
                "variable": {
                    "value": "y1",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[get(i) for i in torch.arange(x.shape[0]).long()]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "cat_98": {
                "variable": {
                    "value": "q1",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[get(i) for i in torch.arange(x.shape[0]).long()]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "cat_100": {
                "variable": {
                    "value": "pair_h",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(q1, y1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "dropout_103": {
                "variable": {
                    "value": "pair_e",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pair_e",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.leakyrelu(torch.matmul(pair_h, self.a).squeeze()).t()",
                            "Call"
                        ],
                        [
                            "F.dropout(pair_e, self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.leakyrelu(torch.matmul(pair_h, self.a2).squeeze()).t()",
                            "Call"
                        ],
                        [
                            "F.dropout(pair_e, self.dropout, training=self.training)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sparse_coo_tensor_105": {
                "variable": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "pair",
                    "type": "variable",
                    "possible_values": [
                        [
                            "adj.nonzero().t()",
                            "Call"
                        ]
                    ]
                },
                "values": {
                    "value": "pair_e",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.leakyrelu(torch.matmul(pair_h, self.a).squeeze()).t()",
                            "Call"
                        ],
                        [
                            "F.dropout(pair_e, self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.leakyrelu(torch.matmul(pair_h, self.a2).squeeze()).t()",
                            "Call"
                        ],
                        [
                            "F.dropout(pair_e, self.dropout, training=self.training)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "torch.Size([x.shape[0], N1, N2])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_108": {
                "variable": {
                    "value": "attention",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "adj > 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.sparse_coo_tensor(pair, pair_e, torch.Size([x.shape[0], N1, N2])).to_dense()",
                            "Call"
                        ],
                        [
                            "torch.sparse_coo_tensor(pair, pair_e, torch.Size([x.shape[0], N1, N2])).to_dense()",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "zero_vec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-9000000000000000.0 * torch.ones_like(e)",
                            "BinOp"
                        ],
                        [
                            "-9000000000000000.0 * torch.ones_like(e)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "softmax_110": {
                "variable": {
                    "value": "attention_node",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attention.transpose(1, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_112": {
                "variable": {
                    "value": "node",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attention_node",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.softmax(attention.transpose(1, 2), dim=2)",
                            "Call"
                        ]
                    ]
                },
                "other": {
                    "value": "edge",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.matmul(attention_edge, x)",
                            "Call"
                        ],
                        [
                            "F.dropout(edge, self.dropout, training=self.training)",
                            "Call"
                        ]
                    ]
                }
            },
            "Parameter_21": {
                "variable": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(self.in_features, self.out_features)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_29": {
                "variable": {
                    "value": "self.bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(self.out_features)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "elu_116": {
                "variable": {
                    "value": "node",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "node",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.matmul(attention_node, edge)",
                            "Call"
                        ],
                        [
                            "F.elu(node)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_35": {
                "size": {
                    "value": "(2 * out_features, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "zeros_36": {
                "size": {
                    "value": "(2 * out_features, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "isnan_77": {
                "input": {
                    "value": "pair_e",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.leakyrelu(torch.matmul(pair_h, self.a).squeeze()).t()",
                            "Call"
                        ],
                        [
                            "F.dropout(pair_e, self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.leakyrelu(torch.matmul(pair_h, self.a2).squeeze()).t()",
                            "Call"
                        ],
                        [
                            "F.dropout(pair_e, self.dropout, training=self.training)",
                            "Call"
                        ]
                    ]
                }
            },
            "any_77": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ones_like_82": {
                "input": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.sparse_coo_tensor(pair, pair_e, torch.Size([x.shape[0], N1, N2])).to_dense()",
                            "Call"
                        ],
                        [
                            "torch.sparse_coo_tensor(pair, pair_e, torch.Size([x.shape[0], N1, N2])).to_dense()",
                            "Call"
                        ]
                    ]
                }
            },
            "isnan_102": {
                "input": {
                    "value": "pair_e",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.leakyrelu(torch.matmul(pair_h, self.a).squeeze()).t()",
                            "Call"
                        ],
                        [
                            "F.dropout(pair_e, self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.leakyrelu(torch.matmul(pair_h, self.a2).squeeze()).t()",
                            "Call"
                        ],
                        [
                            "F.dropout(pair_e, self.dropout, training=self.training)",
                            "Call"
                        ]
                    ]
                }
            },
            "any_102": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ones_like_107": {
                "input": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.sparse_coo_tensor(pair, pair_e, torch.Size([x.shape[0], N1, N2])).to_dense()",
                            "Call"
                        ],
                        [
                            "torch.sparse_coo_tensor(pair, pair_e, torch.Size([x.shape[0], N1, N2])).to_dense()",
                            "Call"
                        ]
                    ]
                }
            },
            "arange_70": {
                "start": {
                    "value": "x.shape[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "matmul_76": {
                "input": {
                    "value": "pair_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.cat((q1, x1), dim=-1)",
                            "Call"
                        ],
                        [
                            "torch.cat((q1, y1), dim=-1)",
                            "Call"
                        ]
                    ]
                },
                "other": {
                    "value": "self.a",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "squeeze_76": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "arange_95": {
                "start": {
                    "value": "x.shape[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "arange_98": {
                "start": {
                    "value": "x.shape[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "matmul_101": {
                "input": {
                    "value": "pair_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.cat((q1, x1), dim=-1)",
                            "Call"
                        ],
                        [
                            "torch.cat((q1, y1), dim=-1)",
                            "Call"
                        ]
                    ]
                },
                "other": {
                    "value": "self.a2",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "squeeze_101": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    }
}