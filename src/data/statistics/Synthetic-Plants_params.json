{
    "code/stage_1/gridSearch.py": {
        "sklearn": {
            "ParameterGrid_22": {
                "param_grid": {
                    "value": "self.parameters",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ParameterGrid_24": {
                "param_grid": {
                    "value": "self.parameters",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "code/metrics.py": {
        "tensorflow": {
            "InceptionV3_38": {
                "variable": {
                    "value": "self.model",
                    "type": "Attribute",
                    "possible_values": []
                },
                "weights": {
                    "value": "imagenet",
                    "type": "str",
                    "possible_values": []
                },
                "include_top": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Model_44": {
                "variable": {
                    "value": "self.features_model",
                    "type": "Attribute",
                    "possible_values": []
                },
                "inputs": {
                    "value": "self.model.input",
                    "type": "Attribute",
                    "possible_values": []
                },
                "outputs": {
                    "value": "self.model.get_layer(feature_name).output",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Model_45": {
                "variable": {
                    "value": "self.logits_model",
                    "type": "Attribute",
                    "possible_values": []
                },
                "inputs": {
                    "value": "self.model.input",
                    "type": "Attribute",
                    "possible_values": []
                },
                "outputs": {
                    "value": "self.model.get_layer(output_name).output",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "code/stage_1/dcgan.py": {
        "tensorflow": {
            "set_verbosity_14": {
                "level": {
                    "value": "tf.logging.ERROR",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Sequential_48": {
                "variable": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Sequential_77": {
                "variable": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Input_110": {
                "variable": {
                    "value": "gan_input",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(self.latent_dim,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Model_113": {
                "variable": {
                    "value": "gan",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "gan_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Input(shape=(self.latent_dim,))",
                            "Call"
                        ]
                    ]
                },
                "outputs": {
                    "value": "gan_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.discriminator(self.generator(gan_input))",
                            "Call"
                        ]
                    ]
                }
            },
            "device_41": {
                "device_name": {
                    "value": "gpu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Dense_51": {
                "units": {
                    "value": "starting * self.startingSize ** 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                },
                "input_dim": {
                    "value": "self.latent_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Reshape_52": {
                "target_shape": {
                    "value": "(self.startingSize, self.startingSize, starting)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "BatchNormalization_53": {
                "momentum": {
                    "value": "0.8",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Conv2D_63": {
                "filters": {
                    "value": "self.outputFilter",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "self.kernel_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Activation_64": {
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "BatchNormalization_65": {
                "momentum": {
                    "value": "0.8",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Conv2D_67": {
                "filters": {
                    "value": "self.channels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Activation_68": {
                "activation": {
                    "value": "tanh",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GaussianNoise_80": {
                "stddev": {
                    "value": "0.2",
                    "type": "float",
                    "possible_values": []
                },
                "input_shape": {
                    "value": "self.img_shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_82": {
                "filters": {
                    "value": "self.outputFilter",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "self.kernel_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "input_shape": {
                    "value": "self.img_shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "LeakyReLU_83": {
                "alpha": {
                    "value": "0.2",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dropout_84": {
                "rate": {
                    "value": "0.25",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Flatten_95": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Dense_96": {
                "units": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "sigmoid",
                    "type": "str",
                    "possible_values": []
                }
            },
            "UpSampling2D_57": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Conv2D_59": {
                "filters": {
                    "value": "self.outputFilter * 2 ** (self.upSamplingLayer - i)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "self.kernel_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Activation_60": {
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "BatchNormalization_61": {
                "momentum": {
                    "value": "0.8",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Conv2D_89": {
                "filters": {
                    "value": "self.outputFilter * 2 ** (i + 1)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "self.kernel_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "LeakyReLU_91": {
                "alpha": {
                    "value": "0.2",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dropout_92": {
                "rate": {
                    "value": "0.25",
                    "type": "float",
                    "possible_values": []
                }
            },
            "BatchNormalization_93": {
                "momentum": {
                    "value": "0.8",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Adam_98": {
                "lr": {
                    "value": "self.d_lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "beta_1": {
                    "value": "self.d_beta_1",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Adam_115": {
                "lr": {
                    "value": "self.g_lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "beta_1": {
                    "value": "self.g_beta_1",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "code/stage_1/gan.py": {
        "tensorflow": {
            "FileWriter_145": {
                "variable": {
                    "value": "summary_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "self.logs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "max_queue": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Summary_170": {
                "variable": {
                    "value": "summary",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Summary_205": {
                "variable": {
                    "value": "summary",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "code/stage_1/wgangp.py": {
        "tensorflow": {
            "square_49": {
                "variable": {
                    "value": "gradients_sqr",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "gradients",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.gradients(y_pred, averaged_samples)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "sum_51": {
                "variable": {
                    "value": "gradients_sqr_sum",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "gradients_sqr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.square(gradients)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "np.arange(1, len(gradients_sqr.shape))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_53": {
                "variable": {
                    "value": "gradient_l2_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "gradients_sqr_sum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.sum(gradients_sqr, axis=np.arange(1, len(gradients_sqr.shape)))",
                            "Call"
                        ]
                    ]
                }
            },
            "square_55": {
                "variable": {
                    "value": "gradient_penalty",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1 - gradient_l2_norm",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Sequential_67": {
                "variable": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Input_82": {
                "variable": {
                    "value": "noise",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(self.latent_dim,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Sequential_89": {
                "variable": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Input_110": {
                "variable": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "self.img_shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Input_123": {
                "variable": {
                    "value": "real_img",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "self.img_shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Input_126": {
                "variable": {
                    "value": "z_disc",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(self.latent_dim,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Model_146": {
                "variable": {
                    "value": "critic_model",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[real_img, z_disc]",
                    "type": "List",
                    "possible_values": []
                },
                "outputs": {
                    "value": "[valid, fake, validity_interpolated]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Input_156": {
                "variable": {
                    "value": "z_gen",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(self.latent_dim,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Model_165": {
                "variable": {
                    "value": "generator_model",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "z_gen",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Input(shape=(self.latent_dim,))",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "valid",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.critic(real_img)",
                            "Call"
                        ],
                        [
                            "self.critic(img)",
                            "Call"
                        ],
                        [
                            "-np.ones((self.batch_size, 1))",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "mean_57": {
                "a": {
                    "value": "gradient_penalty",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.square(1 - gradient_l2_norm)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_61": {
                "a": {
                    "value": "y_true * y_pred",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Model_85": {
                "*args": {
                    "value": "noise",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Input(shape=(self.latent_dim,))",
                            "Call"
                        ],
                        [
                            "np.random.normal(0, 1, (l, self.latent_dim))",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model(noise)",
                            "Call"
                        ],
                        [
                            "Input(shape=self.img_shape)",
                            "Call"
                        ],
                        [
                            "self.generator(z_gen)",
                            "Call"
                        ]
                    ]
                }
            },
            "Model_113": {
                "*args": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model(noise)",
                            "Call"
                        ],
                        [
                            "Input(shape=self.img_shape)",
                            "Call"
                        ],
                        [
                            "self.generator(z_gen)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "validity",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model(img)",
                            "Call"
                        ]
                    ]
                }
            },
            "device_38": {
                "device_name": {
                    "value": "gpu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "gradients_47": {
                "ys": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "y_pred",
                            "Method Argument"
                        ],
                        [
                            "y_pred",
                            "Method Argument"
                        ]
                    ]
                },
                "xs": {
                    "value": "averaged_samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "averaged_samples",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Dense_69": {
                "units": {
                    "value": "128 * input_size * input_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                },
                "input_dim": {
                    "value": "self.latent_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Reshape_70": {
                "target_shape": {
                    "value": "(input_size, input_size, 128)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "UpSampling2D_71": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Conv2D_72": {
                "filters": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "BatchNormalization_73": {
                "momentum": {
                    "value": "0.8",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Activation_74": {
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "UpSampling2D_75": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Conv2D_76": {
                "filters": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "BatchNormalization_77": {
                "momentum": {
                    "value": "0.8",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Activation_78": {
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Conv2D_79": {
                "filters": {
                    "value": "self.channels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Activation_80": {
                "activation": {
                    "value": "tanh",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Conv2D_91": {
                "filters": {
                    "value": "16",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "input_shape": {
                    "value": "self.img_shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "LeakyReLU_92": {
                "alpha": {
                    "value": "0.2",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dropout_93": {
                "rate": {
                    "value": "0.25",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Conv2D_94": {
                "filters": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ZeroPadding2D_95": {
                "padding": {
                    "value": "((0, 1), (0, 1))",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "BatchNormalization_96": {
                "momentum": {
                    "value": "0.8",
                    "type": "float",
                    "possible_values": []
                }
            },
            "LeakyReLU_97": {
                "alpha": {
                    "value": "0.2",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dropout_98": {
                "rate": {
                    "value": "0.25",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Conv2D_99": {
                "filters": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "BatchNormalization_100": {
                "momentum": {
                    "value": "0.8",
                    "type": "float",
                    "possible_values": []
                }
            },
            "LeakyReLU_101": {
                "alpha": {
                    "value": "0.2",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dropout_102": {
                "rate": {
                    "value": "0.25",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Conv2D_103": {
                "filters": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "BatchNormalization_104": {
                "momentum": {
                    "value": "0.8",
                    "type": "float",
                    "possible_values": []
                }
            },
            "LeakyReLU_105": {
                "alpha": {
                    "value": "0.2",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dropout_106": {
                "rate": {
                    "value": "0.25",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Flatten_107": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Dense_108": {
                "units": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "RMSprop_147": {
                "lr": {
                    "value": "self.c_lr",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "RMSprop_166": {
                "lr": {
                    "value": "self.g_lr",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "code/stage_2/help.py": {
        "tensorflow": {
            "shape_212": {
                "variable": {
                    "value": "ori_image_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.random_flip_left_right(image, seed=seed)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [augment_height, augment_width])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, ori_image_shape, seed=seed)",
                            "Call"
                        ],
                        [
                            "image in enumerate(images)",
                            "Call"
                        ],
                        [
                            "image",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "random_flip_left_right_213": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.random_flip_left_right(image, seed=seed)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [augment_height, augment_width])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, ori_image_shape, seed=seed)",
                            "Call"
                        ],
                        [
                            "image in enumerate(images)",
                            "Call"
                        ],
                        [
                            "image",
                            "Method Argument"
                        ]
                    ]
                },
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random.randint(0, 2 ** 31 - 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "random_crop_215": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.random_flip_left_right(image, seed=seed)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [augment_height, augment_width])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, ori_image_shape, seed=seed)",
                            "Call"
                        ],
                        [
                            "image in enumerate(images)",
                            "Call"
                        ],
                        [
                            "image",
                            "Method Argument"
                        ]
                    ]
                },
                "size": {
                    "value": "ori_image_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(image)",
                            "Call"
                        ]
                    ]
                },
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random.randint(0, 2 ** 31 - 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_217": {
                "variable": {
                    "value": "ori_segmap_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "segmap",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.random_flip_left_right(segmap, seed=seed)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(segmap, [augment_height, augment_width], method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(segmap, ori_segmap_shape, seed=seed)",
                            "Call"
                        ],
                        [
                            "segmap",
                            "Method Argument"
                        ],
                        [
                            "segmap",
                            "Method Argument"
                        ],
                        [
                            "segmap",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "random_flip_left_right_218": {
                "variable": {
                    "value": "segmap",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "segmap",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.random_flip_left_right(segmap, seed=seed)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(segmap, [augment_height, augment_width], method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(segmap, ori_segmap_shape, seed=seed)",
                            "Call"
                        ],
                        [
                            "segmap",
                            "Method Argument"
                        ],
                        [
                            "segmap",
                            "Method Argument"
                        ],
                        [
                            "segmap",
                            "Method Argument"
                        ]
                    ]
                },
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random.randint(0, 2 ** 31 - 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "random_crop_220": {
                "variable": {
                    "value": "segmap",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "segmap",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.random_flip_left_right(segmap, seed=seed)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(segmap, [augment_height, augment_width], method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(segmap, ori_segmap_shape, seed=seed)",
                            "Call"
                        ],
                        [
                            "segmap",
                            "Method Argument"
                        ],
                        [
                            "segmap",
                            "Method Argument"
                        ],
                        [
                            "segmap",
                            "Method Argument"
                        ]
                    ]
                },
                "size": {
                    "value": "ori_segmap_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(segmap)",
                            "Call"
                        ]
                    ]
                },
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random.randint(0, 2 ** 31 - 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "trainable_variables_249": {
                "variable": {
                    "value": "model_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "read_file_40": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "filename",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "decode_jpeg_41": {
                "variable": {
                    "value": "x_decode",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.eye(nb_classes)[targets]",
                            "Subscript"
                        ],
                        [
                            "tf.read_file(filename)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "channels": {
                    "value": "self.channels - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dct_method": {
                    "value": "INTEGER_ACCURATE",
                    "type": "str",
                    "possible_values": []
                }
            },
            "read_file_44": {
                "variable": {
                    "value": "nir",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "nir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image_path + '_nir.png'",
                            "BinOp"
                        ],
                        [
                            "np.expand_dims(x[:, :, :, 3], 3)",
                            "Call"
                        ],
                        [
                            "np.repeat(nir, 3, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.read_file(nir)",
                            "Call"
                        ],
                        [
                            "nir",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "decode_jpeg_45": {
                "variable": {
                    "value": "nir_decode",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "nir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image_path + '_nir.png'",
                            "BinOp"
                        ],
                        [
                            "np.expand_dims(x[:, :, :, 3], 3)",
                            "Call"
                        ],
                        [
                            "np.repeat(nir, 3, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.read_file(nir)",
                            "Call"
                        ],
                        [
                            "nir",
                            "Method Argument"
                        ]
                    ]
                },
                "channels": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dct_method": {
                    "value": "INTEGER_ACCURATE",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_49": {
                "variable": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[img, nir_img]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "read_file_53": {
                "variable": {
                    "value": "segmap_x",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "segmap",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.random_flip_left_right(segmap, seed=seed)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(segmap, [augment_height, augment_width], method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(segmap, ori_segmap_shape, seed=seed)",
                            "Call"
                        ],
                        [
                            "segmap",
                            "Method Argument"
                        ],
                        [
                            "segmap",
                            "Method Argument"
                        ],
                        [
                            "segmap",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "decode_jpeg_54": {
                "variable": {
                    "value": "segmap_decode",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "segmap_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.read_file(segmap)",
                            "Call"
                        ],
                        [
                            "tf.read_file(segmap)",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "self.segmap_channel",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dct_method": {
                    "value": "INTEGER_ACCURATE",
                    "type": "str",
                    "possible_values": []
                }
            },
            "one_hot_67": {
                "variable": {
                    "value": "segmap_onehot",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "label_map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "convert_from_color_segmentation(color_value_dict, segmap_img, tensor_type=False)",
                            "Call"
                        ],
                        [
                            "convert_from_color_segmentation(self.color_value_dict, segmap_img, tensor_type=True)",
                            "Call"
                        ],
                        [
                            "convert_from_color_segmentation(self.color_value_dict, segmap_img, tensor_type=True)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "len(self.color_value_dict)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "read_file_72": {
                "variable": {
                    "value": "segmap_x",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "segmap",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.random_flip_left_right(segmap, seed=seed)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(segmap, [augment_height, augment_width], method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(segmap, ori_segmap_shape, seed=seed)",
                            "Call"
                        ],
                        [
                            "segmap",
                            "Method Argument"
                        ],
                        [
                            "segmap",
                            "Method Argument"
                        ],
                        [
                            "segmap",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "decode_jpeg_73": {
                "variable": {
                    "value": "segmap_decode",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "segmap_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.read_file(segmap)",
                            "Call"
                        ],
                        [
                            "tf.read_file(segmap)",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "self.segmap_channel",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dct_method": {
                    "value": "INTEGER_ACCURATE",
                    "type": "str",
                    "possible_values": []
                }
            },
            "one_hot_77": {
                "variable": {
                    "value": "segmap_onehot",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "label_map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "convert_from_color_segmentation(color_value_dict, segmap_img, tensor_type=False)",
                            "Call"
                        ],
                        [
                            "convert_from_color_segmentation(self.color_value_dict, segmap_img, tensor_type=True)",
                            "Call"
                        ],
                        [
                            "convert_from_color_segmentation(self.color_value_dict, segmap_img, tensor_type=True)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "len(self.color_value_dict)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_261": {
                "variable": {
                    "value": "arr_2d",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[tf.shape(arr_3d)[0], tf.shape(arr_3d)[1]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.uint8",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_264": {
                "variable": {
                    "value": "color_array",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "np.asarray(c, dtype=np.uint8)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_all_265": {
                "variable": {
                    "value": "condition",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.equal(arr_3d, color_array)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "where_266": {
                "variable": {
                    "value": "arr_2d",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "condition",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_all(tf.equal(arr_3d, color_array), axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "tf.cast(tf.fill(tf.shape(arr_2d), i), tf.uint8)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "arr_2d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros(shape=[tf.shape(arr_3d)[0], tf.shape(arr_3d)[1]], dtype=tf.uint8)",
                            "Call"
                        ],
                        [
                            "np.zeros((np.shape(arr_3d)[0], np.shape(arr_3d)[1]), dtype=np.uint8)",
                            "Call"
                        ],
                        [
                            "tf.where(condition, tf.cast(tf.fill(tf.shape(arr_2d), i), tf.uint8), arr_2d)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_50": {
                "x": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cv2.imread(image_path + '.png', flags=cv2.IMREAD_GRAYSCALE)",
                            "Call"
                        ],
                        [
                            "cv2.resize(img, dsize=(img_width, img_height))",
                            "Call"
                        ],
                        [
                            "np.expand_dims(img, axis=0)",
                            "Call"
                        ],
                        [
                            "np.expand_dims(img, axis=-1)",
                            "Call"
                        ],
                        [
                            "np.concatenate((img_rgb, img_nir), axis=3)",
                            "Call"
                        ],
                        [
                            "preprocessing(img)",
                            "Call"
                        ],
                        [
                            "np.zeros((h * size[0], w * size[1], c))",
                            "Call"
                        ],
                        [
                            "np.repeat(img, 3, 2)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(x_decode, [self.img_height, self.img_width])",
                            "Call"
                        ],
                        [
                            "tf.concat([img, nir_img], 2)",
                            "Call"
                        ],
                        [
                            "tf.cast(img, tf.float32) / 127.5 - 1",
                            "BinOp"
                        ],
                        [
                            "augmentation(img, segmap_img, augment_height_size, augment_width_size)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_265": {
                "x": {
                    "value": "arr_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "arr_3d",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "color_array",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(np.asarray(c, dtype=np.uint8), shape=[1, 1, -1])",
                            "Call"
                        ],
                        [
                            "np.asarray(c, np.float32).reshape([1, 1, -1])",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_266": {
                "x": {
                    "value": "tf.fill(tf.shape(arr_2d), i)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.uint8",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "fill_266": {
                "dims": {
                    "value": "tf.shape(arr_2d)",
                    "type": "Call",
                    "possible_values": []
                },
                "value": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "idx % size[1]",
                            "BinOp"
                        ],
                        [
                            "color_value_dict.items()",
                            "Call"
                        ],
                        [
                            "color_value_dict.items()",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_261": {
                "input": {
                    "value": "arr_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "arr_3d",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_266": {
                "input": {
                    "value": "arr_2d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros(shape=[tf.shape(arr_3d)[0], tf.shape(arr_3d)[1]], dtype=tf.uint8)",
                            "Call"
                        ],
                        [
                            "np.zeros((np.shape(arr_3d)[0], np.shape(arr_3d)[1]), dtype=np.uint8)",
                            "Call"
                        ],
                        [
                            "tf.where(condition, tf.cast(tf.fill(tf.shape(arr_2d), i), tf.uint8), arr_2d)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "code/stage_2/ops.py": {
        "tensorflow": {
            "moments_230": {
                "variable": {
                    "value": "(x_mean, x_var)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "axes": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "sqrt_231": {
                "variable": {
                    "value": "x_std",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x_var + epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_285": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('kernel', shape=[kernel, kernel, x.get_shape()[-1], channels], initializer=weight_init, regularizer=weight_regularizer)",
                            "Call"
                        ],
                        [
                            "x.get_shape().as_list()",
                            "Call"
                        ],
                        [
                            "tf.get_variable('kernel', shape=[kernel, kernel, x.get_shape()[-1], channels], initializer=weight_init, regularizer=weight_regularizer)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('kernel', shape=[kernel, kernel, x.get_shape()[-1], channels], initializer=weight_init, regularizer=weight_regularizer)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('kernel', [channels, units], tf.float32, initializer=weight_init, regularizer=weight_regularizer_fully)",
                            "Call"
                        ],
                        [
                            "x.get_shape().as_list()",
                            "Call"
                        ],
                        [
                            "x.get_shape().as_list()",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [-1, w_shape[-1]])",
                            "Call"
                        ],
                        [
                            "w",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, w_shape[-1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_287": {
                "variable": {
                    "value": "u",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "u",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, w_shape[-1]]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "stop_gradient_302": {
                "variable": {
                    "value": "u_hat",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "u_hat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "u",
                            "variable"
                        ],
                        [
                            "tf.nn.l2_normalize(u_)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(u_hat)",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_303": {
                "variable": {
                    "value": "v_hat",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "v_hat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.nn.l2_normalize(v_)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(v_hat)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_305": {
                "a": {
                    "value": "v_hat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.nn.l2_normalize(v_)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(v_hat)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('kernel', shape=[kernel, kernel, x.get_shape()[-1], channels], initializer=weight_init, regularizer=weight_regularizer)",
                            "Call"
                        ],
                        [
                            "x.get_shape().as_list()",
                            "Call"
                        ],
                        [
                            "tf.get_variable('kernel', shape=[kernel, kernel, x.get_shape()[-1], channels], initializer=weight_init, regularizer=weight_regularizer)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('kernel', shape=[kernel, kernel, x.get_shape()[-1], channels], initializer=weight_init, regularizer=weight_regularizer)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('kernel', [channels, units], tf.float32, initializer=weight_init, regularizer=weight_regularizer_fully)",
                            "Call"
                        ],
                        [
                            "x.get_shape().as_list()",
                            "Call"
                        ],
                        [
                            "x.get_shape().as_list()",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [-1, w_shape[-1]])",
                            "Call"
                        ],
                        [
                            "w",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_319": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.abs(x - y)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_collection_408": {
                "variable": {
                    "value": "collection_regularization",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.REGULARIZATION_LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "flatten_180": {
                "structure": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "resize_bilinear_240": {
                "images": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "size": {
                    "value": "[256, 256]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "resize_bilinear_245": {
                "images": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "size": {
                    "value": "new_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[h * scale_factor, w * scale_factor]",
                            "List"
                        ],
                        [
                            "[h // scale_factor_h, w // scale_factor_w]",
                            "List"
                        ]
                    ]
                }
            },
            "resize_nearest_neighbor_251": {
                "images": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "size": {
                    "value": "new_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[h * scale_factor, w * scale_factor]",
                            "List"
                        ],
                        [
                            "[h // scale_factor_h, w // scale_factor_w]",
                            "List"
                        ]
                    ]
                }
            },
            "average_pooling2d_254": {
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "scale_factor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "2",
                            "Method Argument"
                        ],
                        [
                            "2",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "leaky_relu_263": {
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.01",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "relu_266": {
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "tanh_270": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_296": {
                "variable": {
                    "value": "v_",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "u_hat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "u",
                            "variable"
                        ],
                        [
                            "tf.nn.l2_normalize(u_)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(u_hat)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.transpose(w)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "l2_normalize_297": {
                "variable": {
                    "value": "v_hat",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "v_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(u_hat, tf.transpose(w))",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_299": {
                "variable": {
                    "value": "u_",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "v_hat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.nn.l2_normalize(v_)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(v_hat)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('kernel', shape=[kernel, kernel, x.get_shape()[-1], channels], initializer=weight_init, regularizer=weight_regularizer)",
                            "Call"
                        ],
                        [
                            "x.get_shape().as_list()",
                            "Call"
                        ],
                        [
                            "tf.get_variable('kernel', shape=[kernel, kernel, x.get_shape()[-1], channels], initializer=weight_init, regularizer=weight_regularizer)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('kernel', shape=[kernel, kernel, x.get_shape()[-1], channels], initializer=weight_init, regularizer=weight_regularizer)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('kernel', [channels, units], tf.float32, initializer=weight_init, regularizer=weight_regularizer_fully)",
                            "Call"
                        ],
                        [
                            "x.get_shape().as_list()",
                            "Call"
                        ],
                        [
                            "x.get_shape().as_list()",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [-1, w_shape[-1]])",
                            "Call"
                        ],
                        [
                            "w",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "l2_normalize_300": {
                "variable": {
                    "value": "u_hat",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "u_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(v_hat, w)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_309": {
                "variable": {
                    "value": "w_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "w / sigma",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(w_norm, w_shape)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "w_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "w.shape.as_list()",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_352": {
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.abs(x - y))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "0.5 * tf.reduce_sum(tf.square(mean) + tf.exp(logvar) - 1 - logvar)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "reduce_mean_375": {
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.abs(x - y))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "0.5 * tf.reduce_sum(tf.square(mean) + tf.exp(logvar) - 1 - logvar)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "reduce_mean_387": {
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.abs(x - y))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "0.5 * tf.reduce_sum(tf.square(mean) + tf.exp(logvar) - 1 - logvar)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "reduce_sum_415": {
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.abs(x - y))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "0.5 * tf.reduce_sum(tf.square(mean) + tf.exp(logvar) - 1 - logvar)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "variable_scope_68": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'conv_0'",
                            "Method Argument"
                        ],
                        [
                            "'conv_0'",
                            "Method Argument"
                        ],
                        [
                            "'linear'",
                            "Method Argument"
                        ],
                        [
                            "'spade_resblock'",
                            "Method Argument"
                        ],
                        [
                            "'spade'",
                            "Method Argument"
                        ],
                        [
                            "'instance_norm'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_87": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "kernel",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[kernel, kernel, x.get_shape()[-1], channels]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "weight_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_contrib.layers.variance_scaling_initializer(factor=factor, mode=mode, uniform=uniform)",
                            "Call"
                        ]
                    ]
                },
                "regularizer": {
                    "value": "weight_regularizer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ]
                    ]
                }
            },
            "conv2d_89": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "filter": {
                    "value": "spectral_norm(w)",
                    "type": "Call",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride, stride, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                }
            },
            "conv2d_96": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape[-1]",
                            "Subscript"
                        ],
                        [
                            "channels",
                            "Method Argument"
                        ],
                        [
                            "channels",
                            "Method Argument"
                        ],
                        [
                            "channels",
                            "Method Argument"
                        ],
                        [
                            "channels",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "4",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_initializer": {
                    "value": "weight_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_contrib.layers.variance_scaling_initializer(factor=factor, mode=mode, uniform=uniform)",
                            "Call"
                        ]
                    ]
                },
                "kernel_regularizer": {
                    "value": "weight_regularizer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ]
                    ]
                },
                "strides": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "2",
                            "Method Argument"
                        ],
                        [
                            "2",
                            "Method Argument"
                        ]
                    ]
                },
                "use_bias": {
                    "value": "use_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_105": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'conv_0'",
                            "Method Argument"
                        ],
                        [
                            "'conv_0'",
                            "Method Argument"
                        ],
                        [
                            "'linear'",
                            "Method Argument"
                        ],
                        [
                            "'spade_resblock'",
                            "Method Argument"
                        ],
                        [
                            "'spade'",
                            "Method Argument"
                        ],
                        [
                            "'instance_norm'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_156": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'conv_0'",
                            "Method Argument"
                        ],
                        [
                            "'conv_0'",
                            "Method Argument"
                        ],
                        [
                            "'linear'",
                            "Method Argument"
                        ],
                        [
                            "'spade_resblock'",
                            "Method Argument"
                        ],
                        [
                            "'spade'",
                            "Method Argument"
                        ],
                        [
                            "'instance_norm'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_162": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "kernel",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[channels, units]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "weight_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_contrib.layers.variance_scaling_initializer(factor=factor, mode=mode, uniform=uniform)",
                            "Call"
                        ]
                    ]
                },
                "regularizer": {
                    "value": "weight_regularizer_fully",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ]
                    ]
                }
            },
            "dense_173": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "units": {
                    "value": "units",
                    "type": "variable",
                    "possible_values": [
                        [
                            "units",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_initializer": {
                    "value": "weight_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_contrib.layers.variance_scaling_initializer(factor=factor, mode=mode, uniform=uniform)",
                            "Call"
                        ]
                    ]
                },
                "kernel_regularizer": {
                    "value": "weight_regularizer_fully",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ]
                    ]
                },
                "use_bias": {
                    "value": "use_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_191": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'conv_0'",
                            "Method Argument"
                        ],
                        [
                            "'conv_0'",
                            "Method Argument"
                        ],
                        [
                            "'linear'",
                            "Method Argument"
                        ],
                        [
                            "'spade_resblock'",
                            "Method Argument"
                        ],
                        [
                            "'spade'",
                            "Method Argument"
                        ],
                        [
                            "'instance_norm'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_208": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'conv_0'",
                            "Method Argument"
                        ],
                        [
                            "'conv_0'",
                            "Method Argument"
                        ],
                        [
                            "'linear'",
                            "Method Argument"
                        ],
                        [
                            "'spade_resblock'",
                            "Method Argument"
                        ],
                        [
                            "'spade'",
                            "Method Argument"
                        ],
                        [
                            "'instance_norm'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "transpose_305": {
                "a": {
                    "value": "u_hat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "u",
                            "variable"
                        ],
                        [
                            "tf.nn.l2_normalize(u_)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(u_hat)",
                            "Call"
                        ]
                    ]
                }
            },
            "control_dependencies_307": {
                "control_inputs": {
                    "value": "[u.assign(u_hat)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "abs_319": {
                "x": {
                    "value": "x - y",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_331": {
                "variable": {
                    "value": "real_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.squared_difference(real[i][-1], 1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_332": {
                "variable": {
                    "value": "fake_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(fake[i][-1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_335": {
                "variable": {
                    "value": "real_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.nn.sigmoid_cross_entropy_with_logits(labels=tf.ones_like(real[i][-1]), logits=real[i][-1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_337": {
                "variable": {
                    "value": "fake_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.nn.sigmoid_cross_entropy_with_logits(labels=tf.zeros_like(fake[i][-1]), logits=fake[i][-1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_348": {
                "variable": {
                    "value": "fake_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "fake[i][-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_mean_360": {
                "variable": {
                    "value": "fake_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.squared_difference(fake[i][-1], 1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_363": {
                "variable": {
                    "value": "fake_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.nn.sigmoid_cross_entropy_with_logits(labels=tf.ones_like(fake[i][-1]), logits=fake[i][-1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_390": {
                "input": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mean",
                            "Method Argument"
                        ],
                        [
                            "mean",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_397": {
                "input_tensor": {
                    "value": "tf.square(mean) + tf.exp(logvar) - 1 - logvar",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "pad_82": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "pad_84": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "mode": {
                    "value": "REFLECT",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_92": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[channels]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "bias_add_93": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('bias', [channels], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('bias', [channels], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('bias', [channels], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('bias', [units], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_111": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, h, w, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "conv2d_113": {
                "variable": {
                    "value": "update_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones(shape=[1, h, w, 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "4",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_initializer": {
                    "value": "tf.constant_initializer(1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "strides": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "2",
                            "Method Argument"
                        ],
                        [
                            "2",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ]
                    ]
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "clip_by_value_118": {
                "variable": {
                    "value": "update_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "update_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(mask, filters=1, kernel_size=kernel, kernel_initializer=tf.constant_initializer(1.0), strides=stride, padding=padding, use_bias=False, trainable=False)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(update_mask, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "get_variable_140": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "kernel",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[kernel, kernel, x.get_shape()[-1], channels]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "weight_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_contrib.layers.variance_scaling_initializer(factor=factor, mode=mode, uniform=uniform)",
                            "Call"
                        ]
                    ]
                },
                "regularizer": {
                    "value": "weight_regularizer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ]
                    ]
                }
            },
            "conv2d_142": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "filter": {
                    "value": "spectral_norm(w)",
                    "type": "Call",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride, stride, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "conv2d_148": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape[-1]",
                            "Subscript"
                        ],
                        [
                            "channels",
                            "Method Argument"
                        ],
                        [
                            "channels",
                            "Method Argument"
                        ],
                        [
                            "channels",
                            "Method Argument"
                        ],
                        [
                            "channels",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "4",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_initializer": {
                    "value": "weight_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_contrib.layers.variance_scaling_initializer(factor=factor, mode=mode, uniform=uniform)",
                            "Call"
                        ]
                    ]
                },
                "kernel_regularizer": {
                    "value": "weight_regularizer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ]
                    ]
                },
                "strides": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "2",
                            "Method Argument"
                        ],
                        [
                            "2",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ]
                    ]
                },
                "use_bias": {
                    "value": "use_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_165": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[units]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_170": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "spectral_norm(w)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "random_normal_initializer_287": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "transpose_296": {
                "a": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('kernel', shape=[kernel, kernel, x.get_shape()[-1], channels], initializer=weight_init, regularizer=weight_regularizer)",
                            "Call"
                        ],
                        [
                            "x.get_shape().as_list()",
                            "Call"
                        ],
                        [
                            "tf.get_variable('kernel', shape=[kernel, kernel, x.get_shape()[-1], channels], initializer=weight_init, regularizer=weight_regularizer)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('kernel', shape=[kernel, kernel, x.get_shape()[-1], channels], initializer=weight_init, regularizer=weight_regularizer)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('kernel', [channels, units], tf.float32, initializer=weight_init, regularizer=weight_regularizer_fully)",
                            "Call"
                        ],
                        [
                            "x.get_shape().as_list()",
                            "Call"
                        ],
                        [
                            "x.get_shape().as_list()",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [-1, w_shape[-1]])",
                            "Call"
                        ],
                        [
                            "w",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "exp_392": {
                "x": {
                    "value": "logvar * 0.5",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_107": {
                "name_or_scope": {
                    "value": "mask",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_121": {
                "name_or_scope": {
                    "value": "x",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_123": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "kernel",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[kernel, kernel, x.get_shape()[-1], channels]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "weight_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_contrib.layers.variance_scaling_initializer(factor=factor, mode=mode, uniform=uniform)",
                            "Call"
                        ]
                    ]
                },
                "regularizer": {
                    "value": "weight_regularizer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ]
                    ]
                }
            },
            "conv2d_125": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "filter": {
                    "value": "spectral_norm(w)",
                    "type": "Call",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride, stride, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "conv2d_127": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape[-1]",
                            "Subscript"
                        ],
                        [
                            "channels",
                            "Method Argument"
                        ],
                        [
                            "channels",
                            "Method Argument"
                        ],
                        [
                            "channels",
                            "Method Argument"
                        ],
                        [
                            "channels",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "4",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_initializer": {
                    "value": "weight_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_contrib.layers.variance_scaling_initializer(factor=factor, mode=mode, uniform=uniform)",
                            "Call"
                        ]
                    ]
                },
                "kernel_regularizer": {
                    "value": "weight_regularizer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ]
                    ]
                },
                "strides": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "2",
                            "Method Argument"
                        ],
                        [
                            "2",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ]
                    ]
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_134": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[channels]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "bias_add_136": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('bias', [channels], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('bias', [channels], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('bias', [channels], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('bias', [units], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_144": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[channels]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "bias_add_146": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('bias', [channels], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('bias', [channels], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('bias', [channels], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('bias', [units], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "squared_difference_331": {
                "x": {
                    "value": "real[i][-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "square_332": {
                "x": {
                    "value": "fake[i][-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_with_logits_336": {
                "labels": {
                    "value": "tf.ones_like(real[i][-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "logits": {
                    "value": "real[i][-1]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "real",
                            "Method Argument"
                        ],
                        [
                            "real",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sigmoid_cross_entropy_with_logits_338": {
                "labels": {
                    "value": "tf.zeros_like(fake[i][-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "logits": {
                    "value": "fake[i][-1]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "fake",
                            "Method Argument"
                        ],
                        [
                            "fake",
                            "Method Argument"
                        ],
                        [
                            "fake",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_343": {
                "input_tensor": {
                    "value": "tf.minimum(real[i][-1] - 1, 0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_344": {
                "input_tensor": {
                    "value": "tf.minimum(-fake[i][-1] - 1, 0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_347": {
                "input_tensor": {
                    "value": "real[i][-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "squared_difference_360": {
                "x": {
                    "value": "fake[i][-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_with_logits_364": {
                "labels": {
                    "value": "tf.ones_like(fake[i][-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "logits": {
                    "value": "fake[i][-1]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "fake",
                            "Method Argument"
                        ],
                        [
                            "fake",
                            "Method Argument"
                        ],
                        [
                            "fake",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_368": {
                "input_tensor": {
                    "value": "fake[i][-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_mean_371": {
                "input_tensor": {
                    "value": "fake[i][-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "matmul_168": {
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]], mode='REFLECT')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(input=x, filter=spectral_norm(w), strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, filters=channels, kernel_size=kernel, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer, strides=stride, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "x * mask_ratio",
                            "BinOp"
                        ],
                        [
                            "tf.nn.bias_add(x, bias)",
                            "Call"
                        ],
                        [
                            "x * update_mask",
                            "BinOp"
                        ],
                        [
                            "flatten(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, units=units, kernel_initializer=weight_init, kernel_regularizer=weight_regularizer_fully, use_bias=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w)) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x, spectral_norm(w))",
                            "Call"
                        ],
                        [
                            "spade(segmap, x_init, channel_in, use_bias=use_bias, sn=False, scope='spade_1')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channel_middle, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_1')",
                            "Call"
                        ],
                        [
                            "spade(segmap, x, channels=channel_middle, use_bias=use_bias, sn=False, scope='spade_2')",
                            "Call"
                        ],
                        [
                            "lrelu(x, 0.2)",
                            "Call"
                        ],
                        [
                            "conv(x, channels=channels, kernel=3, stride=1, pad=1, use_bias=use_bias, sn=sn, scope='conv_2')",
                            "Call"
                        ],
                        [
                            "param_free_norm(x_init)",
                            "Call"
                        ],
                        [
                            "x * (1 + segmap_gamma) + segmap_beta",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "spectral_norm(w)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "minimum_343": {
                "x": {
                    "value": "real[i][-1] - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "minimum_344": {
                "x": {
                    "value": "-fake[i][-1] - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_92": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_114": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_166": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "ones_like_336": {
                "input": {
                    "value": "real[i][-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "zeros_like_338": {
                "input": {
                    "value": "fake[i][-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ones_like_364": {
                "input": {
                    "value": "fake[i][-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "square_397": {
                "x": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mean",
                            "Method Argument"
                        ],
                        [
                            "mean",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "exp_397": {
                "x": {
                    "value": "logvar",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logvar",
                            "Method Argument"
                        ],
                        [
                            "logvar",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "constant_initializer_134": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_144": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            }
        }
    },
    "code/stage_2/spade.py": {
        "tensorflow": {
            "prefetch_to_device_334": {
                "device": {
                    "value": "gpu_device",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'/gpu:0'",
                            "str"
                        ]
                    ]
                },
                "buffer_size": {
                    "value": "self.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "prefetch_to_device_338": {
                "device": {
                    "value": "gpu_device",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'/gpu:0'",
                            "str"
                        ]
                    ]
                },
                "buffer_size": {
                    "value": "self.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_and_batch_333": {
                "map_func": {
                    "value": "self.img_class.image_processing",
                    "type": "Attribute",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "self.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_parallel_batches": {
                    "value": "16",
                    "type": "int",
                    "possible_values": []
                },
                "drop_remainder": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "map_and_batch_337": {
                "map_func": {
                    "value": "self.img_class.test_image_processing",
                    "type": "Attribute",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "self.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_parallel_batches": {
                    "value": "16",
                    "type": "int",
                    "possible_values": []
                },
                "drop_remainder": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shuffle_and_repeat_332": {
                "buffer_size": {
                    "value": "self.dataset_num",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shuffle_and_repeat_336": {
                "buffer_size": {
                    "value": "self.dataset_num",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "code/stage_2/vgg19_keras.py": {
        "tensorflow": {
            "expand_dims_14": {
                "variable": {
                    "value": "nir",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x[:, :, :, 3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "VGG19_41": {
                "variable": {
                    "value": "vgg_pretrained_features",
                    "type": "variable",
                    "possible_values": []
                },
                "weights": {
                    "value": "imagenet",
                    "type": "str",
                    "possible_values": []
                },
                "include_top": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Sequential_48": {
                "variable": {
                    "value": "self.slice1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Sequential_49": {
                "variable": {
                    "value": "self.slice2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Sequential_50": {
                "variable": {
                    "value": "self.slice3",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Sequential_51": {
                "variable": {
                    "value": "self.slice4",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Sequential_52": {
                "variable": {
                    "value": "self.slice5",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "stop_gradient_33": {
                "variable": {
                    "value": "y_vgg_detach",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "y_vgg[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "add_15": {
                "x": {
                    "value": "rgb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x[:, :, :, 0:3]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "nir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(x[:, :, :, 3], 3)",
                            "Call"
                        ]
                    ]
                }
            },
            "preprocess_input_28": {
                "x": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.merge_images(y)",
                            "Call"
                        ],
                        [
                            "(y + 1) / 2 * 255.0",
                            "BinOp"
                        ],
                        [
                            "y",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "code/test_tensorflow.py": {
        "tensorflow": {
            "set_verbosity_5": {
                "level": {
                    "value": "tf.logging.ERROR",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_35": {
                "variable": {
                    "value": "dot_operation",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "random_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform(shape=shape, minval=0, maxval=1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.transpose(random_matrix)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_36": {
                "variable": {
                    "value": "sum_operation",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "dot_operation",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(random_matrix, tf.transpose(random_matrix))",
                            "Call"
                        ]
                    ]
                }
            },
            "device_33": {
                "device_name": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": [
                        [
                            "devices",
                            "variable"
                        ],
                        [
                            "device",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Session_40": {
                "config": {
                    "value": "tf.ConfigProto(log_device_placement=False)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "transpose_35": {
                "a": {
                    "value": "random_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform(shape=shape, minval=0, maxval=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "ConfigProto_40": {
                "log_device_placement": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "code/pytorchMetrics.py": {
        "torch": {
            "cat_127": {
                "variable": {
                    "value": "feature_pixl",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "feature_pixl",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(feature_pixl, 0).to('cpu')",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_128": {
                "variable": {
                    "value": "feature_conv",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "feature_conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(feature_conv, 0).to('cpu')",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_129": {
                "variable": {
                    "value": "feature_logit",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "feature_logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(feature_logit, 0).to('cpu')",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_130": {
                "variable": {
                    "value": "feature_smax",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "feature_smax",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(feature_smax, 0).to('cpu')",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_143": {
                "variable": {
                    "value": "M",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "nX",
                    "type": "variable",
                    "possible_values": [
                        [
                            "X.size(0)",
                            "Call"
                        ]
                    ]
                },
                "out": {
                    "value": "nY",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Y.size(0)",
                            "Call"
                        ]
                    ]
                }
            },
            "cat_166": {
                "variable": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(torch.ones(n0), torch.zeros(n1))",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "cat_167": {
                "tensors": {
                    "value": "(Mxy.transpose(0, 1), Myy)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_173": {
                "variable": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "n0 + n1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ge_177": {
                "variable": {
                    "value": "pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.zeros(n0 + n1)",
                            "Call"
                        ],
                        [
                            "count + label.index_select(0, idx[i])",
                            "BinOp"
                        ]
                    ]
                },
                "other": {
                    "value": "float(k) / 2 * torch.ones(n0 + n1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_196": {
                "variable": {
                    "value": "Mxx",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "-Mxx / (scale * 2 * sigma * sigma)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_197": {
                "variable": {
                    "value": "Mxy",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "-Mxy / (scale * 2 * sigma * sigma)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_198": {
                "variable": {
                    "value": "Myy",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "-Myy / (scale * 2 * sigma * sigma)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cat_224": {
                "variable": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(probs, rem * torch.ones(1))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "from_numpy_265": {
                "variable": {
                    "value": "x_real",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "real",
                    "type": "variable",
                    "possible_values": [
                        [
                            "real",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "permute_265": {
                "variable": {
                    "value": "x_real",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dims": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "from_numpy_266": {
                "variable": {
                    "value": "x_fake",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "fake",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fake",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "permute_266": {
                "variable": {
                    "value": "x_fake",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dims": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "from_numpy_302": {
                "variable": {
                    "value": "x_real",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "x_real",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.from_numpy(real).permute(0, 3, 1, 2).float()",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(x_real).permute(0, 3, 1, 2).float()",
                            "Call"
                        ],
                        [
                            "x_real",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "permute_302": {
                "variable": {
                    "value": "x_real",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dims": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "from_numpy_303": {
                "variable": {
                    "value": "x_fake",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "x_fake",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.from_numpy(fake).permute(0, 3, 1, 2).float()",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(x_fake).permute(0, 3, 1, 2).float()",
                            "Call"
                        ],
                        [
                            "x_fake",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "permute_303": {
                "variable": {
                    "value": "x_fake",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dims": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_121": {
                "variable": {
                    "value": "fsmax",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "flogit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.vgg.classifier(fconv)",
                            "Call"
                        ],
                        [
                            "self.resnet.fc(fconv)",
                            "Call"
                        ],
                        [
                            "self.inception.fc(fconv)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Sequential_54": {
                "variable": {
                    "value": "resnet_feature",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "resnet.conv1",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "no_grad_105": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "eq_188": {
                "input": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.cat((torch.ones(n0), torch.zeros(n1)))",
                            "Call"
                        ]
                    ]
                },
                "other": {
                    "value": "pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.ge(count, float(k) / 2 * torch.ones(n0 + n1)).float()",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_188": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Sequential_70": {
                "variable": {
                    "value": "inception_feature",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "inception.Conv2d_1a_3x3",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_166": {
                "*size": {
                    "value": "n0",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Mxx.size(0)",
                            "Call"
                        ],
                        [
                            "M.size(0)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_166": {
                "*size": {
                    "value": "n1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Myy.size(0)",
                            "Call"
                        ],
                        [
                            "M.size(1)",
                            "Call"
                        ]
                    ]
                }
            },
            "mm_145": {
                "input": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "X.view(nX, -1)",
                            "Call"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ]
                    ]
                },
                "mat2": {
                    "value": "Y.transpose(0, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "diag_171": {
                "input": {
                    "value": "INFINITY * torch.ones(n0 + n1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ones_224": {
                "*size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_177": {
                "*size": {
                    "value": "n0 + n1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ones_171": {
                "*size": {
                    "value": "n0 + n1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "MaxPool2d_73": {
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "MaxPool2d_76": {
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    }
}