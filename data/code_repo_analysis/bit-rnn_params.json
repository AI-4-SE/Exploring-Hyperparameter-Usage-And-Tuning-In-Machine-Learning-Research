{
    "bit_rnn_cell.py": {
        "tensorflow": {
            "sigmoid_47": {
                "variable": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._gate_linear([inputs, state])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "split_48": {
                "variable": {
                    "value": "(r, u)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(self._gate_linear([inputs, state]))",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_98": {
                "variable": {
                    "value": "(i, j, f, o)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "self._linear([inputs, h])",
                    "type": "Call",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_91": {
                "variable": {
                    "value": "(c, h)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "state",
                            "Method Argument"
                        ],
                        [
                            "state",
                            "Method Argument"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_107": {
                "variable": {
                    "value": "new_state",
                    "type": "variable",
                    "possible_values": []
                },
                "c": {
                    "value": "new_c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "c * sigmoid(f + self._forget_bias) + sigmoid(i) * self._activation(j)",
                            "BinOp"
                        ]
                    ]
                },
                "h": {
                    "value": "new_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bit_utils.round_bit(u * state + (1 - u) * c, bit=self._f_bit)",
                            "Call"
                        ],
                        [
                            "bit_utils.round_bit(self._activation(new_c) * sigmoid(o), bit=self._f_bit)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_109": {
                "variable": {
                    "value": "new_state",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[new_c, new_h]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_initializer_36": {
                "variable": {
                    "value": "bias_ones",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tanh_28": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_38": {
                "name_or_scope": {
                    "value": "gates",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_52": {
                "name_or_scope": {
                    "value": "candidate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tanh_80": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "bit_utils.py": {
        "tensorflow": {
            "get_default_graph_46": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_default_graph_62": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "stop_gradient_64": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reduce_mean(tf.abs(x)) * 2.5",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "RegisterGradient_54": {
                "op_type": {
                    "value": "IdentityMaxMinGrad",
                    "type": "str",
                    "possible_values": []
                }
            },
            "round_49": {
                "x": {
                    "value": "x * k",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_64": {
                "input_tensor": {
                    "value": "tf.abs(x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "abs_64": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "clip_by_value_67": {
                "t": {
                    "value": "x / scale",
                    "type": "BinOp",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "-0.5",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            }
        }
    },
    "model.py": {
        "tensorflow": {
            "placeholder_22": {
                "variable": {
                    "value": "self._input_data",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, num_steps]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_23": {
                "variable": {
                    "value": "self._targets",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, num_steps]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "MultiRNNCell_33": {
                "variable": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": []
                },
                "cells": {
                    "value": "[cell] * config.num_layers",
                    "type": "BinOp",
                    "possible_values": []
                },
                "state_is_tuple": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_40": {
                "variable": {
                    "value": "embedding",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "embedding",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[vocab_size, size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_uniform_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "embedding_lookup_44": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "embedding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('embedding', [vocab_size, size], initializer=tf.random_uniform_initializer())",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "self._input_data",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "static_rnn_53": {
                "variable": {
                    "value": "(outputs, state)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "BitGRUCell(size, w_bit=config.w_bit, f_bit=config.f_bit)",
                            "Call"
                        ],
                        [
                            "BitLSTMCell(size, w_bit=config.w_bit, f_bit=config.f_bit, state_is_tuple=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.DropoutWrapper(cell, output_keep_prob=config.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.MultiRNNCell([cell] * config.num_layers, state_is_tuple=False)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(embedding, self._input_data)",
                            "Call"
                        ],
                        [
                            "bit_utils.round_bit(tf.nn.relu(inputs), bit=config.f_bit)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, config.keep_prob)",
                            "Call"
                        ],
                        [
                            "[tf.squeeze(input_, [1]) for input_ in tf.split(value=inputs, num_or_size_splits=num_steps, axis=1)]",
                            "ListComp"
                        ]
                    ]
                },
                "initial_state": {
                    "value": "self._initial_state",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_56": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.concat(values=outputs, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_60": {
                "variable": {
                    "value": "softmax_b",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "softmax_b",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[vocab_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Variable_72": {
                "variable": {
                    "value": "self._lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "trainable_variables_73": {
                "variable": {
                    "value": "tvars",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "clip_by_global_norm_74": {
                "variable": {
                    "value": "(grads, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "t_list": {
                    "value": "tf.gradients(cost, tvars)",
                    "type": "Call",
                    "possible_values": []
                },
                "clip_norm": {
                    "value": "config.max_grad_norm",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "AdamOptimizer_76": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.lr",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "DropoutWrapper_31": {
                "variable": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": []
                },
                "cell": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "BitGRUCell(size, w_bit=config.w_bit, f_bit=config.f_bit)",
                            "Call"
                        ],
                        [
                            "BitLSTMCell(size, w_bit=config.w_bit, f_bit=config.f_bit, state_is_tuple=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.DropoutWrapper(cell, output_keep_prob=config.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.MultiRNNCell([cell] * config.num_layers, state_is_tuple=False)",
                            "Call"
                        ]
                    ]
                },
                "output_keep_prob": {
                    "value": "config.keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_49": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(embedding, self._input_data)",
                            "Call"
                        ],
                        [
                            "bit_utils.round_bit(tf.nn.relu(inputs), bit=config.f_bit)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, config.keep_prob)",
                            "Call"
                        ],
                        [
                            "[tf.squeeze(input_, [1]) for input_ in tf.split(value=inputs, num_or_size_splits=num_steps, axis=1)]",
                            "ListComp"
                        ]
                    ]
                },
                "rate": {
                    "value": "config.keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_59": {
                "variable": {
                    "value": "softmax_w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "softmax_w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[size, vocab_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sigmoid_38": {
                "x": {
                    "value": "self._initial_state",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_46": {
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(embedding, self._input_data)",
                            "Call"
                        ],
                        [
                            "bit_utils.round_bit(tf.nn.relu(inputs), bit=config.f_bit)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, config.keep_prob)",
                            "Call"
                        ],
                        [
                            "[tf.squeeze(input_, [1]) for input_ in tf.split(value=inputs, num_or_size_splits=num_steps, axis=1)]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "squeeze_51": {
                "input": {
                    "value": "input_",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_56": {
                "values": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.rnn.static_rnn(cell, inputs, initial_state=self._initial_state)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_61": {
                "a": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.concat(values=outputs, axis=1), [-1, size])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "softmax_w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('softmax_w', [size, vocab_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_66": {
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.legacy_seq2seq.sequence_loss_by_example([logits], [tf.reshape(self._targets, [-1])], [tf.ones([batch_size * num_steps])])",
                            "Call"
                        ]
                    ]
                }
            },
            "gradients_75": {
                "ys": {
                    "value": "cost",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cost",
                            "Call"
                        ]
                    ]
                },
                "xs": {
                    "value": "tvars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ]
                    ]
                }
            },
            "assign_80": {
                "ref": {
                    "value": "self.lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "lr_value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lr_value",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "random_uniform_initializer_43": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "split_52": {
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(embedding, self._input_data)",
                            "Call"
                        ],
                        [
                            "bit_utils.round_bit(tf.nn.relu(inputs), bit=config.f_bit)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, config.keep_prob)",
                            "Call"
                        ],
                        [
                            "[tf.squeeze(input_, [1]) for input_ in tf.split(value=inputs, num_or_size_splits=num_steps, axis=1)]",
                            "ListComp"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "num_steps",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_64": {
                "tensor": {
                    "value": "self._targets",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_65": {
                "shape": {
                    "value": "[batch_size * num_steps]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tanh_58": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "reader.py": {
        "tensorflow": {
            "convert_to_tensor_99": {
                "variable": {
                    "value": "raw_data",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "raw_data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(raw_data, name='raw_data', dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "np.array(raw_data, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "raw_data",
                            "Method Argument"
                        ],
                        [
                            "raw_data",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "raw_data",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "size_102": {
                "variable": {
                    "value": "data_len",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "raw_data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(raw_data, name='raw_data', dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "np.array(raw_data, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "raw_data",
                            "Method Argument"
                        ],
                        [
                            "raw_data",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_104": {
                "variable": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "raw_data[0:batch_size * batch_len]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, batch_len]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "assert_positive_108": {
                "variable": {
                    "value": "assertion",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "epoch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(batch_len - 1) // num_steps",
                            "BinOp"
                        ],
                        [
                            "tf.identity(epoch_size, name='epoch_size')",
                            "Call"
                        ],
                        [
                            "(batch_len - 1) // num_steps",
                            "BinOp"
                        ]
                    ]
                },
                "message": {
                    "value": "epoch_size == 0, decrease batch_size or num_steps",
                    "type": "str",
                    "possible_values": []
                }
            },
            "range_input_producer_114": {
                "variable": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": []
                },
                "limit": {
                    "value": "epoch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(batch_len - 1) // num_steps",
                            "BinOp"
                        ],
                        [
                            "tf.identity(epoch_size, name='epoch_size')",
                            "Call"
                        ],
                        [
                            "(batch_len - 1) // num_steps",
                            "BinOp"
                        ]
                    ]
                },
                "shuffle": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "strided_slice_115": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_read_words(filename)",
                            "Call"
                        ],
                        [
                            "_read_words(filename)",
                            "Call"
                        ],
                        [
                            "tf.reshape(raw_data[0:batch_size * batch_len], [batch_size, batch_len])",
                            "Call"
                        ],
                        [
                            "np.zeros([batch_size, batch_len], dtype=np.int32)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, i * num_steps]",
                    "type": "List",
                    "possible_values": []
                },
                "end": {
                    "value": "[batch_size, (i + 1) * num_steps]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "strided_slice_118": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_read_words(filename)",
                            "Call"
                        ],
                        [
                            "_read_words(filename)",
                            "Call"
                        ],
                        [
                            "tf.reshape(raw_data[0:batch_size * batch_len], [batch_size, batch_len])",
                            "Call"
                        ],
                        [
                            "np.zeros([batch_size, batch_len], dtype=np.int32)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, i * num_steps + 1]",
                    "type": "List",
                    "possible_values": []
                },
                "end": {
                    "value": "[batch_size, (i + 1) * num_steps + 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "GFile_33": {
                "name": {
                    "value": "filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "filename",
                            "Method Argument"
                        ],
                        [
                            "filename",
                            "Method Argument"
                        ],
                        [
                            "filename",
                            "Method Argument"
                        ]
                    ]
                },
                "mode": {
                    "value": "r",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_98": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "identity_112": {
                "variable": {
                    "value": "epoch_size",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "epoch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(batch_len - 1) // num_steps",
                            "BinOp"
                        ],
                        [
                            "tf.identity(epoch_size, name='epoch_size')",
                            "Call"
                        ],
                        [
                            "(batch_len - 1) // num_steps",
                            "BinOp"
                        ]
                    ]
                },
                "name": {
                    "value": "epoch_size",
                    "type": "str",
                    "possible_values": []
                }
            },
            "control_dependencies_111": {
                "control_inputs": {
                    "value": "[assertion]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "train.py": {
        "tensorflow": {
            "run_102": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_63": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_63": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_71": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_71": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_65": {
                "name_or_scope": {
                    "value": "model",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.initializers.variance_scaling(distribution='uniform')",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_67": {
                "name_or_scope": {
                    "value": "model",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.initializers.variance_scaling(distribution='uniform')",
                            "Call"
                        ]
                    ]
                }
            },
            "no_op_97": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_op_92": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    }
}