{
    "imagenet_input.py": {
        "tensorflow": {
            "placeholder_40": {
                "variable": {
                    "value": "image_bytes_list",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_fn_44": {
                "variable": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "_preprocess_image",
                    "type": "variable",
                    "possible_values": []
                },
                "elems": {
                    "value": "image_bytes_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(shape=[None], dtype=tf.string)",
                            "Call"
                        ]
                    ]
                },
                "back_prop": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "parse_single_example_105": {
                "variable": {
                    "value": "parsed",
                    "type": "variable",
                    "possible_values": []
                },
                "serialized": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "keys_to_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'image/encoded': tf.FixedLenFeature((), tf.string, ''), 'image/class/label': tf.FixedLenFeature([], tf.int64, -1)}",
                            "Dict"
                        ]
                    ]
                }
            },
            "reshape_106": {
                "variable": {
                    "value": "image_bytes",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "parsed['image/encoded']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ServingInputReceiver_46": {
                "features": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(_preprocess_image, image_bytes_list, back_prop=False, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "receiver_tensors": {
                    "value": "{'image_bytes': image_bytes_list}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "zeros_253": {
                "shape": {
                    "value": "[self.image_size, self.image_size, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bfloat16 if self.use_bfloat16 else tf.float32",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "TFRecordDataset_283": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                },
                "filenames": {
                    "value": "filename",
                    "type": "variable",
                    "possible_values": []
                },
                "buffer_size": {
                    "value": "buffer_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8 * 1024 * 1024",
                            "BinOp"
                        ]
                    ]
                }
            },
            "FixedLenFeature_101": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "default_value": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "FixedLenFeature_102": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "default_value": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_115": {
                "x": {
                    "value": "tf.reshape(parsed['image/class/label'], shape=[])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_and_batch_174": {
                "map_func": {
                    "value": "self.dataset_parser",
                    "type": "Attribute",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "params['batch_size']",
                            "Subscript"
                        ]
                    ]
                },
                "num_parallel_batches": {
                    "value": "self.num_cores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "drop_remainder": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "info_265": {
                "msg": {
                    "value": "Undefined data_dir implies null input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "repeat_266": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "parallel_interleave_288": {
                "map_func": {
                    "value": "fetch_dataset",
                    "type": "variable",
                    "possible_values": []
                },
                "cycle_length": {
                    "value": "self.num_parallel_calls",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sloppy": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reshape_116": {
                "tensor": {
                    "value": "parsed['image/class/label']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_259": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shuffle_and_repeat_293": {
                "buffer_size": {
                    "value": "1024 * 16",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "TensorShape_80": {
                "dims": {
                    "value": "[None, None, None, batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_82": {
                "dims": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_85": {
                "dims": {
                    "value": "[batch_size, None, None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_87": {
                "dims": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_181": {
                "a": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(_preprocess_image, image_bytes_list, back_prop=False, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 2, 3, 0]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "legacy_layers.py": {
        "tensorflow": {}
    },
    "mnasnet_main.py": {
        "tensorflow": {
            "load_checkpoint_303": {
                "variable": {
                    "value": "checkpoint_reader",
                    "type": "variable",
                    "possible_values": []
                },
                "ckpt_dir_or_file": {
                    "value": "checkpoint_path",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "one_hot_450": {
                "variable": {
                    "value": "one_hot_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "depth": {
                    "value": "FLAGS.num_label_classes",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_451": {
                "variable": {
                    "value": "cross_entropy",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(logits, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "onehot_labels": {
                    "value": "one_hot_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(labels, FLAGS.num_label_classes)",
                            "Call"
                        ]
                    ]
                },
                "label_smoothing": {
                    "value": "FLAGS.label_smoothing",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_global_step_463": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "TPUClusterResolver_723": {
                "variable": {
                    "value": "tpu_cluster_resolver",
                    "type": "variable",
                    "possible_values": []
                },
                "tpu": {
                    "value": "FLAGS.tpu if FLAGS.tpu or FLAGS.use_tpu else ''",
                    "type": "IfExp",
                    "possible_values": []
                },
                "zone": {
                    "value": "FLAGS.tpu_zone",
                    "type": "Attribute",
                    "possible_values": []
                },
                "project": {
                    "value": "FLAGS.gcp_project",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "RunConfig_732": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "cluster": {
                    "value": "tpu_cluster_resolver",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.cluster_resolver.TPUClusterResolver(FLAGS.tpu if FLAGS.tpu or FLAGS.use_tpu else '', zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)",
                            "Call"
                        ]
                    ]
                },
                "model_dir": {
                    "value": "FLAGS.model_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "save_checkpoints_steps": {
                    "value": "save_checkpoints_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "max(100, FLAGS.iterations_per_loop)",
                            "Call"
                        ]
                    ]
                },
                "log_step_count_steps": {
                    "value": "FLAGS.log_step_count_steps",
                    "type": "Attribute",
                    "possible_values": []
                },
                "session_config": {
                    "value": "tf.ConfigProto(graph_options=tf.GraphOptions(rewrite_options=rewriter_config_pb2.RewriterConfig(disable_meta_optimizer=True)))",
                    "type": "Call",
                    "possible_values": []
                },
                "tpu_config": {
                    "value": "tf.contrib.tpu.TPUConfig(iterations_per_loop=FLAGS.iterations_per_loop, per_host_input_for_training=tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TPUEstimator_758": {
                "variable": {
                    "value": "mnasnet_est",
                    "type": "variable",
                    "possible_values": []
                },
                "use_tpu": {
                    "value": "FLAGS.use_tpu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "model_fn": {
                    "value": "mnasnet_model_fn",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.tpu.RunConfig(cluster=tpu_cluster_resolver, model_dir=FLAGS.model_dir, save_checkpoints_steps=save_checkpoints_steps, log_step_count_steps=FLAGS.log_step_count_steps, session_config=tf.ConfigProto(graph_options=tf.GraphOptions(rewrite_options=rewriter_config_pb2.RewriterConfig(disable_meta_optimizer=True))), tpu_config=tf.contrib.tpu.TPUConfig(iterations_per_loop=FLAGS.iterations_per_loop, per_host_input_for_training=tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2))",
                            "Call"
                        ]
                    ]
                },
                "train_batch_size": {
                    "value": "FLAGS.train_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "eval_batch_size": {
                    "value": "FLAGS.eval_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "export_to_tpu": {
                    "value": "FLAGS.export_to_tpu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "params",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dict(steps_per_epoch=FLAGS.num_train_images / FLAGS.train_batch_size, use_bfloat16=FLAGS.use_bfloat16, quantized_training=FLAGS.quantized_training)",
                            "Call"
                        ]
                    ]
                }
            },
            "global_variables_307": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "transpose_361": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features['feature']",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(features, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(features, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "features / tf.constant(STDDEV_RGB, shape=[1, 1, 3], dtype=features.dtype)",
                            "BinOp"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 3, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_364": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features['feature']",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(features, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(features, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "features / tf.constant(STDDEV_RGB, shape=[1, 1, 3], dtype=features.dtype)",
                            "BinOp"
                        ]
                    ]
                },
                "perm": {
                    "value": "[3, 0, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_367": {
                "value": {
                    "value": "MEAN_RGB",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[0.485 * 255, 0.456 * 255, 0.406 * 255]",
                            "List"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "features.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_368": {
                "value": {
                    "value": "STDDEV_RGB",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[0.229 * 255, 0.224 * 255, 0.225 * 255]",
                            "List"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "features.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_372": {
                "msg": {
                    "value": "Using open-source implementation for MnasNet definition.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_399": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(logits, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ExponentialMovingAverage_465": {
                "variable": {
                    "value": "ema",
                    "type": "variable",
                    "possible_values": []
                },
                "decay": {
                    "value": "FLAGS.moving_average_decay",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_updates": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.get_global_step()",
                            "Call"
                        ]
                    ]
                }
            },
            "get_collection_492": {
                "variable": {
                    "value": "update_ops",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.UPDATE_OPS",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_591": {
                "msg": {
                    "value": "'number of trainable parameters: {}'.format(num_params)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TPUEstimatorSpec_622": {
                "mode": {
                    "value": "mode",
                    "type": "variable",
                    "possible_values": []
                },
                "loss": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cross_entropy + FLAGS.weight_decay * tf.add_n([tf.nn.l2_loss(v) for v in tf.trainable_variables() if 'batch_normalization' not in v.name])",
                            "BinOp"
                        ]
                    ]
                },
                "train_op": {
                    "value": "train_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "optimizer.minimize(loss, global_step)",
                            "Call"
                        ],
                        [
                            "ema.apply(ema_vars)",
                            "Call"
                        ]
                    ]
                },
                "host_call": {
                    "value": "host_call",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "(host_call_fn, [gs_t, loss_t, lr_t, ce_t])",
                            "Tuple"
                        ]
                    ]
                },
                "eval_metrics": {
                    "value": "eval_metrics",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "(metric_fn, [labels, logits])",
                            "Tuple"
                        ]
                    ]
                },
                "scaffold_fn": {
                    "value": "scaffold_fn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "restore_scaffold",
                            "variable"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "init_scaffold",
                            "variable"
                        ],
                        [
                            "eval_scaffold",
                            "variable"
                        ]
                    ]
                }
            },
            "info_699": {
                "msg": {
                    "value": "Starting to export model.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_704": {
                "msg": {
                    "value": "Starting to export TFLite.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_709": {
                "name": {
                    "value": "tflite_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(export_dir, FLAGS.model_name + '.tflite')",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "wb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "write_709": {
                "tag": {
                    "value": "tflite_model",
                    "type": "variable",
                    "possible_values": [
                        [
                            "converter.convert()",
                            "Call"
                        ]
                    ]
                }
            },
            "set_verbosity_884": {
                "level": {
                    "value": "tf.logging.INFO",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_329": {
                "msg": {
                    "value": "Init variable [%s] from [%s] in ckpt",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "v.op.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "variable_name_ckpt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "v.op.name",
                            "Attribute"
                        ],
                        [
                            "v.op.name + '/ExponentialMovingAverage'",
                            "BinOp"
                        ]
                    ]
                }
            },
            "latest_checkpoint_420": {
                "variable": {
                    "value": "restore_checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "FLAGS.model_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TPUEstimatorSpec_437": {
                "mode": {
                    "value": "mode",
                    "type": "variable",
                    "possible_values": []
                },
                "predictions": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'classes': tf.argmax(logits, axis=1), 'probabilities': tf.nn.softmax(logits, name='softmax_tensor')}",
                            "Dict"
                        ],
                        [
                            "tf.argmax(logits, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "export_outputs": {
                    "value": "{'classify': tf.estimator.export.PredictOutput(predictions)}",
                    "type": "Dict",
                    "possible_values": []
                },
                "scaffold_fn": {
                    "value": "scaffold_fn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "restore_scaffold",
                            "variable"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "init_scaffold",
                            "variable"
                        ],
                        [
                            "eval_scaffold",
                            "variable"
                        ]
                    ]
                }
            },
            "global_variables_468": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "CrossShardOptimizer_488": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "opt": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mnasnet_utils.build_optimizer(learning_rate)",
                            "Call"
                        ],
                        [
                            "tf.contrib.tpu.CrossShardOptimizer(optimizer)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_544": {
                "variable": {
                    "value": "gs_t",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.get_global_step()",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_545": {
                "variable": {
                    "value": "loss_t",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cross_entropy + FLAGS.weight_decay * tf.add_n([tf.nn.l2_loss(v) for v in tf.trainable_variables() if 'batch_normalization' not in v.name])",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_546": {
                "variable": {
                    "value": "lr_t",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mnasnet_utils.build_learning_rate(scaled_lr, global_step, params['steps_per_epoch'])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_547": {
                "variable": {
                    "value": "ce_t",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "current_epoch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(global_step, tf.float32) / params['steps_per_epoch']",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "argmax_578": {
                "variable": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(logits, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "accuracy_579": {
                "variable": {
                    "value": "top_1_accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "predictions": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'classes': tf.argmax(logits, axis=1), 'probabilities': tf.nn.softmax(logits, name='softmax_tensor')}",
                            "Dict"
                        ],
                        [
                            "tf.argmax(logits, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_580": {
                "variable": {
                    "value": "in_top_5",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.nn.in_top_k(logits, labels, 5)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "mean_581": {
                "variable": {
                    "value": "top_5_accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "in_top_5",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.nn.in_top_k(logits, labels, 5), tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_598": {
                "msg": {
                    "value": "Initializing from pretrained checkpoint: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "FLAGS.init_checkpoint",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Saver_617": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "restore_vars_dict",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "ema.variables_to_restore(ema_vars)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_712": {
                "msg": {
                    "value": "Starting to export quantized TFLite.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_719": {
                "name": {
                    "value": "quant_tflite_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(export_dir, FLAGS.model_name + '_postquant.tflite')",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "wb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "write_719": {
                "tag": {
                    "value": "quant_tflite_model",
                    "type": "variable",
                    "possible_values": [
                        [
                            "converter.convert()",
                            "Call"
                        ]
                    ]
                }
            },
            "info_770": {
                "msg": {
                    "value": "Using Bigtable dataset, table %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "FLAGS.bigtable_table",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "checkpoints_iterator_798": {
                "checkpoint_dir": {
                    "value": "FLAGS.model_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "timeout": {
                    "value": "FLAGS.eval_timeout",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_832": {
                "msg": {
                    "value": "Training for %d steps (%.2f epochs in total). Current step %d.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "FLAGS.train_steps",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "FLAGS.train_steps / params['steps_per_epoch']",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_315": {
                "msg": {
                    "value": "Exclude [%s] from loading from checkpoint.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "v.op.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "bfloat16_scope_393": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_409": {
                "msg": {
                    "value": "Adding fake quantization ops for training.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_414": {
                "msg": {
                    "value": "Adding fake quantization ops for evaluation.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_423": {
                "msg": {
                    "value": "Restoring from the latest checkpoint: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "restore_checkpoint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.latest_checkpoint(FLAGS.model_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_425": {
                "msg": {
                    "value": "str(variables_to_restore)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Saver_428": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "variables_to_restore",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{}",
                            "Dict"
                        ],
                        [
                            "get_pretrained_variables_to_restore(restore_checkpoint, load_moving_average=True)",
                            "Call"
                        ],
                        [
                            "get_pretrained_variables_to_restore(FLAGS.init_checkpoint, has_moving_average_decay)",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_434": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(logits, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_435": {
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(logits, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "softmax_tensor",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_n_457": {
                "inputs": {
                    "value": "[tf.nn.l2_loss(v) for v in tf.trainable_variables() if 'batch_normalization' not in v.name]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "trainable_variables_467": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_collection_467": {
                "key": {
                    "value": "moving_vars",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_478": {
                "x": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.get_global_step()",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "control_dependencies_493": {
                "control_inputs": {
                    "value": "update_ops",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.UPDATE_OPS)",
                            "Call"
                        ]
                    ]
                }
            },
            "init_from_checkpoint_609": {
                "ckpt_dir_or_file": {
                    "value": "FLAGS.init_checkpoint",
                    "type": "Attribute",
                    "possible_values": []
                },
                "assignment_map": {
                    "value": "variables_to_restore",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{}",
                            "Dict"
                        ],
                        [
                            "get_pretrained_variables_to_restore(restore_checkpoint, load_moving_average=True)",
                            "Call"
                        ],
                        [
                            "get_pretrained_variables_to_restore(FLAGS.init_checkpoint, has_moving_average_decay)",
                            "Call"
                        ]
                    ]
                }
            },
            "Scaffold_618": {
                "saver": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.Saver(variables_to_restore)",
                            "Call"
                        ],
                        [
                            "tf.train.Saver(restore_vars_dict)",
                            "Call"
                        ]
                    ]
                }
            },
            "ConfigProto_737": {
                "graph_options": {
                    "value": "tf.GraphOptions(rewrite_options=rewriter_config_pb2.RewriterConfig(disable_meta_optimizer=True))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TPUConfig_741": {
                "iterations_per_loop": {
                    "value": "FLAGS.iterations_per_loop",
                    "type": "Attribute",
                    "possible_values": []
                },
                "per_host_input_for_training": {
                    "value": "tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_781": {
                "msg": {
                    "value": "Using fake dataset.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_783": {
                "msg": {
                    "value": "Using dataset: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "FLAGS.data_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_800": {
                "msg": {
                    "value": "Starting to evaluate.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_877": {
                "msg": {
                    "value": "Finished training up to step %d. Elapsed seconds %d.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "FLAGS.train_steps",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "elapsed_time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "int(time.time() - start_timestamp)",
                            "Call"
                        ],
                        [
                            "int(time.time() - start_timestamp)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_323": {
                "msg": {
                    "value": "Skip init [%s] from [%s] as it is not in the checkpoint",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "v.op.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "variable_name_ckpt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "v.op.name",
                            "Attribute"
                        ],
                        [
                            "v.op.name + '/ExponentialMovingAverage'",
                            "BinOp"
                        ]
                    ]
                }
            },
            "Scaffold_429": {
                "saver": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.Saver(variables_to_restore)",
                            "Call"
                        ],
                        [
                            "tf.train.Saver(restore_vars_dict)",
                            "Call"
                        ]
                    ]
                }
            },
            "control_dependencies_497": {
                "control_inputs": {
                    "value": "[train_op]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "in_top_k_580": {
                "targets": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(logits, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "predictions": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "k": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                }
            },
            "trainable_variables_590": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "init_from_checkpoint_603": {
                "ckpt_dir_or_file": {
                    "value": "FLAGS.init_checkpoint",
                    "type": "Attribute",
                    "possible_values": []
                },
                "assignment_map": {
                    "value": "variables_to_restore",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{}",
                            "Dict"
                        ],
                        [
                            "get_pretrained_variables_to_restore(restore_checkpoint, load_moving_average=True)",
                            "Call"
                        ],
                        [
                            "get_pretrained_variables_to_restore(FLAGS.init_checkpoint, has_moving_average_decay)",
                            "Call"
                        ]
                    ]
                }
            },
            "Scaffold_605": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_808": {
                "msg": {
                    "value": "Eval results: %s. Elapsed seconds: %d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "eval_results",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mnasnet_est.evaluate(input_fn=imagenet_eval.input_fn, steps=eval_steps, checkpoint_path=ckpt)",
                            "Call"
                        ],
                        [
                            "mnasnet_est.evaluate(input_fn=imagenet_eval.input_fn, steps=FLAGS.num_eval_images // FLAGS.eval_batch_size)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "elapsed_time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "int(time.time() - start_timestamp)",
                            "Call"
                        ],
                        [
                            "int(time.time() - start_timestamp)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_862": {
                "msg": {
                    "value": "Finished training up to step %d. Elapsed seconds %d.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "next_checkpoint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "min(current_step + FLAGS.steps_per_eval, FLAGS.train_steps)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "int(time.time() - start_timestamp)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_869": {
                "msg": {
                    "value": "Starting to evaluate.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_873": {
                "msg": {
                    "value": "Eval results at step %d: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "next_checkpoint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "min(current_step + FLAGS.steps_per_eval, FLAGS.train_steps)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "eval_results",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mnasnet_est.evaluate(input_fn=imagenet_eval.input_fn, steps=eval_steps, checkpoint_path=ckpt)",
                            "Call"
                        ],
                        [
                            "mnasnet_est.evaluate(input_fn=imagenet_eval.input_fn, steps=FLAGS.num_eval_images // FLAGS.eval_batch_size)",
                            "Call"
                        ]
                    ]
                }
            },
            "PredictOutput_441": {
                "outputs": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'classes': tf.argmax(logits, axis=1), 'probabilities': tf.nn.softmax(logits, name='softmax_tensor')}",
                            "Dict"
                        ],
                        [
                            "tf.argmax(logits, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "l2_loss_458": {
                "t": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.global_variables()",
                            "Call"
                        ],
                        [
                            "tf.global_variables()",
                            "Call"
                        ]
                    ]
                }
            },
            "create_file_writer_530": {
                "logdir": {
                    "value": "FLAGS.model_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "max_queue": {
                    "value": "FLAGS.iterations_per_loop",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GraphOptions_738": {
                "rewrite_options": {
                    "value": "rewriter_config_pb2.RewriterConfig(disable_meta_optimizer=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_814": {
                "msg": {
                    "value": "Evaluation finished after training step %d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "current_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "estimator._load_global_step_from_checkpoint_dir(FLAGS.model_dir)",
                            "Call"
                        ],
                        [
                            "int(os.path.basename(ckpt).split('-')[1])",
                            "Call"
                        ],
                        [
                            "next_checkpoint",
                            "variable"
                        ]
                    ]
                }
            },
            "info_823": {
                "msg": {
                    "value": "Checkpoint %s no longer exists, skipping checkpoint",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "ckpt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "evaluation.checkpoints_iterator(FLAGS.model_dir, timeout=FLAGS.eval_timeout)",
                            "Call"
                        ]
                    ]
                }
            },
            "trainable_variables_459": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_533": {
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "loss[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scalar_534": {
                "name": {
                    "value": "learning_rate",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "lr[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scalar_535": {
                "name": {
                    "value": "current_epoch",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "ce[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "mnasnet_model.py": {
        "tensorflow": {
            "BatchNormalization_212": {
                "variable": {
                    "value": "self._bn1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "self._channel_axis",
                    "type": "Attribute",
                    "possible_values": []
                },
                "momentum": {
                    "value": "self._batch_norm_momentum",
                    "type": "Attribute",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "self._batch_norm_epsilon",
                    "type": "Attribute",
                    "possible_values": []
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "BatchNormalization_249": {
                "variable": {
                    "value": "self._bn2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "self._channel_axis",
                    "type": "Attribute",
                    "possible_values": []
                },
                "momentum": {
                    "value": "self._batch_norm_momentum",
                    "type": "Attribute",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "self._batch_norm_epsilon",
                    "type": "Attribute",
                    "possible_values": []
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_mean_264": {
                "variable": {
                    "value": "se_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "self._spatial_dims",
                    "type": "Attribute",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "relu_287": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "self._bn1(self._depthwise_conv(x), training=training)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "BatchNormalization_370": {
                "variable": {
                    "value": "self._bn0",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "channel_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "int"
                        ],
                        [
                            "-1",
                            "UnaryOp"
                        ]
                    ]
                },
                "momentum": {
                    "value": "batch_norm_momentum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._global_params.batch_norm_momentum",
                            "Attribute"
                        ]
                    ]
                },
                "epsilon": {
                    "value": "batch_norm_epsilon",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._global_params.batch_norm_epsilon",
                            "Attribute"
                        ]
                    ]
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "BatchNormalization_385": {
                "variable": {
                    "value": "self._bn1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "channel_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "int"
                        ],
                        [
                            "-1",
                            "UnaryOp"
                        ]
                    ]
                },
                "momentum": {
                    "value": "batch_norm_momentum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._global_params.batch_norm_momentum",
                            "Attribute"
                        ]
                    ]
                },
                "epsilon": {
                    "value": "batch_norm_epsilon",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._global_params.batch_norm_epsilon",
                            "Attribute"
                        ]
                    ]
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "GlobalAveragePooling2D_391": {
                "variable": {
                    "value": "self._avg_pooling",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self._global_params.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_122": {
                "filters": {
                    "value": "filters",
                    "type": "variable",
                    "possible_values": [
                        [
                            "filters * multiplier",
                            "BinOp"
                        ],
                        [
                            "self._block_args.input_filters * self._block_args.expand_ratio",
                            "BinOp"
                        ],
                        [
                            "self._block_args.output_filters",
                            "Attribute"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._block_args.kernel_size",
                            "Attribute"
                        ]
                    ]
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "kernel_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "use_bias",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Conv2D_130": {
                "filters": {
                    "value": "filters",
                    "type": "variable",
                    "possible_values": [
                        [
                            "filters * multiplier",
                            "BinOp"
                        ],
                        [
                            "self._block_args.input_filters * self._block_args.expand_ratio",
                            "BinOp"
                        ],
                        [
                            "self._block_args.output_filters",
                            "Attribute"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._block_args.kernel_size",
                            "Attribute"
                        ]
                    ]
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "kernel_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "use_bias",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "BatchNormalization_190": {
                "variable": {
                    "value": "self._bn0",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "self._channel_axis",
                    "type": "Attribute",
                    "possible_values": []
                },
                "momentum": {
                    "value": "self._batch_norm_momentum",
                    "type": "Attribute",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "self._batch_norm_epsilon",
                    "type": "Attribute",
                    "possible_values": []
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "DepthwiseConv2D_199": {
                "variable": {
                    "value": "self._depthwise_conv",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "[kernel_size, kernel_size]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "self._block_args.strides",
                    "type": "Attribute",
                    "possible_values": []
                },
                "depthwise_initializer": {
                    "value": "conv_kernel_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "info_266": {
                "msg": {
                    "value": "'Built Squeeze and Excitation with tensor shape: %s' % se_tensor.shape",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_280": {
                "msg": {
                    "value": "'Block input: %s shape: %s' % (inputs.name, inputs.shape)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "relu_282": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "self._bn0(self._expand_conv(inputs), training=training)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_285": {
                "msg": {
                    "value": "'Expand: %s shape: %s' % (x.name, x.shape)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_288": {
                "msg": {
                    "value": "'DWConv: %s shape: %s' % (x.name, x.shape)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_302": {
                "msg": {
                    "value": "'Project: %s shape: %s' % (x.name, x.shape)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Dense_394": {
                "variable": {
                    "value": "self._fc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "self._global_params.num_classes",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "dense_kernel_initializer",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Dense_398": {
                "variable": {
                    "value": "self._fc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "self._global_params.num_classes",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "dense_kernel_initializer",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Dropout_402": {
                "variable": {
                    "value": "self._dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "rate": {
                    "value": "self._global_params.dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_421": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "self._bn0(self._conv_stem(inputs), training=training)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_423": {
                "msg": {
                    "value": "'Built stem layers with output shape: %s' % outputs.shape",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "relu_265": {
                "features": {
                    "value": "self._se_reduce(se_tensor)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_268": {
                "x": {
                    "value": "se_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(input_tensor, self._spatial_dims, keepdims=True)",
                            "Call"
                        ],
                        [
                            "self._se_expand(tf.nn.relu(self._se_reduce(se_tensor)))",
                            "Call"
                        ]
                    ]
                }
            },
            "add_301": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(self._bn0(self._expand_conv(inputs), training=training))",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.nn.relu(self._bn1(self._depthwise_conv(x), training=training))",
                            "Call"
                        ],
                        [
                            "self._bn2(self._project_conv(x), training=training)",
                            "Call"
                        ],
                        [
                            "self._call_se(x)",
                            "Call"
                        ],
                        [
                            "tf.add(x, inputs)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "variable_scope_420": {
                "name_or_scope": {
                    "value": "mnas_stem",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_450": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "self._bn1(self._conv_head(outputs), training=training)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_291": {
                "name_or_scope": {
                    "value": "se",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_435": {
                "name_or_scope": {
                    "value": "'mnas_blocks_%s' % idx",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_449": {
                "name_or_scope": {
                    "value": "mnas_head",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "mnasnet_models.py": {
        "tensorflow": {
            "identity_280": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model(images, training=training)",
                            "Call"
                        ],
                        [
                            "tf.identity(logits, 'logits')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "logits",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_308": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model(images, training=training, features_only=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(features, 'global_pool')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "global_pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_276": {
                "name_or_scope": {
                    "value": "model_name",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "variable_scope_304": {
                "name_or_scope": {
                    "value": "model_name",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "mnasnet_utils.py": {
        "tensorflow": {
            "exponential_decay_37": {
                "variable": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "initial_lr",
                    "type": "variable",
                    "possible_values": []
                },
                "global_step": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "decay_steps": {
                    "value": "decay_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "steps_per_epoch * decay_epochs",
                            "BinOp"
                        ]
                    ]
                },
                "decay_rate": {
                    "value": "decay_factor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.97",
                            "Method Argument"
                        ]
                    ]
                },
                "staircase": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cond_54": {
                "variable": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "global_step < warmup_steps",
                    "type": "Compare",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : warmup_lr",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : lr",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "GradientDescentOptimizer_67": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "info_49": {
                "msg": {
                    "value": "'Learning rate warmup_epochs: %d' % warmup_epochs",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_66": {
                "msg": {
                    "value": "Using SGD optimizer",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MomentumOptimizer_70": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "momentum": {
                    "value": "momentum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.9",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_52": {
                "x": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_69": {
                "msg": {
                    "value": "Using Momentum optimizer",
                    "type": "str",
                    "possible_values": []
                }
            },
            "RMSPropOptimizer_74": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "decay": {
                    "value": "decay",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.9",
                            "Method Argument"
                        ]
                    ]
                },
                "momentum": {
                    "value": "momentum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.9",
                            "Method Argument"
                        ]
                    ]
                },
                "epsilon": {
                    "value": "epsilon",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.001",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "info_73": {
                "msg": {
                    "value": "Using RMSProp optimizer",
                    "type": "str",
                    "possible_values": []
                }
            },
            "fatal_77": {
                "msg": {
                    "value": "Unknown optimizer:",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "optimizer_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'rmsprop'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cos_42": {
                "x": {
                    "value": "np.pi * tf.cast(global_step, tf.float32) / total_steps",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_42": {
                "x": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "preprocessing.py": {
        "tensorflow": {
            "equal_80": {
                "variable": {
                    "value": "match",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cast_81": {
                "variable": {
                    "value": "match",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "match",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(a, b)",
                            "Call"
                        ],
                        [
                            "tf.cast(match, tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_87": {
                "variable": {
                    "value": "bbox",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[0.0, 0.0, 1.0, 1.0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "extract_jpeg_shape_96": {
                "variable": {
                    "value": "original_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image_bytes",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cond_99": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "bad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_at_least_x_are_equal(original_shape, tf.shape(image), 3)",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : _decode_and_center_crop(image_bytes, image_size)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.image.resize_bicubic([image], [image_size, image_size])[0]",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "extract_jpeg_shape_110": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image_bytes",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cast_114": {
                "variable": {
                    "value": "padded_center_crop_size",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "image_size / (image_size + CROP_PADDING) * tf.cast(tf.minimum(image_height, image_width), tf.float32)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_121": {
                "variable": {
                    "value": "crop_window",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[offset_height, offset_width, padded_center_crop_size, padded_center_crop_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "decode_and_crop_jpeg_123": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image_bytes",
                    "type": "variable",
                    "possible_values": []
                },
                "crop_window": {
                    "value": "crop_window",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([offset_y, offset_x, target_height, target_width])",
                            "Call"
                        ],
                        [
                            "tf.stack([offset_height, offset_width, padded_center_crop_size, padded_center_crop_size])",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "random_flip_left_right_131": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image_bytes, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4, 4.0 / 3.0), area_range=(0.08, 1.0), max_attempts=10, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.cond(bad, lambda : _decode_and_center_crop(image_bytes, image_size), lambda : tf.image.resize_bicubic([image], [image_size, image_size])[0])",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [image_size, image_size])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "_decode_and_random_crop(image_bytes, image_size)",
                            "Call"
                        ],
                        [
                            "_flip(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [image_size, image_size, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.bfloat16 if use_bfloat16 else tf.float32)",
                            "Call"
                        ],
                        [
                            "_decode_and_center_crop(image_bytes, image_size)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [image_size, image_size, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.bfloat16 if use_bfloat16 else tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_148": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image_bytes, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4, 4.0 / 3.0), area_range=(0.08, 1.0), max_attempts=10, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.cond(bad, lambda : _decode_and_center_crop(image_bytes, image_size), lambda : tf.image.resize_bicubic([image], [image_size, image_size])[0])",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [image_size, image_size])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "_decode_and_random_crop(image_bytes, image_size)",
                            "Call"
                        ],
                        [
                            "_flip(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [image_size, image_size, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.bfloat16 if use_bfloat16 else tf.float32)",
                            "Call"
                        ],
                        [
                            "_decode_and_center_crop(image_bytes, image_size)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [image_size, image_size, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.bfloat16 if use_bfloat16 else tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[image_size, image_size, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "convert_image_dtype_149": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image_bytes, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4, 4.0 / 3.0), area_range=(0.08, 1.0), max_attempts=10, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.cond(bad, lambda : _decode_and_center_crop(image_bytes, image_size), lambda : tf.image.resize_bicubic([image], [image_size, image_size])[0])",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [image_size, image_size])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "_decode_and_random_crop(image_bytes, image_size)",
                            "Call"
                        ],
                        [
                            "_flip(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [image_size, image_size, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.bfloat16 if use_bfloat16 else tf.float32)",
                            "Call"
                        ],
                        [
                            "_decode_and_center_crop(image_bytes, image_size)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [image_size, image_size, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.bfloat16 if use_bfloat16 else tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.bfloat16 if use_bfloat16 else tf.float32",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "reshape_166": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image_bytes, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4, 4.0 / 3.0), area_range=(0.08, 1.0), max_attempts=10, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.cond(bad, lambda : _decode_and_center_crop(image_bytes, image_size), lambda : tf.image.resize_bicubic([image], [image_size, image_size])[0])",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [image_size, image_size])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "_decode_and_random_crop(image_bytes, image_size)",
                            "Call"
                        ],
                        [
                            "_flip(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [image_size, image_size, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.bfloat16 if use_bfloat16 else tf.float32)",
                            "Call"
                        ],
                        [
                            "_decode_and_center_crop(image_bytes, image_size)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [image_size, image_size, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.bfloat16 if use_bfloat16 else tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[image_size, image_size, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "convert_image_dtype_167": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image_bytes, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4, 4.0 / 3.0), area_range=(0.08, 1.0), max_attempts=10, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.cond(bad, lambda : _decode_and_center_crop(image_bytes, image_size), lambda : tf.image.resize_bicubic([image], [image_size, image_size])[0])",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [image_size, image_size])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "_decode_and_random_crop(image_bytes, image_size)",
                            "Call"
                        ],
                        [
                            "_flip(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [image_size, image_size, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.bfloat16 if use_bfloat16 else tf.float32)",
                            "Call"
                        ],
                        [
                            "_decode_and_center_crop(image_bytes, image_size)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [image_size, image_size, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.bfloat16 if use_bfloat16 else tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.bfloat16 if use_bfloat16 else tf.float32",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "extract_jpeg_shape_58": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image_bytes",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sample_distorted_bounding_box_59": {
                "variable": {
                    "value": "sample_distorted_bounding_box",
                    "type": "variable",
                    "possible_values": []
                },
                "image_size": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.extract_jpeg_shape(image_bytes)",
                            "Call"
                        ],
                        [
                            "tf.image.extract_jpeg_shape(image_bytes)",
                            "Call"
                        ]
                    ]
                },
                "bounding_boxes": {
                    "value": "bbox",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant([0.0, 0.0, 1.0, 1.0], dtype=tf.float32, shape=[1, 1, 4])",
                            "Call"
                        ]
                    ]
                },
                "min_object_covered": {
                    "value": "min_object_covered",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.1",
                            "Method Argument"
                        ]
                    ]
                },
                "aspect_ratio_range": {
                    "value": "aspect_ratio_range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(0.75",
                            "Method Argument"
                        ]
                    ]
                },
                "area_range": {
                    "value": "area_range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(0.05",
                            "Method Argument"
                        ]
                    ]
                },
                "max_attempts": {
                    "value": "max_attempts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100",
                            "Method Argument"
                        ]
                    ]
                },
                "use_image_if_no_bounding_boxes": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "unstack_70": {
                "variable": {
                    "value": "(offset_y, offset_x, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "bbox_begin",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "unstack_71": {
                "variable": {
                    "value": "(target_height, target_width, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "bbox_size",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "stack_72": {
                "variable": {
                    "value": "crop_window",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[offset_y, offset_x, target_height, target_width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "decode_and_crop_jpeg_73": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image_bytes",
                    "type": "variable",
                    "possible_values": []
                },
                "crop_window": {
                    "value": "crop_window",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([offset_y, offset_x, target_height, target_width])",
                            "Call"
                        ],
                        [
                            "tf.stack([offset_height, offset_width, padded_center_crop_size, padded_center_crop_size])",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "greater_equal_82": {
                "x": {
                    "value": "tf.reduce_sum(match)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "name_scope_57": {
                "name": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_82": {
                "input_tensor": {
                    "value": "match",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(a, b)",
                            "Call"
                        ],
                        [
                            "tf.cast(match, tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_97": {
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image_bytes, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4, 4.0 / 3.0), area_range=(0.08, 1.0), max_attempts=10, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.cond(bad, lambda : _decode_and_center_crop(image_bytes, image_size), lambda : tf.image.resize_bicubic([image], [image_size, image_size])[0])",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [image_size, image_size])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "_decode_and_random_crop(image_bytes, image_size)",
                            "Call"
                        ],
                        [
                            "_flip(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [image_size, image_size, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.bfloat16 if use_bfloat16 else tf.float32)",
                            "Call"
                        ],
                        [
                            "_decode_and_center_crop(image_bytes, image_size)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [image_size, image_size, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.bfloat16 if use_bfloat16 else tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "resize_bicubic_124": {
                "images": {
                    "value": "[image]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[image_size, image_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_116": {
                "x": {
                    "value": "tf.minimum(image_height, image_width)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "resize_bicubic_102": {
                "images": {
                    "value": "[image]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[image_size, image_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "minimum_116": {
                "x": {
                    "value": "image_height",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape[0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "image_width",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape[1]",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    }
}