{
    "data.py": {
        "tensorflow": {
            "load_data_66": {
                "variable": {
                    "value": "((xtrain, ytrain), (xvalid, yvalid))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_186": {
                "name_or_scope": {
                    "value": "standardize",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "learners/convnet.py": {
        "tensorflow": {
            "get_variable_45": {
                "variable": {
                    "value": "weights[w6]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "w6",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.dim_hidden[-1], self.dim_output]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "fc_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.layers.xavier_initializer(dtype=self.floattype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_46": {
                "variable": {
                    "value": "weights[b6]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.zeros([self.dim_output], dtype=self.floattype)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "b6",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_65": {
                "variable": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_standardize(inp, datamean, datastd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(hidden, [-1, np.prod([int(dim) for dim in hidden.get_shape()[1:]])])",
                            "Call"
                        ],
                        [
                            "self.conv_block(hidden, weights[f'conv{l + 1}'], weights[f'b{l + 1}'])",
                            "Call"
                        ],
                        [
                            "self.convbn_block(hidden, weights[f'conv{l + 1}'], weights[f'scale{l + 1}'], weights[f'offset{l + 1}'], buffers[f'mean{l + 1}'], buffers[f'var{l + 1}'], training)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, np.prod([int(dim) for dim in hidden.get_shape()[1:]])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "max_pool_74": {
                "variable": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(inp, conv, no_stride, 'SAME') + bias",
                            "BinOp"
                        ],
                        [
                            "activation(inp)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inp, stride, stride, max_pool_pad)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inp, conv, no_stride, 'SAME')",
                            "Call"
                        ],
                        [
                            "self.batch_norm(inp, buffermean, buffervar, scale, offset, training)",
                            "Call"
                        ],
                        [
                            "activation(inp)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inp, stride, stride, max_pool_pad)",
                            "Call"
                        ],
                        [
                            "tf.nn.batch_normalization(inp, curmean, curvar, offset, scale, eps)",
                            "Call"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ]
                    ]
                },
                "ksize": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 2, 2, 1]",
                            "List"
                        ],
                        [
                            "[1, 2, 2, 1]",
                            "List"
                        ]
                    ]
                },
                "strides": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 2, 2, 1]",
                            "List"
                        ],
                        [
                            "[1, 2, 2, 1]",
                            "List"
                        ]
                    ]
                },
                "padding": {
                    "value": "max_pool_pad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "conv2d_80": {
                "variable": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(inp, conv, no_stride, 'SAME') + bias",
                            "BinOp"
                        ],
                        [
                            "activation(inp)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inp, stride, stride, max_pool_pad)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inp, conv, no_stride, 'SAME')",
                            "Call"
                        ],
                        [
                            "self.batch_norm(inp, buffermean, buffervar, scale, offset, training)",
                            "Call"
                        ],
                        [
                            "activation(inp)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inp, stride, stride, max_pool_pad)",
                            "Call"
                        ],
                        [
                            "tf.nn.batch_normalization(inp, curmean, curvar, offset, scale, eps)",
                            "Call"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv",
                            "Method Argument"
                        ],
                        [
                            "conv",
                            "Method Argument"
                        ]
                    ]
                },
                "strides": {
                    "value": "no_stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 1, 1, 1]",
                            "List"
                        ],
                        [
                            "[1, 1, 1, 1]",
                            "List"
                        ]
                    ]
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_83": {
                "variable": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(inp, conv, no_stride, 'SAME') + bias",
                            "BinOp"
                        ],
                        [
                            "activation(inp)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inp, stride, stride, max_pool_pad)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inp, conv, no_stride, 'SAME')",
                            "Call"
                        ],
                        [
                            "self.batch_norm(inp, buffermean, buffervar, scale, offset, training)",
                            "Call"
                        ],
                        [
                            "activation(inp)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inp, stride, stride, max_pool_pad)",
                            "Call"
                        ],
                        [
                            "tf.nn.batch_normalization(inp, curmean, curvar, offset, scale, eps)",
                            "Call"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ]
                    ]
                },
                "ksize": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 2, 2, 1]",
                            "List"
                        ],
                        [
                            "[1, 2, 2, 1]",
                            "List"
                        ]
                    ]
                },
                "strides": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 2, 2, 1]",
                            "List"
                        ],
                        [
                            "[1, 2, 2, 1]",
                            "List"
                        ]
                    ]
                },
                "padding": {
                    "value": "max_pool_pad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "batch_normalization_95": {
                "variable": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(inp, conv, no_stride, 'SAME') + bias",
                            "BinOp"
                        ],
                        [
                            "activation(inp)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inp, stride, stride, max_pool_pad)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inp, conv, no_stride, 'SAME')",
                            "Call"
                        ],
                        [
                            "self.batch_norm(inp, buffermean, buffervar, scale, offset, training)",
                            "Call"
                        ],
                        [
                            "activation(inp)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inp, stride, stride, max_pool_pad)",
                            "Call"
                        ],
                        [
                            "tf.nn.batch_normalization(inp, curmean, curvar, offset, scale, eps)",
                            "Call"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ]
                    ]
                },
                "mean": {
                    "value": "curmean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(inp, axes=[0, 1, 2], keep_dims=False)",
                            "Call"
                        ],
                        [
                            "buffermean",
                            "variable"
                        ]
                    ]
                },
                "variance": {
                    "value": "curvar",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(inp, axes=[0, 1, 2], keep_dims=False)",
                            "Call"
                        ],
                        [
                            "buffervar",
                            "variable"
                        ]
                    ]
                },
                "offset": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "offset",
                            "Method Argument"
                        ],
                        [
                            "offset",
                            "Method Argument"
                        ]
                    ]
                },
                "scale": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scale",
                            "Method Argument"
                        ],
                        [
                            "scale",
                            "Method Argument"
                        ]
                    ]
                },
                "variance_epsilon": {
                    "value": "eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1e-05",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_34": {
                "variable": {
                    "value": "weights[conv + str(i + 1)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "'conv' + str(i + 1)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[k, k, previous, self.dim_hidden[i]]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "conv_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.layers.xavier_initializer_conv2d(dtype=self.floattype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "moments_88": {
                "variable": {
                    "value": "(curmean, curvar)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(inp, conv, no_stride, 'SAME') + bias",
                            "BinOp"
                        ],
                        [
                            "activation(inp)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inp, stride, stride, max_pool_pad)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inp, conv, no_stride, 'SAME')",
                            "Call"
                        ],
                        [
                            "self.batch_norm(inp, buffermean, buffervar, scale, offset, training)",
                            "Call"
                        ],
                        [
                            "activation(inp)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inp, stride, stride, max_pool_pad)",
                            "Call"
                        ],
                        [
                            "tf.nn.batch_normalization(inp, curmean, curvar, offset, scale, eps)",
                            "Call"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ]
                    ]
                },
                "axes": {
                    "value": "[0, 1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Variable_36": {
                "variable": {
                    "value": "weights[b + str(i + 1)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.zeros([self.dim_hidden[i]], dtype=self.floattype)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "'b' + str(i + 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Variable_38": {
                "variable": {
                    "value": "weights[scale + str(i + 1)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.ones([self.dim_hidden[i]], dtype=self.floattype)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "'scale' + str(i + 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Variable_39": {
                "variable": {
                    "value": "weights[offset + str(i + 1)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.zeros([self.dim_hidden[i]], dtype=self.floattype)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "'offset' + str(i + 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Variable_41": {
                "variable": {
                    "value": "buffers[mean + str(i + 1)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.zeros([self.dim_hidden[i]])",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "'mean' + str(i + 1)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Variable_42": {
                "variable": {
                    "value": "buffers[var + str(i + 1)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.ones([self.dim_hidden[i]])",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "'var' + str(i + 1)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "zeros_46": {
                "shape": {
                    "value": "[self.dim_output]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_66": {
                "a": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_standardize(inp, datamean, datastd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(hidden, [-1, np.prod([int(dim) for dim in hidden.get_shape()[1:]])])",
                            "Call"
                        ],
                        [
                            "self.conv_block(hidden, weights[f'conv{l + 1}'], weights[f'b{l + 1}'])",
                            "Call"
                        ],
                        [
                            "self.convbn_block(hidden, weights[f'conv{l + 1}'], weights[f'scale{l + 1}'], weights[f'offset{l + 1}'], buffers[f'mean{l + 1}'], buffers[f'var{l + 1}'], training)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weights['w6']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "conv2d_72": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(inp, conv, no_stride, 'SAME') + bias",
                            "BinOp"
                        ],
                        [
                            "activation(inp)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inp, stride, stride, max_pool_pad)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inp, conv, no_stride, 'SAME')",
                            "Call"
                        ],
                        [
                            "self.batch_norm(inp, buffermean, buffervar, scale, offset, training)",
                            "Call"
                        ],
                        [
                            "activation(inp)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inp, stride, stride, max_pool_pad)",
                            "Call"
                        ],
                        [
                            "tf.nn.batch_normalization(inp, curmean, curvar, offset, scale, eps)",
                            "Call"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv",
                            "Method Argument"
                        ],
                        [
                            "conv",
                            "Method Argument"
                        ]
                    ]
                },
                "strides": {
                    "value": "no_stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 1, 1, 1]",
                            "List"
                        ],
                        [
                            "[1, 1, 1, 1]",
                            "List"
                        ]
                    ]
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_36": {
                "shape": {
                    "value": "[self.dim_hidden[i]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_38": {
                "shape": {
                    "value": "[self.dim_hidden[i]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_39": {
                "shape": {
                    "value": "[self.dim_hidden[i]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_41": {
                "shape": {
                    "value": "[self.dim_hidden[i]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_42": {
                "shape": {
                    "value": "[self.dim_hidden[i]]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "learners/general_model.py": {
        "tensorflow": {
            "Flatten_73": {
                "variable": {
                    "value": "self.flatten",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "features",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Input_230": {
                "variable": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "self.expected_shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Model_231": {
                "variable": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.Input(shape=self.expected_shape)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "self.call(input, preprocessing=False)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "self.architecture",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_default_graph_232": {
                "variable": {
                    "value": "current_scope",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "RandomNormal_77": {
                "stddev": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            }
        }
    },
    "learners/keras_applications/__init__.py": {
        "tensorflow": {
            "image_data_format_46": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "learners/linear.py": {
        "tensorflow": {
            "reshape_16": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(x, [-1, 2])",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_18": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "affine",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[x.get_shape()[1], out_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.uniform_unit_scaling_initializer(factor=1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_20": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[out_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_default_graph_22": {
                "variable": {
                    "value": "graph",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "xw_plus_b_25": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(x, [-1, 2])",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "weights": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('affine', [x.get_shape()[1], out_dim], initializer=tf.uniform_unit_scaling_initializer(factor=1.0))",
                            "Call"
                        ],
                        [
                            "graph.get_tensor_by_name(graph.get_name_scope() + '/affine:0')",
                            "Call"
                        ]
                    ]
                },
                "biases": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('bias', [out_dim], initializer=tf.constant_initializer())",
                            "Call"
                        ],
                        [
                            "graph.get_tensor_by_name(graph.get_name_scope() + '/bias:0')",
                            "Call"
                        ]
                    ]
                }
            },
            "uniform_unit_scaling_initializer_19": {
                "factor": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_20": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "learners/mobilenet.py": {
        "tensorflow": {
            "get_variable_60": {
                "variable": {
                    "value": "weights[classifier_weights]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "classifier_weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1280, self.dim_output]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "fc_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.layers.xavier_initializer(dtype=self.floattype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_62": {
                "variable": {
                    "value": "weights[classifier_bias]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.zeros([self.dim_output], dtype=self.floattype)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "classifier_bias",
                    "type": "str",
                    "possible_values": []
                }
            },
            "avg_pool_113": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.depthwise_conv2d(x, weights['conv_' + idx], [1, stride, stride, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, weights['conv_' + idx], [1, stride, stride, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "self.batch_norm(x, buffers['mean_' + idx], buffers['var_' + idx], weights['scale_' + idx], weights['offset_' + idx], training)",
                            "Call"
                        ],
                        [
                            "x + weights['bias_' + idx]",
                            "BinOp"
                        ],
                        [
                            "activation(x)",
                            "Call"
                        ],
                        [
                            "tf_standardize(x, datamean, datastd)",
                            "Call"
                        ],
                        [
                            "self.forward_layer(x, weights, buffers, 'input', training)",
                            "Call"
                        ],
                        [
                            "self.forward_layer(x, weights, buffers, 'output', training)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(x, [1, x.shape[1], x.shape[2], 1], [1, 1, 1, 1], 'VALID')",
                            "Call"
                        ],
                        [
                            "y + shortcut",
                            "BinOp"
                        ],
                        [
                            "y",
                            "variable"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, x.shape[1], x.shape[2], 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_114": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.depthwise_conv2d(x, weights['conv_' + idx], [1, stride, stride, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, weights['conv_' + idx], [1, stride, stride, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "self.batch_norm(x, buffers['mean_' + idx], buffers['var_' + idx], weights['scale_' + idx], weights['offset_' + idx], training)",
                            "Call"
                        ],
                        [
                            "x + weights['bias_' + idx]",
                            "BinOp"
                        ],
                        [
                            "activation(x)",
                            "Call"
                        ],
                        [
                            "tf_standardize(x, datamean, datastd)",
                            "Call"
                        ],
                        [
                            "self.forward_layer(x, weights, buffers, 'input', training)",
                            "Call"
                        ],
                        [
                            "self.forward_layer(x, weights, buffers, 'output', training)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(x, [1, x.shape[1], x.shape[2], 1], [1, 1, 1, 1], 'VALID')",
                            "Call"
                        ],
                        [
                            "y + shortcut",
                            "BinOp"
                        ],
                        [
                            "y",
                            "variable"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, np.prod([int(dim) for dim in x.get_shape()[1:]])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "depthwise_conv2d_69": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.depthwise_conv2d(x, weights['conv_' + idx], [1, stride, stride, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, weights['conv_' + idx], [1, stride, stride, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "self.batch_norm(x, buffers['mean_' + idx], buffers['var_' + idx], weights['scale_' + idx], weights['offset_' + idx], training)",
                            "Call"
                        ],
                        [
                            "x + weights['bias_' + idx]",
                            "BinOp"
                        ],
                        [
                            "activation(x)",
                            "Call"
                        ],
                        [
                            "tf_standardize(x, datamean, datastd)",
                            "Call"
                        ],
                        [
                            "self.forward_layer(x, weights, buffers, 'input', training)",
                            "Call"
                        ],
                        [
                            "self.forward_layer(x, weights, buffers, 'output', training)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(x, [1, x.shape[1], x.shape[2], 1], [1, 1, 1, 1], 'VALID')",
                            "Call"
                        ],
                        [
                            "y + shortcut",
                            "BinOp"
                        ],
                        [
                            "y",
                            "variable"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "filter": {
                    "value": "weights['conv_' + idx]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride, stride, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "conv2d_71": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.depthwise_conv2d(x, weights['conv_' + idx], [1, stride, stride, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, weights['conv_' + idx], [1, stride, stride, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "self.batch_norm(x, buffers['mean_' + idx], buffers['var_' + idx], weights['scale_' + idx], weights['offset_' + idx], training)",
                            "Call"
                        ],
                        [
                            "x + weights['bias_' + idx]",
                            "BinOp"
                        ],
                        [
                            "activation(x)",
                            "Call"
                        ],
                        [
                            "tf_standardize(x, datamean, datastd)",
                            "Call"
                        ],
                        [
                            "self.forward_layer(x, weights, buffers, 'input', training)",
                            "Call"
                        ],
                        [
                            "self.forward_layer(x, weights, buffers, 'output', training)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(x, [1, x.shape[1], x.shape[2], 1], [1, 1, 1, 1], 'VALID')",
                            "Call"
                        ],
                        [
                            "y + shortcut",
                            "BinOp"
                        ],
                        [
                            "y",
                            "variable"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "weights['conv_' + idx]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride, stride, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_63": {
                "shape": {
                    "value": "[self.dim_output]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_115": {
                "a": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(x, [-1, np.prod([int(dim) for dim in x.get_shape()[1:]])])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weights['classifier_weights']",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "learners/modules.py": {
        "tensorflow": {
            "size_81": {
                "variable": {
                    "value": "inputs_size",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ops.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "math_ops.cast(inputs, self.dtype)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "constant_value_112": {
                "variable": {
                    "value": "training_value",
                    "type": "variable",
                    "possible_values": []
                },
                "pylist": {
                    "value": "training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._get_training_value(training)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "training",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_151": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ops.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "math_ops.cast(inputs, self.dtype)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "rank_152": {
                "variable": {
                    "value": "rank",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ops.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "math_ops.cast(inputs, self.dtype)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "depthwise_conv2d_187": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ops.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "math_ops.cast(inputs, self.dtype)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "filter": {
                    "value": "depthwise_kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "params.get(self.name + '/depthwise_kernel:0')",
                            "Call"
                        ],
                        [
                            "params.get(self.name + '/depthwise_kernel:0')",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "self.strides",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding": {
                    "value": "self.padding",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dilation_rate": {
                    "value": "self.dilation_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "separable_conv2d_224": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ops.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "math_ops.cast(inputs, self.dtype)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "depthwise_filter": {
                    "value": "depthwise_kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "params.get(self.name + '/depthwise_kernel:0')",
                            "Call"
                        ],
                        [
                            "params.get(self.name + '/depthwise_kernel:0')",
                            "Call"
                        ]
                    ]
                },
                "pointwise_filter": {
                    "value": "pointwise_kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "params.get(self.name + '/pointwise_kernel:0')",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(1,) + self.strides + (1,)",
                            "BinOp"
                        ],
                        [
                            "(1, 1) + self.strides",
                            "BinOp"
                        ]
                    ]
                },
                "padding": {
                    "value": "self.padding.upper()",
                    "type": "Call",
                    "possible_values": []
                },
                "rate": {
                    "value": "self.dilation_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data_format": {
                    "value": "conv_utils.convert_data_format(self.data_format, ndim=4)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_107": {
                "variable": {
                    "value": "sample_size",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "array_ops.size(inputs) / array_ops.size(variance)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "variance.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_118": {
                "variable": {
                    "value": "momentum",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self.momentum",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "bias_add_169": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._convolution_op(inputs, kernel)",
                            "Call"
                        ],
                        [
                            "nn.bias_add(outputs, bias, data_format='NHWC')",
                            "Call"
                        ],
                        [
                            "outputs + bias",
                            "BinOp"
                        ],
                        [
                            "nn.bias_add(outputs, bias, data_format='NCHW')",
                            "Call"
                        ],
                        [
                            "self._fused_batch_norm(inputs, training=training, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "standard_ops.tensordot(inputs, kernel, [[rank - 1], [0]])",
                            "Call"
                        ],
                        [
                            "gen_math_ops.mat_mul(inputs, kernel)",
                            "Call"
                        ],
                        [
                            "nn.bias_add(outputs, bias)",
                            "Call"
                        ],
                        [
                            "backend.depthwise_conv2d(inputs, depthwise_kernel, strides=self.strides, padding=self.padding, dilation_rate=self.dilation_rate, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "backend.bias_add(outputs, bias, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "nn.separable_conv2d(inputs, depthwise_kernel, pointwise_kernel, strides=strides, padding=self.padding.upper(), rate=self.dilation_rate, data_format=conv_utils.convert_data_format(self.data_format, ndim=4))",
                            "Call"
                        ],
                        [
                            "nn.bias_add(outputs, bias, data_format=conv_utils.convert_data_format(self.data_format, ndim=4))",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ],
                        [
                            "array_ops.reshape(bias, (1, self.filters, 1))",
                            "Call"
                        ],
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ],
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ],
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ]
                    ]
                }
            },
            "bias_add_196": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._convolution_op(inputs, kernel)",
                            "Call"
                        ],
                        [
                            "nn.bias_add(outputs, bias, data_format='NHWC')",
                            "Call"
                        ],
                        [
                            "outputs + bias",
                            "BinOp"
                        ],
                        [
                            "nn.bias_add(outputs, bias, data_format='NCHW')",
                            "Call"
                        ],
                        [
                            "self._fused_batch_norm(inputs, training=training, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "standard_ops.tensordot(inputs, kernel, [[rank - 1], [0]])",
                            "Call"
                        ],
                        [
                            "gen_math_ops.mat_mul(inputs, kernel)",
                            "Call"
                        ],
                        [
                            "nn.bias_add(outputs, bias)",
                            "Call"
                        ],
                        [
                            "backend.depthwise_conv2d(inputs, depthwise_kernel, strides=self.strides, padding=self.padding, dilation_rate=self.dilation_rate, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "backend.bias_add(outputs, bias, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "nn.separable_conv2d(inputs, depthwise_kernel, pointwise_kernel, strides=strides, padding=self.padding.upper(), rate=self.dilation_rate, data_format=conv_utils.convert_data_format(self.data_format, ndim=4))",
                            "Call"
                        ],
                        [
                            "nn.bias_add(outputs, bias, data_format=conv_utils.convert_data_format(self.data_format, ndim=4))",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ],
                        [
                            "array_ops.reshape(bias, (1, self.filters, 1))",
                            "Call"
                        ],
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ],
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ],
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ]
                    ]
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "bias_add_234": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._convolution_op(inputs, kernel)",
                            "Call"
                        ],
                        [
                            "nn.bias_add(outputs, bias, data_format='NHWC')",
                            "Call"
                        ],
                        [
                            "outputs + bias",
                            "BinOp"
                        ],
                        [
                            "nn.bias_add(outputs, bias, data_format='NCHW')",
                            "Call"
                        ],
                        [
                            "self._fused_batch_norm(inputs, training=training, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "standard_ops.tensordot(inputs, kernel, [[rank - 1], [0]])",
                            "Call"
                        ],
                        [
                            "gen_math_ops.mat_mul(inputs, kernel)",
                            "Call"
                        ],
                        [
                            "nn.bias_add(outputs, bias)",
                            "Call"
                        ],
                        [
                            "backend.depthwise_conv2d(inputs, depthwise_kernel, strides=self.strides, padding=self.padding, dilation_rate=self.dilation_rate, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "backend.bias_add(outputs, bias, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "nn.separable_conv2d(inputs, depthwise_kernel, pointwise_kernel, strides=strides, padding=self.padding.upper(), rate=self.dilation_rate, data_format=conv_utils.convert_data_format(self.data_format, ndim=4))",
                            "Call"
                        ],
                        [
                            "nn.bias_add(outputs, bias, data_format=conv_utils.convert_data_format(self.data_format, ndim=4))",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ],
                        [
                            "array_ops.reshape(bias, (1, self.filters, 1))",
                            "Call"
                        ],
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ],
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ],
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ]
                    ]
                },
                "data_format": {
                    "value": "conv_utils.convert_data_format(self.data_format, ndim=4)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "bias_add_44": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._convolution_op(inputs, kernel)",
                            "Call"
                        ],
                        [
                            "nn.bias_add(outputs, bias, data_format='NHWC')",
                            "Call"
                        ],
                        [
                            "outputs + bias",
                            "BinOp"
                        ],
                        [
                            "nn.bias_add(outputs, bias, data_format='NCHW')",
                            "Call"
                        ],
                        [
                            "self._fused_batch_norm(inputs, training=training, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "standard_ops.tensordot(inputs, kernel, [[rank - 1], [0]])",
                            "Call"
                        ],
                        [
                            "gen_math_ops.mat_mul(inputs, kernel)",
                            "Call"
                        ],
                        [
                            "nn.bias_add(outputs, bias)",
                            "Call"
                        ],
                        [
                            "backend.depthwise_conv2d(inputs, depthwise_kernel, strides=self.strides, padding=self.padding, dilation_rate=self.dilation_rate, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "backend.bias_add(outputs, bias, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "nn.separable_conv2d(inputs, depthwise_kernel, pointwise_kernel, strides=strides, padding=self.padding.upper(), rate=self.dilation_rate, data_format=conv_utils.convert_data_format(self.data_format, ndim=4))",
                            "Call"
                        ],
                        [
                            "nn.bias_add(outputs, bias, data_format=conv_utils.convert_data_format(self.data_format, ndim=4))",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ],
                        [
                            "array_ops.reshape(bias, (1, self.filters, 1))",
                            "Call"
                        ],
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ],
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ],
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ]
                    ]
                },
                "data_format": {
                    "value": "NHWC",
                    "type": "str",
                    "possible_values": []
                }
            },
            "fused_batch_norm_84": {
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ops.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "math_ops.cast(inputs, self.dtype)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "scale": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "params.get(self.name + '/gamma:0')",
                            "Call"
                        ],
                        [
                            "self.gamma if self.scale else self._gamma_const",
                            "IfExp"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "offset": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "params.get(self.name + '/beta:0')",
                            "Call"
                        ],
                        [
                            "self.beta if self.center else self._beta_const",
                            "IfExp"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "epsilon": {
                    "value": "self.epsilon",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self._data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "fused_batch_norm_92": {
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ops.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "math_ops.cast(inputs, self.dtype)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "scale": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "params.get(self.name + '/gamma:0')",
                            "Call"
                        ],
                        [
                            "self.gamma if self.scale else self._gamma_const",
                            "IfExp"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "offset": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "params.get(self.name + '/beta:0')",
                            "Call"
                        ],
                        [
                            "self.beta if self.center else self._beta_const",
                            "IfExp"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "mean": {
                    "value": "self.moving_mean",
                    "type": "Attribute",
                    "possible_values": []
                },
                "variance": {
                    "value": "self.moving_variance",
                    "type": "Attribute",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "self.epsilon",
                    "type": "Attribute",
                    "possible_values": []
                },
                "is_training": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self._data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "in_cross_replica_context_120": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cast_166": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ops.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "math_ops.cast(inputs, self.dtype)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_39": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ],
                        [
                            "array_ops.reshape(bias, (1, self.filters, 1))",
                            "Call"
                        ],
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ],
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ],
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(1, self.filters, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "bias_add_42": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._convolution_op(inputs, kernel)",
                            "Call"
                        ],
                        [
                            "nn.bias_add(outputs, bias, data_format='NHWC')",
                            "Call"
                        ],
                        [
                            "outputs + bias",
                            "BinOp"
                        ],
                        [
                            "nn.bias_add(outputs, bias, data_format='NCHW')",
                            "Call"
                        ],
                        [
                            "self._fused_batch_norm(inputs, training=training, gamma=gamma, beta=beta)",
                            "Call"
                        ],
                        [
                            "standard_ops.tensordot(inputs, kernel, [[rank - 1], [0]])",
                            "Call"
                        ],
                        [
                            "gen_math_ops.mat_mul(inputs, kernel)",
                            "Call"
                        ],
                        [
                            "nn.bias_add(outputs, bias)",
                            "Call"
                        ],
                        [
                            "backend.depthwise_conv2d(inputs, depthwise_kernel, strides=self.strides, padding=self.padding, dilation_rate=self.dilation_rate, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "backend.bias_add(outputs, bias, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "nn.separable_conv2d(inputs, depthwise_kernel, pointwise_kernel, strides=strides, padding=self.padding.upper(), rate=self.dilation_rate, data_format=conv_utils.convert_data_format(self.data_format, ndim=4))",
                            "Call"
                        ],
                        [
                            "nn.bias_add(outputs, bias, data_format=conv_utils.convert_data_format(self.data_format, ndim=4))",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ],
                        [
                            "array_ops.reshape(bias, (1, self.filters, 1))",
                            "Call"
                        ],
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ],
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ],
                        [
                            "params.get(self.name + '/bias:0')",
                            "Call"
                        ]
                    ]
                },
                "data_format": {
                    "value": "NCHW",
                    "type": "str",
                    "possible_values": []
                }
            },
            "size_108": {
                "input": {
                    "value": "variance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_utils.smart_cond(training, _fused_batch_norm_training, _fused_batch_norm_inference)",
                            "Call"
                        ],
                        [
                            "variance * factor",
                            "BinOp"
                        ]
                    ]
                }
            },
            "cast_109": {
                "x": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "variance.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "learners/resnet.py": {
        "tensorflow": {
            "get_variable_54": {
                "variable": {
                    "value": "weights[classifier_weights]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "classifier_weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_filters // 2, self.dim_output]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "fc_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.layers.xavier_initializer(dtype=self.floattype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_56": {
                "variable": {
                    "value": "weights[classifier_bias]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.zeros([self.dim_output], dtype=self.floattype)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "classifier_bias",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_64": {
                "variable": {
                    "value": "weights[conv_ + id_string]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "'conv_' + id_string",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[size, size, num_filters_in, num_filters_out]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "conv_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.layers.xavier_initializer_conv2d(dtype=self.floattype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "conv2d_79": {
                "variable": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(inp, conv, [1, stride, stride, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "self.batch_norm(inp, buffermean, buffervar, scale, offset, training)",
                            "Call"
                        ],
                        [
                            "activation(inp)",
                            "Call"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv",
                            "Method Argument"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride, stride, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "avg_pool_120": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.res_layer(y, weights['conv_input'], weights.get('scale_input'), weights.get('offset_input'), buffers.get('mean_input'), buffers.get('var_input'), training, stride=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(x, [1, x.shape[1], x.shape[2], 1], [1, 1, 1, 1], 'VALID')",
                            "Call"
                        ],
                        [
                            "self.res_layer(x, weights[f'conv_{idx}_{block}_r'], weights.get(f'scale_{idx}_{block}_r'), weights.get(f'offset_{idx}_{block}_r'), buffers.get(f'mean_{idx}_{block}_r'), buffers.get(f'var_{idx}_{block}_r'), training, stride=stride, activation=tf.identity)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, x.shape[1], x.shape[2], 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_122": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.res_layer(y, weights['conv_input'], weights.get('scale_input'), weights.get('offset_input'), buffers.get('mean_input'), buffers.get('var_input'), training, stride=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(x, [1, x.shape[1], x.shape[2], 1], [1, 1, 1, 1], 'VALID')",
                            "Call"
                        ],
                        [
                            "self.res_layer(x, weights[f'conv_{idx}_{block}_r'], weights.get(f'scale_{idx}_{block}_r'), weights.get(f'offset_{idx}_{block}_r'), buffers.get(f'mean_{idx}_{block}_r'), buffers.get(f'var_{idx}_{block}_r'), training, stride=stride, activation=tf.identity)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, np.prod([int(dim) for dim in x.get_shape()[1:]])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Variable_68": {
                "variable": {
                    "value": "weights[scale_ + id_string]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.ones([num_filters_out], dtype=self.floattype)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "'scale_' + id_string",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Variable_70": {
                "variable": {
                    "value": "weights[offset_ + id_string]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.zeros([num_filters_out], dtype=self.floattype)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "'offset_' + id_string",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Variable_73": {
                "variable": {
                    "value": "buffers[mean_ + id_string]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.zeros([num_filters_out])",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "'mean_' + id_string",
                    "type": "BinOp",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Variable_75": {
                "variable": {
                    "value": "buffers[var_ + id_string]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.ones([num_filters_out])",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "'var_' + id_string",
                    "type": "BinOp",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "zeros_57": {
                "shape": {
                    "value": "[self.dim_output]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_116": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.res_layer(y, weights['conv_input'], weights.get('scale_input'), weights.get('offset_input'), buffers.get('mean_input'), buffers.get('var_input'), training, stride=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(x, [1, x.shape[1], x.shape[2], 1], [1, 1, 1, 1], 'VALID')",
                            "Call"
                        ],
                        [
                            "self.res_layer(x, weights[f'conv_{idx}_{block}_r'], weights.get(f'scale_{idx}_{block}_r'), weights.get(f'offset_{idx}_{block}_r'), buffers.get(f'mean_{idx}_{block}_r'), buffers.get(f'var_{idx}_{block}_r'), training, stride=stride, activation=tf.identity)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_123": {
                "a": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(x, [-1, np.prod([int(dim) for dim in x.get_shape()[1:]])])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weights['classifier_weights']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ones_68": {
                "shape": {
                    "value": "[num_filters_out]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_70": {
                "shape": {
                    "value": "[num_filters_out]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_73": {
                "shape": {
                    "value": "[num_filters_out]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_75": {
                "shape": {
                    "value": "[num_filters_out]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "learners/vgg.py": {
        "tensorflow": {
            "get_variable_42": {
                "variable": {
                    "value": "weights[dense_weights_1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "dense_weights_1",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[512, 512]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "fc_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.layers.xavier_initializer(dtype=self.floattype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_44": {
                "variable": {
                    "value": "weights[dense_bias_1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.zeros([512], dtype=self.floattype)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "dense_bias_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_46": {
                "variable": {
                    "value": "weights[dense_weights_2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "dense_weights_2",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[512, 512]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "fc_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.layers.xavier_initializer(dtype=self.floattype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_48": {
                "variable": {
                    "value": "weights[dense_bias_2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.zeros([512], dtype=self.floattype)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "dense_bias_2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_52": {
                "variable": {
                    "value": "weights[classifier_weights]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "classifier_weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[512, self.dim_output]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "fc_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.layers.xavier_initializer(dtype=self.floattype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_54": {
                "variable": {
                    "value": "weights[classifier_bias]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.zeros([self.dim_output], dtype=self.floattype)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "classifier_bias",
                    "type": "str",
                    "possible_values": []
                }
            },
            "conv2d_86": {
                "variable": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(inp, conv, [1, stride, stride, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "self.batch_norm(inp, buffermean, buffervar, scale, offset, training)",
                            "Call"
                        ],
                        [
                            "activation(inp)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inp, conv, [1, stride, stride, 1], 'SAME') + bias",
                            "BinOp"
                        ],
                        [
                            "activation(inp)",
                            "Call"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv",
                            "Method Argument"
                        ],
                        [
                            "conv",
                            "Method Argument"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride, stride, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_124": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_standardize(x, datamean, datastd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, np.prod([int(dim) for dim in x.get_shape()[1:]])])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(tf.matmul(x, weights['dense_weights_1']) + weights['dense_bias_1'])",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(x, stride, stride, 'VALID')",
                            "Call"
                        ],
                        [
                            "self.bn_layer(x, weights[f'conv_{idx}_{layer}'], weights.get(f'scale_{idx}_{layer}'), weights.get(f'offset_{idx}_{layer}'), buffers.get(f'mean_{idx}_{layer}'), buffers.get(f'var_{idx}_{layer}'), training, stride=1, activation=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(x, weights[f'conv_{idx}_{layer}'], weights[f'bias_{idx}_{layer}'], training, stride=1, activation=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, np.prod([int(dim) for dim in x.get_shape()[1:]])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_127": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "tf.matmul(x, weights['dense_weights_1']) + weights['dense_bias_1']",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "relu_128": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "tf.matmul(x, weights['dense_weights_2']) + weights['dense_bias_2']",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "get_variable_63": {
                "variable": {
                    "value": "weights[conv_ + id_string]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "'conv_' + id_string",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[size, size, num_filters_in, num_filters_out]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "conv_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.layers.xavier_initializer_conv2d(dtype=self.floattype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_66": {
                "variable": {
                    "value": "weights[conv_ + id_string]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "'conv_' + id_string",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[size, size, num_filters_in, num_filters_out // num_filters_in]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "conv_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.layers.xavier_initializer_conv2d(dtype=self.floattype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_70": {
                "variable": {
                    "value": "weights[scale_ + id_string]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.ones([num_filters_out], dtype=self.floattype)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "'scale_' + id_string",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Variable_72": {
                "variable": {
                    "value": "weights[offset_ + id_string]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.zeros([num_filters_out], dtype=self.floattype)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "'offset_' + id_string",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Variable_75": {
                "variable": {
                    "value": "buffers[mean_ + id_string]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.zeros([num_filters_out])",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "'mean_' + id_string",
                    "type": "BinOp",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Variable_77": {
                "variable": {
                    "value": "buffers[var_ + id_string]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.ones([num_filters_out])",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "'var_' + id_string",
                    "type": "BinOp",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Variable_79": {
                "variable": {
                    "value": "weights[bias_ + id_string]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.zeros([num_filters_out], dtype=self.floattype)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "'bias_' + id_string",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "max_pool_121": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_standardize(x, datamean, datastd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, np.prod([int(dim) for dim in x.get_shape()[1:]])])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(tf.matmul(x, weights['dense_weights_1']) + weights['dense_bias_1'])",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(x, stride, stride, 'VALID')",
                            "Call"
                        ],
                        [
                            "self.bn_layer(x, weights[f'conv_{idx}_{layer}'], weights.get(f'scale_{idx}_{layer}'), weights.get(f'offset_{idx}_{layer}'), buffers.get(f'mean_{idx}_{layer}'), buffers.get(f'var_{idx}_{layer}'), training, stride=1, activation=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(x, weights[f'conv_{idx}_{layer}'], weights[f'bias_{idx}_{layer}'], training, stride=1, activation=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "ksize": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 2, 2, 1]",
                            "List"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                },
                "strides": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 2, 2, 1]",
                            "List"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_45": {
                "shape": {
                    "value": "[512]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_49": {
                "shape": {
                    "value": "[512]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_55": {
                "shape": {
                    "value": "[self.dim_output]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "conv2d_96": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(inp, conv, [1, stride, stride, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "self.batch_norm(inp, buffermean, buffervar, scale, offset, training)",
                            "Call"
                        ],
                        [
                            "activation(inp)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inp, conv, [1, stride, stride, 1], 'SAME') + bias",
                            "BinOp"
                        ],
                        [
                            "activation(inp)",
                            "Call"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ],
                        [
                            "inp",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv",
                            "Method Argument"
                        ],
                        [
                            "conv",
                            "Method Argument"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride, stride, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "matmul_129": {
                "a": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(tf.matmul(x, weights['dense_weights_2']) + weights['dense_bias_2'])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weights['classifier_weights']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ones_70": {
                "shape": {
                    "value": "[num_filters_out]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_72": {
                "shape": {
                    "value": "[num_filters_out]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_75": {
                "shape": {
                    "value": "[num_filters_out]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_77": {
                "shape": {
                    "value": "[num_filters_out]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_79": {
                "shape": {
                    "value": "[num_filters_out]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_127": {
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_standardize(x, datamean, datastd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, np.prod([int(dim) for dim in x.get_shape()[1:]])])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(tf.matmul(x, weights['dense_weights_1']) + weights['dense_bias_1'])",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(x, stride, stride, 'VALID')",
                            "Call"
                        ],
                        [
                            "self.bn_layer(x, weights[f'conv_{idx}_{layer}'], weights.get(f'scale_{idx}_{layer}'), weights.get(f'offset_{idx}_{layer}'), buffers.get(f'mean_{idx}_{layer}'), buffers.get(f'var_{idx}_{layer}'), training, stride=1, activation=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(x, weights[f'conv_{idx}_{layer}'], weights[f'bias_{idx}_{layer}'], training, stride=1, activation=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "weights['dense_weights_1']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "matmul_128": {
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_standardize(x, datamean, datastd)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [-1, np.prod([int(dim) for dim in x.get_shape()[1:]])])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(tf.matmul(x, weights['dense_weights_1']) + weights['dense_bias_1'])",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(x, stride, stride, 'VALID')",
                            "Call"
                        ],
                        [
                            "self.bn_layer(x, weights[f'conv_{idx}_{layer}'], weights.get(f'scale_{idx}_{layer}'), weights.get(f'offset_{idx}_{layer}'), buffers.get(f'mean_{idx}_{layer}'), buffers.get(f'var_{idx}_{layer}'), training, stride=1, activation=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(x, weights[f'conv_{idx}_{layer}'], weights[f'bias_{idx}_{layer}'], training, stride=1, activation=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "weights['dense_weights_2']",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "main.py": {
        "tensorflow": {
            "GPUOptions_177": {
                "variable": {
                    "value": "gpu_options",
                    "type": "variable",
                    "possible_values": []
                },
                "allow_growth": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "visible_device_list": {
                    "value": "str(localrank % len(args.gpu))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Session_178": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "tf.ConfigProto(allow_soft_placement=True, gpu_options=gpu_options)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ConfigProto_178": {
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "gpu_options": {
                    "value": "gpu_options",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.GPUOptions(allow_growth=True, visible_device_list=str(localrank % len(args.gpu)))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "meta.py": {
        "tensorflow": {
            "variables_initializer_40": {
                "variable": {
                    "value": "self.modified_global_initializer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "var_list": {
                    "value": "list(global_variables)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "placeholder_46": {
                "variable": {
                    "value": "self.lrnrate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "lrnrate",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_47": {
                "variable": {
                    "value": "self.craftrate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "craftrate",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_48": {
                "variable": {
                    "value": "self.augment",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self.args.augment",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "augment",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_49": {
                "variable": {
                    "value": "self.epochmass",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "epochmass",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_53": {
                "variable": {
                    "value": "self.poisonmask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "[False] * self.args.npoison",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "poisonmask",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Variable_54": {
                "variable": {
                    "value": "self.poisonlabels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.constant(self.ybase, dtype=self.inttype)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "poisonlabels",
                    "type": "str",
                    "possible_values": []
                }
            },
            "boolean_mask_55": {
                "variable": {
                    "value": "poisonlabels_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.poisonlabels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "mask": {
                    "value": "self.poisonmask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "poisonlabels_masked",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variables_initializer_31": {
                "var_list": {
                    "value": "[self.weights0[name] for name in self.coldstart_names]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "variables_initializer_32": {
                "var_list": {
                    "value": "[buffer0 for buffer0 in self.buffers0.values()]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "variable_scope_52": {
                "name_or_scope": {
                    "value": "poisons",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Variable_57": {
                "variable": {
                    "value": "self.poisoninputs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.constant(self.xbase, dtype=self.floattype)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "poisoninputs",
                    "type": "str",
                    "possible_values": []
                }
            },
            "boolean_mask_58": {
                "variable": {
                    "value": "poisoninputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.poisoninputs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "mask": {
                    "value": "self.poisonmask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "poisoninputs_masked",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Variable_60": {
                "variable": {
                    "value": "self.perts",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.zeros_like(self.xbase, dtype=self.floattype)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "perts",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Variable_61": {
                "variable": {
                    "value": "self.colorperts",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.zeros([self.args.npoison, *self.args.gridshape, 3], dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "colorperts",
                    "type": "str",
                    "possible_values": []
                }
            },
            "boolean_mask_62": {
                "variable": {
                    "value": "perts_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.perts",
                    "type": "Attribute",
                    "possible_values": []
                },
                "mask": {
                    "value": "self.poisonmask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "perts_masked",
                    "type": "str",
                    "possible_values": []
                }
            },
            "boolean_mask_63": {
                "variable": {
                    "value": "colorperts_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.colorperts",
                    "type": "Attribute",
                    "possible_values": []
                },
                "mask": {
                    "value": "self.poisonmask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "colorperts_masked",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_64": {
                "variable": {
                    "value": "xbase",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self.xbase",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "xbase",
                    "type": "str",
                    "possible_values": []
                }
            },
            "boolean_mask_65": {
                "variable": {
                    "value": "poisoninputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "xbase",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(self.xbase, dtype=self.floattype, name='xbase')",
                            "Call"
                        ],
                        [
                            "xbase",
                            "Method Argument"
                        ]
                    ]
                },
                "mask": {
                    "value": "self.poisonmask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "poisoninputs_masked",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_67": {
                "variable": {
                    "value": "poisoninputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "poisoninputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(self.poisoninputs, self.poisonmask, axis=0, name='poisoninputs_masked')",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(xbase, self.poisonmask, axis=0, name='poisoninputs_masked')",
                            "Call"
                        ],
                        [
                            "recolor(poisoninputs_, colorperts_, name='poisoninputs_masked_recolored')",
                            "Call"
                        ],
                        [
                            "tf.add(poisoninputs_, perts_, name='poisoninputs_masked_perturbed')",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "perts_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(self.perts, self.poisonmask, axis=0, name='perts_masked')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "poisoninputs_masked_perturbed",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_71": {
                "value": {
                    "value": "self.ytarget",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.inttype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_101": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "cleaninputs",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.args.batchsize, 32, 32, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_102": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "cleanlabels",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.args.batchsize]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.inttype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "boolean_mask_107": {
                "variable": {
                    "value": "cleaninputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(name='cleaninputs', shape=[self.args.batchsize, 32, 32, 3], dtype=self.floattype)",
                            "Call"
                        ],
                        [
                            "tf.concat([poisoninputs_, cleaninputs_], axis=0, name='concat_inputs')",
                            "Call"
                        ],
                        [
                            "tf.cond(self.augment, lambda : tf_preprocess(inputs, self.args.batchsize), lambda : inputs)",
                            "Call"
                        ],
                        [
                            "tf.concat([inputs, inputsT], axis=0, name='concat_targ_inputs')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs, name='inputs_stopgrad')",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "self.cleanmask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "cleaninputs_masked",
                    "type": "str",
                    "possible_values": []
                }
            },
            "boolean_mask_108": {
                "variable": {
                    "value": "cleanlabels_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(name='cleanlabels', shape=[self.args.batchsize], dtype=self.inttype)",
                            "Call"
                        ],
                        [
                            "tf.concat([poisonlabels_, cleanlabels_], axis=0, name='concat_labels')",
                            "Call"
                        ],
                        [
                            "tf.concat([labels, labelsT], axis=0, name='concat_targ_labels')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels, name='labels_stopgrad')",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "self.cleanmask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "cleanlabels_masked",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_109": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[poisoninputs_, cleaninputs_]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "concat_inputs",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_110": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[poisonlabels_, cleanlabels_]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "concat_labels",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_113": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs, inputsT]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "concat_targ_inputs",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_114": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[labels, labelsT]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "concat_targ_labels",
                    "type": "str",
                    "possible_values": []
                }
            },
            "gradients_135": {
                "variable": {
                    "value": "grad_list",
                    "type": "variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "xent",
                    "type": "variable",
                    "possible_values": [
                        [
                            "metrics(labels[:self.args.batchsize], logits[:self.args.batchsize], self.args.batchsize)",
                            "Call"
                        ],
                        [
                            "xent + 0.0002 * l2_weights(self.weights)",
                            "BinOp"
                        ]
                    ]
                },
                "xs": {
                    "value": "[self.weights[key] for key in self.trainable_names]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "softmax_149": {
                "variable": {
                    "value": "softmax",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits[self.args.batchsize:]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_mean_153": {
                "variable": {
                    "value": "xentNT",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "neglogprobrev[:, int(self.ybase[0])]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "variable_scope_166": {
                "name_or_scope": {
                    "value": "targeter-0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_170": {
                "name_or_scope": {
                    "value": "trainop",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_179": {
                "name_or_scope": {
                    "value": "results",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_202": {
                "variable": {
                    "value": "self.xentC",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.xentCs[1:]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "xentC",
                    "type": "str",
                    "possible_values": []
                }
            },
            "AdamOptimizer_217": {
                "variable": {
                    "value": "self.optim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.craftrate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_35": {
                "scope": {
                    "value": "adapter-0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "global_variables_36": {
                "scope": {
                    "value": "targeter-0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "global_variables_39": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_54": {
                "value": {
                    "value": "self.ybase",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.inttype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_98": {
                "name_or_scope": {
                    "value": "'adapter-' + str(i)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_106": {
                "variable": {
                    "value": "self.cleanmask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "[True] * self.args.batchsize",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "cleanmask",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cond_112": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "self.augment",
                    "type": "Attribute",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf_preprocess(inputs, self.args.batchsize)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : inputs",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "stop_gradient_116": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(name='cleaninputs', shape=[self.args.batchsize, 32, 32, 3], dtype=self.floattype)",
                            "Call"
                        ],
                        [
                            "tf.concat([poisoninputs_, cleaninputs_], axis=0, name='concat_inputs')",
                            "Call"
                        ],
                        [
                            "tf.cond(self.augment, lambda : tf_preprocess(inputs, self.args.batchsize), lambda : inputs)",
                            "Call"
                        ],
                        [
                            "tf.concat([inputs, inputsT], axis=0, name='concat_targ_inputs')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs, name='inputs_stopgrad')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "inputs_stopgrad",
                    "type": "str",
                    "possible_values": []
                }
            },
            "stop_gradient_117": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(name='cleanlabels', shape=[self.args.batchsize], dtype=self.inttype)",
                            "Call"
                        ],
                        [
                            "tf.concat([poisonlabels_, cleanlabels_], axis=0, name='concat_labels')",
                            "Call"
                        ],
                        [
                            "tf.concat([labels, labelsT], axis=0, name='concat_targ_labels')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels, name='labels_stopgrad')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "labels_stopgrad",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_141": {
                "name_or_scope": {
                    "value": "'targeter-' + str(i)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_158": {
                "variable": {
                    "value": "self.accC0",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(tf.equal(tf.argmax(softmax, axis=1), self.ytarget), dtype=self.floattype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "control_dependencies_171": {
                "control_inputs": {
                    "value": "[self.xentT0, self.accT0, self.cwT0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "GradientDescentOptimizer_173": {
                "variable": {
                    "value": "optim",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.lrnrate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_199": {
                "name_or_scope": {
                    "value": "metaloss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_215": {
                "name_or_scope": {
                    "value": "metagrad",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_222": {
                "variable": {
                    "value": "metagrad_accum",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "f'metagrad_accum_{tf_basename(metavar)}'",
                    "type": "JoinedStr",
                    "possible_values": []
                },
                "shape": {
                    "value": "metavar.shape.as_list()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_229": {
                "name_or_scope": {
                    "value": "craftop",
                    "type": "str",
                    "possible_values": []
                }
            },
            "clip_by_value_237": {
                "variable": {
                    "value": "clipped",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "self.perts",
                    "type": "Attribute",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "-self.args.eps",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "self.args.eps",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_244": {
                "variable": {
                    "value": "eye",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(eye, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[self.args.npoison, 1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_246": {
                "variable": {
                    "value": "clipped",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "clipped",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.clip_by_value(self.perts, -self.args.eps, self.args.eps)",
                            "Call"
                        ],
                        [
                            "[tf.clip_by_value(self.colorperts[:, :, :, :, i], -self.args.epscolor[i], self.args.epscolor[i]) for i in range(3)]",
                            "ListComp"
                        ],
                        [
                            "[tf.clip_by_value(eye[:, :, :, :, i] + clipped[i], xrefmin[i], xrefmax[i]) - eye[:, :, :, :, i] for i in range(3)]",
                            "ListComp"
                        ],
                        [
                            "tf.stack(clipped, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "variable_scope_252": {
                "name_or_scope": {
                    "value": "results",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_57": {
                "value": {
                    "value": "self.xbase",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_60": {
                "input": {
                    "value": "self.xbase",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_61": {
                "shape": {
                    "value": "[self.args.npoison, *self.args.gridshape, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "log_150": {
                "x": {
                    "value": "softmax",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(logits[self.args.batchsize:])",
                            "Call"
                        ]
                    ]
                }
            },
            "log_151": {
                "x": {
                    "value": "1 - softmax",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "add_n_152": {
                "inputs": {
                    "value": "[neglogprobrev[i, ytarg] for (i, ytarg) in enumerate(self.ytarget)]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "MomentumOptimizer_174": {
                "variable": {
                    "value": "optim",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.lrnrate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "momentum": {
                    "value": "0.9",
                    "type": "float",
                    "possible_values": []
                }
            },
            "MomentumOptimizer_175": {
                "variable": {
                    "value": "optim",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.lrnrate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "momentum": {
                    "value": "0.9",
                    "type": "float",
                    "possible_values": []
                }
            },
            "add_n_200": {
                "inputs": {
                    "value": "self.xentTs[1:]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "xentT",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_n_201": {
                "inputs": {
                    "value": "self.cwTs[1:]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "cwT",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_n_203": {
                "inputs": {
                    "value": "self.xentNTs[1:]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "xentNT",
                    "type": "str",
                    "possible_values": []
                }
            },
            "control_dependencies_234": {
                "control_inputs": {
                    "value": "[craftop]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "assign_126": {
                "ref": {
                    "value": "self.buffers0[key]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "value": {
                    "value": "self.buffers[key]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cast_158": {
                "x": {
                    "value": "tf.equal(tf.argmax(softmax, axis=1), self.ytarget)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_add_225": {
                "ref": {
                    "value": "metagrad_accum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name=f'metagrad_accum_{tf_basename(metavar)}', shape=metavar.shape.as_list(), dtype=self.floattype, initializer=tf.zeros_initializer, trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "metagrad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "metagradients",
                            "variable"
                        ]
                    ]
                },
                "name": {
                    "value": "f'metagrad_accumop_{tf_basename(metavar)}'",
                    "type": "JoinedStr",
                    "possible_values": []
                }
            },
            "placeholder_226": {
                "shape": {
                    "value": "metavar.shape.as_list()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.floattype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "f'avg_metagrads_{tf_basename(metavar)}'",
                    "type": "JoinedStr",
                    "possible_values": []
                }
            },
            "assign_240": {
                "ref": {
                    "value": "self.perts",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "clipped",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.clip_by_value(self.perts, -self.args.eps, self.args.eps)",
                            "Call"
                        ],
                        [
                            "[tf.clip_by_value(self.colorperts[:, :, :, :, i], -self.args.epscolor[i], self.args.epscolor[i]) for i in range(3)]",
                            "ListComp"
                        ],
                        [
                            "[tf.clip_by_value(eye[:, :, :, :, i] + clipped[i], xrefmin[i], xrefmax[i]) - eye[:, :, :, :, i] for i in range(3)]",
                            "ListComp"
                        ],
                        [
                            "tf.stack(clipped, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "clipop_perts",
                    "type": "str",
                    "possible_values": []
                }
            },
            "clip_by_value_243": {
                "t": {
                    "value": "self.colorperts[:, :, :, :, i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "-self.args.epscolor[i]",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "self.args.epscolor[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "expand_dims_244": {
                "input": {
                    "value": "eye",
                    "type": "variable",
                    "possible_values": [
                        [
                            "recolor(poisoninputs_, colorperts_, name='poisoninputs_masked_recolored')",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(eye, 0), [self.args.npoison, 1, 1, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "assign_247": {
                "ref": {
                    "value": "self.colorperts",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "clipped",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.clip_by_value(self.perts, -self.args.eps, self.args.eps)",
                            "Call"
                        ],
                        [
                            "[tf.clip_by_value(self.colorperts[:, :, :, :, i], -self.args.epscolor[i], self.args.epscolor[i]) for i in range(3)]",
                            "ListComp"
                        ],
                        [
                            "[tf.clip_by_value(eye[:, :, :, :, i] + clipped[i], xrefmin[i], xrefmax[i]) - eye[:, :, :, :, i] for i in range(3)]",
                            "ListComp"
                        ],
                        [
                            "tf.stack(clipped, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "clipop_colorperts",
                    "type": "str",
                    "possible_values": []
                }
            },
            "assign_249": {
                "ref": {
                    "value": "metagrad_accum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name=f'metagrad_accum_{tf_basename(metavar)}', shape=metavar.shape.as_list(), dtype=self.floattype, initializer=tf.zeros_initializer, trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "tf.zeros_like(metagrad_accum)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "f'zeroop_{tf_basename(metagrad_accum)}'",
                    "type": "JoinedStr",
                    "possible_values": []
                }
            },
            "equal_158": {
                "x": {
                    "value": "tf.argmax(softmax, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.ytarget",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "clip_by_value_245": {
                "t": {
                    "value": "eye[:, :, :, :, i] + clipped[i]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "xrefmin[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "xrefmax[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "zeros_like_249": {
                "input": {
                    "value": "metagrad_accum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name=f'metagrad_accum_{tf_basename(metavar)}', shape=metavar.shape.as_list(), dtype=self.floattype, initializer=tf.zeros_initializer, trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_158": {
                "input": {
                    "value": "softmax",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(logits[self.args.batchsize:])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "recolor.py": {
        "tensorflow": {
            "map_fn_32": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "_recolor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_recolor",
                            "Call"
                        ]
                    ]
                },
                "elems": {
                    "value": "(inputs, colorperts)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "parallel_iterations": {
                    "value": "500",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_44": {
                "variable": {
                    "value": "flattened",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.reshape((d * ncolorres) ** 2, [-1]) for (d, ncolorres) in zip([dpert_y, dpert_u, dpert_v], gridshape)]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_45": {
                "variable": {
                    "value": "smoothloss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "flattened",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.reshape((d * ncolorres) ** 2, [-1]) for (d, ncolorres) in zip([dpert_y, dpert_u, dpert_v], gridshape)], axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "meshgrid_19": {
                "variable": {
                    "value": "eye",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "*[tf.linspace(start=start, stop=stop, num=ncolorres) for (start, stop, ncolorres) in zip(xrefmin, xrefmax, gridshape)]",
                    "type": "Starred",
                    "possible_values": []
                },
                "indexing": {
                    "value": "ij",
                    "type": "str",
                    "possible_values": []
                }
            },
            "stack_20": {
                "variable": {
                    "value": "eye",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "eye",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.meshgrid(*[tf.linspace(start=start, stop=stop, num=ncolorres) for (start, stop, ncolorres) in zip(xrefmin, xrefmax, gridshape)], indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.stack(eye, axis=-1)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "yuv_to_rgb_33": {
                "images": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(_recolor, (inputs, colorperts), dtype=tf.float32, parallel_iterations=500, name=name)",
                            "Call"
                        ],
                        [
                            "tf.image.yuv_to_rgb(outputs) * 255.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "rgb_to_yuv_25": {
                "images": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.rgb_to_yuv(img) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tfp.math.batch_interp_regular_nd_grid(img, xrefmin, xrefmax, yref, axis=-4)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_44": {
                "tensor": {
                    "value": "(d * ncolorres) ** 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "linspace_19": {
                "start": {
                    "value": "start",
                    "type": "variable",
                    "possible_values": []
                },
                "stop": {
                    "value": "stop",
                    "type": "variable",
                    "possible_values": []
                },
                "num": {
                    "value": "ncolorres",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "utils.py": {
        "tensorflow": {
            "get_default_graph_79": {
                "variable": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "pad_118": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(inputs, [[0, 0], [4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(inputs, [batchsize, 32, 32, 3])",
                            "Call"
                        ],
                        [
                            "tf.map_fn(tf.image.random_flip_left_right, inputs)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [4, 4], [4, 4], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "random_crop_119": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(inputs, [[0, 0], [4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(inputs, [batchsize, 32, 32, 3])",
                            "Call"
                        ],
                        [
                            "tf.map_fn(tf.image.random_flip_left_right, inputs)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "size": {
                    "value": "[batchsize, 32, 32, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "map_fn_120": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "tf.image.random_flip_left_right",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(inputs, [[0, 0], [4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(inputs, [batchsize, 32, 32, 3])",
                            "Call"
                        ],
                        [
                            "tf.map_fn(tf.image.random_flip_left_right, inputs)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_50": {
                "tensor": {
                    "value": "tf.one_hot(labels, nclass)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batchsize, nclass]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "equal_62": {
                "variable": {
                    "value": "equal",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.cast(tf.argmax(logits, axis=1), dtype=labels.dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_63": {
                "variable": {
                    "value": "acc",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.to_float(equal)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "acc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_70": {
                "variable": {
                    "value": "labels_reshaped",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "labels_reshaped",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_reshape_labels_like_logits(labels, logits, batchsize)",
                            "Call"
                        ],
                        [
                            "_reshape_labels_like_logits(labels, logits, batchsize)",
                            "Call"
                        ],
                        [
                            "tf.cast(labels_reshaped, dtype=logits.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "logits.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_71": {
                "variable": {
                    "value": "target_logit",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "logits * labels_reshaped",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_72": {
                "variable": {
                    "value": "second_logit",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "logits - logits * labels_reshaped",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "maximum_73": {
                "variable": {
                    "value": "cw_indiv",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "second_logit - target_logit",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "clamp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-100",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "add_n_112": {
                "inputs": {
                    "value": "[tf.reduce_sum(weight ** 2) for weight in weights.values() if len(weight.shape.as_list()) > 1]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "one_hot_50": {
                "indices": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "depth": {
                    "value": "nclass",
                    "type": "variable",
                    "possible_values": [
                        [
                            "10",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_54": {
                "name_or_scope": {
                    "value": "metrics",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_57": {
                "variable": {
                    "value": "xent",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.nn.softmax_cross_entropy_with_logits_v2(labels=labels_reshaped, logits=logits)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "xent",
                    "type": "str",
                    "possible_values": []
                }
            },
            "softmax_60": {
                "variable": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_61": {
                "variable": {
                    "value": "xent",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "categorical_crossentropy(labels_reshaped, 1 - preds)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_68": {
                "name_or_scope": {
                    "value": "carlini",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_75": {
                "input_tensor": {
                    "value": "cw_indiv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.maximum(second_logit - target_logit, clamp)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_62": {
                "x": {
                    "value": "tf.argmax(logits, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "labels.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_float_63": {
                "x": {
                    "value": "equal",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(labels, tf.cast(tf.argmax(logits, axis=1), dtype=labels.dtype))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_112": {
                "input_tensor": {
                    "value": "weight ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_v2_57": {
                "labels": {
                    "value": "labels_reshaped",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_reshape_labels_like_logits(labels, logits, batchsize)",
                            "Call"
                        ],
                        [
                            "_reshape_labels_like_logits(labels, logits, batchsize)",
                            "Call"
                        ],
                        [
                            "tf.cast(labels_reshaped, dtype=logits.dtype)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "categorical_crossentropy_61": {
                "y_true": {
                    "value": "labels_reshaped",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_reshape_labels_like_logits(labels, logits, batchsize)",
                            "Call"
                        ],
                        [
                            "_reshape_labels_like_logits(labels, logits, batchsize)",
                            "Call"
                        ],
                        [
                            "tf.cast(labels_reshaped, dtype=logits.dtype)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "1 - preds",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "argmax_62": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "trainable_variables_80": {
                "scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_default_graph().get_name_scope()",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "victim.py": {
        "tensorflow": {
            "GPUOptions_158": {
                "variable": {
                    "value": "gpu_options",
                    "type": "variable",
                    "possible_values": []
                },
                "allow_growth": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "visible_device_list": {
                    "value": "str(localrank % len(args.gpu))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Session_159": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "tf.ConfigProto(allow_soft_placement=True, gpu_options=gpu_options)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ConfigProto_159": {
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "gpu_options": {
                    "value": "gpu_options",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.GPUOptions(allow_growth=True, visible_device_list=str(localrank % len(args.gpu)))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    }
}