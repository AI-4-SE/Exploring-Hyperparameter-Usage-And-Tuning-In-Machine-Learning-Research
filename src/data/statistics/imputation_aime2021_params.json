{
    "src/bo_joint_training_spatial_denoiser.py": {
        "sklearn": {
            "KFold_260": {
                "variable": {
                    "value": "cv_split",
                    "type": "variable",
                    "possible_values": []
                },
                "n_splits": {
                    "value": "n_splits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "6",
                            "int"
                        ]
                    ]
                }
            }
        },
        "tensorflow": {
            "list_physical_devices_79": {
                "variable": {
                    "value": "devices",
                    "type": "variable",
                    "possible_values": []
                },
                "device_type": {
                    "value": "CPU",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Adamax_139": {
                "variable": {
                    "value": "current_optimizer_spatial",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "current_learning_rate_spatial",
                    "type": "variable",
                    "possible_values": [
                        [
                            "float(hyperparameters[:, 3])",
                            "Call"
                        ]
                    ]
                }
            },
            "Adam_140": {
                "variable": {
                    "value": "current_optimizer_denoiser",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "current_learning_rate_denoiser",
                    "type": "variable",
                    "possible_values": [
                        [
                            "float(hyperparameters[:, 4])",
                            "Call"
                        ]
                    ]
                }
            },
            "Sequential_171": {
                "variable": {
                    "value": "denoiser",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Adamax_243": {
                "variable": {
                    "value": "current_optimizer_spatial",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "current_learning_rate_spatial",
                    "type": "variable",
                    "possible_values": [
                        [
                            "float(hyperparameters[:, 3])",
                            "Call"
                        ]
                    ]
                }
            },
            "Adam_244": {
                "variable": {
                    "value": "current_optimizer_denoiser",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "current_learning_rate_denoiser",
                    "type": "variable",
                    "possible_values": [
                        [
                            "float(hyperparameters[:, 4])",
                            "Call"
                        ]
                    ]
                }
            },
            "list_physical_devices_76": {
                "device_type": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'CPU'",
                            "str"
                        ]
                    ]
                }
            },
            "set_visible_devices_80": {
                "devices": {
                    "value": "devices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.config.experimental.list_physical_devices(device_type='CPU')",
                            "Call"
                        ]
                    ]
                },
                "device_type": {
                    "value": "CPU",
                    "type": "str",
                    "possible_values": []
                }
            },
            "set_soft_device_placement_81": {
                "enabled": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "set_soft_device_placement_85": {
                "enabled": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "set_memory_growth_87": {
                "device": {
                    "value": "gpu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.config.experimental.list_physical_devices(device)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "enable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "GRU_172": {
                "units": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "tf.keras.regularizers.l2(current_denoiser_reg)",
                    "type": "Call",
                    "possible_values": []
                },
                "recurrent_regularizer": {
                    "value": "tf.keras.regularizers.l2(current_denoiser_reg)",
                    "type": "Call",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "tf.keras.regularizers.l2(current_denoiser_reg)",
                    "type": "Call",
                    "possible_values": []
                },
                "return_sequences": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "input_shape": {
                    "value": "_bold_set.shape[2:]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "current_use_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bool(hyperparameters[:, 6])",
                            "Call"
                        ]
                    ]
                },
                "dropout": {
                    "value": "current_dropout",
                    "type": "variable",
                    "possible_values": [
                        [
                            "float(hyperparameters[:, 7])",
                            "Call"
                        ]
                    ]
                },
                "recurrent_dropout": {
                    "value": "current_recurrent_dropout",
                    "type": "variable",
                    "possible_values": [
                        [
                            "float(hyperparameters[:, 8])",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "src/bo_spatial.py": {
        "sklearn": {
            "KFold_175": {
                "variable": {
                    "value": "cv_split",
                    "type": "variable",
                    "possible_values": []
                },
                "n_splits": {
                    "value": "n_splits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "6",
                            "int"
                        ]
                    ]
                }
            }
        },
        "tensorflow": {
            "list_physical_devices_73": {
                "variable": {
                    "value": "devices",
                    "type": "variable",
                    "possible_values": []
                },
                "device_type": {
                    "value": "CPU",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Adamax_117": {
                "variable": {
                    "value": "current_optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "current_learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "float(hyperparameters[:, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "Adamax_173": {
                "variable": {
                    "value": "current_optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "current_learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "float(hyperparameters[:, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "list_physical_devices_70": {
                "device_type": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'CPU'",
                            "str"
                        ]
                    ]
                }
            },
            "set_visible_devices_74": {
                "devices": {
                    "value": "devices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.config.experimental.list_physical_devices(device_type='CPU')",
                            "Call"
                        ]
                    ]
                },
                "device_type": {
                    "value": "CPU",
                    "type": "str",
                    "possible_values": []
                }
            },
            "set_soft_device_placement_75": {
                "enabled": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "set_soft_device_placement_79": {
                "enabled": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "set_memory_growth_81": {
                "device": {
                    "value": "gpu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.config.experimental.list_physical_devices(device)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "enable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "src/utils/data_utils.py": {
        "sklearn": {
            "shuffle_257": {
                "variable": {
                    "value": "(imputted_bold, target_denoised)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "imputted_bold",
                    "type": "variable",
                    "possible_values": []
                },
                "*arrays_1": {
                    "value": "target_denoised",
                    "type": "variable",
                    "possible_values": []
                },
                "random_state": {
                    "value": "random_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "10",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "StandardScaler_321": {
                "variable": {
                    "value": "eeg_scaler",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "StandardScaler_325": {
                "variable": {
                    "value": "bold_scaler",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "StandardScaler_343": {
                "variable": {
                    "value": "eeg_scaler",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "StandardScaler_347": {
                "variable": {
                    "value": "bold_scaler",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "StandardScaler_77": {
                "variable": {
                    "value": "scaler",
                    "type": "variable",
                    "possible_values": []
                },
                "copy": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "StandardScaler_421": {
                "variable": {
                    "value": "scaler",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "src/utils/losses_utils.py": {
        "sklearn": {},
        "tensorflow": {
            "square_18": {
                "variable": {
                    "value": "square_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "square_19": {
                "variable": {
                    "value": "margin_square",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "K.maximum(1.0 - y_pred, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "l2_normalize_32": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=2)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.cast(x, 'float32')",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_flatten(x)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_33": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=2)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_flatten(y)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_50": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=2)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.cast(x, 'float32')",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_flatten(x)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_51": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=2)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_flatten(y)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_69": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=2)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.cast(x, 'float32')",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_flatten(x)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_70": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=2)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_flatten(y)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_89": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=2)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.cast(x, 'float32')",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_flatten(x)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_90": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=2)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_flatten(y)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_100": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=2)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.cast(x, 'float32')",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_flatten(x)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_101": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=2)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_flatten(y)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_108": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=2)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.cast(x, 'float32')",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_flatten(x)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "l2_normalize_121": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=2)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(x)",
                            "Call"
                        ],
                        [
                            "K.cast(x, 'float32')",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.l2_normalize(x, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_flatten(x)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_122": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=2)",
                            "Call"
                        ],
                        [
                            "K.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "K.batch_flatten(y)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.l2_normalize(y, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_flatten(y)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sqrt_140": {
                "variable": {
                    "value": "n_volumes_distance",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.keras.backend.sum(tf.keras.backend.square(x - y), axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_171": {
                "variable": {
                    "value": "positives",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "positives",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.ones(real_pred.shape, dtype='float32')",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(positives)",
                            "Call"
                        ],
                        [
                            "np.ones(real_pred.shape, dtype='float32')",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(positives)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_172": {
                "variable": {
                    "value": "negatives",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "negatives",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros(real_pred.shape, dtype='float32')",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(negatives)",
                            "Call"
                        ],
                        [
                            "np.zeros(real_pred.shape, dtype='float32')",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(negatives)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_195": {
                "variable": {
                    "value": "positives",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "positives",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.ones(real_pred.shape, dtype='float32')",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(positives)",
                            "Call"
                        ],
                        [
                            "np.ones(real_pred.shape, dtype='float32')",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(positives)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_196": {
                "variable": {
                    "value": "negatives",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "negatives",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros(real_pred.shape, dtype='float32')",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(negatives)",
                            "Call"
                        ],
                        [
                            "np.zeros(real_pred.shape, dtype='float32')",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(negatives)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_20": {
                "a": {
                    "value": "y_true * square_pred + (1 - y_true) * margin_square",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_83": {
                "x": {
                    "value": "a / (K.sqrt(b) * K.sqrt(c))",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "squeeze_97": {
                "input": {
                    "value": "tf.keras.backend.mean(tf.abs(a / (K.sqrt(b) * K.sqrt(c))), axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "mean_129": {
                "a": {
                    "value": "tf.abs(a / (tf.keras.backend.sqrt(b) * tf.keras.backend.sqrt(c)))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sqrt_136": {
                "x": {
                    "value": "tf.keras.backend.sum(tf.keras.backend.square(x - y), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sum_141": {
                "a": {
                    "value": "n_volumes_distance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.sqrt(tf.keras.backend.sum(tf.keras.backend.square(x - y), axis=1))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "mean_202": {
                "a": {
                    "value": "reconstruction_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "correlation_angle([outputs, targets])",
                            "Call"
                        ],
                        [
                            "correlation_angle_mean_voxels([outputs, targets])",
                            "Call"
                        ],
                        [
                            "correlation_angle([outputs, targets])",
                            "Call"
                        ],
                        [
                            "correlation_angle_mean_voxels([outputs, targets])",
                            "Call"
                        ],
                        [
                            "correlation_angle_each_voxel([outputs, targets])",
                            "Call"
                        ],
                        [
                            "euclidean(outputs, targets)",
                            "Call"
                        ],
                        [
                            "mean_volume_euclidean(outputs, targets)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_210": {
                "a": {
                    "value": "K.log(1 - reconstruction_loss)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mean_215": {
                "a": {
                    "value": "K.log(1 - reconstruction_loss)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mean_219": {
                "a": {
                    "value": "tf.keras.backend.log(1 - reconstruction_loss)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mean_223": {
                "a": {
                    "value": "reconstruction_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "correlation_angle([outputs, targets])",
                            "Call"
                        ],
                        [
                            "correlation_angle_mean_voxels([outputs, targets])",
                            "Call"
                        ],
                        [
                            "correlation_angle([outputs, targets])",
                            "Call"
                        ],
                        [
                            "correlation_angle_mean_voxels([outputs, targets])",
                            "Call"
                        ],
                        [
                            "correlation_angle_each_voxel([outputs, targets])",
                            "Call"
                        ],
                        [
                            "euclidean(outputs, targets)",
                            "Call"
                        ],
                        [
                            "mean_volume_euclidean(outputs, targets)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_227": {
                "a": {
                    "value": "reconstruction_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "correlation_angle([outputs, targets])",
                            "Call"
                        ],
                        [
                            "correlation_angle_mean_voxels([outputs, targets])",
                            "Call"
                        ],
                        [
                            "correlation_angle([outputs, targets])",
                            "Call"
                        ],
                        [
                            "correlation_angle_mean_voxels([outputs, targets])",
                            "Call"
                        ],
                        [
                            "correlation_angle_each_voxel([outputs, targets])",
                            "Call"
                        ],
                        [
                            "euclidean(outputs, targets)",
                            "Call"
                        ],
                        [
                            "mean_volume_euclidean(outputs, targets)",
                            "Call"
                        ]
                    ]
                }
            },
            "maximum_19": {
                "x": {
                    "value": "1.0 - y_pred",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "abs_64": {
                "x": {
                    "value": "a / (K.sqrt(b) * K.sqrt(c))",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "mean_97": {
                "a": {
                    "value": "tf.abs(a / (K.sqrt(b) * K.sqrt(c)))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "abs_129": {
                "x": {
                    "value": "a / (tf.keras.backend.sqrt(b) * tf.keras.backend.sqrt(c))",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sum_136": {
                "a": {
                    "value": "tf.keras.backend.square(x - y)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "sum_140": {
                "a": {
                    "value": "tf.keras.backend.square(x - y)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_156": {
                "input_tensor": {
                    "value": "tf.log(gen_pred)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_174": {
                "input_tensor": {
                    "value": "tf.log(positives) + tf.log(1.0 - negatives) + tf.log(1.0 - gen_pred)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_180": {
                "input_tensor": {
                    "value": "gen_pred",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_mean_198": {
                "input_tensor": {
                    "value": "negatives",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros(real_pred.shape, dtype='float32')",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(negatives)",
                            "Call"
                        ],
                        [
                            "np.zeros(real_pred.shape, dtype='float32')",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(negatives)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_206": {
                "a": {
                    "value": "reconstruction_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "correlation_angle([outputs, targets])",
                            "Call"
                        ],
                        [
                            "correlation_angle_mean_voxels([outputs, targets])",
                            "Call"
                        ],
                        [
                            "correlation_angle([outputs, targets])",
                            "Call"
                        ],
                        [
                            "correlation_angle_mean_voxels([outputs, targets])",
                            "Call"
                        ],
                        [
                            "correlation_angle_each_voxel([outputs, targets])",
                            "Call"
                        ],
                        [
                            "euclidean(outputs, targets)",
                            "Call"
                        ],
                        [
                            "mean_volume_euclidean(outputs, targets)",
                            "Call"
                        ]
                    ]
                }
            },
            "log_210": {
                "x": {
                    "value": "1 - reconstruction_loss",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_215": {
                "x": {
                    "value": "1 - reconstruction_loss",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_219": {
                "x": {
                    "value": "1 - reconstruction_loss",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "transpose_316": {
                "variable": {
                    "value": "H1",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "y_pred[instance, 0:o1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "transpose_317": {
                "variable": {
                    "value": "H2",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "y_pred[instance, o1:o1 + o2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "where_341": {
                "variable": {
                    "value": "posInd1",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.greater(D1, eps)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_nd_342": {
                "variable": {
                    "value": "D1",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "D1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(D1, posInd1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "posInd1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.greater(D1, eps))",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_343": {
                "a": {
                    "value": "V1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(tf.nn.embedding_lookup(tf.transpose(V1), tf.squeeze(posInd1)))",
                            "Call"
                        ]
                    ]
                }
            },
            "where_345": {
                "variable": {
                    "value": "posInd2",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.greater(D2, eps)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_nd_346": {
                "variable": {
                    "value": "D2",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "D2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(D2, posInd2)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "posInd2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.greater(D2, eps))",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_347": {
                "a": {
                    "value": "V2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(tf.nn.embedding_lookup(tf.transpose(V2), tf.squeeze(posInd2)))",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_349": {
                "a": {
                    "value": "V1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(tf.nn.embedding_lookup(tf.transpose(V1), tf.squeeze(posInd1)))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.diag(D1 ** (-0.5))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_350": {
                "a": {
                    "value": "V2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(tf.nn.embedding_lookup(tf.transpose(V2), tf.squeeze(posInd2)))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.diag(D2 ** (-0.5))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_352": {
                "a": {
                    "value": "SigmaHat11RootInv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.matmul(V1, tf.diag(D1 ** (-0.5))), V1, transpose_b=True)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "SigmaHat12",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.divide(1, m - 1), tf.float32) * tf.matmul(H1bar, H2bar, transpose_b=True)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "abs_97": {
                "x": {
                    "value": "a / (K.sqrt(b) * K.sqrt(c))",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "square_136": {
                "x": {
                    "value": "x - y",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "square_140": {
                "x": {
                    "value": "x - y",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_156": {
                "x": {
                    "value": "gen_pred",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sqrt_355": {
                "variable": {
                    "value": "corr",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.trace(tf.matmul(Tval, Tval, transpose_a=True))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_nd_358": {
                "variable": {
                    "value": "U",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "U",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(U, tf.where(tf.greater(U, eps)))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.where(tf.greater(U, eps))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_359": {
                "variable": {
                    "value": "kk",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.cast(tf.shape(U), tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "minimum_360": {
                "variable": {
                    "value": "K",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "kk",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.cast(tf.shape(U), tf.int32), [])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "outdim_size",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "top_k_361": {
                "variable": {
                    "value": "(w, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "U",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(U, tf.where(tf.greater(U, eps)))",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "K",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.minimum(kk, outdim_size)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_362": {
                "variable": {
                    "value": "corr",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.sqrt(w)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_45": {
                "x": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=2)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_dot(y, y, axes=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_83": {
                "x": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=2)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_dot(y, y, axes=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_115": {
                "x": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=2)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_dot(y, y, axes=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "log_174": {
                "x": {
                    "value": "1.0 - negatives",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_325": {
                "input": {
                    "value": "H1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(y_pred[instance, 0:o1])",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_flatten(H1)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_331": {
                "x": {
                    "value": "tf.divide(1, m - 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_331": {
                "a": {
                    "value": "H1bar",
                    "type": "variable",
                    "possible_values": [
                        [
                            "H1 - tf.cast(tf.divide(1, m), tf.float32) * tf.matmul(H1, tf.ones([m, m]))",
                            "BinOp"
                        ]
                    ]
                },
                "b": {
                    "value": "H2bar",
                    "type": "variable",
                    "possible_values": [
                        [
                            "H2 - tf.cast(tf.divide(1, m), tf.float32) * tf.matmul(H2, tf.ones([m, m]))",
                            "BinOp"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "greater_341": {
                "x": {
                    "value": "D1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(D1, posInd1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1e-12",
                            "float"
                        ]
                    ]
                }
            },
            "embedding_lookup_343": {
                "params": {
                    "value": "tf.transpose(V1)",
                    "type": "Call",
                    "possible_values": []
                },
                "ids": {
                    "value": "tf.squeeze(posInd1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "greater_345": {
                "x": {
                    "value": "D2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(D2, posInd2)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1e-12",
                            "float"
                        ]
                    ]
                }
            },
            "embedding_lookup_347": {
                "params": {
                    "value": "tf.transpose(V2)",
                    "type": "Call",
                    "possible_values": []
                },
                "ids": {
                    "value": "tf.squeeze(posInd2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_64": {
                "x": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=2)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_dot(y, y, axes=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_129": {
                "x": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=2)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_dot(y, y, axes=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_328": {
                "x": {
                    "value": "tf.divide(1, m)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_328": {
                "a": {
                    "value": "H1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(y_pred[instance, 0:o1])",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_flatten(H1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.ones([m, m])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_329": {
                "x": {
                    "value": "tf.divide(1, m)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_329": {
                "a": {
                    "value": "H2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(y_pred[instance, o1:o1 + o2])",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_flatten(H2)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.ones([m, m])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "divide_331": {
                "x": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "y": {
                    "value": "m - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_332": {
                "x": {
                    "value": "tf.divide(1, m - 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_332": {
                "a": {
                    "value": "H1bar",
                    "type": "variable",
                    "possible_values": [
                        [
                            "H1 - tf.cast(tf.divide(1, m), tf.float32) * tf.matmul(H1, tf.ones([m, m]))",
                            "BinOp"
                        ]
                    ]
                },
                "b": {
                    "value": "H1bar",
                    "type": "variable",
                    "possible_values": [
                        [
                            "H1 - tf.cast(tf.divide(1, m), tf.float32) * tf.matmul(H1, tf.ones([m, m]))",
                            "BinOp"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "eye_332": {
                "num_rows": {
                    "value": "o1",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cast_334": {
                "x": {
                    "value": "tf.divide(1, m - 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_334": {
                "a": {
                    "value": "H2bar",
                    "type": "variable",
                    "possible_values": [
                        [
                            "H2 - tf.cast(tf.divide(1, m), tf.float32) * tf.matmul(H2, tf.ones([m, m]))",
                            "BinOp"
                        ]
                    ]
                },
                "b": {
                    "value": "H2bar",
                    "type": "variable",
                    "possible_values": [
                        [
                            "H2 - tf.cast(tf.divide(1, m), tf.float32) * tf.matmul(H2, tf.ones([m, m]))",
                            "BinOp"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "eye_334": {
                "num_rows": {
                    "value": "o2",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "squeeze_343": {
                "input": {
                    "value": "posInd1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.greater(D1, eps))",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_347": {
                "input": {
                    "value": "posInd2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.greater(D2, eps))",
                            "Call"
                        ]
                    ]
                }
            },
            "diag_349": {
                "diagonal": {
                    "value": "D1 ** (-0.5)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "diag_350": {
                "diagonal": {
                    "value": "D2 ** (-0.5)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "trace_355": {
                "*args": {
                    "value": "tf.matmul(Tval, Tval, transpose_a=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_357": {
                "a": {
                    "value": "Tval",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.matmul(SigmaHat11RootInv, SigmaHat12), SigmaHat22RootInv)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "Tval",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.matmul(SigmaHat11RootInv, SigmaHat12), SigmaHat22RootInv)",
                            "Call"
                        ]
                    ]
                },
                "transpose_a": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "where_358": {
                "condition": {
                    "value": "tf.greater(U, eps)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_359": {
                "x": {
                    "value": "tf.shape(U)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sqrt_362": {
                "x": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sqrt_97": {
                "x": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=2)",
                            "Call"
                        ],
                        [
                            "K.batch_dot(y, y, axes=1)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.batch_dot(y, y, axes=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "divide_328": {
                "x": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "y": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(H1)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "ones_328": {
                "shape": {
                    "value": "[m, m]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "divide_329": {
                "x": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "y": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(H1)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "ones_329": {
                "shape": {
                    "value": "[m, m]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "divide_332": {
                "x": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "y": {
                    "value": "m - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "divide_334": {
                "x": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "y": {
                    "value": "m - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "matmul_355": {
                "a": {
                    "value": "Tval",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.matmul(SigmaHat11RootInv, SigmaHat12), SigmaHat22RootInv)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "Tval",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.matmul(SigmaHat11RootInv, SigmaHat12), SigmaHat22RootInv)",
                            "Call"
                        ]
                    ]
                },
                "transpose_a": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "greater_358": {
                "x": {
                    "value": "U",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(U, tf.where(tf.greater(U, eps)))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1e-12",
                            "float"
                        ]
                    ]
                }
            },
            "shape_359": {
                "input": {
                    "value": "U",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(U, tf.where(tf.greater(U, eps)))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "src/utils/layers_utils.py": {
        "tensorflow": {
            "zeros_45": {
                "variable": {
                    "value": "self.missing_values_mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "inputs.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_50": {
                "variable": {
                    "value": "grads[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "value": {
                    "value": "np.multiply(grads[0].numpy(), self._weights_mask)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_51": {
                "variable": {
                    "value": "grads[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "value": {
                    "value": "np.multiply(grads[1].numpy(), self._biases_mask)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_205": {
                "variable": {
                    "value": "grads[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "value": {
                    "value": "np.multiply(grads[0].numpy(), self._weights_mask)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_206": {
                "variable": {
                    "value": "grads[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "value": {
                    "value": "np.multiply(grads[1].numpy(), self._biases_mask)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_304": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.stack((output, new_mask), axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_119": {
                "input_tensor": {
                    "value": "inputs[:, 1, :]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "matmul_132": {
                "a": {
                    "value": "inputs[:, 0, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "self.w",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_243": {
                "a": {
                    "value": "inputs[:, 0, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "self.w",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_296": {
                "a": {
                    "value": "inputs[:, 0, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "self.w",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "src/utils/training_utils.py": {
        "tensorflow": {
            "SGD_9": {
                "lr": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "SGD_131": {
                "lr": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Adam_213": {
                "lr": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Adam_250": {
                "lr": {
                    "value": "0.0001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "mean_245": {
                "a": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.mean(tf.abs(out - missing_mask_train[batch_init:batch_init + batch_size, 0, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_complete_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold_val)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1)).numpy()",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "mean_35": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.abs(out - missing_mask_train[batch_init:batch_init + batch_size, 0, :])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multiply_36": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.mean(tf.abs(out - missing_mask_train[batch_init:batch_init + batch_size, 0, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_complete_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold_val)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1)).numpy()",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.constant(target_missing_train.shape[1], dtype='float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "divide_37": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.mean(tf.abs(out - missing_mask_train[batch_init:batch_init + batch_size, 0, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_complete_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold_val)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1)).numpy()",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.constant(n_complete_values, dtype='float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mean_40": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.mean(tf.abs(out - missing_mask_train[batch_init:batch_init + batch_size, 0, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_complete_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold_val)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1)).numpy()",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_61": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.abs(out - target_missing_train[batch_init:batch_init + batch_size])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multiply_62": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.mean(tf.abs(out - missing_mask_train[batch_init:batch_init + batch_size, 0, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_complete_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold_val)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1)).numpy()",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.constant(target_missing_train.shape[1], dtype='float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "divide_63": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.mean(tf.abs(out - missing_mask_train[batch_init:batch_init + batch_size, 0, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_complete_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold_val)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1)).numpy()",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.constant(n_missing_values, dtype='float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mean_66": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.mean(tf.abs(out - missing_mask_train[batch_init:batch_init + batch_size, 0, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_complete_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold_val)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1)).numpy()",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_103": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.abs(out - target_missing_val[batch_init:batch_init + batch_size])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multiply_104": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.mean(tf.abs(out - missing_mask_train[batch_init:batch_init + batch_size, 0, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_complete_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold_val)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1)).numpy()",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.constant(target_missing_val.shape[1], dtype='float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "divide_105": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.mean(tf.abs(out - missing_mask_train[batch_init:batch_init + batch_size, 0, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_complete_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold_val)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1)).numpy()",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.constant(n_missing_values, dtype='float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mean_108": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.mean(tf.abs(out - missing_mask_train[batch_init:batch_init + batch_size, 0, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_complete_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold_val)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1)).numpy()",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_156": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.abs(out - target_missing_train[batch_init:batch_init + batch_size, :])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multiply_157": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.mean(tf.abs(out - missing_mask_train[batch_init:batch_init + batch_size, 0, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_complete_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold_val)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1)).numpy()",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.constant(target_missing_train.shape[1], dtype='float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "divide_158": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.mean(tf.abs(out - missing_mask_train[batch_init:batch_init + batch_size, 0, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_complete_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold_val)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1)).numpy()",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.constant(n_missing_values, dtype='float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mean_161": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.mean(tf.abs(out - missing_mask_train[batch_init:batch_init + batch_size, 0, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_complete_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold_val)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1)).numpy()",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_189": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.abs(out - target_missing_val[batch_init:batch_init + batch_size, :])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multiply_190": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.mean(tf.abs(out - missing_mask_train[batch_init:batch_init + batch_size, 0, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_complete_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold_val)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1)).numpy()",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.constant(target_missing_val.shape[1], dtype='float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "divide_191": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.mean(tf.abs(out - missing_mask_train[batch_init:batch_init + batch_size, 0, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_complete_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold_val)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1)).numpy()",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.constant(n_missing_values, dtype='float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mean_194": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.mean(tf.abs(out - missing_mask_train[batch_init:batch_init + batch_size, 0, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_complete_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold_val)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1)).numpy()",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_225": {
                "a": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.mean(tf.abs(out - missing_mask_train[batch_init:batch_init + batch_size, 0, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_complete_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_train[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_train.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.abs(out - target_missing_val[batch_init:batch_init + batch_size, :]), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.math.multiply(loss, tf.constant(target_missing_val.shape[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.math.divide(loss, tf.constant(n_missing_values, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.keras.losses.MAE(out, target_bold_val)",
                            "Call"
                        ],
                        [
                            "tf.keras.backend.mean(tf.keras.backend.mean(loss, axis=1)).numpy()",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "GradientTape_25": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "GradientTape_51": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "add_75": {
                "x": {
                    "value": "complete_grads[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "retrieval_grads[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "add_76": {
                "x": {
                    "value": "complete_grads[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "retrieval_grads[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "GradientTape_144": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "GradientTape_219": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "abs_35": {
                "x": {
                    "value": "out - missing_mask_train[batch_init:batch_init + batch_size, 0, :]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_36": {
                "value": {
                    "value": "target_missing_train.shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_37": {
                "value": {
                    "value": "n_complete_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "target_missing_train.shape[1] - np.sum(missing_mask_train[batch_init, 1, :])",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "abs_61": {
                "x": {
                    "value": "out - target_missing_train[batch_init:batch_init + batch_size]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_62": {
                "value": {
                    "value": "target_missing_train.shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_63": {
                "value": {
                    "value": "n_missing_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.sum(missing_mask_train[batch_init, 1, :])",
                            "Call"
                        ],
                        [
                            "np.sum(missing_mask_val[batch_init, 1, :])",
                            "Call"
                        ],
                        [
                            "np.sum(missing_mask_train[batch_init, 1, :])",
                            "Call"
                        ],
                        [
                            "np.sum(missing_mask_val[batch_init, 1, :])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "abs_103": {
                "x": {
                    "value": "out - target_missing_val[batch_init:batch_init + batch_size]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_104": {
                "value": {
                    "value": "target_missing_val.shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_105": {
                "value": {
                    "value": "n_missing_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.sum(missing_mask_train[batch_init, 1, :])",
                            "Call"
                        ],
                        [
                            "np.sum(missing_mask_val[batch_init, 1, :])",
                            "Call"
                        ],
                        [
                            "np.sum(missing_mask_train[batch_init, 1, :])",
                            "Call"
                        ],
                        [
                            "np.sum(missing_mask_val[batch_init, 1, :])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "multiply_153": {
                "x": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model(missing_mask_train[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "model(missing_mask_train[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "model(missing_mask_val[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "model(missing_mask_train[batch_init:batch_init + batch_size, 0])",
                            "Call"
                        ],
                        [
                            "missing_mask_train[batch_init:batch_init + batch_size, 0, :] + tf.multiply(out, missing_mask_train[batch_init:batch_init + batch_size, 1, :])",
                            "BinOp"
                        ],
                        [
                            "model(missing_mask_val[batch_init:batch_init + batch_size, 0])",
                            "Call"
                        ],
                        [
                            "missing_mask_val[batch_init:batch_init + batch_size, 0, :] + tf.multiply(out, missing_mask_val[batch_init:batch_init + batch_size, 1, :])",
                            "BinOp"
                        ],
                        [
                            "model(imputted_bold[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "model(imputted_bold_val)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "missing_mask_train[batch_init:batch_init + batch_size, 1, :]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "abs_156": {
                "x": {
                    "value": "out - target_missing_train[batch_init:batch_init + batch_size, :]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_157": {
                "value": {
                    "value": "target_missing_train.shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_158": {
                "value": {
                    "value": "n_missing_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.sum(missing_mask_train[batch_init, 1, :])",
                            "Call"
                        ],
                        [
                            "np.sum(missing_mask_val[batch_init, 1, :])",
                            "Call"
                        ],
                        [
                            "np.sum(missing_mask_train[batch_init, 1, :])",
                            "Call"
                        ],
                        [
                            "np.sum(missing_mask_val[batch_init, 1, :])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "multiply_186": {
                "x": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model(missing_mask_train[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "model(missing_mask_train[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "model(missing_mask_val[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "model(missing_mask_train[batch_init:batch_init + batch_size, 0])",
                            "Call"
                        ],
                        [
                            "missing_mask_train[batch_init:batch_init + batch_size, 0, :] + tf.multiply(out, missing_mask_train[batch_init:batch_init + batch_size, 1, :])",
                            "BinOp"
                        ],
                        [
                            "model(missing_mask_val[batch_init:batch_init + batch_size, 0])",
                            "Call"
                        ],
                        [
                            "missing_mask_val[batch_init:batch_init + batch_size, 0, :] + tf.multiply(out, missing_mask_val[batch_init:batch_init + batch_size, 1, :])",
                            "BinOp"
                        ],
                        [
                            "model(imputted_bold[batch_init:batch_init + batch_size])",
                            "Call"
                        ],
                        [
                            "model(imputted_bold_val)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "missing_mask_val[batch_init:batch_init + batch_size, 1, :]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "abs_189": {
                "x": {
                    "value": "out - target_missing_val[batch_init:batch_init + batch_size, :]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_190": {
                "value": {
                    "value": "target_missing_val.shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_191": {
                "value": {
                    "value": "n_missing_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.sum(missing_mask_train[batch_init, 1, :])",
                            "Call"
                        ],
                        [
                            "np.sum(missing_mask_val[batch_init, 1, :])",
                            "Call"
                        ],
                        [
                            "np.sum(missing_mask_train[batch_init, 1, :])",
                            "Call"
                        ],
                        [
                            "np.sum(missing_mask_val[batch_init, 1, :])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    }
}